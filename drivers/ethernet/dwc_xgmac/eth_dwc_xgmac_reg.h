/*
 * Intel Hard Processor System 10 Giga bit TSN Ethernet Media Access controller (XGMAC) driver
 *
 * DWC XGMAC IP register definations
 *
 * Copyright (c) 2023 Intel Corporation.
 * SPDX-License-Identifier: Apache-2.0
 */

#ifndef _ZEPHYR_DRIVERS_ETHERNET_ETH_DWC_XGMAC_REG_H_
#define _ZEPHYR_DRIVERS_ETHERNET_ETH_DWC_XGMAC_REG_H_

/*
 * Component : DWCXG_CORE
 * MAC Protocol-Core Registers.
 *
 */
/*
 * Register : MAC_Tx_Configuration
 *
 * The MAC Transmit Configuration register establishes the operating mode of the
 * MAC transmitter.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_TE
 *  [1]     | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_DDIC
 *  [2]     | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_2
 *  [3]     | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_ISM
 *  [7:4]   | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_ISR
 *  [10:8]  | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_IPG
 *  [11]    | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_IFP
 *  [12]    | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_TC
 *  [13]    | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_LUD
 *  [15:14] | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_15_14
 *  [16]    | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_JD
 *  [17]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_17
 *  [18]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM
 *  [19]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_PEN
 *  [22:20] | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_SARC
 *  [23]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_23
 *  [24]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_VNE
 *  [25]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_VNM
 *  [26]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_26
 *  [27]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH
 *  [28]    | R      | 0x0   | CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN
 *  [31:29] | RW     | 0x0   | CORE_MAC_TX_CONFIGURATION_SS
 *
 */
/*
 * Field : TE
 *
 * Transmitter Enable.
 *
 * When this bit is set, the Tx state machine of the MAC is enabled for
 * transmission on the GMII or XGMII interface.
 *
 * When this bit is reset, the MAC Tx state machine is disabled after it completes
 * the transmission of the current packet. The Tx state machine does not transmit
 * any more packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_TE register field. */
#define CORE_MAC_TX_CONFIGURATION_TE_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_TE register field. */
#define CORE_MAC_TX_CONFIGURATION_TE_MSB	0
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_TE register field. */
#define CORE_MAC_TX_CONFIGURATION_TE_WIDTH	1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_TE register field value. */
#define CORE_MAC_TX_CONFIGURATION_TE_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_TE register field value. */
#define CORE_MAC_TX_CONFIGURATION_TE_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_TX_CONFIGURATION_TE register field. */
#define CORE_MAC_TX_CONFIGURATION_TE_RESET	0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_TE field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_TE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_TX_CONFIGURATION_TE register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_TE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : DDIC
 *
 * Disable DIC Algorithm.
 *
 * When this bit is set, the Deficit Idle Count (DIC) algorithm is disabled and
 * DWC_xgmac always has a minimum IFG of 12 bytes between transmitted packets.
 *
 * When reset to zero, the DIC is activated and the minimum IFG varies between 9
 * and 15 bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_DDIC register field. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_DDIC register field. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_MSB	  1
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_DDIC register field. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_WIDTH	  1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_DDIC register field value. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_DDIC register field value. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MAC_TX_CONFIGURATION_DDIC register field. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_RESET	  0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_DDIC field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_DDIC_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_TX_CONFIGURATION_DDIC register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_DDIC_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_2 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_LSB	2
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_2 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_MSB	2
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_2 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_WIDTH	1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_2 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_SET_MSK	0x00000004
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_2 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_CLR_MSK	0xfffffffb
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_2 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_RESET	0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_2 field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_2_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : ISM
 *
 * IFG Stretch Mode.
 *
 * When this bit is set, DWC_xgmac enforces extended inter-packet spacing (one
 * extra octet of IDLE for every ISR (IFG Stretch Ratio) number of bytes) to
 * support less-than-10-Gbps data rates.
 *
 * When this bit is reset, inter-packet gap extension is not performed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_ISM register field. */
#define CORE_MAC_TX_CONFIGURATION_ISM_LSB	 3
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_ISM register field. */
#define CORE_MAC_TX_CONFIGURATION_ISM_MSB	 3
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_ISM register field. */
#define CORE_MAC_TX_CONFIGURATION_ISM_WIDTH	 1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_ISM register field value. */
#define CORE_MAC_TX_CONFIGURATION_ISM_SET_MSK	 0x00000008
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_ISM register field value. */
#define CORE_MAC_TX_CONFIGURATION_ISM_CLR_MSK	 0xfffffff7
/* The reset value of the CORE_MAC_TX_CONFIGURATION_ISM register field. */
#define CORE_MAC_TX_CONFIGURATION_ISM_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_ISM field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_ISM_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_TX_CONFIGURATION_ISM register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_ISM_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : ISR
 *
 * IFG Stretch Ratio.
 *
 * This value controls the number of bytes in a transmitted packet for which one
 * octet of IDLE is added to the IFG. To operate DWC_xgmac for 10GBASE-W (WIS
 * layer), the value must be 13 (decimal).
 *
 * Note that 0 is not a valid value and must not be written. Before enabling ISM
 * (IFG Stretch Mode) bit, this ISR number should be programmed to a non-zero
 * value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_ISR register field. */
#define CORE_MAC_TX_CONFIGURATION_ISR_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_ISR register field. */
#define CORE_MAC_TX_CONFIGURATION_ISR_MSB	 7
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_ISR register field. */
#define CORE_MAC_TX_CONFIGURATION_ISR_WIDTH	 4
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_ISR register field value. */
#define CORE_MAC_TX_CONFIGURATION_ISR_SET_MSK	 0x000000f0
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_ISR register field value. */
#define CORE_MAC_TX_CONFIGURATION_ISR_CLR_MSK	 0xffffff0f
/* The reset value of the CORE_MAC_TX_CONFIGURATION_ISR register field. */
#define CORE_MAC_TX_CONFIGURATION_ISR_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_ISR field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_ISR_GET(value) (((value)&0x000000f0) >> 4)
/* Produces a CORE_MAC_TX_CONFIGURATION_ISR register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_ISR_SET(value) (((value) << 4) & 0x000000f0)

/*
 * Field : IPG
 *
 * Inter-Packet Gap
 *
 * These bits control the minimum IPG between packets during transmission. When IFP
 * is cleared, the minimum IPG between transmitted packets is reduced in both GMII
 * and XGMII mode. The corresponding IPG values are given as follows.
 *
 * * 3'b000: 96 bit times
 *
 * * 3'b001: 88 bit times
 *
 * * 3'b010: 80 bit times
 *
 * * 3'b011: 72 bit times
 *
 * * 3'b100: 64 bit times
 *
 * * 3'b101: 3'b111: Reserved
 *
 * In the half-duplex mode, the minimum IPG can be configured only for 64-bit times
 * (IPG = 100). Lower values are not considered.
 *
 * When a JAM pattern is transmitted because of backpressure activation, the MAC
 * does not consider the minimum IPG.
 *
 * When IFP is set, the minimum IPG is increased in steps of 32 bits as follows. In
 * 10G (XGMII) mode, when IFP is set, it overrides the functions of DDIC and ISM
 * bits.
 *
 * The EIPG bits (in MAC_Extended_Configuration register) along with IPG bits gives
 * a 10-bit value to control the required IPG as follows:
 *
 * * {EIPG,IPG}: Minimum Inter-Packet Gap
 *
 * * 10'h000: 96 bit times
 *
 * * 10'h001: 128 bit times
 *
 * * 10'h002: 160 bit times
 *
 * * 10'h003: 192 bit times
 *
 * * 10'h004: 224 bit times
 *
 * * ...
 *
 * * 10'h3FF: 32832 bit times
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_IPG register field. */
#define CORE_MAC_TX_CONFIGURATION_IPG_LSB	 8
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_IPG register field. */
#define CORE_MAC_TX_CONFIGURATION_IPG_MSB	 10
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_IPG register field. */
#define CORE_MAC_TX_CONFIGURATION_IPG_WIDTH	 3
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_IPG register field value. */
#define CORE_MAC_TX_CONFIGURATION_IPG_SET_MSK	 0x00000700
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_IPG register field value. */
#define CORE_MAC_TX_CONFIGURATION_IPG_CLR_MSK	 0xfffff8ff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_IPG register field. */
#define CORE_MAC_TX_CONFIGURATION_IPG_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_IPG field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_IPG_GET(value) (((value)&0x00000700) >> 8)
/* Produces a CORE_MAC_TX_CONFIGURATION_IPG register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_IPG_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : IFP
 *
 * IPG Control
 *
 * When this bit is set, the minimum IPG is increased in steps of 32 bits from the
 * default 96 bits, depending on the programming of the IPG field. In the XGMII
 * mode, this bit has higher priority than the ISM bit.
 *
 * When this bit is reset, the minimum IFG is decreased in steps of 8 bits from the
 * default 96 bits, depending on the programming of the IPG field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_IFP register field. */
#define CORE_MAC_TX_CONFIGURATION_IFP_LSB	 11
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_IFP register field. */
#define CORE_MAC_TX_CONFIGURATION_IFP_MSB	 11
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_IFP register field. */
#define CORE_MAC_TX_CONFIGURATION_IFP_WIDTH	 1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_IFP register field value. */
#define CORE_MAC_TX_CONFIGURATION_IFP_SET_MSK	 0x00000800
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_IFP register field value. */
#define CORE_MAC_TX_CONFIGURATION_IFP_CLR_MSK	 0xfffff7ff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_IFP register field. */
#define CORE_MAC_TX_CONFIGURATION_IFP_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_IFP field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_IFP_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_TX_CONFIGURATION_IFP register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_IFP_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : TC
 *
 * Transmit Configuration in RGMII.
 *
 * When set, this bit enables the transmission of duplex mode, link speed, and link
 * up or down information to the PHY in the RGMII, port. When this bit is reset, no
 * such information is driven to the PHY. The details of this feature are provided
 * in the following sections:
 *
 * * 1'b0: Disable Transmit Configuration in RGMII
 *
 * * 1'b1: Enable Transmit Configuration in RGMII
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_TC register field. */
#define CORE_MAC_TX_CONFIGURATION_TC_LSB	12
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_TC register field. */
#define CORE_MAC_TX_CONFIGURATION_TC_MSB	12
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_TC register field. */
#define CORE_MAC_TX_CONFIGURATION_TC_WIDTH	1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_TC register field value. */
#define CORE_MAC_TX_CONFIGURATION_TC_SET_MSK	0x00001000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_TC register field value. */
#define CORE_MAC_TX_CONFIGURATION_TC_CLR_MSK	0xffffefff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_TC register field. */
#define CORE_MAC_TX_CONFIGURATION_TC_RESET	0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_TC field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_TC_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_TX_CONFIGURATION_TC register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_TC_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : LUD
 *
 * Link Up or Down.
 *
 * This bit indicates whether the link is up or down during transmission of
 * configuration in the RGMII interface.
 *
 * * 1'b0: Link down
 *
 * * 1'b1: Link up
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_LUD register field. */
#define CORE_MAC_TX_CONFIGURATION_LUD_LSB	 13
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_LUD register field. */
#define CORE_MAC_TX_CONFIGURATION_LUD_MSB	 13
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_LUD register field. */
#define CORE_MAC_TX_CONFIGURATION_LUD_WIDTH	 1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_LUD register field value. */
#define CORE_MAC_TX_CONFIGURATION_LUD_SET_MSK	 0x00002000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_LUD register field value. */
#define CORE_MAC_TX_CONFIGURATION_LUD_CLR_MSK	 0xffffdfff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_LUD register field. */
#define CORE_MAC_TX_CONFIGURATION_LUD_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_LUD field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_LUD_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_TX_CONFIGURATION_LUD register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_LUD_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_LSB	    14
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_MSB	    15
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_WIDTH	    2
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_SET_MSK    0x0000c000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_CLR_MSK    0xffff3fff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_RESET	    0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : JD
 *
 * Jabber Disable.
 *
 * When this bit is set, the DWC_xgmac disables the jabber timer on the
 * transmitter. Transmission of up to 16383-byte packets is supported.
 *
 * When this bit is reset, DWC_xgmac cuts off the transmitter if the application
 * sends more than 2048 bytes of data (10240 bytes if JE (in MAC_Rx_Configuration
 * register is set high) during transmission.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_JD register field. */
#define CORE_MAC_TX_CONFIGURATION_JD_LSB	16
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_JD register field. */
#define CORE_MAC_TX_CONFIGURATION_JD_MSB	16
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_JD register field. */
#define CORE_MAC_TX_CONFIGURATION_JD_WIDTH	1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_JD register field value. */
#define CORE_MAC_TX_CONFIGURATION_JD_SET_MSK	0x00010000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_JD register field value. */
#define CORE_MAC_TX_CONFIGURATION_JD_CLR_MSK	0xfffeffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_JD register field. */
#define CORE_MAC_TX_CONFIGURATION_JD_RESET	0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_JD field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_JD_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_TX_CONFIGURATION_JD register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_JD_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : Reserved_17
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_17 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_LSB	 17
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_17 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_MSB	 17
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_17 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_WIDTH	 1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_17 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_SET_MSK	 0x00020000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_17 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_CLR_MSK	 0xfffdffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_17 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_17 field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_17 register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_17_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : Reserved_PCHM
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_LSB	   18
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_MSB	   18
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_WIDTH	   1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_SET_MSK	   0x00040000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_CLR_MSK	   0xfffbffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_RESET	   0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : Reserved_PEN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_LSB	  19
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_MSB	  19
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_WIDTH	  1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_SET_MSK	  0x00080000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_CLR_MSK	  0xfff7ffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_RESET	  0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_PEN field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_PEN register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_PEN_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : SARC
 *
 * Source Address Insertion or Replacement Control.
 *
 * This field controls the source address insertion or replacement for all
 * transmitted packets. Bit 22 specifies which MAC Address register (0 or 1) is
 * used for source address insertion or replacement based on the values of
 * Bits[21:20]:
 *
 * 2'b0x: The SA insertion-replacement is controlled by one of the following:
 *
 * * mti_sa_ctrl_i input signal in XGMAC-CORE configuration
 *
 * * SAIC field (Bits[26:24]) of Transmit Control Word in XGMAC-MTL configuration
 *
 * * SAIC field (Bits[25:23]) of TDES3 Normal Descriptor in XGMAC-AXI configuration
 *
 * 2'b10:
 *
 * * If Bit 22 is set to 0, the MAC inserts the content of the MAC Address 0
 *   registers (MAC_Address0_High and MAC_Address0_Low) in the SA field of all
 *   transmitted packets.
 *
 * * If Bit 22 is set to 1 and the Enable MAC Address Register 1 option is selected
 *   while configuring the controller, the MAC inserts the content of the MAC
 *   Address 1 registers (MAC_Address1_High and MAC_Address1_Low) in the SA field
 *   of all transmitted packets.
 *
 * 2'b11:
 *
 * * If Bit 22 is set to 0, the MAC replaces the content of the MAC Address 0
 *   registers (MAC_Address0_High and MAC_Address0_Low) in the SA field of all
 *   transmitted packets.
 *
 * * If Bit 22 is set to 1 and the MAC Address Register 1 is enabled, the MAC
 *   replaces the content of the MAC Address 1 registers (MAC_Address1_High and
 *   MAC_Address1_Low) in the SA field of all transmitted packets.
 *
 * Note:
 *
 * * Changes to this field take effect only on the start of a packet. If you write
 *   to this register field when a packet is being transmitted, only the subsequent
 *   packet can use the updated value, that is, the current packet does not use the
 *   updated value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_SARC register field. */
#define CORE_MAC_TX_CONFIGURATION_SARC_LSB	  20
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_SARC register field. */
#define CORE_MAC_TX_CONFIGURATION_SARC_MSB	  22
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_SARC register field. */
#define CORE_MAC_TX_CONFIGURATION_SARC_WIDTH	  3
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_SARC register field value. */
#define CORE_MAC_TX_CONFIGURATION_SARC_SET_MSK	  0x00700000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_SARC register field value. */
#define CORE_MAC_TX_CONFIGURATION_SARC_CLR_MSK	  0xff8fffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_SARC register field. */
#define CORE_MAC_TX_CONFIGURATION_SARC_RESET	  0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_SARC field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_SARC_GET(value) (((value)&0x00700000) >> 20)
/* Produces a CORE_MAC_TX_CONFIGURATION_SARC register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_SARC_SET(value) (((value) << 20) & 0x00700000)

/*
 * Field : Reserved_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_23 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_LSB	 23
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_23 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_MSB	 23
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_23 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_WIDTH	 1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_23 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_SET_MSK	 0x00800000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_23 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_CLR_MSK	 0xff7fffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_23 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_23 field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_23 register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_23_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : Reserved_VNE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_LSB	  24
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_MSB	  24
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_WIDTH	  1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_SET_MSK	  0x01000000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_CLR_MSK	  0xfeffffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_RESET	  0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_VNE field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_VNE register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNE_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : Reserved_VNM
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_LSB	  25
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_MSB	  25
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_WIDTH	  1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_SET_MSK	  0x02000000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_CLR_MSK	  0xfdffffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_RESET	  0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_VNM field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_VNM register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_VNM_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : Reserved_26
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_26 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_LSB	 26
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_26 register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_MSB	 26
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_26 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_WIDTH	 1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_26 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_SET_MSK	 0x04000000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_26 register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_CLR_MSK	 0xfbffffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_26 register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_RESET	 0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_26 field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_26 register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_26_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : Reserved_GT9WH
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_LSB	    27
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register
 * field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_MSB	    27
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_WIDTH	    1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_SET_MSK    0x08000000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_RESET	    0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : Reserved_G9991EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN
 * register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_LSB	      28
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN
 * register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_MSB	      28
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_WIDTH      1
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_SET_MSK    0x10000000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN register field value. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_CLR_MSK    0xefffffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN register field. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_RESET      0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN register field value suitable for setting
 * the register. */
#define CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : SS
 *
 * Speed Selection.
 *
 * Software programs these bits to instruct the MAC to operate in one of the
 * following possible speeds:
 *
 * * 3'b000     10G     XGMII
 *
 * * 3'b001     Reserved
 *
 * * 3'b010     2.5G    GMII
 *
 * * 3'b011     1G      GMII
 *
 * * 3'b100     100M    MII
 *
 * * 3'b101     5G      XGMII
 *
 * * 3'b110     2.5G    XGMII
 *
 * * 3'b111     10M     MII
 *
 * These bits must be programmed only once; after a hardware reset and before the
 * transmitter and receiver are enabled (by bit 0 of this register and bit 0 of the
 * MAC_Rx_Configuration register).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_CONFIGURATION_SS register field. */
#define CORE_MAC_TX_CONFIGURATION_SS_LSB	29
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_CONFIGURATION_SS register field. */
#define CORE_MAC_TX_CONFIGURATION_SS_MSB	31
/* The width in bits of the CORE_MAC_TX_CONFIGURATION_SS register field. */
#define CORE_MAC_TX_CONFIGURATION_SS_WIDTH	3
/* The mask used to set the CORE_MAC_TX_CONFIGURATION_SS register field value. */
#define CORE_MAC_TX_CONFIGURATION_SS_SET_MSK	0xe0000000
/* The mask used to clear the CORE_MAC_TX_CONFIGURATION_SS register field value. */
#define CORE_MAC_TX_CONFIGURATION_SS_CLR_MSK	0x1fffffff
/* The reset value of the CORE_MAC_TX_CONFIGURATION_SS register field. */
#define CORE_MAC_TX_CONFIGURATION_SS_RESET	0x0
/* Extracts the CORE_MAC_TX_CONFIGURATION_SS field value from a register. */
#define CORE_MAC_TX_CONFIGURATION_SS_GET(value) (((value)&0xe0000000) >> 29)
/* Produces a CORE_MAC_TX_CONFIGURATION_SS register field value suitable for setting the register.
 */
#define CORE_MAC_TX_CONFIGURATION_SS_SET(value) (((value) << 29) & 0xe0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TX_CONFIGURATION.
 */
struct CORE_MAC_TX_CONFIGURATION_s {
	volatile uint32_t TE : 1;		    /* CORE_MAC_TX_CONFIGURATION_TE */
	volatile uint32_t DDIC : 1;		    /* CORE_MAC_TX_CONFIGURATION_DDIC */
	const volatile uint32_t Reserved_2 : 1;	    /* CORE_MAC_TX_CONFIGURATION_RESERVED_2 */
	volatile uint32_t ISM : 1;		    /* CORE_MAC_TX_CONFIGURATION_ISM */
	volatile uint32_t ISR : 4;		    /* CORE_MAC_TX_CONFIGURATION_ISR */
	volatile uint32_t IPG : 3;		    /* CORE_MAC_TX_CONFIGURATION_IPG */
	volatile uint32_t IFP : 1;		    /* CORE_MAC_TX_CONFIGURATION_IFP */
	volatile uint32_t TC : 1;		    /* CORE_MAC_TX_CONFIGURATION_TC */
	volatile uint32_t LUD : 1;		    /* CORE_MAC_TX_CONFIGURATION_LUD */
	const volatile uint32_t Reserved_15_14 : 2; /* CORE_MAC_TX_CONFIGURATION_RESERVED_15_14 */
	volatile uint32_t JD : 1;		    /* CORE_MAC_TX_CONFIGURATION_JD */
	const volatile uint32_t Reserved_17 : 1;    /* CORE_MAC_TX_CONFIGURATION_RESERVED_17 */
	const volatile uint32_t Reserved_PCHM : 1;  /* CORE_MAC_TX_CONFIGURATION_RESERVED_PCHM */
	const volatile uint32_t Reserved_PEN : 1;   /* CORE_MAC_TX_CONFIGURATION_RESERVED_PEN */
	volatile uint32_t SARC : 3;		    /* CORE_MAC_TX_CONFIGURATION_SARC */
	const volatile uint32_t Reserved_23 : 1;    /* CORE_MAC_TX_CONFIGURATION_RESERVED_23 */
	const volatile uint32_t Reserved_VNE : 1;   /* CORE_MAC_TX_CONFIGURATION_RESERVED_VNE */
	const volatile uint32_t Reserved_VNM : 1;   /* CORE_MAC_TX_CONFIGURATION_RESERVED_VNM */
	const volatile uint32_t Reserved_26 : 1;    /* CORE_MAC_TX_CONFIGURATION_RESERVED_26 */
	const volatile uint32_t Reserved_GT9WH : 1; /* CORE_MAC_TX_CONFIGURATION_RESERVED_GT9WH */
	const volatile uint32_t
		Reserved_G9991EN : 1; /* CORE_MAC_TX_CONFIGURATION_RESERVED_G9991EN */
	volatile uint32_t SS : 3;     /* CORE_MAC_TX_CONFIGURATION_SS */
};

/* The typedef declaration for register CORE_MAC_TX_CONFIGURATION. */
typedef struct CORE_MAC_TX_CONFIGURATION_s CORE_MAC_TX_CONFIGURATION_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TX_CONFIGURATION register. */
#define CORE_MAC_TX_CONFIGURATION_RESET 0x00000000
/* The byte offset of the CORE_MAC_TX_CONFIGURATION register from the beginning of the component. */
#define CORE_MAC_TX_CONFIGURATION_OFST	0x0

/*
 * Register : MAC_Rx_Configuration
 *
 * The MAC Receive Configuration register establishes the operating mode of the MAC
 * receiver.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_RE
 *  [1]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_ACS
 *  [2]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_CST
 *  [3]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_DCRCC
 *  [4]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_SPEN
 *  [5]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_USP
 *  [6]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_GPSLCE
 *  [7]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_WD
 *  [8]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_JE
 *  [9]     | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_IPC
 *  [10]    | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_LM
 *  [11]    | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_S2KP
 *  [14:12] | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_HDSMS
 *  [15]    | R      | 0x0   | CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM
 *  [29:16] | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_GPSL
 *  [30]    | R      | 0x0   | CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN
 *  [31]    | RW     | 0x0   | CORE_MAC_RX_CONFIGURATION_ARPEN
 *
 */
/*
 * Field : RE
 *
 * Receiver Enable.
 *
 * When this bit is set, the Rx state machine of the MAC is enabled for receiving
 * packets from the GMII or XGMII interface. When this bit is reset, the MAC Rx
 * state machine is disabled after it completes the reception of the current
 * packet. The Rx state machine does not receive any more packets from the GMII or
 * XGMII interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_RE register field. */
#define CORE_MAC_RX_CONFIGURATION_RE_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_RE register field. */
#define CORE_MAC_RX_CONFIGURATION_RE_MSB	0
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_RE register field. */
#define CORE_MAC_RX_CONFIGURATION_RE_WIDTH	1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_RE register field value. */
#define CORE_MAC_RX_CONFIGURATION_RE_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_RE register field value. */
#define CORE_MAC_RX_CONFIGURATION_RE_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_RX_CONFIGURATION_RE register field. */
#define CORE_MAC_RX_CONFIGURATION_RE_RESET	0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_RE field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_RE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_RX_CONFIGURATION_RE register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_RE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : ACS
 *
 * Automatic Pad or CRC Stripping.
 *
 * When this bit is set, the MAC strips the Pad or FCS field on the incoming
 * packets, only if the value of the length field is less than 1536 bytes. All
 * received packets with length field greater than or equal to 1536 bytes are
 * passed to the application without stripping the Pad or FCS field.
 *
 * When this bit is reset, the MAC passes all the incoming packets to the
 * application, without any modification.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_ACS register field. */
#define CORE_MAC_RX_CONFIGURATION_ACS_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_ACS register field. */
#define CORE_MAC_RX_CONFIGURATION_ACS_MSB	 1
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_ACS register field. */
#define CORE_MAC_RX_CONFIGURATION_ACS_WIDTH	 1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_ACS register field value. */
#define CORE_MAC_RX_CONFIGURATION_ACS_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_ACS register field value. */
#define CORE_MAC_RX_CONFIGURATION_ACS_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MAC_RX_CONFIGURATION_ACS register field. */
#define CORE_MAC_RX_CONFIGURATION_ACS_RESET	 0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_ACS field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_ACS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_RX_CONFIGURATION_ACS register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_ACS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : CST
 *
 * CRC stripping for Type packets.
 *
 * When this bit is set, the last four bytes (FCS) of all packets of Ether type
 * (field greater than 1536) are stripped and dropped before forwarding the packet
 * to the application. This function is not valid when the IP Checksum Engine (Type
 * 1) is enabled in the MAC receiver. This function is valid when Type 2 Checksum
 * Offload Engine is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_CST register field. */
#define CORE_MAC_RX_CONFIGURATION_CST_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_CST register field. */
#define CORE_MAC_RX_CONFIGURATION_CST_MSB	 2
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_CST register field. */
#define CORE_MAC_RX_CONFIGURATION_CST_WIDTH	 1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_CST register field value. */
#define CORE_MAC_RX_CONFIGURATION_CST_SET_MSK	 0x00000004
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_CST register field value. */
#define CORE_MAC_RX_CONFIGURATION_CST_CLR_MSK	 0xfffffffb
/* The reset value of the CORE_MAC_RX_CONFIGURATION_CST register field. */
#define CORE_MAC_RX_CONFIGURATION_CST_RESET	 0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_CST field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_CST_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_RX_CONFIGURATION_CST register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_CST_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : DCRCC
 *
 * Disable CRC Checking for Received Packets.
 *
 * When this bit is set, the MAC receiver does not check the CRC field in the
 * received packets. When this bit is reset, the MAC receiver always checks the CRC
 * field in the received packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_DCRCC register field.
 */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_LSB	   3
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_DCRCC register field. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_MSB	   3
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_DCRCC register field. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_WIDTH	   1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_DCRCC register field value. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_SET_MSK	   0x00000008
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_DCRCC register field value. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_CLR_MSK	   0xfffffff7
/* The reset value of the CORE_MAC_RX_CONFIGURATION_DCRCC register field. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_RESET	   0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_DCRCC field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_RX_CONFIGURATION_DCRCC register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_CONFIGURATION_DCRCC_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : SPEN
 *
 * Slow Protocol Detection Enable.
 *
 * When this bit is set, MAC processes the Slow Protocol packets (Ether Type
 * 0x8809) and provides the Rx status. The MAC discards the Slow Protocol packets
 * with invalid sub-types.
 *
 * When this bit is reset, the MAC forwards all error-free Slow Protocol packets to
 * the application. The MAC considers such packets as normal Type packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_SPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_LSB	  4
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_SPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_MSB	  4
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_SPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_WIDTH	  1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_SPEN register field value. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_SET_MSK	  0x00000010
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_SPEN register field value. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_CLR_MSK	  0xffffffef
/* The reset value of the CORE_MAC_RX_CONFIGURATION_SPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_RESET	  0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_SPEN field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_SPEN_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_RX_CONFIGURATION_SPEN register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_SPEN_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : USP
 *
 * Unicast Slow Protocol Packet Detect.
 *
 * When this bit is set, the MAC detects the Slow Protocol packets with unicast
 * address of the station specified in the MAC_Address0_High and MAC_Address0_Low
 * registers. The MAC also detects the Slow Protocol packets with the Slow
 * Protocols multicast address (01-80-C2-00-00-02).
 *
 * When this bit is reset, the MAC detects only Slow Protocol packets with the Slow
 * Protocol multicast address specified in the IEEE 802.3-2018, Section 5.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_USP register field. */
#define CORE_MAC_RX_CONFIGURATION_USP_LSB	 5
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_USP register field. */
#define CORE_MAC_RX_CONFIGURATION_USP_MSB	 5
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_USP register field. */
#define CORE_MAC_RX_CONFIGURATION_USP_WIDTH	 1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_USP register field value. */
#define CORE_MAC_RX_CONFIGURATION_USP_SET_MSK	 0x00000020
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_USP register field value. */
#define CORE_MAC_RX_CONFIGURATION_USP_CLR_MSK	 0xffffffdf
/* The reset value of the CORE_MAC_RX_CONFIGURATION_USP register field. */
#define CORE_MAC_RX_CONFIGURATION_USP_RESET	 0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_USP field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_USP_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_RX_CONFIGURATION_USP register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_USP_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : GPSLCE
 *
 * Giant Packet Size Limit Control Enable.
 *
 * When this bit is set, the MAC considers the value in GPSL field in
 * MAC_Rx_Configuration register to declare a received packet as Giant packet. This
 * field must be programmed to more than 1518 bytes. Otherwise, the MAC considers
 * 1518 bytes as giant packet limit.
 *
 * When this bit is reset, the MAC considers a received packet as Giant packet when
 * its size is greater than 1518 bytes (1522 bytes for tagged packet).
 *
 * The watchdog timeout limit, Jumbo Packet Enable and 2K Packet Enable have higher
 * precedence over this bit, that is the MAC considers a received packet as Giant
 * packet when its size is greater than 9018 bytes (9022 bytes for tagged packet)
 * with Jumbo Packet Enabled and greater than 2000 bytes with 2K Packet Enabled.
 * The watchdog timeout, if enabled, terminates the received packet when watchdog
 * limit is reached. Therefore, the programmed giant packet limit should be less
 * than the watchdog limit to get the giant packet status.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_GPSLCE register field.
 */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_LSB	    6
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_GPSLCE register field.
 */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_MSB	    6
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_GPSLCE register field. */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_WIDTH	    1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_GPSLCE register field value. */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_SET_MSK    0x00000040
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_GPSLCE register field value. */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MAC_RX_CONFIGURATION_GPSLCE register field. */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_RESET	    0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_GPSLCE field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MAC_RX_CONFIGURATION_GPSLCE register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_CONFIGURATION_GPSLCE_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : WD
 *
 * Watchdog Disable.
 *
 * When this bit is set, the MAC disables the watchdog timer on the receiver. The
 * MAC can receive packets of up to 16383 bytes.
 *
 * When this bit is reset, the MAC does not allow more than 2048 bytes (10240 if JE
 * is set high) of the packet being received. The MAC cuts off any bytes received
 * after 2048 bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_WD register field. */
#define CORE_MAC_RX_CONFIGURATION_WD_LSB	7
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_WD register field. */
#define CORE_MAC_RX_CONFIGURATION_WD_MSB	7
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_WD register field. */
#define CORE_MAC_RX_CONFIGURATION_WD_WIDTH	1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_WD register field value. */
#define CORE_MAC_RX_CONFIGURATION_WD_SET_MSK	0x00000080
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_WD register field value. */
#define CORE_MAC_RX_CONFIGURATION_WD_CLR_MSK	0xffffff7f
/* The reset value of the CORE_MAC_RX_CONFIGURATION_WD register field. */
#define CORE_MAC_RX_CONFIGURATION_WD_RESET	0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_WD field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_WD_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_RX_CONFIGURATION_WD register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_WD_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : JE
 *
 * Jumbo Packet Enable.
 *
 * When this bit is set, the MAC allows jumbo packets of 9018 bytes (9022 bytes for
 * VLAN tagged packets) without reporting a giant packet error in the Rx packet
 * status.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_JE register field. */
#define CORE_MAC_RX_CONFIGURATION_JE_LSB	8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_JE register field. */
#define CORE_MAC_RX_CONFIGURATION_JE_MSB	8
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_JE register field. */
#define CORE_MAC_RX_CONFIGURATION_JE_WIDTH	1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_JE register field value. */
#define CORE_MAC_RX_CONFIGURATION_JE_SET_MSK	0x00000100
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_JE register field value. */
#define CORE_MAC_RX_CONFIGURATION_JE_CLR_MSK	0xfffffeff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_JE register field. */
#define CORE_MAC_RX_CONFIGURATION_JE_RESET	0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_JE field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_JE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_RX_CONFIGURATION_JE register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_JE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : IPC
 *
 * Checksum Offload.
 *
 * When set, this bit enables the IPv4 header checksum checking and IPv4 or IPv6
 * TCP, UDP, or ICMP payload checksum checking.
 *
 * When this bit is reset, the COE function in the receiver is disabled.
 *
 * The Layer 3 and Layer 4 Packet Filter, Enable Header-Payload Split, Enable
 * Receive Side Scaling and Enable Support for Virtualized Network features
 * automatically selects the IPC Full Checksum Offload Engine on the Receive side.
 * This bit must be set when any of these features are enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_IPC register field. */
#define CORE_MAC_RX_CONFIGURATION_IPC_LSB	 9
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_IPC register field. */
#define CORE_MAC_RX_CONFIGURATION_IPC_MSB	 9
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_IPC register field. */
#define CORE_MAC_RX_CONFIGURATION_IPC_WIDTH	 1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_IPC register field value. */
#define CORE_MAC_RX_CONFIGURATION_IPC_SET_MSK	 0x00000200
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_IPC register field value. */
#define CORE_MAC_RX_CONFIGURATION_IPC_CLR_MSK	 0xfffffdff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_IPC register field. */
#define CORE_MAC_RX_CONFIGURATION_IPC_RESET	 0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_IPC field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_IPC_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_RX_CONFIGURATION_IPC register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_IPC_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : LM
 *
 * Loopback Mode.
 *
 * When this bit is set, the MAC operates in the loopback mode at GMII or XGMII.
 * The (X)GMII Rx clock input (clk_rx_312pt5_i) is required for the loopback to
 * work properly. This is because the Tx clock is not internally looped back.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_LM register field. */
#define CORE_MAC_RX_CONFIGURATION_LM_LSB	10
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_LM register field. */
#define CORE_MAC_RX_CONFIGURATION_LM_MSB	10
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_LM register field. */
#define CORE_MAC_RX_CONFIGURATION_LM_WIDTH	1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_LM register field value. */
#define CORE_MAC_RX_CONFIGURATION_LM_SET_MSK	0x00000400
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_LM register field value. */
#define CORE_MAC_RX_CONFIGURATION_LM_CLR_MSK	0xfffffbff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_LM register field. */
#define CORE_MAC_RX_CONFIGURATION_LM_RESET	0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_LM field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_LM_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MAC_RX_CONFIGURATION_LM register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_LM_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : S2KP
 *
 * IEEE 802.3as Support for 2K Packets.
 *
 * When this bit is set, the MAC considers all packets with up to 2000 bytes length
 * as normal packets. When the JE bit is not set, the MAC considers all the
 * received packets of size more than 2K bytes as Giant packets.
 *
 * When this bit is reset and the JE bit is not set, the MAC considers all the
 * received packets of size more than 1518 bytes (1522 bytes for tagged) as giant
 * packets.
 *
 * Note:  When the JE bit is set, setting this bit has no effect on the giant
 * packet status.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_S2KP register field. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_LSB	  11
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_S2KP register field. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_MSB	  11
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_S2KP register field. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_WIDTH	  1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_S2KP register field value. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_SET_MSK	  0x00000800
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_S2KP register field value. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_CLR_MSK	  0xfffff7ff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_S2KP register field. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_RESET	  0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_S2KP field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_S2KP_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_RX_CONFIGURATION_S2KP register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_S2KP_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : HDSMS
 *
 * Maximum Size for Splitting the Header Data.
 *
 * These bits indicate the maximum header size allowed for splitting the header
 * data in the received packet:
 *
 * * 3'b000: 64 bytes
 *
 * * 3'b001: 128 bytes
 *
 * * 3'b010: 256 bytes
 *
 * * 3'b011: 512 bytes
 *
 * * 3'b100: 1023 bytes
 *
 * * 3'b101-3'b111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_HDSMS register field.
 */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_LSB	   12
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_HDSMS register field. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_MSB	   14
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_HDSMS register field. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_WIDTH	   3
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_HDSMS register field value. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_SET_MSK	   0x00007000
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_HDSMS register field value. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_CLR_MSK	   0xffff8fff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_HDSMS register field. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_RESET	   0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_HDSMS field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_GET(value) (((value)&0x00007000) >> 12)
/* Produces a CORE_MAC_RX_CONFIGURATION_HDSMS register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_CONFIGURATION_HDSMS_SET(value) (((value) << 12) & 0x00007000)

/*
 * Field : Reserved_PRXM
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register
 * field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_LSB	   15
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register
 * field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_MSB	   15
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_WIDTH	   1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register field value. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_SET_MSK	   0x00008000
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register field value. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_CLR_MSK	   0xffff7fff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_RESET	   0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : GPSL
 *
 * Giant Packet Size Limit.
 *
 * If the received packet size is greater than the value programmed in this field
 * in units of bytes, the MAC declares the received packet as Giant packet. The
 * value programmed in this field must be greater than or equal to 1518 bytes. Any
 * other programmed value is considered as 1518 bytes.
 *
 * For VLAN tagged packets, the MAC adds 4 bytes to the programmed value. The value
 * in this field is applicable when the GPSLCE bit is set in MAC_Rx_Configuration
 * register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_GPSL register field. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_LSB	  16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_GPSL register field. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_MSB	  29
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_GPSL register field. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_WIDTH	  14
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_GPSL register field value. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_SET_MSK	  0x3fff0000
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_GPSL register field value. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_CLR_MSK	  0xc000ffff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_GPSL register field. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_RESET	  0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_GPSL field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_GPSL_GET(value) (((value)&0x3fff0000) >> 16)
/* Produces a CORE_MAC_RX_CONFIGURATION_GPSL register field value suitable for setting the register.
 */
#define CORE_MAC_RX_CONFIGURATION_GPSL_SET(value) (((value) << 16) & 0x3fff0000)

/*
 * Field : Reserved_ELEN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register
 * field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_LSB	   30
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register
 * field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_MSB	   30
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_WIDTH	   1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register field value. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_SET_MSK	   0x40000000
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register field value. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_CLR_MSK	   0xbfffffff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register field. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_RESET	   0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : ARPEN
 *
 * ARP enable.
 *
 * When this bit is set, ARP offload is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_CONFIGURATION_ARPEN register field.
 */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_CONFIGURATION_ARPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_MSB	   31
/* The width in bits of the CORE_MAC_RX_CONFIGURATION_ARPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_WIDTH	   1
/* The mask used to set the CORE_MAC_RX_CONFIGURATION_ARPEN register field value. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MAC_RX_CONFIGURATION_ARPEN register field value. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MAC_RX_CONFIGURATION_ARPEN register field. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_RESET	   0x0
/* Extracts the CORE_MAC_RX_CONFIGURATION_ARPEN field value from a register. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_RX_CONFIGURATION_ARPEN register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_CONFIGURATION_ARPEN_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RX_CONFIGURATION.
 */
struct CORE_MAC_RX_CONFIGURATION_s {
	volatile uint32_t RE : 1;		   /* CORE_MAC_RX_CONFIGURATION_RE */
	volatile uint32_t ACS : 1;		   /* CORE_MAC_RX_CONFIGURATION_ACS */
	volatile uint32_t CST : 1;		   /* CORE_MAC_RX_CONFIGURATION_CST */
	volatile uint32_t DCRCC : 1;		   /* CORE_MAC_RX_CONFIGURATION_DCRCC */
	volatile uint32_t SPEN : 1;		   /* CORE_MAC_RX_CONFIGURATION_SPEN */
	volatile uint32_t USP : 1;		   /* CORE_MAC_RX_CONFIGURATION_USP */
	volatile uint32_t GPSLCE : 1;		   /* CORE_MAC_RX_CONFIGURATION_GPSLCE */
	volatile uint32_t WD : 1;		   /* CORE_MAC_RX_CONFIGURATION_WD */
	volatile uint32_t JE : 1;		   /* CORE_MAC_RX_CONFIGURATION_JE */
	volatile uint32_t IPC : 1;		   /* CORE_MAC_RX_CONFIGURATION_IPC */
	volatile uint32_t LM : 1;		   /* CORE_MAC_RX_CONFIGURATION_LM */
	volatile uint32_t S2KP : 1;		   /* CORE_MAC_RX_CONFIGURATION_S2KP */
	volatile uint32_t HDSMS : 3;		   /* CORE_MAC_RX_CONFIGURATION_HDSMS */
	const volatile uint32_t Reserved_PRXM : 1; /* CORE_MAC_RX_CONFIGURATION_RESERVED_PRXM */
	volatile uint32_t GPSL : 14;		   /* CORE_MAC_RX_CONFIGURATION_GPSL */
	const volatile uint32_t Reserved_ELEN : 1; /* CORE_MAC_RX_CONFIGURATION_RESERVED_ELEN */
	volatile uint32_t ARPEN : 1;		   /* CORE_MAC_RX_CONFIGURATION_ARPEN */
};

/* The typedef declaration for register CORE_MAC_RX_CONFIGURATION. */
typedef struct CORE_MAC_RX_CONFIGURATION_s CORE_MAC_RX_CONFIGURATION_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RX_CONFIGURATION register. */
#define CORE_MAC_RX_CONFIGURATION_RESET 0x00000000
/* The byte offset of the CORE_MAC_RX_CONFIGURATION register from the beginning of the component. */
#define CORE_MAC_RX_CONFIGURATION_OFST	0x4

/*
 * Register : MAC_Packet_Filter
 *
 * The MAC Packet Filter register contains the filter controls for receiving
 * packets. Some of the controls from this register go to the address check block
 * of the MAC which performs the first level of address filtering. The second level
 * of filtering is performed on the incoming packet based on other controls such as
 * Pass Bad Packets and Pass Control Packets.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_PR
 *  [1]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_HUC
 *  [2]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_HMC
 *  [3]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_DAIF
 *  [4]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_PM
 *  [5]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_DBF
 *  [7:6]   | RW     | 0x0   | CORE_MAC_PACKET_FILTER_PCF
 *  [8]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_SAIF
 *  [9]     | RW     | 0x0   | CORE_MAC_PACKET_FILTER_SAF
 *  [10]    | RW     | 0x0   | CORE_MAC_PACKET_FILTER_HPF
 *  [12:11] | RW     | 0x0   | CORE_MAC_PACKET_FILTER_DHLFRS
 *  [15:13] | R      | 0x0   | CORE_MAC_PACKET_FILTER_RESERVED_15_13
 *  [16]    | RW     | 0x0   | CORE_MAC_PACKET_FILTER_VTFE
 *  [19:17] | R      | 0x0   | CORE_MAC_PACKET_FILTER_RESERVED_19_17
 *  [20]    | RW     | 0x0   | CORE_MAC_PACKET_FILTER_IPFE
 *  [21]    | RW     | 0x0   | CORE_MAC_PACKET_FILTER_DNTU
 *  [22]    | R      | 0x0   | CORE_MAC_PACKET_FILTER_RESERVED_VUCC
 *  [30:23] | R      | 0x0   | CORE_MAC_PACKET_FILTER_RESERVED_30_23
 *  [31]    | RW     | 0x0   | CORE_MAC_PACKET_FILTER_RA
 *
 */
/*
 * Field : PR
 *
 * Promiscuous Mode.
 *
 * When this bit is set, the Address Filtering module passes all incoming packets
 * irrespective of the destination or source address. The SA or DA Filter Fails
 * status bits of the Rx Status Word are always cleared when PR is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_PR register field. */
#define CORE_MAC_PACKET_FILTER_PR_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_PR register field. */
#define CORE_MAC_PACKET_FILTER_PR_MSB	     0
/* The width in bits of the CORE_MAC_PACKET_FILTER_PR register field. */
#define CORE_MAC_PACKET_FILTER_PR_WIDTH	     1
/* The mask used to set the CORE_MAC_PACKET_FILTER_PR register field value. */
#define CORE_MAC_PACKET_FILTER_PR_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_PACKET_FILTER_PR register field value. */
#define CORE_MAC_PACKET_FILTER_PR_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_PACKET_FILTER_PR register field. */
#define CORE_MAC_PACKET_FILTER_PR_RESET	     0x0
/* Extracts the CORE_MAC_PACKET_FILTER_PR field value from a register. */
#define CORE_MAC_PACKET_FILTER_PR_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_PACKET_FILTER_PR register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_PR_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : HUC
 *
 * Hash Unicast.
 *
 * When this bit is set, the MAC performs the destination address filtering of
 * unicast packets according to the hash table.
 *
 * When this bit is reset, the MAC performs a perfect destination address filtering
 * for unicast packets, that is, it compares the DA field with the values
 * programmed in MAC_Address registers.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_HUC register field. */
#define CORE_MAC_PACKET_FILTER_HUC_LSB	      1
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_HUC register field. */
#define CORE_MAC_PACKET_FILTER_HUC_MSB	      1
/* The width in bits of the CORE_MAC_PACKET_FILTER_HUC register field. */
#define CORE_MAC_PACKET_FILTER_HUC_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_HUC register field value. */
#define CORE_MAC_PACKET_FILTER_HUC_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_PACKET_FILTER_HUC register field value. */
#define CORE_MAC_PACKET_FILTER_HUC_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_PACKET_FILTER_HUC register field. */
#define CORE_MAC_PACKET_FILTER_HUC_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_HUC field value from a register. */
#define CORE_MAC_PACKET_FILTER_HUC_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_PACKET_FILTER_HUC register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_HUC_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : HMC
 *
 * Hash Multicast.
 *
 * When this bit is set, the MAC performs the destination address filtering of
 * received multicast packets according to the hash table.
 *
 * When this bit is reset, the MAC performs the perfect destination address
 * filtering for multicast packets, that is, it compares the DA field with the
 * values programmed in MAC_Address registers.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_HMC register field. */
#define CORE_MAC_PACKET_FILTER_HMC_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_HMC register field. */
#define CORE_MAC_PACKET_FILTER_HMC_MSB	      2
/* The width in bits of the CORE_MAC_PACKET_FILTER_HMC register field. */
#define CORE_MAC_PACKET_FILTER_HMC_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_HMC register field value. */
#define CORE_MAC_PACKET_FILTER_HMC_SET_MSK    0x00000004
/* The mask used to clear the CORE_MAC_PACKET_FILTER_HMC register field value. */
#define CORE_MAC_PACKET_FILTER_HMC_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MAC_PACKET_FILTER_HMC register field. */
#define CORE_MAC_PACKET_FILTER_HMC_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_HMC field value from a register. */
#define CORE_MAC_PACKET_FILTER_HMC_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_PACKET_FILTER_HMC register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_HMC_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : DAIF
 *
 * DA Inverse Filtering.
 *
 * When this bit is set, the Address Check block operates in inverse filtering mode
 * for the DA address comparison for both unicast and multicast packets.
 *
 * When this bit is reset, normal filtering of packets is performed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_DAIF register field. */
#define CORE_MAC_PACKET_FILTER_DAIF_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_DAIF register field. */
#define CORE_MAC_PACKET_FILTER_DAIF_MSB	       3
/* The width in bits of the CORE_MAC_PACKET_FILTER_DAIF register field. */
#define CORE_MAC_PACKET_FILTER_DAIF_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_DAIF register field value. */
#define CORE_MAC_PACKET_FILTER_DAIF_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_PACKET_FILTER_DAIF register field value. */
#define CORE_MAC_PACKET_FILTER_DAIF_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_PACKET_FILTER_DAIF register field. */
#define CORE_MAC_PACKET_FILTER_DAIF_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_DAIF field value from a register. */
#define CORE_MAC_PACKET_FILTER_DAIF_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_PACKET_FILTER_DAIF register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_DAIF_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : PM
 *
 * Pass All Multicast.
 *
 * When this bit is set, it indicates that all the received packets with a
 * multicast destination address (first bit in the destination address field is 1)
 * are passed.
 *
 * When this bit is reset, filtering of multicast packet depends on HMC bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_PM register field. */
#define CORE_MAC_PACKET_FILTER_PM_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_PM register field. */
#define CORE_MAC_PACKET_FILTER_PM_MSB	     4
/* The width in bits of the CORE_MAC_PACKET_FILTER_PM register field. */
#define CORE_MAC_PACKET_FILTER_PM_WIDTH	     1
/* The mask used to set the CORE_MAC_PACKET_FILTER_PM register field value. */
#define CORE_MAC_PACKET_FILTER_PM_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_PACKET_FILTER_PM register field value. */
#define CORE_MAC_PACKET_FILTER_PM_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_PACKET_FILTER_PM register field. */
#define CORE_MAC_PACKET_FILTER_PM_RESET	     0x0
/* Extracts the CORE_MAC_PACKET_FILTER_PM field value from a register. */
#define CORE_MAC_PACKET_FILTER_PM_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_PACKET_FILTER_PM register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_PM_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : DBF
 *
 * Disable Broadcast Packets.
 *
 * When this bit is set, the AFM module blocks all incoming broadcast packets. In
 * addition, it overrides all other filter settings.
 *
 * When this bit is reset, the AFM module passes all the received broadcast
 * packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_DBF register field. */
#define CORE_MAC_PACKET_FILTER_DBF_LSB	      5
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_DBF register field. */
#define CORE_MAC_PACKET_FILTER_DBF_MSB	      5
/* The width in bits of the CORE_MAC_PACKET_FILTER_DBF register field. */
#define CORE_MAC_PACKET_FILTER_DBF_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_DBF register field value. */
#define CORE_MAC_PACKET_FILTER_DBF_SET_MSK    0x00000020
/* The mask used to clear the CORE_MAC_PACKET_FILTER_DBF register field value. */
#define CORE_MAC_PACKET_FILTER_DBF_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MAC_PACKET_FILTER_DBF register field. */
#define CORE_MAC_PACKET_FILTER_DBF_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_DBF field value from a register. */
#define CORE_MAC_PACKET_FILTER_DBF_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_PACKET_FILTER_DBF register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_DBF_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : PCF
 *
 * Pass Control Packets.
 *
 * These bits control the forwarding of all control packets (including unicast and
 * multicast Pause packets).
 *
 * * 00: The MAC filters all control packets from reaching the application.
 *
 * * 01: The MAC forwards all control packets except Pause packets to the
 *   application even if they fail the Address filter.
 *
 * * 10: The MAC forwards all control packets to the application even if they fail
 *   the Address filter.
 *
 * * 11: The MAC forwards the control packets that pass the Address filter.
 *
 * When G9991 Ethernet encapsulated mode is enabled, this is true for DFC control
 * packets (when both OPCODE and TIME field matches it is DFC Pause packet and when
 * Type field matches it is DFC generic control packet).
 *
 * When G9991 native mode is enabled, these bits control the forwarding of DFC
 * PAUSE packets (when both OPCODE and TIME field matches it is DFC Pause packet
 * and the DFC generic control packet definition is not valid in this case as the
 * Type field is not present) as follows:
 *
 * * 00/01: The MAC filters all DFC Pause packets from reaching the application.
 *
 * * 10/11: The MAC forwards all the DFC Pause packets to application.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_PCF register field. */
#define CORE_MAC_PACKET_FILTER_PCF_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_PCF register field. */
#define CORE_MAC_PACKET_FILTER_PCF_MSB	      7
/* The width in bits of the CORE_MAC_PACKET_FILTER_PCF register field. */
#define CORE_MAC_PACKET_FILTER_PCF_WIDTH      2
/* The mask used to set the CORE_MAC_PACKET_FILTER_PCF register field value. */
#define CORE_MAC_PACKET_FILTER_PCF_SET_MSK    0x000000c0
/* The mask used to clear the CORE_MAC_PACKET_FILTER_PCF register field value. */
#define CORE_MAC_PACKET_FILTER_PCF_CLR_MSK    0xffffff3f
/* The reset value of the CORE_MAC_PACKET_FILTER_PCF register field. */
#define CORE_MAC_PACKET_FILTER_PCF_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_PCF field value from a register. */
#define CORE_MAC_PACKET_FILTER_PCF_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a CORE_MAC_PACKET_FILTER_PCF register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_PCF_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : SAIF
 *
 * SA Inverse Filtering.
 *
 * When this bit is set, the Address Check block operates in the inverse filtering
 * mode for SA address comparison. If the SA of a packet matches the values
 * programmed in the MAC_Address registers, it is marked as failing the SA Address
 * filter.
 *
 * When this bit is reset, if the SA of a packet does not match the values
 * programmed in the MAC_Address registers, it is marked as failing the SA Address
 * filter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_SAIF register field. */
#define CORE_MAC_PACKET_FILTER_SAIF_LSB	       8
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_SAIF register field. */
#define CORE_MAC_PACKET_FILTER_SAIF_MSB	       8
/* The width in bits of the CORE_MAC_PACKET_FILTER_SAIF register field. */
#define CORE_MAC_PACKET_FILTER_SAIF_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_SAIF register field value. */
#define CORE_MAC_PACKET_FILTER_SAIF_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_PACKET_FILTER_SAIF register field value. */
#define CORE_MAC_PACKET_FILTER_SAIF_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_PACKET_FILTER_SAIF register field. */
#define CORE_MAC_PACKET_FILTER_SAIF_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_SAIF field value from a register. */
#define CORE_MAC_PACKET_FILTER_SAIF_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_PACKET_FILTER_SAIF register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_SAIF_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : SAF
 *
 * Source Address Filter Enable.
 *
 * When this bit is set, the MAC compares the SA field of the received packets with
 * the values programmed in the enabled MAC_Address registers. If the comparison
 * fails, the MAC drops the packet.
 *
 * When this bit is reset, the MAC forwards the received packet to the application
 * with updated SAF bit of the Rx Status depending on the SA address comparison.
 *
 * Note:  According to the IEEE specification, Bit 47 of the SA is reserved.
 * However, in DWC_xgmac, the MAC compares all 48 bits. The software driver should
 * consider this while programming the MAC address registers for SA.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_SAF register field. */
#define CORE_MAC_PACKET_FILTER_SAF_LSB	      9
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_SAF register field. */
#define CORE_MAC_PACKET_FILTER_SAF_MSB	      9
/* The width in bits of the CORE_MAC_PACKET_FILTER_SAF register field. */
#define CORE_MAC_PACKET_FILTER_SAF_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_SAF register field value. */
#define CORE_MAC_PACKET_FILTER_SAF_SET_MSK    0x00000200
/* The mask used to clear the CORE_MAC_PACKET_FILTER_SAF register field value. */
#define CORE_MAC_PACKET_FILTER_SAF_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MAC_PACKET_FILTER_SAF register field. */
#define CORE_MAC_PACKET_FILTER_SAF_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_SAF field value from a register. */
#define CORE_MAC_PACKET_FILTER_SAF_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_PACKET_FILTER_SAF register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_SAF_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : HPF
 *
 * Hash or Perfect Filter.
 *
 * When this bit is set, the address filter passes a packet if it matches either
 * the perfect filtering or hash filtering as set by the HMC or HUC bit.
 *
 * When this bit is reset and the HUC or HMC bit is set, the packet is passed only
 * if it matches the Hash filter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_HPF register field. */
#define CORE_MAC_PACKET_FILTER_HPF_LSB	      10
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_HPF register field. */
#define CORE_MAC_PACKET_FILTER_HPF_MSB	      10
/* The width in bits of the CORE_MAC_PACKET_FILTER_HPF register field. */
#define CORE_MAC_PACKET_FILTER_HPF_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_HPF register field value. */
#define CORE_MAC_PACKET_FILTER_HPF_SET_MSK    0x00000400
/* The mask used to clear the CORE_MAC_PACKET_FILTER_HPF register field value. */
#define CORE_MAC_PACKET_FILTER_HPF_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MAC_PACKET_FILTER_HPF register field. */
#define CORE_MAC_PACKET_FILTER_HPF_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_HPF field value from a register. */
#define CORE_MAC_PACKET_FILTER_HPF_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MAC_PACKET_FILTER_HPF register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_HPF_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : DHLFRS
 *
 * DA Hash Index or L3/L4 Filter Number in Receive Status.
 *
 * This field selects either DA hash index, L3/L4 filter number or both information
 * to provide in receive descriptor.
 *
 * Values: 0x0: Use both backward compatible DA hash index & L3/L4 filter number
 * fields in receive status.
 *
 * For its proper usage, program DA hash table and number of L3/L4 filters in such
 * way that these index fields can be accommodated respective index/number.
 *
 * 0x1: Use combined DA hash table index and L3/L4 filter number fields to provide
 * only DA hash table index.
 *
 * 0x2: Use combined DA hash table index and L3/L4 filter number fields to provide
 * only L3/L4 filter number.
 *
 * 0x3: Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_DHLFRS register field. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_LSB	 11
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_DHLFRS register field. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_MSB	 12
/* The width in bits of the CORE_MAC_PACKET_FILTER_DHLFRS register field. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_WIDTH	 2
/* The mask used to set the CORE_MAC_PACKET_FILTER_DHLFRS register field value. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_SET_MSK	 0x00001800
/* The mask used to clear the CORE_MAC_PACKET_FILTER_DHLFRS register field value. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_CLR_MSK	 0xffffe7ff
/* The reset value of the CORE_MAC_PACKET_FILTER_DHLFRS register field. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_RESET	 0x0
/* Extracts the CORE_MAC_PACKET_FILTER_DHLFRS field value from a register. */
#define CORE_MAC_PACKET_FILTER_DHLFRS_GET(value) (((value)&0x00001800) >> 11)
/* Produces a CORE_MAC_PACKET_FILTER_DHLFRS register field value suitable for setting the register.
 */
#define CORE_MAC_PACKET_FILTER_DHLFRS_SET(value) (((value) << 11) & 0x00001800)

/*
 * Field : Reserved_15_13
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_15_13 register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_LSB	 13
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_15_13 register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_MSB	 15
/* The width in bits of the CORE_MAC_PACKET_FILTER_RESERVED_15_13 register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_WIDTH	 3
/* The mask used to set the CORE_MAC_PACKET_FILTER_RESERVED_15_13 register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_SET_MSK	 0x0000e000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_RESERVED_15_13 register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_CLR_MSK	 0xffff1fff
/* The reset value of the CORE_MAC_PACKET_FILTER_RESERVED_15_13 register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_RESET	 0x0
/* Extracts the CORE_MAC_PACKET_FILTER_RESERVED_15_13 field value from a register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_GET(value) (((value)&0x0000e000) >> 13)
/* Produces a CORE_MAC_PACKET_FILTER_RESERVED_15_13 register field value suitable for setting the
 * register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_15_13_SET(value) (((value) << 13) & 0x0000e000)

/*
 * Field : VTFE
 *
 * VLAN Tag Filter Enable.
 *
 * When this bit is set, the MAC drops the VLAN tagged packets that do not match
 * the VLAN Tag. When this bit is reset, the MAC forwards all packets irrespective
 * of the match status of the VLAN Tag.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_VTFE register field. */
#define CORE_MAC_PACKET_FILTER_VTFE_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_VTFE register field. */
#define CORE_MAC_PACKET_FILTER_VTFE_MSB	       16
/* The width in bits of the CORE_MAC_PACKET_FILTER_VTFE register field. */
#define CORE_MAC_PACKET_FILTER_VTFE_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_VTFE register field value. */
#define CORE_MAC_PACKET_FILTER_VTFE_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_VTFE register field value. */
#define CORE_MAC_PACKET_FILTER_VTFE_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_PACKET_FILTER_VTFE register field. */
#define CORE_MAC_PACKET_FILTER_VTFE_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_VTFE field value from a register. */
#define CORE_MAC_PACKET_FILTER_VTFE_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_PACKET_FILTER_VTFE register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_VTFE_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : Reserved_19_17
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_19_17 register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_LSB	 17
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_19_17 register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_MSB	 19
/* The width in bits of the CORE_MAC_PACKET_FILTER_RESERVED_19_17 register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_WIDTH	 3
/* The mask used to set the CORE_MAC_PACKET_FILTER_RESERVED_19_17 register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_SET_MSK	 0x000e0000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_RESERVED_19_17 register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_CLR_MSK	 0xfff1ffff
/* The reset value of the CORE_MAC_PACKET_FILTER_RESERVED_19_17 register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_RESET	 0x0
/* Extracts the CORE_MAC_PACKET_FILTER_RESERVED_19_17 field value from a register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_GET(value) (((value)&0x000e0000) >> 17)
/* Produces a CORE_MAC_PACKET_FILTER_RESERVED_19_17 register field value suitable for setting the
 * register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_19_17_SET(value) (((value) << 17) & 0x000e0000)

/*
 * Field : IPFE
 *
 * Layer 3 and Layer 4 Filter Enable.
 *
 * When this bit is set, the MAC drops packets that do not match the enabled Layer
 * 3 and Layer 4 filters. If Layer 3 or Layer 4 filters are not enabled for
 * matching, this bit does not have any effect.
 *
 * When this bit is reset, the MAC forwards all packets irrespective of the match
 * status of the Layer 3 and Layer 4 fields.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_IPFE register field. */
#define CORE_MAC_PACKET_FILTER_IPFE_LSB	       20
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_IPFE register field. */
#define CORE_MAC_PACKET_FILTER_IPFE_MSB	       20
/* The width in bits of the CORE_MAC_PACKET_FILTER_IPFE register field. */
#define CORE_MAC_PACKET_FILTER_IPFE_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_IPFE register field value. */
#define CORE_MAC_PACKET_FILTER_IPFE_SET_MSK    0x00100000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_IPFE register field value. */
#define CORE_MAC_PACKET_FILTER_IPFE_CLR_MSK    0xffefffff
/* The reset value of the CORE_MAC_PACKET_FILTER_IPFE register field. */
#define CORE_MAC_PACKET_FILTER_IPFE_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_IPFE field value from a register. */
#define CORE_MAC_PACKET_FILTER_IPFE_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_PACKET_FILTER_IPFE register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_IPFE_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : DNTU
 *
 * Drop Non-TCP/UDP over IP Packets.
 *
 * When this bit is set, the MAC drops the non-TCP or UDP over IP packets. The MAC
 * forward only those packets that are processed by the Layer 4 filter. When this
 * bit is reset, the MAC forwards all non-TCP or UDP over IP packets.
 *
 * When support for L2 Virtualized network over L3 Network is enabled,
 *
 * * If VNE=1 and VNM=0, all non VxLAN type packets and all non-TCP/UDP type normal
 *   packets are dropped.
 *
 * * If VNE=1 and VNM=1, all non NVGRE type packets and all non-TCP/UDP type normal
 *   packets are dropped.
 *
 * * If VNE=0, all non-TCP/UDP type normal packets are dropped.
 *
 * Note:  When this bit is set in NVGRE mode (when VNE=1, VNM=1), NVGRE packets
 * (which are also non-TCP/UDP) are not dropped.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_DNTU register field. */
#define CORE_MAC_PACKET_FILTER_DNTU_LSB	       21
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_DNTU register field. */
#define CORE_MAC_PACKET_FILTER_DNTU_MSB	       21
/* The width in bits of the CORE_MAC_PACKET_FILTER_DNTU register field. */
#define CORE_MAC_PACKET_FILTER_DNTU_WIDTH      1
/* The mask used to set the CORE_MAC_PACKET_FILTER_DNTU register field value. */
#define CORE_MAC_PACKET_FILTER_DNTU_SET_MSK    0x00200000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_DNTU register field value. */
#define CORE_MAC_PACKET_FILTER_DNTU_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MAC_PACKET_FILTER_DNTU register field. */
#define CORE_MAC_PACKET_FILTER_DNTU_RESET      0x0
/* Extracts the CORE_MAC_PACKET_FILTER_DNTU field value from a register. */
#define CORE_MAC_PACKET_FILTER_DNTU_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MAC_PACKET_FILTER_DNTU register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_DNTU_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : Reserved_VUCC
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_VUCC register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_LSB	22
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_VUCC register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_MSB	22
/* The width in bits of the CORE_MAC_PACKET_FILTER_RESERVED_VUCC register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_WIDTH	1
/* The mask used to set the CORE_MAC_PACKET_FILTER_RESERVED_VUCC register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_SET_MSK	0x00400000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_RESERVED_VUCC register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_CLR_MSK	0xffbfffff
/* The reset value of the CORE_MAC_PACKET_FILTER_RESERVED_VUCC register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_RESET	0x0
/* Extracts the CORE_MAC_PACKET_FILTER_RESERVED_VUCC field value from a register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MAC_PACKET_FILTER_RESERVED_VUCC register field value suitable for setting the
 * register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_VUCC_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : Reserved_30_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_30_23 register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_LSB	 23
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_RESERVED_30_23 register
 * field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_MSB	 30
/* The width in bits of the CORE_MAC_PACKET_FILTER_RESERVED_30_23 register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_WIDTH	 8
/* The mask used to set the CORE_MAC_PACKET_FILTER_RESERVED_30_23 register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_SET_MSK	 0x7f800000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_RESERVED_30_23 register field value. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_CLR_MSK	 0x807fffff
/* The reset value of the CORE_MAC_PACKET_FILTER_RESERVED_30_23 register field. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_RESET	 0x0
/* Extracts the CORE_MAC_PACKET_FILTER_RESERVED_30_23 field value from a register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_GET(value) (((value)&0x7f800000) >> 23)
/* Produces a CORE_MAC_PACKET_FILTER_RESERVED_30_23 register field value suitable for setting the
 * register. */
#define CORE_MAC_PACKET_FILTER_RESERVED_30_23_SET(value) (((value) << 23) & 0x7f800000)

/*
 * Field : RA
 *
 * Receive All.
 *
 * When this bit is set, the MAC Receiver module passes all the received packets to
 * the application, irrespective of whether they pass the address filter or not.
 * The result of the SA or DA filtering is updated (pass or fail) in the
 * corresponding bit in the Rx Status Word.
 *
 * When this bit is reset, the Receiver module passes only those packets to the
 * application that pass the SA or DA address filter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PACKET_FILTER_RA register field. */
#define CORE_MAC_PACKET_FILTER_RA_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_PACKET_FILTER_RA register field. */
#define CORE_MAC_PACKET_FILTER_RA_MSB	     31
/* The width in bits of the CORE_MAC_PACKET_FILTER_RA register field. */
#define CORE_MAC_PACKET_FILTER_RA_WIDTH	     1
/* The mask used to set the CORE_MAC_PACKET_FILTER_RA register field value. */
#define CORE_MAC_PACKET_FILTER_RA_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_PACKET_FILTER_RA register field value. */
#define CORE_MAC_PACKET_FILTER_RA_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_PACKET_FILTER_RA register field. */
#define CORE_MAC_PACKET_FILTER_RA_RESET	     0x0
/* Extracts the CORE_MAC_PACKET_FILTER_RA field value from a register. */
#define CORE_MAC_PACKET_FILTER_RA_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_PACKET_FILTER_RA register field value suitable for setting the register. */
#define CORE_MAC_PACKET_FILTER_RA_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PACKET_FILTER.
 */
struct CORE_MAC_PACKET_FILTER_s {
	volatile uint32_t PR : 1;		    /* CORE_MAC_PACKET_FILTER_PR */
	volatile uint32_t HUC : 1;		    /* CORE_MAC_PACKET_FILTER_HUC */
	volatile uint32_t HMC : 1;		    /* CORE_MAC_PACKET_FILTER_HMC */
	volatile uint32_t DAIF : 1;		    /* CORE_MAC_PACKET_FILTER_DAIF */
	volatile uint32_t PM : 1;		    /* CORE_MAC_PACKET_FILTER_PM */
	volatile uint32_t DBF : 1;		    /* CORE_MAC_PACKET_FILTER_DBF */
	volatile uint32_t PCF : 2;		    /* CORE_MAC_PACKET_FILTER_PCF */
	volatile uint32_t SAIF : 1;		    /* CORE_MAC_PACKET_FILTER_SAIF */
	volatile uint32_t SAF : 1;		    /* CORE_MAC_PACKET_FILTER_SAF */
	volatile uint32_t HPF : 1;		    /* CORE_MAC_PACKET_FILTER_HPF */
	volatile uint32_t DHLFRS : 2;		    /* CORE_MAC_PACKET_FILTER_DHLFRS */
	const volatile uint32_t Reserved_15_13 : 3; /* CORE_MAC_PACKET_FILTER_RESERVED_15_13 */
	volatile uint32_t VTFE : 1;		    /* CORE_MAC_PACKET_FILTER_VTFE */
	const volatile uint32_t Reserved_19_17 : 3; /* CORE_MAC_PACKET_FILTER_RESERVED_19_17 */
	volatile uint32_t IPFE : 1;		    /* CORE_MAC_PACKET_FILTER_IPFE */
	volatile uint32_t DNTU : 1;		    /* CORE_MAC_PACKET_FILTER_DNTU */
	const volatile uint32_t Reserved_VUCC : 1;  /* CORE_MAC_PACKET_FILTER_RESERVED_VUCC */
	const volatile uint32_t Reserved_30_23 : 8; /* CORE_MAC_PACKET_FILTER_RESERVED_30_23 */
	volatile uint32_t RA : 1;		    /* CORE_MAC_PACKET_FILTER_RA */
};

/* The typedef declaration for register CORE_MAC_PACKET_FILTER. */
typedef struct CORE_MAC_PACKET_FILTER_s CORE_MAC_PACKET_FILTER_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PACKET_FILTER register. */
#define CORE_MAC_PACKET_FILTER_RESET 0x00000000
/* The byte offset of the CORE_MAC_PACKET_FILTER register from the beginning of the component. */
#define CORE_MAC_PACKET_FILTER_OFST  0x8

/*
 * Register : MAC_WD_JB_Timeout
 *
 * The Watchdog and Jabber Timeout register controls the watchdog timeout limit for
 * received packets and jabber timeout limit for transmitted packets.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------
 *  [3:0]   | RW     | 0x0   | CORE_MAC_WD_JB_TIMEOUT_WTO
 *  [7:4]   | R      | 0x0   | CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4
 *  [8]     | RW     | 0x0   | CORE_MAC_WD_JB_TIMEOUT_PWE
 *  [15:9]  | R      | 0x0   | CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9
 *  [19:16] | RW     | 0x0   | CORE_MAC_WD_JB_TIMEOUT_JTO
 *  [23:20] | R      | 0x0   | CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20
 *  [24]    | RW     | 0x0   | CORE_MAC_WD_JB_TIMEOUT_PJE
 *  [31:25] | R      | 0x0   | CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25
 *
 */
/*
 * Field : WTO
 *
 * Watchdog Timeout.
 *
 * When the PWE bit is set and the WD bit of the MAC_Rx_Configuration register is
 * reset, this field is used as watchdog timeout limit for a received packet. If
 * the length of a received packet exceeds the value of this field, such a packet
 * is terminated and declared as an error packet.
 *
 * Encoding is as follows:
 *
 * * 4'h0: 2 KB
 *
 * * 4'h1: 3 KB
 *
 * * 4'h2: 4 KB
 *
 * * 4'h3: 5 KB
 *
 * * ...
 *
 * * 4'hC: 14 KB
 *
 * * 4'hD: 15 KB
 *
 * * 4'hE: 16383 Bytes
 *
 * * 4'hF: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_WTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_WTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_MSB	      3
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_WTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_WIDTH      4
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_WTO register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_SET_MSK    0x0000000f
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_WTO register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_CLR_MSK    0xfffffff0
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_WTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_RESET      0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_WTO field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_WTO register field value suitable for setting the register. */
#define CORE_MAC_WD_JB_TIMEOUT_WTO_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : Reserved_7_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_LSB	       4
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_MSB	       7
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_WIDTH      4
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_SET_MSK    0x000000f0
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_CLR_MSK    0xffffff0f
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_RESET      0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_GET(value) (((value)&0x000000f0) >> 4)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 register field value suitable for setting the
 * register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4_SET(value) (((value) << 4) & 0x000000f0)

/*
 * Field : PWE
 *
 * Programmable Watchdog Enable.
 *
 * When this bit is set and the WD bit of the MAC_Rx_Configuration register is
 * reset, the WTO field is used as watchdog timeout limit for a received packet.
 *
 * When this bit is cleared, the watchdog timeout for a received packet is
 * controlled by setting of WD and JE bits in MAC_Rx_Configuration register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_PWE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_LSB	      8
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_PWE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_MSB	      8
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_PWE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_WIDTH      1
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_PWE register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_PWE register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_PWE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_RESET      0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_PWE field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_PWE register field value suitable for setting the register. */
#define CORE_MAC_WD_JB_TIMEOUT_PWE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : Reserved_15_9
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_LSB	9
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_MSB	15
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_WIDTH	7
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_SET_MSK	0x0000fe00
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_CLR_MSK	0xffff01ff
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_RESET	0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_GET(value) (((value)&0x0000fe00) >> 9)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 register field value suitable for setting the
 * register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9_SET(value) (((value) << 9) & 0x0000fe00)

/*
 * Field : JTO
 *
 * Jabber Timeout.
 *
 * When the PJE bit is set and the JD bit of the MAC_Tx_Configuration register is
 * reset, this field is used as jabber timeout limit for a transmitted packet. If
 * the length of a transmitted packet exceeds the value of this field, such a
 * packet is terminated and declared as an error packet.
 *
 * Encoding is as follows:
 *
 * * 4'h0: 2 KB
 *
 * * 4'h1: 3 KB
 *
 * * 4'h2: 4 KB
 *
 * * 4'h3: 5 KB
 *
 * * ...
 *
 * * 4'hC: 14 KB
 *
 * * 4'hD: 15 KB
 *
 * * 4'hE: 16383 Bytes
 *
 * * 4'hF: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_JTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_JTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_MSB	      19
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_JTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_WIDTH      4
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_JTO register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_SET_MSK    0x000f0000
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_JTO register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_CLR_MSK    0xfff0ffff
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_JTO register field. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_RESET      0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_JTO field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_JTO register field value suitable for setting the register. */
#define CORE_MAC_WD_JB_TIMEOUT_JTO_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : Reserved_23_20
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_LSB	 20
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_MSB	 23
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_WIDTH	 4
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_SET_MSK	 0x00f00000
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_CLR_MSK	 0xff0fffff
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_RESET	 0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_GET(value) (((value)&0x00f00000) >> 20)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 register field value suitable for setting the
 * register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20_SET(value) (((value) << 20) & 0x00f00000)

/*
 * Field : PJE
 *
 * Programmable Jabber Enable.
 *
 * When this bit is set and the JD bit of the MAC_Tx_Configuration register is
 * reset, the JTO field is used as jabber timeout limit for a transmitted packet.
 *
 * When this bit is cleared, the jabber timeout limit for a transmitted packet is
 * controlled by setting of JD and JE bits in MAC_Tx_Configuration and
 * MAC_Rx_Configuration registers, respectively.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_PJE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_PJE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_MSB	      24
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_PJE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_WIDTH      1
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_PJE register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_SET_MSK    0x01000000
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_PJE register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_PJE register field. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_RESET      0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_PJE field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_PJE register field value suitable for setting the register. */
#define CORE_MAC_WD_JB_TIMEOUT_PJE_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : Reserved_31_25
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_LSB	 25
/* The Most Significant Bit (MSB) position of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register
 * field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_MSB	 31
/* The width in bits of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_WIDTH	 7
/* The mask used to set the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_SET_MSK	 0xfe000000
/* The mask used to clear the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register field value. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_CLR_MSK	 0x01ffffff
/* The reset value of the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register field. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_RESET	 0x0
/* Extracts the CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 field value from a register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_GET(value) (((value)&0xfe000000) >> 25)
/* Produces a CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 register field value suitable for setting the
 * register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25_SET(value) (((value) << 25) & 0xfe000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_WD_JB_TIMEOUT.
 */
struct CORE_MAC_WD_JB_TIMEOUT_s {
	volatile uint32_t WTO : 4;		    /* CORE_MAC_WD_JB_TIMEOUT_WTO */
	const volatile uint32_t Reserved_7_4 : 4;   /* CORE_MAC_WD_JB_TIMEOUT_RESERVED_7_4 */
	volatile uint32_t PWE : 1;		    /* CORE_MAC_WD_JB_TIMEOUT_PWE */
	const volatile uint32_t Reserved_15_9 : 7;  /* CORE_MAC_WD_JB_TIMEOUT_RESERVED_15_9 */
	volatile uint32_t JTO : 4;		    /* CORE_MAC_WD_JB_TIMEOUT_JTO */
	const volatile uint32_t Reserved_23_20 : 4; /* CORE_MAC_WD_JB_TIMEOUT_RESERVED_23_20 */
	volatile uint32_t PJE : 1;		    /* CORE_MAC_WD_JB_TIMEOUT_PJE */
	const volatile uint32_t Reserved_31_25 : 7; /* CORE_MAC_WD_JB_TIMEOUT_RESERVED_31_25 */
};

/* The typedef declaration for register CORE_MAC_WD_JB_TIMEOUT. */
typedef struct CORE_MAC_WD_JB_TIMEOUT_s CORE_MAC_WD_JB_TIMEOUT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_WD_JB_TIMEOUT register. */
#define CORE_MAC_WD_JB_TIMEOUT_RESET 0x00000000
/* The byte offset of the CORE_MAC_WD_JB_TIMEOUT register from the beginning of the component. */
#define CORE_MAC_WD_JB_TIMEOUT_OFST  0xc

/*
 * Register : MAC_Hash_Table_Reg0
 *
 * You can specify the width of the hash table by using the Hash Table Size option
 * in coreConsultant.
 *
 * The 64-bit, 128-bit, or 256-bit hash table is used for group address filtering.
 * For hash filtering, the content of the destination address in the incoming
 * packet is passed through the CRC logic and the upper six (seven or eight in 128-
 * or 256-bit Hash) bits of the CRC register are used to index the content of the
 * Hash table. The most significant bits determines the register to be used (Hash
 * Table Register X), and the least significant five bits determine the bit within
 * the register. For example, a hash value of 7b'1100000 (in 128-bit Hash) selects
 * Bit 0 of the Hash Table Register 3 and a value of 8b'10111111 (in 256-bit Hash)
 * selects Bit 31 of the Hash Table Register 5.
 *
 * The hash value of the destination address is calculated in the following way:
 *
 * * Calculate the 32-bit CRC for the DA (See IEEE 802.3-2018, Section 3.2.8 for
 *   the steps to calculate CRC32).
 *
 * * Perform bit-wise reversal for the value obtained in Step 1.
 *
 * * Take the upper 6 (or 7 or 8) bits from the value obtained in Step 2.
 *
 * If the corresponding bit value of the register is 1'b1, the packet is accepted.
 * Otherwise, it is rejected. If the PM bit is set in MAC_Packet_Filter, all
 * multicast packets are accepted regardless of the multicast hash values.
 *
 * If the Hash Table register is configured to be double-synchronized to the
 * (X)GMII clock domain, the synchronization is triggered only when Bits[31:24] (in
 * little-endian mode) or Bits[7:0] (in big-endian mode) of the Hash Table Register
 * X registers are written.
 *
 * If double-synchronization is enabled, consecutive writes to this register should
 * be performed after at least four clock cycles in the destination clock domain.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_HASH_TABLE_REG0_HT31T0
 *
 */
/*
 * Field : HT31T0
 *
 * First 32 bits of Hash Table.
 *
 * This field contains the first 32 Bits[31:0] of the Hash table.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HASH_TABLE_REG0_HT31T0 register field.
 */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HASH_TABLE_REG0_HT31T0 register field. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_MSB	   31
/* The width in bits of the CORE_MAC_HASH_TABLE_REG0_HT31T0 register field. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_WIDTH	   32
/* The mask used to set the CORE_MAC_HASH_TABLE_REG0_HT31T0 register field value. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_MAC_HASH_TABLE_REG0_HT31T0 register field value. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_CLR_MSK	   0x00000000
/* The reset value of the CORE_MAC_HASH_TABLE_REG0_HT31T0 register field. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_RESET	   0x0
/* Extracts the CORE_MAC_HASH_TABLE_REG0_HT31T0 field value from a register. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_HASH_TABLE_REG0_HT31T0 register field value suitable for setting the
 * register. */
#define CORE_MAC_HASH_TABLE_REG0_HT31T0_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HASH_TABLE_REG0.
 */
struct CORE_MAC_HASH_TABLE_REG0_s {
	volatile uint32_t HT31T0 : 32; /* CORE_MAC_HASH_TABLE_REG0_HT31T0 */
};

/* The typedef declaration for register CORE_MAC_HASH_TABLE_REG0. */
typedef struct CORE_MAC_HASH_TABLE_REG0_s CORE_MAC_HASH_TABLE_REG0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HASH_TABLE_REG0 register. */
#define CORE_MAC_HASH_TABLE_REG0_RESET 0x00000000
/* The byte offset of the CORE_MAC_HASH_TABLE_REG0 register from the beginning of the component. */
#define CORE_MAC_HASH_TABLE_REG0_OFST  0x10

/*
 * Register : MAC_Hash_Table_Reg1
 *
 * You can specify the width of the hash table by using the Hash Table Size option
 * in coreConsultant.
 *
 * The 64-bit, 128-bit, or 256-bit hash table is used for group address filtering.
 * For hash filtering, the content of the destination address in the incoming
 * packet is passed through the CRC logic and the upper six (seven or eight in 128-
 * or 256-bit Hash) bits of the CRC register are used to index the content of the
 * Hash table. The most significant bits determines the register to be used (Hash
 * Table Register X), and the least significant five bits determine the bit within
 * the register. For example, a hash value of 7b'1100000 (in 128-bit Hash) selects
 * Bit 0 of the Hash Table Register 3 and a value of 8b'10111111 (in 256-bit Hash)
 * selects Bit 31 of the Hash Table Register 5.
 *
 * The hash value of the destination address is calculated in the following way:
 *
 * * Calculate the 32-bit CRC for the DA (See IEEE 802.3-2018, Section 3.2.8 for
 *   the steps to calculate CRC32).
 *
 * * Perform bit-wise reversal for the value obtained in Step 1.
 *
 * * Take the upper 6 (or 7 or 8) bits from the value obtained in Step 2.
 *
 * If the corresponding bit value of the register is 1'b1, the packet is accepted.
 * Otherwise, it is rejected. If the PM bit is set in MAC_Packet_Filter, all
 * multicast packets are accepted regardless of the multicast hash values.
 *
 * If the Hash Table register is configured to be double-synchronized to the
 * (X)GMII clock domain, the synchronization is triggered only when Bits[31:24] (in
 * little-endian mode) or Bits[7:0] (in big-endian mode) of the Hash Table Register
 * X registers are written.
 *
 * If double-synchronization is enabled, consecutive writes to this register should
 * be performed after at least four clock cycles in the destination clock domain.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_HASH_TABLE_REG1_HT31T0
 *
 */
/*
 * Field : HT31T0
 *
 * First 32 bits of Hash Table.
 *
 * This field contains the first 32 Bits[31:0] of the Hash table.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HASH_TABLE_REG1_HT31T0 register field.
 */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HASH_TABLE_REG1_HT31T0 register field. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_MSB	   31
/* The width in bits of the CORE_MAC_HASH_TABLE_REG1_HT31T0 register field. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_WIDTH	   32
/* The mask used to set the CORE_MAC_HASH_TABLE_REG1_HT31T0 register field value. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_MAC_HASH_TABLE_REG1_HT31T0 register field value. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_CLR_MSK	   0x00000000
/* The reset value of the CORE_MAC_HASH_TABLE_REG1_HT31T0 register field. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_RESET	   0x0
/* Extracts the CORE_MAC_HASH_TABLE_REG1_HT31T0 field value from a register. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_HASH_TABLE_REG1_HT31T0 register field value suitable for setting the
 * register. */
#define CORE_MAC_HASH_TABLE_REG1_HT31T0_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HASH_TABLE_REG1.
 */
struct CORE_MAC_HASH_TABLE_REG1_s {
	volatile uint32_t HT31T0 : 32; /* CORE_MAC_HASH_TABLE_REG1_HT31T0 */
};

/* The typedef declaration for register CORE_MAC_HASH_TABLE_REG1. */
typedef struct CORE_MAC_HASH_TABLE_REG1_s CORE_MAC_HASH_TABLE_REG1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HASH_TABLE_REG1 register. */
#define CORE_MAC_HASH_TABLE_REG1_RESET 0x00000000
/* The byte offset of the CORE_MAC_HASH_TABLE_REG1 register from the beginning of the component. */
#define CORE_MAC_HASH_TABLE_REG1_OFST  0x14

/*
 * Register : MAC_VLAN_Tag_Ctrl
 *
 * MAC_VLAN_Tag_Ctrl register is a re-defined version of MAC_VLAN_Tag register.
 * This register holds the control and addressing fields required for indirect
 * accessing of the MAC_VLAN_Tag_Filter registers, when Extended Rx VLAN Filter is
 * enabled.
 *
 * And also it holds the control fields for MAC VLAN Hash Filter and perfect
 * filtering, when either of Extended Rx VLAN or External Receive VLAN Tag Lookup
 * based perfect filter feature is selected.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_OB
 *  [1]     | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_CT
 *  [6:2]   | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_OFS
 *  [11:7]  | R      | 0x0   | CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7
 *  [13:12] | R      | 0x0   | CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL
 *  [15:14] | R      | 0x0   | CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL
 *  [16]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_ETV
 *  [17]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_VTIM
 *  [18]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_ESVL
 *  [19]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_ERSVLM
 *  [20]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_DOVLTC
 *  [22:21] | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_EVLS
 *  [23]    | R      | 0x0   | CORE_MAC_VLAN_TAG_CTRL_RESERVED_23
 *  [24]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_EVLRXS
 *  [25]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_VTHM
 *  [26]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_EDVLP
 *  [27]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_ERIVLT
 *  [29:28] | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_EIVLS
 *  [30]    | R      | 0x0   | CORE_MAC_VLAN_TAG_CTRL_RESERVED_30
 *  [31]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_CTRL_EIVLRXS
 *
 */
/*
 * Field : OB
 *
 * Operation Busy.
 *
 * This bit is set along with a read or write command for initiating the indirect
 * access to per VLAN Tag Filter register. The next indirect register access can be
 * initiated only after this bit is reset.
 *
 * During a write operation, the bit is reset only after the data has been written
 * into the Per VLAN Tag register.
 *
 * During a read operation, the data should be read from the MAC_VLAN_Tag_Data
 * register only after this bit is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_OB register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_OB register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_MSB	     0
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_OB register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_WIDTH	     1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_OB register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_OB register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_OB register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_RESET	     0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_OB field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_OB register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_OB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : CT
 *
 * Command Type.
 *
 * This bit indicates if the current register access is a read or a write.
 *
 * When set, it indicate a read operation. When reset, it indicates a write
 * operation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_CT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_LSB	     1
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_CT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_MSB	     1
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_CT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_WIDTH	     1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_CT register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_CT register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_CT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_RESET	     0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_CT field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_CT register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_CT_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : OFS
 *
 * Offset.
 *
 * This field holds the address offset of the MAC VLAN Tag Filter register which
 * the application is trying to access. The width of the field depends on the
 * number of MAC VLAN Tag registers enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_OFS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_OFS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_MSB	      6
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_OFS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_WIDTH      5
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_OFS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_SET_MSK    0x0000007c
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_OFS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_CLR_MSK    0xffffff83
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_OFS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_OFS field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_GET(value) (((value)&0x0000007c) >> 2)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_OFS register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_OFS_SET(value) (((value) << 2) & 0x0000007c)

/*
 * Field : Reserved_11_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_LSB	7
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_MSB	11
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_WIDTH	5
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_SET_MSK	0x00000f80
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_CLR_MSK	0xfffff07f
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_RESET	0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_GET(value) (((value)&0x00000f80) >> 7)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7_SET(value) (((value) << 7) & 0x00000f80)

/*
 * Field : Reserved_EROVTL
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_LSB	  12
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_MSB	  13
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_WIDTH	  2
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_SET_MSK	  0x00003000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_CLR_MSK	  0xffffcfff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_GET(value) (((value)&0x00003000) >> 12)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : Reserved_ERIVTL
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_LSB	  14
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_MSB	  15
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_WIDTH	  2
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_SET_MSK	  0x0000c000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_CLR_MSK	  0xffff3fff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : ETV
 *
 * Enable 12-Bit VLAN Tag Comparison for VLAN hash filtering.
 *
 * When this bit is set, a 12-bit VLAN identifier is used for VLAN hash filtering
 * instead of the complete 16-bit VLAN tag.
 *
 * When this bit is reset, all 16 bits of the 15th and 16th bytes of the received
 * VLAN packet are used for VLAN hash filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_ETV register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_ETV register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_MSB	      16
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_ETV register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_ETV register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_ETV register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_ETV register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_ETV field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_ETV register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_ETV_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : VTIM
 *
 * VLAN Tag Inverse Match/Result Enable.
 *
 * When this bit is set, this bit enables the VLAN Tag inverse matching for non-
 * Lookup based filtering. The packets without matching VLAN Tag are marked as
 * matched. And for lookup-based filtering, it inverses actual result.
 *
 * When reset, this bit enables the VLAN Tag perfect matching for non-Lookup based
 * filtering. The packets with matched VLAN Tag are marked as matched. And for
 * lookup-based filtering, it uses actual result.
 *
 * Note: for more detail regarding lookup-based filtering inversion, refer its
 * filter status sub-section.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_VTIM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_LSB	       17
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_VTIM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_MSB	       17
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_VTIM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_VTIM register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_SET_MSK    0x00020000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_VTIM register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_VTIM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_VTIM field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_VTIM register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_VTIM_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : ESVL
 *
 * Enable S-VLAN.
 *
 * When this bit is set, the MAC transmitter and receiver consider the S-VLAN
 * packets (Type = 0x88A8) as valid VLAN tagged packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_ESVL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_LSB	       18
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_ESVL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_MSB	       18
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_ESVL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_ESVL register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_SET_MSK    0x00040000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_ESVL register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_ESVL register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_ESVL field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_ESVL register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_ESVL_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : ERSVLM
 *
 * Enable Receive S-VLAN Match for VLAN hash filtering.
 *
 * When this bit is set, the MAC receiver enables filtering or matching for S-VLAN
 * (Type = 0x88A8) packets.
 *
 * When this bit is reset, the MAC receiver enables filtering or matching for
 * C-VLAN (Type = 0x8100) packets.
 *
 * The ERIVLT bit determines the VLAN tag position considered for filtering or
 * matching.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_MSB	 19
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_SET_MSK	 0x00080000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_CLR_MSK	 0xfff7ffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_ERSVLM field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_ERSVLM register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_ERSVLM_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : DOVLTC
 *
 * Disable VLAN Type Check for VLAN hash filtering.
 *
 * When this bit is set, the MAC does not check whether the VLAN Tag specified by
 * the ERIVLT bit is of type S-VLAN or C-VLAN.
 *
 * When this bit is reset, the MAC filters or matches the VLAN Tag specified by the
 * ERIVLT bit only when VLAN Tag type is similar to the one specified by the ERSVLM
 * bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_LSB	 20
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_MSB	 20
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_SET_MSK	 0x00100000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_CLR_MSK	 0xffefffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_DOVLTC field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_DOVLTC register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_DOVLTC_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : EVLS
 *
 * Enable VLAN Tag Stripping on Receive.
 *
 * This field indicates the stripping operation on the outer VLAN Tag in received
 * packet:
 *
 * * 2'b00: Do not strip
 *
 * * 2'b01: Strip if VLAN filter passes
 *
 * * 2'b10: Strip if VLAN filter fails
 *
 * * 2'b11: Always strip
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_EVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_LSB	       21
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_EVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_MSB	       22
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_EVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_WIDTH      2
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_EVLS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_SET_MSK    0x00600000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_EVLS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_CLR_MSK    0xff9fffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_EVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_EVLS field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_GET(value) (((value)&0x00600000) >> 21)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_EVLS register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLS_SET(value) (((value) << 21) & 0x00600000)

/*
 * Field : Reserved_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_LSB	      23
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register field.
 */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_MSB	      23
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_SET_MSK    0x00800000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_23_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : EVLRXS
 *
 * Enable VLAN Tag in Rx status.
 *
 * When this bit is set, MAC provides the outer VLAN Tag in the Rx status.
 *
 * When this bit is reset, the MAC does not provide the outer VLAN Tag in Rx
 * status.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_LSB	 24
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_MSB	 24
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_SET_MSK	 0x01000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_CLR_MSK	 0xfeffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_EVLRXS field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_EVLRXS register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_EVLRXS_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : VTHM
 *
 * VLAN Tag Hash Table Match Enable.
 *
 * When this bit is set, the most significant four bits of CRC of VLAN Tag are used
 * to index the content of the MAC_VLAN_Hash_Table register. A value of 1 in the
 * VLAN Hash Table register, corresponding to the index, indicates that the packet
 * matched the VLAN hash table.
 *
 * When the ETV bit is set, the CRC of the 12-bit VLAN Identifier (VID) is used for
 * comparison. When the ETV bit is reset, the CRC of the 16-bit VLAN tag is used
 * for comparison.
 *
 * When this bit is reset, the VLAN Hash Match operation is not performed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_VTHM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_LSB	       25
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_VTHM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_MSB	       25
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_VTHM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_VTHM register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_SET_MSK    0x02000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_VTHM register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_VTHM register field. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_VTHM field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_VTHM register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_CTRL_VTHM_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : EDVLP
 *
 * Enable Double VLAN Processing.
 *
 * When this bit is set, the MAC enables processing of up to two VLAN Tags on Tx
 * and Rx (if present). When this bit is reset, the MAC enables processing of up to
 * one VLAN Tag on Tx and Rx (if present).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_EDVLP register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_LSB	26
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_EDVLP register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_MSB	26
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_EDVLP register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_WIDTH	1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_EDVLP register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_SET_MSK	0x04000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_EDVLP register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_CLR_MSK	0xfbffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_EDVLP register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_RESET	0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_EDVLP field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_EDVLP register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_EDVLP_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : ERIVLT
 *
 * Enable Inner VLAN Tag for VLAN hash filtering.
 *
 * When this bit and the EDVLP field are set, the MAC receiver enables hash
 * operation on the inner VLAN Tag (if present). When this bit is reset, the MAC
 * receiver enables hash operation on the outer VLAN Tag (if present). The ERSVLM
 * bit determines which VLAN type is enabled for filtering or matching.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_LSB	 27
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_MSB	 27
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_SET_MSK	 0x08000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_CLR_MSK	 0xf7ffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_ERIVLT field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_ERIVLT register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_ERIVLT_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : EIVLS
 *
 * Enable Inner VLAN Tag Stripping on Receive.
 *
 * This field indicates the stripping operation on inner VLAN Tag in the received
 * packet:
 *
 * * 2'b00: Do not strip
 *
 * * 2'b01: Strip if VLAN filter passes
 *
 * * 2'b10: Strip if VLAN filter fails
 *
 * * 2'b11: Always strip
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_EIVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_LSB	28
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_EIVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_MSB	29
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_EIVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_WIDTH	2
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_EIVLS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_SET_MSK	0x30000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_EIVLS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_CLR_MSK	0xcfffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_EIVLS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_RESET	0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_EIVLS field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_GET(value) (((value)&0x30000000) >> 28)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_EIVLS register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLS_SET(value) (((value) << 28) & 0x30000000)

/*
 * Field : Reserved_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register
 * field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register field.
 */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_MSB	      30
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register field. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESERVED_30_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : EIVLRXS
 *
 * Enable Inner VLAN Tag in Rx Status.
 *
 * When this bit is set, the MAC provides the inner VLAN Tag in the Rx status.
 *
 * When this bit is reset, the MAC does not provide the inner VLAN Tag in Rx
 * status.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_LSB	  31
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_MSB	  31
/* The width in bits of the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_WIDTH	  1
/* The mask used to set the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_SET_MSK	  0x80000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field value. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_CLR_MSK	  0x7fffffff
/* The reset value of the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_TAG_CTRL_EIVLRXS field value from a register. */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_VLAN_TAG_CTRL_EIVLRXS register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_CTRL_EIVLRXS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_VLAN_TAG_CTRL.
 */
struct CORE_MAC_VLAN_TAG_CTRL_s {
	volatile uint32_t OB : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_OB */
	volatile uint32_t CT : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_CT */
	volatile uint32_t OFS : 5;		     /* CORE_MAC_VLAN_TAG_CTRL_OFS */
	const volatile uint32_t Reserved_11_7 : 5;   /* CORE_MAC_VLAN_TAG_CTRL_RESERVED_11_7 */
	const volatile uint32_t Reserved_EROVTL : 2; /* CORE_MAC_VLAN_TAG_CTRL_RESERVED_EROVTL */
	const volatile uint32_t Reserved_ERIVTL : 2; /* CORE_MAC_VLAN_TAG_CTRL_RESERVED_ERIVTL */
	volatile uint32_t ETV : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_ETV */
	volatile uint32_t VTIM : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_VTIM */
	volatile uint32_t ESVL : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_ESVL */
	volatile uint32_t ERSVLM : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_ERSVLM */
	volatile uint32_t DOVLTC : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_DOVLTC */
	volatile uint32_t EVLS : 2;		     /* CORE_MAC_VLAN_TAG_CTRL_EVLS */
	const volatile uint32_t Reserved_23 : 1;     /* CORE_MAC_VLAN_TAG_CTRL_RESERVED_23 */
	volatile uint32_t EVLRXS : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_EVLRXS */
	volatile uint32_t VTHM : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_VTHM */
	volatile uint32_t EDVLP : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_EDVLP */
	volatile uint32_t ERIVLT : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_ERIVLT */
	volatile uint32_t EIVLS : 2;		     /* CORE_MAC_VLAN_TAG_CTRL_EIVLS */
	const volatile uint32_t Reserved_30 : 1;     /* CORE_MAC_VLAN_TAG_CTRL_RESERVED_30 */
	volatile uint32_t EIVLRXS : 1;		     /* CORE_MAC_VLAN_TAG_CTRL_EIVLRXS */
};

/* The typedef declaration for register CORE_MAC_VLAN_TAG_CTRL. */
typedef struct CORE_MAC_VLAN_TAG_CTRL_s CORE_MAC_VLAN_TAG_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_VLAN_TAG_CTRL register. */
#define CORE_MAC_VLAN_TAG_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_VLAN_TAG_CTRL register from the beginning of the component. */
#define CORE_MAC_VLAN_TAG_CTRL_OFST  0x50

/*
 * Register : MAC_VLAN_Tag_Data
 *
 * This register holds the read/write data for Indirect Access of the Per VLAN Tag
 * registers. During the read access, this field contains valid read data only
 * after the OB bit is reset. During the write access, this field should be valid
 * prior to setting the OB bit in the MAC_VLAN_Tag_Ctrl register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_VID
 *  [16]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_VEN
 *  [17]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_ETV
 *  [18]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_DOVLTC
 *  [19]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_ERSVLM
 *  [20]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_ERIVLT
 *  [23:21] | R      | 0x0   | CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21
 *  [24]    | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_DMACHEN
 *  [27:25] | RW     | 0x0   | CORE_MAC_VLAN_TAG_DATA_DMACHN
 *  [31:28] | R      | 0x0   | CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y
 *
 */
/*
 * Field : VID
 *
 * VLAN Tag Identifier for Receive Packets.
 *
 * This field contains the IEEE 802.1Q VLAN tag to identify the VLAN packets. This
 * VLAN tag identifier is compared to the 15th and 16th bytes of the packets being
 * received for VLAN packets. The following list describes the bits of this field:
 *
 * * Bits[15:13]: User Priority
 *
 * * Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
 *
 * * Bits[11:0]: VLAN Identifier (VID) field of VLAN tag
 *
 * When the ETV bit is set, only the VID is used for comparison.
 *
 * If this field ([11:0] if ETV is set) is all zeros, the MAC does not check the
 * 15th and 16th bytes for VLAN tag comparison and declares all packets with Type
 * field value of 0x8100 or 0x88a8 as VLAN packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_VID register field. */
#define CORE_MAC_VLAN_TAG_DATA_VID_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_VID register field. */
#define CORE_MAC_VLAN_TAG_DATA_VID_MSB	      15
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_VID register field. */
#define CORE_MAC_VLAN_TAG_DATA_VID_WIDTH      16
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_VID register field value. */
#define CORE_MAC_VLAN_TAG_DATA_VID_SET_MSK    0x0000ffff
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_VID register field value. */
#define CORE_MAC_VLAN_TAG_DATA_VID_CLR_MSK    0xffff0000
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_VID register field. */
#define CORE_MAC_VLAN_TAG_DATA_VID_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_VID field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_VID_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_VLAN_TAG_DATA_VID register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_DATA_VID_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : VEN
 *
 * VLAN Tag Enable.
 *
 * This bit is used to enable or disable the VLAN Tag.
 *
 * When this bit is set, the MAC compares the VLAN Tag of received packet with the
 * VLAN Tag ID.
 *
 * When this bit is not set, no comparison is performed, irrespective of the
 * programming of the other fields.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_VEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_VEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_MSB	      16
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_VEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_VEN register field value. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_VEN register field value. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_VEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_VEN field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_VLAN_TAG_DATA_VEN register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_DATA_VEN_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : ETV
 *
 * Enable 12-Bit VLAN Tag Comparison.
 *
 * When this bit is set, a 12-bit VLAN identifier is used for comparing and
 * filtering instead of the complete 16-bit VLAN tag. Bits[11:0] of VLAN tag are
 * compared with the corresponding field in the received VLAN-tagged packet.
 * Similarly, when enabled, only 12 bits of the VLAN tag in the received packet are
 * used for hash-based VLAN filtering.
 *
 * When this bit is reset, all 16 bits of the 15th and 16th bytes of the received
 * VLAN packet are used for comparison and VLAN hash filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_ETV register field. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_LSB	      17
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_ETV register field. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_MSB	      17
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_ETV register field. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_WIDTH      1
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_ETV register field value. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_SET_MSK    0x00020000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_ETV register field value. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_ETV register field. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_RESET      0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_ETV field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_VLAN_TAG_DATA_ETV register field value suitable for setting the register. */
#define CORE_MAC_VLAN_TAG_DATA_ETV_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : DOVLTC
 *
 * Disable VLAN Type Check.
 *
 * When this bit is set, the MAC does not check whether the VLAN Tag specified by
 * the ERIVLT bit is of type S-VLAN or C-VLAN.
 *
 * When this bit is reset, the MAC filters or matches the VLAN Tag specified by the
 * ERIVLT bit only when VLAN Tag type is similar to the one specified by the ERSVLM
 * bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_LSB	 18
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_MSB	 18
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_DOVLTC register field value. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_SET_MSK	 0x00040000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_DOVLTC register field value. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_CLR_MSK	 0xfffbffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_DOVLTC register field. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_DOVLTC field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_VLAN_TAG_DATA_DOVLTC register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_DATA_DOVLTC_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : ERSVLM
 *
 * Enable Receive S-VLAN Match.
 *
 * When this bit is set, the MAC receiver enables filtering or matching for S-VLAN
 * (Type = 0x88A8) packets.
 *
 * When this bit is reset, the MAC receiver enables filtering or matching for
 * C-VLAN (Type = 0x8100) packets.
 *
 * The ERIVLT bit determines the VLAN tag position considered for filtering or
 * matching.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_MSB	 19
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_ERSVLM register field value. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_SET_MSK	 0x00080000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_ERSVLM register field value. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_CLR_MSK	 0xfff7ffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_ERSVLM register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_ERSVLM field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_VLAN_TAG_DATA_ERSVLM register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_DATA_ERSVLM_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : ERIVLT
 *
 * Enable Inner VLAN Tag.
 *
 * When this bit and the EDVLP field are set, the MAC receiver enables operation on
 * the inner VLAN Tag (if present). When this bit is reset, the MAC receiver
 * enables operation on the outer VLAN Tag (if present). The ERSVLM bit determines
 * which VLAN type is enabled for filtering or matching.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_LSB	 20
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_MSB	 20
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_WIDTH	 1
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_ERIVLT register field value. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_SET_MSK	 0x00100000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_ERIVLT register field value. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_CLR_MSK	 0xffefffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_ERIVLT register field. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_ERIVLT field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_VLAN_TAG_DATA_ERIVLT register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_DATA_ERIVLT_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : Reserved_23_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register
 * field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_LSB	 21
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register
 * field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_MSB	 23
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_WIDTH	 3
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register field value. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_SET_MSK	 0x00e00000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register field value. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_CLR_MSK	 0xff1fffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_GET(value) (((value)&0x00e00000) >> 21)
/* Produces a CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21_SET(value) (((value) << 21) & 0x00e00000)

/*
 * Field : DMACHEN
 *
 * DMA Channel Number Enable.
 *
 * This bit is the Enable for the DMA Channel Number value programmed in the field
 * DMACH.
 *
 * When this bit is reset, routing does not occur based on VLAN Filter result. The
 * packet is routed based on DA Based DMA Channel Routing.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_DMACHEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_LSB	  24
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_DMACHEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_MSB	  24
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_DMACHEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_WIDTH	  1
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_DMACHEN register field value. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_SET_MSK	  0x01000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_DMACHEN register field value. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_CLR_MSK	  0xfeffffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_DMACHEN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_DMACHEN field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_VLAN_TAG_DATA_DMACHEN register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_DATA_DMACHEN_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : DMACHN
 *
 * DMA Channel Number.
 *
 * The DMA Channel number to which the VLAN Tagged Packet is to be routed if it
 * passes this VLAN Tag Filter is programmed in this field.
 *
 * If the Routing based on VLAN Tag Filter is not necessary, this field need not be
 * programmed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_DMACHN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_LSB	 25
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_DMACHN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_MSB	 27
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_DMACHN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_WIDTH	 3
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_DMACHN register field value. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_SET_MSK	 0x0e000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_DMACHN register field value. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_CLR_MSK	 0xf1ffffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_DMACHN register field. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_DMACHN field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_GET(value) (((value)&0x0e000000) >> 25)
/* Produces a CORE_MAC_VLAN_TAG_DATA_DMACHN register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_TAG_DATA_DMACHN_SET(value) (((value) << 25) & 0x0e000000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register
 * field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_LSB	28
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register
 * field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_MSB	31
/* The width in bits of the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_WIDTH	4
/* The mask used to set the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register field value. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_SET_MSK	0xf0000000
/* The mask used to clear the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register field value. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_CLR_MSK	0x0fffffff
/* The reset value of the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register field. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_RESET	0x0
/* Extracts the CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y field value from a register. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_GET(value) (((value)&0xf0000000) >> 28)
/* Produces a CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y_SET(value) (((value) << 28) & 0xf0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_VLAN_TAG_DATA.
 */
struct CORE_MAC_VLAN_TAG_DATA_s {
	volatile uint32_t VID : 16;		    /* CORE_MAC_VLAN_TAG_DATA_VID */
	volatile uint32_t VEN : 1;		    /* CORE_MAC_VLAN_TAG_DATA_VEN */
	volatile uint32_t ETV : 1;		    /* CORE_MAC_VLAN_TAG_DATA_ETV */
	volatile uint32_t DOVLTC : 1;		    /* CORE_MAC_VLAN_TAG_DATA_DOVLTC */
	volatile uint32_t ERSVLM : 1;		    /* CORE_MAC_VLAN_TAG_DATA_ERSVLM */
	volatile uint32_t ERIVLT : 1;		    /* CORE_MAC_VLAN_TAG_DATA_ERIVLT */
	const volatile uint32_t Reserved_23_21 : 3; /* CORE_MAC_VLAN_TAG_DATA_RESERVED_23_21 */
	volatile uint32_t DMACHEN : 1;		    /* CORE_MAC_VLAN_TAG_DATA_DMACHEN */
	volatile uint32_t DMACHN : 3;		    /* CORE_MAC_VLAN_TAG_DATA_DMACHN */
	const volatile uint32_t Reserved_31_y : 4;  /* CORE_MAC_VLAN_TAG_DATA_RESERVED_31_Y */
};

/* The typedef declaration for register CORE_MAC_VLAN_TAG_DATA. */
typedef struct CORE_MAC_VLAN_TAG_DATA_s CORE_MAC_VLAN_TAG_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_VLAN_TAG_DATA register. */
#define CORE_MAC_VLAN_TAG_DATA_RESET 0x00000000
/* The byte offset of the CORE_MAC_VLAN_TAG_DATA register from the beginning of the component. */
#define CORE_MAC_VLAN_TAG_DATA_OFST  0x54

/*
 * Register : MAC_VLAN_Hash_Table
 *
 * When the ERSVLM bit of MAC_VLAN_Tag register is set, the 16-bit VLAN Hash Table
 * register is used for group address filtering based on the VLAN tag. For hash
 * filtering, the content of the 16-bit VLAN tag or 12-bit VLAN ID (based on the
 * ETV bit of MAC_VLAN_Tag register) in the incoming packet is passed through the
 * CRC logic. The upper four bits of the calculated CRC are used to index the
 * contents of the VLAN Hash table. For example, a hash value of 4b'1000 selects
 * Bit 8 of the VLAN Hash table.
 *
 * The hash value of the destination address is calculated in the following way:
 *
 * * Calculate the 32-bit CRC for the VLAN tag or ID (For steps to calculate CRC32,
 *   see Section 3.2.8 of IEEE 802.3-2018).
 *
 * * Perform bit-wise reversal for the value obtained in step 1.
 *
 * * Take the upper four bits from the value obtained in step 2.
 *
 * If the VLAN hash Table register is configured to be double-synchronized to the
 * (X)GMII clock domain, the synchronization is triggered only when Bits[15:8] (in
 * little-endian mode) or Bits[7:0] (in big-endian mode) of this register are
 * written.
 *
 * If double-synchronization is enabled, consecutive writes to this register should
 * be performed after at least four clock cycles in the destination clock domain.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_VLAN_HASH_TABLE_VLHT
 *  [31:16] | R      | 0x0   | CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16
 *
 */
/*
 * Field : VLHT
 *
 * VLAN Hash Table.
 *
 * This field contains the 16-bit VLAN Hash Table.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_HASH_TABLE_VLHT register field. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_HASH_TABLE_VLHT register field. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_MSB	 15
/* The width in bits of the CORE_MAC_VLAN_HASH_TABLE_VLHT register field. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_WIDTH	 16
/* The mask used to set the CORE_MAC_VLAN_HASH_TABLE_VLHT register field value. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_VLAN_HASH_TABLE_VLHT register field value. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_VLAN_HASH_TABLE_VLHT register field. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_RESET	 0x0
/* Extracts the CORE_MAC_VLAN_HASH_TABLE_VLHT field value from a register. */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_VLAN_HASH_TABLE_VLHT register field value suitable for setting the register.
 */
#define CORE_MAC_VLAN_HASH_TABLE_VLHT_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register
 * field. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_LSB	   16
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register
 * field. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_MSB	   31
/* The width in bits of the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register field. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_WIDTH	   16
/* The mask used to set the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register field value. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_SET_MSK	   0xffff0000
/* The mask used to clear the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register field value. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_CLR_MSK	   0x0000ffff
/* The reset value of the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register field. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 field value from a register. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_VLAN_HASH_TABLE.
 */
struct CORE_MAC_VLAN_HASH_TABLE_s {
	volatile uint32_t VLHT : 16;		     /* CORE_MAC_VLAN_HASH_TABLE_VLHT */
	const volatile uint32_t Reserved_31_16 : 16; /* CORE_MAC_VLAN_HASH_TABLE_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_VLAN_HASH_TABLE. */
typedef struct CORE_MAC_VLAN_HASH_TABLE_s CORE_MAC_VLAN_HASH_TABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_VLAN_HASH_TABLE register. */
#define CORE_MAC_VLAN_HASH_TABLE_RESET 0x00000000
/* The byte offset of the CORE_MAC_VLAN_HASH_TABLE register from the beginning of the component. */
#define CORE_MAC_VLAN_HASH_TABLE_OFST  0x58

/*
 * Register : MAC_VLAN_Incl
 *
 * The VLAN Tag Inclusion or Replacement register contains the VLAN tag for
 * insertion or replacement in the Transmit packets. It also contains the VLAN tag
 * insertion controls.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_VLAN_INCL_VLT
 *  [17:16] | RW     | 0x0   | CORE_MAC_VLAN_INCL_VLC
 *  [18]    | RW     | 0x0   | CORE_MAC_VLAN_INCL_VLP
 *  [19]    | RW     | 0x0   | CORE_MAC_VLAN_INCL_CSVL
 *  [20]    | RW     | 0x0   | CORE_MAC_VLAN_INCL_VLTI
 *  [21]    | RW     | 0x0   | CORE_MAC_VLAN_INCL_CBTI
 *  [23:22] | R      | 0x0   | CORE_MAC_VLAN_INCL_RESERVED_23_22
 *  [26:24] | RW     | 0x0   | CORE_MAC_VLAN_INCL_ADDR
 *  [29:27] | R      | 0x0   | CORE_MAC_VLAN_INCL_RESERVED_29_Y
 *  [30]    | RW     | 0x0   | CORE_MAC_VLAN_INCL_RDWR
 *  [31]    | R      | 0x0   | CORE_MAC_VLAN_INCL_BUSY
 *
 */
/*
 * Field : VLT
 *
 * VLAN Tag for Transmit Packets.
 *
 * This field contains the value of the VLAN tag to be inserted or replaced. The
 * value must only be changed when the transmit lines are inactive or during the
 * initialization phase.
 *
 * Bits[15:13] are the User Priority field, Bit 12 is the CFI/DEI field, and
 * Bits[11:0] are the VID field in the VLAN tag.
 *
 * The following list describes the bits of this field:
 *
 * * Bits[15:13]: User Priority
 *
 * * Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
 *
 * * Bits[11:0]: VLAN Identifier (VID) field of VLAN tag
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_VLT register field. */
#define CORE_MAC_VLAN_INCL_VLT_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_VLT register field. */
#define CORE_MAC_VLAN_INCL_VLT_MSB	  15
/* The width in bits of the CORE_MAC_VLAN_INCL_VLT register field. */
#define CORE_MAC_VLAN_INCL_VLT_WIDTH	  16
/* The mask used to set the CORE_MAC_VLAN_INCL_VLT register field value. */
#define CORE_MAC_VLAN_INCL_VLT_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_VLAN_INCL_VLT register field value. */
#define CORE_MAC_VLAN_INCL_VLT_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_VLAN_INCL_VLT register field. */
#define CORE_MAC_VLAN_INCL_VLT_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_INCL_VLT field value from a register. */
#define CORE_MAC_VLAN_INCL_VLT_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_VLAN_INCL_VLT register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_VLT_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : VLC
 *
 * VLAN Tag Control in Transmit Packets.
 *
 * * 2'b00: No VLAN tag deletion, insertion, or replacement
 *
 * * 2'b01: VLAN tag deletion
 *
 * The MAC removes the VLAN type (bytes 13 and 14) and VLAN tag (bytes 15 and 16)
 * of all transmitted packets with VLAN tags.
 *
 * * 2'b10: VLAN tag insertion
 *
 * The MAC inserts VLT in bytes 15 and 16 of the packet after inserting the Type
 * value (0x8100 or 0x88a8) in bytes 13 and 14. This operation is performed on all
 * transmitted packets, irrespective of whether they already have a VLAN tag.
 *
 * * 2'b11: VLAN tag replacement
 *
 * The MAC replaces VLT in bytes 15 and 16 of all VLAN-type transmitted packets
 * (Bytes 13 and 14 are 0x8100 or 0x88a8).
 *
 * Note:  Changes to this field take effect only on the start of a packet. If you
 * write this register field when a packet is being transmitted, only the
 * subsequent packet can use the updated value, that is, the current packet does
 * not use the updated value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_VLC register field. */
#define CORE_MAC_VLAN_INCL_VLC_LSB	  16
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_VLC register field. */
#define CORE_MAC_VLAN_INCL_VLC_MSB	  17
/* The width in bits of the CORE_MAC_VLAN_INCL_VLC register field. */
#define CORE_MAC_VLAN_INCL_VLC_WIDTH	  2
/* The mask used to set the CORE_MAC_VLAN_INCL_VLC register field value. */
#define CORE_MAC_VLAN_INCL_VLC_SET_MSK	  0x00030000
/* The mask used to clear the CORE_MAC_VLAN_INCL_VLC register field value. */
#define CORE_MAC_VLAN_INCL_VLC_CLR_MSK	  0xfffcffff
/* The reset value of the CORE_MAC_VLAN_INCL_VLC register field. */
#define CORE_MAC_VLAN_INCL_VLC_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_INCL_VLC field value from a register. */
#define CORE_MAC_VLAN_INCL_VLC_GET(value) (((value)&0x00030000) >> 16)
/* Produces a CORE_MAC_VLAN_INCL_VLC register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_VLC_SET(value) (((value) << 16) & 0x00030000)

/*
 * Field : VLP
 *
 * VLAN Priority Control.
 *
 * When this bit is set, the control bits[17:16] are used for VLAN deletion,
 * insertion, or replacement.
 *
 * When this bit is reset, the mti_vlan_ctrl_i control input is used and
 * bits[17:16] are ignored.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_VLP register field. */
#define CORE_MAC_VLAN_INCL_VLP_LSB	  18
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_VLP register field. */
#define CORE_MAC_VLAN_INCL_VLP_MSB	  18
/* The width in bits of the CORE_MAC_VLAN_INCL_VLP register field. */
#define CORE_MAC_VLAN_INCL_VLP_WIDTH	  1
/* The mask used to set the CORE_MAC_VLAN_INCL_VLP register field value. */
#define CORE_MAC_VLAN_INCL_VLP_SET_MSK	  0x00040000
/* The mask used to clear the CORE_MAC_VLAN_INCL_VLP register field value. */
#define CORE_MAC_VLAN_INCL_VLP_CLR_MSK	  0xfffbffff
/* The reset value of the CORE_MAC_VLAN_INCL_VLP register field. */
#define CORE_MAC_VLAN_INCL_VLP_RESET	  0x0
/* Extracts the CORE_MAC_VLAN_INCL_VLP field value from a register. */
#define CORE_MAC_VLAN_INCL_VLP_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_VLAN_INCL_VLP register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_VLP_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : CSVL
 *
 * C-VLAN or S-VLAN.
 *
 * When this bit is set, S-VLAN type (0x88A8) is inserted or replaced in the 13th
 * and 14th bytes of transmitted packets.
 *
 * When this bit is reset, C-VLAN type (0x8100) is inserted or replaced in the 13th
 * and 14th bytes of transmitted packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_CSVL register field. */
#define CORE_MAC_VLAN_INCL_CSVL_LSB	   19
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_CSVL register field. */
#define CORE_MAC_VLAN_INCL_CSVL_MSB	   19
/* The width in bits of the CORE_MAC_VLAN_INCL_CSVL register field. */
#define CORE_MAC_VLAN_INCL_CSVL_WIDTH	   1
/* The mask used to set the CORE_MAC_VLAN_INCL_CSVL register field value. */
#define CORE_MAC_VLAN_INCL_CSVL_SET_MSK	   0x00080000
/* The mask used to clear the CORE_MAC_VLAN_INCL_CSVL register field value. */
#define CORE_MAC_VLAN_INCL_CSVL_CLR_MSK	   0xfff7ffff
/* The reset value of the CORE_MAC_VLAN_INCL_CSVL register field. */
#define CORE_MAC_VLAN_INCL_CSVL_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_INCL_CSVL field value from a register. */
#define CORE_MAC_VLAN_INCL_CSVL_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_VLAN_INCL_CSVL register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_CSVL_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : VLTI
 *
 * VLAN Tag Input.
 *
 * When this bit is set, it indicates that the VLAN tag to be inserted or replaced
 * in Tx packet should be taken from the following:
 *
 * * The mti_vlan_tag_i signal in XGMAC-CORE configurations
 *
 * * The control word in XGMAC-MTL configurations
 *
 * * The Tx descriptor in XGMAC-AXI configurations
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_VLTI register field. */
#define CORE_MAC_VLAN_INCL_VLTI_LSB	   20
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_VLTI register field. */
#define CORE_MAC_VLAN_INCL_VLTI_MSB	   20
/* The width in bits of the CORE_MAC_VLAN_INCL_VLTI register field. */
#define CORE_MAC_VLAN_INCL_VLTI_WIDTH	   1
/* The mask used to set the CORE_MAC_VLAN_INCL_VLTI register field value. */
#define CORE_MAC_VLAN_INCL_VLTI_SET_MSK	   0x00100000
/* The mask used to clear the CORE_MAC_VLAN_INCL_VLTI register field value. */
#define CORE_MAC_VLAN_INCL_VLTI_CLR_MSK	   0xffefffff
/* The reset value of the CORE_MAC_VLAN_INCL_VLTI register field. */
#define CORE_MAC_VLAN_INCL_VLTI_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_INCL_VLTI field value from a register. */
#define CORE_MAC_VLAN_INCL_VLTI_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_VLAN_INCL_VLTI register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_VLTI_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : CBTI
 *
 * Channel Based Tag Insertion.
 *
 * When this bit is set, outer VLAN tag is inserted for every packets transmitted
 * by the MAC. The tag value is taken from the queue/channel specific VLAN tag
 * register. This overrides VLTI, VLP, VLC and VLT fields of this register
 *
 * When this bit is set, a write operation to byte 3 of this register initiates the
 * read/write access to the indirect register.
 *
 * When reset, outer VLAN operation is based on the setting of VLTI, VLP, VLC, and
 * VLT fields of this register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_CBTI register field. */
#define CORE_MAC_VLAN_INCL_CBTI_LSB	   21
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_CBTI register field. */
#define CORE_MAC_VLAN_INCL_CBTI_MSB	   21
/* The width in bits of the CORE_MAC_VLAN_INCL_CBTI register field. */
#define CORE_MAC_VLAN_INCL_CBTI_WIDTH	   1
/* The mask used to set the CORE_MAC_VLAN_INCL_CBTI register field value. */
#define CORE_MAC_VLAN_INCL_CBTI_SET_MSK	   0x00200000
/* The mask used to clear the CORE_MAC_VLAN_INCL_CBTI register field value. */
#define CORE_MAC_VLAN_INCL_CBTI_CLR_MSK	   0xffdfffff
/* The reset value of the CORE_MAC_VLAN_INCL_CBTI register field. */
#define CORE_MAC_VLAN_INCL_CBTI_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_INCL_CBTI field value from a register. */
#define CORE_MAC_VLAN_INCL_CBTI_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MAC_VLAN_INCL_CBTI register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_CBTI_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : Reserved_23_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_RESERVED_23_22 register field.
 */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_LSB	     22
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_RESERVED_23_22 register field.
 */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_MSB	     23
/* The width in bits of the CORE_MAC_VLAN_INCL_RESERVED_23_22 register field. */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_WIDTH	     2
/* The mask used to set the CORE_MAC_VLAN_INCL_RESERVED_23_22 register field value. */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_SET_MSK    0x00c00000
/* The mask used to clear the CORE_MAC_VLAN_INCL_RESERVED_23_22 register field value. */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_CLR_MSK    0xff3fffff
/* The reset value of the CORE_MAC_VLAN_INCL_RESERVED_23_22 register field. */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_RESET	     0x0
/* Extracts the CORE_MAC_VLAN_INCL_RESERVED_23_22 field value from a register. */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_GET(value) (((value)&0x00c00000) >> 22)
/* Produces a CORE_MAC_VLAN_INCL_RESERVED_23_22 register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_INCL_RESERVED_23_22_SET(value) (((value) << 22) & 0x00c00000)

/*
 * Field : ADDR
 *
 * Address.
 *
 * This field selects one of the queue/channel specific VLAN Inclusion register for
 * read/write access.
 *
 * This does not have any effect when CBTI is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_ADDR register field. */
#define CORE_MAC_VLAN_INCL_ADDR_LSB	   24
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_ADDR register field. */
#define CORE_MAC_VLAN_INCL_ADDR_MSB	   26
/* The width in bits of the CORE_MAC_VLAN_INCL_ADDR register field. */
#define CORE_MAC_VLAN_INCL_ADDR_WIDTH	   3
/* The mask used to set the CORE_MAC_VLAN_INCL_ADDR register field value. */
#define CORE_MAC_VLAN_INCL_ADDR_SET_MSK	   0x07000000
/* The mask used to clear the CORE_MAC_VLAN_INCL_ADDR register field value. */
#define CORE_MAC_VLAN_INCL_ADDR_CLR_MSK	   0xf8ffffff
/* The reset value of the CORE_MAC_VLAN_INCL_ADDR register field. */
#define CORE_MAC_VLAN_INCL_ADDR_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_INCL_ADDR field value from a register. */
#define CORE_MAC_VLAN_INCL_ADDR_GET(value) (((value)&0x07000000) >> 24)
/* Produces a CORE_MAC_VLAN_INCL_ADDR register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_ADDR_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : Reserved_29_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_RESERVED_29_Y register field.
 */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_LSB	    27
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_RESERVED_29_Y register field.
 */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_MSB	    29
/* The width in bits of the CORE_MAC_VLAN_INCL_RESERVED_29_Y register field. */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_WIDTH	    3
/* The mask used to set the CORE_MAC_VLAN_INCL_RESERVED_29_Y register field value. */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_SET_MSK    0x38000000
/* The mask used to clear the CORE_MAC_VLAN_INCL_RESERVED_29_Y register field value. */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_CLR_MSK    0xc7ffffff
/* The reset value of the CORE_MAC_VLAN_INCL_RESERVED_29_Y register field. */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_RESET	    0x0
/* Extracts the CORE_MAC_VLAN_INCL_RESERVED_29_Y field value from a register. */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_GET(value) (((value)&0x38000000) >> 27)
/* Produces a CORE_MAC_VLAN_INCL_RESERVED_29_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_VLAN_INCL_RESERVED_29_Y_SET(value) (((value) << 27) & 0x38000000)

/*
 * Field : RDWR
 *
 * Read Write Control.
 *
 * This bit controls the read or write operation for indirectly accessing the
 * queue/channel specific VLAN Inclusion register.
 *
 * When set, indicates write operation and when reset indicates read operation
 *
 * This does not have any effect when CBTI is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_RDWR register field. */
#define CORE_MAC_VLAN_INCL_RDWR_LSB	   30
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_RDWR register field. */
#define CORE_MAC_VLAN_INCL_RDWR_MSB	   30
/* The width in bits of the CORE_MAC_VLAN_INCL_RDWR register field. */
#define CORE_MAC_VLAN_INCL_RDWR_WIDTH	   1
/* The mask used to set the CORE_MAC_VLAN_INCL_RDWR register field value. */
#define CORE_MAC_VLAN_INCL_RDWR_SET_MSK	   0x40000000
/* The mask used to clear the CORE_MAC_VLAN_INCL_RDWR register field value. */
#define CORE_MAC_VLAN_INCL_RDWR_CLR_MSK	   0xbfffffff
/* The reset value of the CORE_MAC_VLAN_INCL_RDWR register field. */
#define CORE_MAC_VLAN_INCL_RDWR_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_INCL_RDWR field value from a register. */
#define CORE_MAC_VLAN_INCL_RDWR_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_VLAN_INCL_RDWR register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_RDWR_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : BUSY
 *
 * BUSY.
 *
 * This bit indicates the status of the read/write operation of indirect access to
 * the queue/channel specific VLAN inclusion register.
 *
 * For write operation write to a register is complete when this bit is reset. For
 * read operation the read data is valid when the bit is reset.
 *
 * No further writes are allowed to this register when this bit is set. This does
 * not have any effect when CBTI is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VLAN_INCL_BUSY register field. */
#define CORE_MAC_VLAN_INCL_BUSY_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MAC_VLAN_INCL_BUSY register field. */
#define CORE_MAC_VLAN_INCL_BUSY_MSB	   31
/* The width in bits of the CORE_MAC_VLAN_INCL_BUSY register field. */
#define CORE_MAC_VLAN_INCL_BUSY_WIDTH	   1
/* The mask used to set the CORE_MAC_VLAN_INCL_BUSY register field value. */
#define CORE_MAC_VLAN_INCL_BUSY_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MAC_VLAN_INCL_BUSY register field value. */
#define CORE_MAC_VLAN_INCL_BUSY_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MAC_VLAN_INCL_BUSY register field. */
#define CORE_MAC_VLAN_INCL_BUSY_RESET	   0x0
/* Extracts the CORE_MAC_VLAN_INCL_BUSY field value from a register. */
#define CORE_MAC_VLAN_INCL_BUSY_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_VLAN_INCL_BUSY register field value suitable for setting the register. */
#define CORE_MAC_VLAN_INCL_BUSY_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_VLAN_INCL.
 */
struct CORE_MAC_VLAN_INCL_s {
	volatile uint32_t VLT : 16;		    /* CORE_MAC_VLAN_INCL_VLT */
	volatile uint32_t VLC : 2;		    /* CORE_MAC_VLAN_INCL_VLC */
	volatile uint32_t VLP : 1;		    /* CORE_MAC_VLAN_INCL_VLP */
	volatile uint32_t CSVL : 1;		    /* CORE_MAC_VLAN_INCL_CSVL */
	volatile uint32_t VLTI : 1;		    /* CORE_MAC_VLAN_INCL_VLTI */
	volatile uint32_t CBTI : 1;		    /* CORE_MAC_VLAN_INCL_CBTI */
	const volatile uint32_t Reserved_23_22 : 2; /* CORE_MAC_VLAN_INCL_RESERVED_23_22 */
	volatile uint32_t ADDR : 3;		    /* CORE_MAC_VLAN_INCL_ADDR */
	const volatile uint32_t Reserved_29_y : 3;  /* CORE_MAC_VLAN_INCL_RESERVED_29_Y */
	volatile uint32_t RDWR : 1;		    /* CORE_MAC_VLAN_INCL_RDWR */
	const volatile uint32_t BUSY : 1;	    /* CORE_MAC_VLAN_INCL_BUSY */
};

/* The typedef declaration for register CORE_MAC_VLAN_INCL. */
typedef struct CORE_MAC_VLAN_INCL_s CORE_MAC_VLAN_INCL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_VLAN_INCL register. */
#define CORE_MAC_VLAN_INCL_RESET 0x00000000
/* The byte offset of the CORE_MAC_VLAN_INCL register from the beginning of the component. */
#define CORE_MAC_VLAN_INCL_OFST	 0x60

/*
 * Register : MAC_Inner_VLAN_Incl
 *
 * The Inner VLAN Tag Inclusion or Replacement register contains the inner VLAN tag
 * to be inserted or replaced in the Transmit packet. It also contains the inner
 * VLAN tag insertion controls.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_INNER_VLAN_INCL_VLT
 *  [17:16] | RW     | 0x0   | CORE_MAC_INNER_VLAN_INCL_VLC
 *  [18]    | RW     | 0x0   | CORE_MAC_INNER_VLAN_INCL_VLP
 *  [19]    | RW     | 0x0   | CORE_MAC_INNER_VLAN_INCL_CSVL
 *  [20]    | RW     | 0x0   | CORE_MAC_INNER_VLAN_INCL_VLTI
 *  [31:21] | R      | 0x0   | CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21
 *
 */
/*
 * Field : VLT
 *
 * VLAN Tag for Transmit Packets.
 *
 * This field contains the value of the VLAN tag to be inserted or replaced. The
 * value must only be changed when the transmit lines are inactive or during the
 * initialization phase.
 *
 * Bits[15:13] are the User Priority field, Bit 12 is the CFI/DEI field, and
 *
 * Bits[11:0] are the VID field in the VLAN tag.
 *
 * The following list describes the bits of this field:
 *
 * * Bits[15:13]: User Priority
 *
 * * Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
 *
 * * Bits[11:0]: VLAN Identifier (VID) field of VLAN tag
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INNER_VLAN_INCL_VLT register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_INNER_VLAN_INCL_VLT register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_MSB	15
/* The width in bits of the CORE_MAC_INNER_VLAN_INCL_VLT register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_WIDTH	16
/* The mask used to set the CORE_MAC_INNER_VLAN_INCL_VLT register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_SET_MSK	0x0000ffff
/* The mask used to clear the CORE_MAC_INNER_VLAN_INCL_VLT register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_CLR_MSK	0xffff0000
/* The reset value of the CORE_MAC_INNER_VLAN_INCL_VLT register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_RESET	0x0
/* Extracts the CORE_MAC_INNER_VLAN_INCL_VLT field value from a register. */
#define CORE_MAC_INNER_VLAN_INCL_VLT_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_INNER_VLAN_INCL_VLT register field value suitable for setting the register.
 */
#define CORE_MAC_INNER_VLAN_INCL_VLT_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : VLC
 *
 * VLAN Tag Control in Transmit Packets.
 *
 * * 2'b00: No VLAN tag deletion, insertion, or replacement
 *
 * * 2'b01: VLAN tag deletion
 *
 * The MAC removes the VLAN type (bytes 17 and 18) and VLAN tag (bytes 19 and 20)
 * of all transmitted packets with VLAN tags.
 *
 * * 2'b10: VLAN tag insertion
 *
 * The MAC inserts VLT in bytes 19 and 20 of the packet after inserting the Type
 * value (0x8100 or 0x88a8) in bytes 17 and 18. This operation is performed on all
 * transmitted packets, irrespective of whether they already have a VLAN tag.
 *
 * * 2'b11: VLAN tag replacement
 *
 * The MAC replaces VLT in bytes 19 and 20 of all VLAN-type transmitted packets
 * (Bytes 17 and 18 are 0x8100 or 0x88a8).
 *
 * Note:  Changes to this field take effect only on the start of a packet. If you
 * write this register field when a packet is being transmitted, only the
 * subsequent packet can use the updated value, that is, the current packet does
 * not use the updated value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INNER_VLAN_INCL_VLC register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_LSB	16
/* The Most Significant Bit (MSB) position of the CORE_MAC_INNER_VLAN_INCL_VLC register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_MSB	17
/* The width in bits of the CORE_MAC_INNER_VLAN_INCL_VLC register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_WIDTH	2
/* The mask used to set the CORE_MAC_INNER_VLAN_INCL_VLC register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_SET_MSK	0x00030000
/* The mask used to clear the CORE_MAC_INNER_VLAN_INCL_VLC register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_CLR_MSK	0xfffcffff
/* The reset value of the CORE_MAC_INNER_VLAN_INCL_VLC register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_RESET	0x0
/* Extracts the CORE_MAC_INNER_VLAN_INCL_VLC field value from a register. */
#define CORE_MAC_INNER_VLAN_INCL_VLC_GET(value) (((value)&0x00030000) >> 16)
/* Produces a CORE_MAC_INNER_VLAN_INCL_VLC register field value suitable for setting the register.
 */
#define CORE_MAC_INNER_VLAN_INCL_VLC_SET(value) (((value) << 16) & 0x00030000)

/*
 * Field : VLP
 *
 * VLAN Priority Control.
 *
 * When this bit is set, the VLC field is used for VLAN deletion, insertion, or
 * replacement. When this bit is reset, the mti_vlan_ctrl_i control input is used
 * and the VLC field is ignored.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INNER_VLAN_INCL_VLP register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_LSB	18
/* The Most Significant Bit (MSB) position of the CORE_MAC_INNER_VLAN_INCL_VLP register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_MSB	18
/* The width in bits of the CORE_MAC_INNER_VLAN_INCL_VLP register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_WIDTH	1
/* The mask used to set the CORE_MAC_INNER_VLAN_INCL_VLP register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_SET_MSK	0x00040000
/* The mask used to clear the CORE_MAC_INNER_VLAN_INCL_VLP register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_CLR_MSK	0xfffbffff
/* The reset value of the CORE_MAC_INNER_VLAN_INCL_VLP register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_RESET	0x0
/* Extracts the CORE_MAC_INNER_VLAN_INCL_VLP field value from a register. */
#define CORE_MAC_INNER_VLAN_INCL_VLP_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_INNER_VLAN_INCL_VLP register field value suitable for setting the register.
 */
#define CORE_MAC_INNER_VLAN_INCL_VLP_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : CSVL
 *
 * C-VLAN or S-VLAN.
 *
 * When this bit is set, S-VLAN type (0x88A8) is inserted or replaced in the 13th
 * and 14th bytes of transmitted packets. When this bit is reset, C-VLAN type
 * (0x8100) is inserted or replaced in the 13th and 14th bytes of transmitted
 * packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INNER_VLAN_INCL_CSVL register field. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_INNER_VLAN_INCL_CSVL register field. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_MSB	 19
/* The width in bits of the CORE_MAC_INNER_VLAN_INCL_CSVL register field. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_WIDTH	 1
/* The mask used to set the CORE_MAC_INNER_VLAN_INCL_CSVL register field value. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_SET_MSK	 0x00080000
/* The mask used to clear the CORE_MAC_INNER_VLAN_INCL_CSVL register field value. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_CLR_MSK	 0xfff7ffff
/* The reset value of the CORE_MAC_INNER_VLAN_INCL_CSVL register field. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_RESET	 0x0
/* Extracts the CORE_MAC_INNER_VLAN_INCL_CSVL field value from a register. */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_INNER_VLAN_INCL_CSVL register field value suitable for setting the register.
 */
#define CORE_MAC_INNER_VLAN_INCL_CSVL_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : VLTI
 *
 * VLAN Tag Input.
 *
 * When this bit is set, it indicates that the VLAN tag to be inserted or replaced
 * in Tx packet should be taken from the following:
 *
 * * The mti_vlan_tag_i signal in XGMAC-CORE configurations
 *
 * * The control word in XGMAC-MTL configurations
 *
 * * The Tx descriptor in XGMAC-AXI configurations
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INNER_VLAN_INCL_VLTI register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_LSB	 20
/* The Most Significant Bit (MSB) position of the CORE_MAC_INNER_VLAN_INCL_VLTI register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_MSB	 20
/* The width in bits of the CORE_MAC_INNER_VLAN_INCL_VLTI register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_WIDTH	 1
/* The mask used to set the CORE_MAC_INNER_VLAN_INCL_VLTI register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_SET_MSK	 0x00100000
/* The mask used to clear the CORE_MAC_INNER_VLAN_INCL_VLTI register field value. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_CLR_MSK	 0xffefffff
/* The reset value of the CORE_MAC_INNER_VLAN_INCL_VLTI register field. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_RESET	 0x0
/* Extracts the CORE_MAC_INNER_VLAN_INCL_VLTI field value from a register. */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_INNER_VLAN_INCL_VLTI register field value suitable for setting the register.
 */
#define CORE_MAC_INNER_VLAN_INCL_VLTI_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : Reserved_31_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register
 * field. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_LSB	   21
/* The Most Significant Bit (MSB) position of the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register
 * field. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_MSB	   31
/* The width in bits of the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register field. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_WIDTH	   11
/* The mask used to set the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register field value. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_SET_MSK	   0xffe00000
/* The mask used to clear the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register field value. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_CLR_MSK	   0x001fffff
/* The reset value of the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register field. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_RESET	   0x0
/* Extracts the CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 field value from a register. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_GET(value) (((value)&0xffe00000) >> 21)
/* Produces a CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 register field value suitable for setting the
 * register. */
#define CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21_SET(value) (((value) << 21) & 0xffe00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_INNER_VLAN_INCL.
 */
struct CORE_MAC_INNER_VLAN_INCL_s {
	volatile uint32_t VLT : 16;		     /* CORE_MAC_INNER_VLAN_INCL_VLT */
	volatile uint32_t VLC : 2;		     /* CORE_MAC_INNER_VLAN_INCL_VLC */
	volatile uint32_t VLP : 1;		     /* CORE_MAC_INNER_VLAN_INCL_VLP */
	volatile uint32_t CSVL : 1;		     /* CORE_MAC_INNER_VLAN_INCL_CSVL */
	volatile uint32_t VLTI : 1;		     /* CORE_MAC_INNER_VLAN_INCL_VLTI */
	const volatile uint32_t Reserved_31_21 : 11; /* CORE_MAC_INNER_VLAN_INCL_RESERVED_31_21 */
};

/* The typedef declaration for register CORE_MAC_INNER_VLAN_INCL. */
typedef struct CORE_MAC_INNER_VLAN_INCL_s CORE_MAC_INNER_VLAN_INCL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_INNER_VLAN_INCL register. */
#define CORE_MAC_INNER_VLAN_INCL_RESET 0x00000000
/* The byte offset of the CORE_MAC_INNER_VLAN_INCL register from the beginning of the component. */
#define CORE_MAC_INNER_VLAN_INCL_OFST  0x64

/*
 * Register : MAC_Rx_Eth_Type_Match
 *
 * The receive Ethernet type match register contains the ether type value that
 * needs to be compared with the ether length/type field of the received packet.
 * The result is indicated in the packet_type field of receive status word. This
 * field must be programmed with values greater than or equal to 1536. Values less
 * than these are ignored.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_RX_ETH_TYPE_MATCH_ET
 *  [31:16] | R      | 0x0   | CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16
 *
 */
/*
 * Field : ET
 *
 * Ethernet Type.
 *
 * This field holds the Ethernet Type value used for length/type matching.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_ETH_TYPE_MATCH_ET register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_ETH_TYPE_MATCH_ET register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_MSB	 15
/* The width in bits of the CORE_MAC_RX_ETH_TYPE_MATCH_ET register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_WIDTH	 16
/* The mask used to set the CORE_MAC_RX_ETH_TYPE_MATCH_ET register field value. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_RX_ETH_TYPE_MATCH_ET register field value. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_RX_ETH_TYPE_MATCH_ET register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_RESET	 0x0
/* Extracts the CORE_MAC_RX_ETH_TYPE_MATCH_ET field value from a register. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_RX_ETH_TYPE_MATCH_ET register field value suitable for setting the register.
 */
#define CORE_MAC_RX_ETH_TYPE_MATCH_ET_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16
 * register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_LSB	     16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 register
 * field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_MSB	     31
/* The width in bits of the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_WIDTH	     16
/* The mask used to set the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 register field value. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 register field value. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 register field. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_RESET	     0x0
/* Extracts the CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 field value from a register. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 register field value suitable for setting
 * the register. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RX_ETH_TYPE_MATCH.
 */
struct CORE_MAC_RX_ETH_TYPE_MATCH_s {
	volatile uint32_t ET : 16;		     /* CORE_MAC_RX_ETH_TYPE_MATCH_ET */
	const volatile uint32_t Reserved_31_16 : 16; /* CORE_MAC_RX_ETH_TYPE_MATCH_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_RX_ETH_TYPE_MATCH. */
typedef struct CORE_MAC_RX_ETH_TYPE_MATCH_s CORE_MAC_RX_ETH_TYPE_MATCH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RX_ETH_TYPE_MATCH register. */
#define CORE_MAC_RX_ETH_TYPE_MATCH_RESET 0x00000000
/* The byte offset of the CORE_MAC_RX_ETH_TYPE_MATCH register from the beginning of the component.
 */
#define CORE_MAC_RX_ETH_TYPE_MATCH_OFST	 0x6c

/*
 * Register : MAC_Q0_Tx_Flow_Ctrl
 *
 * The MAC_Q0_Tx_Flow_Ctrl register controls the generation of the Control (Pause
 * Command) packets by the Flow control module of the MAC. A Write to a register
 * with the Busy bit set to 1 triggers the Flow Control block to generate a Pause
 * packet. The fields of the control packet are selected as specified in the IEEE
 * 802.3-2018 specification, and the Pause Time value from this register is used in
 * the Pause Time field of the control packet. The Busy bit remains set until the
 * control packet is transmitted by the MAC. The application must make sure that
 * the Busy bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q0_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy or Backpressure Activate.
 *
 * This bit initiates a Pause packet in the full-duplex mode and activates the
 * backpressure function in the half-duplex mode if the TFE bit is set.
 *
 * In the full-duplex mode, this bit should be read as 1'b0 before writing to this
 * register.To initiate a Pause packet, the application must set this bit to 1'b1.
 * During Control packet transfer, this bit continues to be set to indicate that a
 * packet transmission is in progress. When Pause packet transmission is complete,
 * the MAC resets this bit to 1'b0. You should not write to this register until
 * this bit is cleared.
 *
 * When this bit is set (and TFE bit is set) in the half-duplex mode, the MAC
 * asserts the backpressure. During backpressure, when the MAC receives a new
 * packet, the transmitter starts sending a JAM pattern resulting in a collision.
 * This control register bit is logically ORed with the mti_flowctrl_i input signal
 * for the backpressure function. When the MAC is configured for the full-duplex
 * mode, the BPA is automatically disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q0_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * In the full-duplex mode, when this bit is set, the MAC enables the flow control
 * operation based on Tx Pause packets. When this bit is reset, the flow control
 * operation in the MAC is disabled, and the MAC does not transmit any Pause
 * packets by itself.
 *
 * In the half-duplex mode, when this bit is set, the MAC enables the backpressure
 * operation. When this bit is reset, the backpressure feature is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q0_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 3'b000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 3'b001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 3'b010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 3'b011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 3'b100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 3'b101 - 3'b111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[0] or
 * mti_flowctrl_i[0]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q0_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q0_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q0_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q0_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q0_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q0_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q0_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q0_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q0_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q0_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q0_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q0_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q0_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q0_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q0_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q0_TX_FLOW_CTRL_s CORE_MAC_Q0_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q0_TX_FLOW_CTRL register. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q0_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q0_TX_FLOW_CTRL_OFST  0x70

/*
 * Register : MAC_Q1_Tx_Flow_Ctrl
 *
 * The MAC_Q1_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q1_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q1_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q1_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[1] or
 * mti_flowctrl_i[1]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q1_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q1_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q1_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q1_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q1_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q1_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q1_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q1_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q1_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q1_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q1_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q1_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q1_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q1_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q1_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q1_TX_FLOW_CTRL_s CORE_MAC_Q1_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q1_TX_FLOW_CTRL register. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q1_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q1_TX_FLOW_CTRL_OFST  0x74

/*
 * Register : MAC_Q2_Tx_Flow_Ctrl
 *
 * The MAC_Q2_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q2_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q2_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q2_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[2] or
 * mti_flowctrl_i[2]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q2_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q2_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q2_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q2_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q2_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q2_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q2_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q2_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q2_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q2_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q2_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q2_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q2_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q2_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q2_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q2_TX_FLOW_CTRL_s CORE_MAC_Q2_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q2_TX_FLOW_CTRL register. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q2_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q2_TX_FLOW_CTRL_OFST  0x78

/*
 * Register : MAC_Q3_Tx_Flow_Ctrl
 *
 * The MAC_Q3_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q3_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q3_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q3_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[3] or
 * mti_flowctrl_i[3]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q3_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q3_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q3_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q3_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q3_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q3_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q3_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q3_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q3_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q3_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q3_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q3_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q3_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q3_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q3_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q3_TX_FLOW_CTRL_s CORE_MAC_Q3_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q3_TX_FLOW_CTRL register. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q3_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q3_TX_FLOW_CTRL_OFST  0x7c

/*
 * Register : MAC_Q4_Tx_Flow_Ctrl
 *
 * The MAC_Q4_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q4_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q4_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q4_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[4] or
 * mti_flowctrl_i[4]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q4_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q4_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q4_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q4_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q4_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q4_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q4_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q4_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q4_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q4_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q4_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q4_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q4_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q4_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q4_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q4_TX_FLOW_CTRL_s CORE_MAC_Q4_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q4_TX_FLOW_CTRL register. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q4_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q4_TX_FLOW_CTRL_OFST  0x80

/*
 * Register : MAC_Q5_Tx_Flow_Ctrl
 *
 * The MAC_Q5_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q5_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q5_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q5_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[5] or
 * mti_flowctrl_i[5]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q5_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q5_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q5_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q5_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q5_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q5_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q5_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q5_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q5_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q5_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q5_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q5_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q5_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q5_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q5_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q5_TX_FLOW_CTRL_s CORE_MAC_Q5_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q5_TX_FLOW_CTRL register. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q5_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q5_TX_FLOW_CTRL_OFST  0x84

/*
 * Register : MAC_Q6_Tx_Flow_Ctrl
 *
 * The MAC_Q6_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q6_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q6_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q6_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[6] or
 * mti_flowctrl_i[6]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q6_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q6_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q6_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q6_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q6_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q6_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q6_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q6_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q6_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q6_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q6_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q6_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q6_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q6_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q6_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q6_TX_FLOW_CTRL_s CORE_MAC_Q6_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q6_TX_FLOW_CTRL register. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q6_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q6_TX_FLOW_CTRL_OFST  0x88

/*
 * Register : MAC_Q7_Tx_Flow_Ctrl
 *
 * The MAC_Q7_Tx_Flow_Ctrl register is per priority and controls the generation of
 * the PFC (Priority Flow Control) packets by the Flow control module of the MAC. A
 * write to a register with the Busy bit set to 1 triggers the Flow Control block
 * to generate a PFC packet for corresponding priority. The fields of the PFC
 * packet are selected as specified in the IEEE 802.3-2018 specification, and the
 * Pause Time value from this register is used in the Pause Time field for
 * corresponding priority in the PFC packet. The Busy bit remains set until the PFC
 * packet is transmitted by the MAC. The application must make sure that the Busy
 * bit is cleared before writing to the register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_FCB
 *  [1]     | RW     | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_TFE
 *  [3:2]   | R      | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2
 *  [6:4]   | RW     | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_PLT
 *  [7]     | RW     | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ
 *  [15:8]  | R      | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8
 *  [31:16] | RW     | 0x0   | CORE_MAC_Q7_TX_FLOW_CTRL_PT
 *
 */
/*
 * Field : FCB
 *
 * Flow Control Busy.
 *
 * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
 * packet, the application must set this bit to 1'b1. During Control packet
 * transfer, this bit continues to be set to indicate that a packet transmission is
 * in progress. When Pause packet transmission is complete, the MAC resets this bit
 * to 1'b0. You should not write to this register until this bit is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_MSB	0
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_WIDTH	1
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_SET_MSK	0x00000001
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_RESET	0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_FCB field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_FCB register field value suitable for setting the register.
 */
#define CORE_MAC_Q7_TX_FLOW_CTRL_FCB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TFE
 *
 * Transmit Flow Control Enable.
 *
 * When this bit is set, the MAC enables the flow control operation based on Tx
 * Pause packets. When this bit is reset, the flow control operation in the MAC is
 * disabled, and the MAC does not transmit any Pause packets by itself.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_MSB	1
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_WIDTH	1
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_RESET	0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_TFE field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_TFE register field value suitable for setting the register.
 */
#define CORE_MAC_Q7_TX_FLOW_CTRL_TFE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register
 * field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_MSB	 3
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_WIDTH	 2
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_SET_MSK	 0x0000000c
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_CLR_MSK	 0xfffffff3
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_RESET	 0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : PLT
 *
 * Pause Low Threshold.
 *
 * This field configures the threshold of the Pause timer at which the input flow
 * control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic
 * retransmission of the Pause packet.
 *
 * The threshold values should be always less than the Pause Time configured in
 * Bits[31:16]. For example, if PT = 100H (256 slot times), and PLT = 001, a second
 * Pause packet is automatically transmitted if the mti_flowctrl_i signal is
 * asserted at 228 (256 - 28) slot times after the first Pause packet is
 * transmitted.
 *
 * The following list provides the threshold values for different values:
 *
 * * 000: Pause Time minus 4 Slot Times (PT - 4 slot times)
 *
 * * 001: Pause Time minus 28 Slot Times (PT - 28 slot times)
 *
 * * 010: Pause Time minus 36 Slot Times (PT - 36 slot times)
 *
 * * 011: Pause Time minus 144 Slot Times (PT - 144 slot times)
 *
 * * 100: Pause Time minus 256 Slot Times (PT - 256 slot times)
 *
 * * 101-111: Reserved
 *
 * The slot time is defined as the time taken to transmit 512 bits (64 bytes) on
 * the GMII or XGMII interface.
 *
 * This (approximate) computation is based on the packet size (64, 1518, 2000,
 * 9018, or 16384) + 2 Pause Packet Size + IPG in Slot Times.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_MSB	6
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_WIDTH	3
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_SET_MSK	0x00000070
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_CLR_MSK	0xffffff8f
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_RESET	0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_PLT field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_GET(value) (((value)&0x00000070) >> 4)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_PLT register field value suitable for setting the register.
 */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PLT_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : DZPQ
 *
 * Disable Zero-Quanta Pause.
 *
 * When this bit is set, it disables the automatic generation of the zero-quanta
 * Pause packets on de-assertion of the flow-control signal from the FIFO layer
 * (MTL or external sideband flow control signal sbd_flowctrl_i[7] or
 * mti_flowctrl_i[7]).
 *
 * When this bit is reset, normal operation with automatic zero-quanta Pause packet
 * generation is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_MSB	 7
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_WIDTH	 1
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_RESET	 0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ register field value suitable for setting the register.
 */
#define CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register
 * field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PT
 *
 * Pause Time.
 *
 * This field holds the value to be used in the Pause Time field in the Tx control
 * packet. If the Pause Time bits are configured to be double-synchronized to the
 * (X)GMII clock domain, consecutive writes to this register should be performed
 * only after at least four clock cycles in the destination clock domain.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_Q7_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_MSB	       31
/* The width in bits of the CORE_MAC_Q7_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_WIDTH      16
/* The mask used to set the CORE_MAC_Q7_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_Q7_TX_FLOW_CTRL_PT register field value. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL_PT register field. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_RESET      0x0
/* Extracts the CORE_MAC_Q7_TX_FLOW_CTRL_PT field value from a register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_Q7_TX_FLOW_CTRL_PT register field value suitable for setting the register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_PT_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_Q7_TX_FLOW_CTRL.
 */
struct CORE_MAC_Q7_TX_FLOW_CTRL_s {
	volatile uint32_t FCB : 1;		   /* CORE_MAC_Q7_TX_FLOW_CTRL_FCB */
	volatile uint32_t TFE : 1;		   /* CORE_MAC_Q7_TX_FLOW_CTRL_TFE */
	const volatile uint32_t Reserved_3_2 : 2;  /* CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_3_2 */
	volatile uint32_t PLT : 3;		   /* CORE_MAC_Q7_TX_FLOW_CTRL_PLT */
	volatile uint32_t DZPQ : 1;		   /* CORE_MAC_Q7_TX_FLOW_CTRL_DZPQ */
	const volatile uint32_t Reserved_15_8 : 8; /* CORE_MAC_Q7_TX_FLOW_CTRL_RESERVED_15_8 */
	volatile uint32_t PT : 16;		   /* CORE_MAC_Q7_TX_FLOW_CTRL_PT */
};

/* The typedef declaration for register CORE_MAC_Q7_TX_FLOW_CTRL. */
typedef struct CORE_MAC_Q7_TX_FLOW_CTRL_s CORE_MAC_Q7_TX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_Q7_TX_FLOW_CTRL register. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_Q7_TX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_Q7_TX_FLOW_CTRL_OFST  0x8c

/*
 * Register : MAC_Rx_Flow_Ctrl
 *
 * The Receive Flow Control register controls the pausing of MAC Transmit based on
 * the received Pause packet.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [0]    | RW     | 0x0   | CORE_MAC_RX_FLOW_CTRL_RFE
 *  [1]    | RW     | 0x0   | CORE_MAC_RX_FLOW_CTRL_UP
 *  [7:2]  | R      | 0x0   | CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2
 *  [8]    | RW     | 0x0   | CORE_MAC_RX_FLOW_CTRL_PFCE
 *  [31:9] | R      | 0x0   | CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9
 *
 */
/*
 * Field : RFE
 *
 * Receive Flow Control Enable.
 *
 * When this bit is set and the MAC is operating in full-duplex mode, the MAC
 * decodes the received Pause packet and disables its transmitter for a specified
 * (Pause) time. When this bit is reset or when the MAC operates in half-duplex
 * mode, the decode function of the Pause packet is disabled.
 *
 * When PFC is enabled, flow control is enabled for PFC packets. The MAC decodes
 * the received PFC packet and disables the corresponding Traffic Class, with
 * matching priorities, for a duration of received Pause time.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_FLOW_CTRL_RFE register field. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_FLOW_CTRL_RFE register field. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_MSB	     0
/* The width in bits of the CORE_MAC_RX_FLOW_CTRL_RFE register field. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_WIDTH	     1
/* The mask used to set the CORE_MAC_RX_FLOW_CTRL_RFE register field value. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_RX_FLOW_CTRL_RFE register field value. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_RX_FLOW_CTRL_RFE register field. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_RESET	     0x0
/* Extracts the CORE_MAC_RX_FLOW_CTRL_RFE field value from a register. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_RX_FLOW_CTRL_RFE register field value suitable for setting the register. */
#define CORE_MAC_RX_FLOW_CTRL_RFE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : UP
 *
 * Unicast Pause Packet Detect.
 *
 * A pause packet is processed when it has the unique multicast address specified
 * in the IEEE 802.3-2018. When this bit is set, the MAC can also detect Pause
 * packets with unicast address of the station. This unicast address should be as
 * specified in MAC_Address0_High and MAC_Address0_Low.
 *
 * When this bit is reset, the MAC only detects Pause packets with unique multicast
 * address.
 *
 * Note: The MAC does not process a Pause packet if the multicast address is
 * different from the unique multicast address. This is also applicable to the
 * received PFC packet when the Priority Flow Control (PFC) is enabled. The unique
 * multicast address (0x01_80_C2_00_00_01) is as specified in IEEE 802.1Qbb-2011.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_FLOW_CTRL_UP register field. */
#define CORE_MAC_RX_FLOW_CTRL_UP_LSB	    1
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_FLOW_CTRL_UP register field. */
#define CORE_MAC_RX_FLOW_CTRL_UP_MSB	    1
/* The width in bits of the CORE_MAC_RX_FLOW_CTRL_UP register field. */
#define CORE_MAC_RX_FLOW_CTRL_UP_WIDTH	    1
/* The mask used to set the CORE_MAC_RX_FLOW_CTRL_UP register field value. */
#define CORE_MAC_RX_FLOW_CTRL_UP_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_RX_FLOW_CTRL_UP register field value. */
#define CORE_MAC_RX_FLOW_CTRL_UP_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_RX_FLOW_CTRL_UP register field. */
#define CORE_MAC_RX_FLOW_CTRL_UP_RESET	    0x0
/* Extracts the CORE_MAC_RX_FLOW_CTRL_UP field value from a register. */
#define CORE_MAC_RX_FLOW_CTRL_UP_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_RX_FLOW_CTRL_UP register field value suitable for setting the register. */
#define CORE_MAC_RX_FLOW_CTRL_UP_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_7_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register
 * field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register field.
 */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_MSB	      7
/* The width in bits of the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_WIDTH      6
/* The mask used to set the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register field value. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_SET_MSK    0x000000fc
/* The mask used to clear the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register field value. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_CLR_MSK    0xffffff03
/* The reset value of the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_RESET      0x0
/* Extracts the CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 field value from a register. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_GET(value) (((value)&0x000000fc) >> 2)
/* Produces a CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2_SET(value) (((value) << 2) & 0x000000fc)

/*
 * Field : PFCE
 *
 * Priority Based Flow Control Enable.
 *
 * When this bit is set, it enables generation and reception of priority-based flow
 * control (PFC) packets. When this bit is reset, it enables generation and
 * reception of IEEE 802.3-2018 Pause control packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_FLOW_CTRL_PFCE register field. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_LSB	      8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_FLOW_CTRL_PFCE register field. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_MSB	      8
/* The width in bits of the CORE_MAC_RX_FLOW_CTRL_PFCE register field. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_WIDTH      1
/* The mask used to set the CORE_MAC_RX_FLOW_CTRL_PFCE register field value. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_RX_FLOW_CTRL_PFCE register field value. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_RX_FLOW_CTRL_PFCE register field. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_RESET      0x0
/* Extracts the CORE_MAC_RX_FLOW_CTRL_PFCE field value from a register. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_RX_FLOW_CTRL_PFCE register field value suitable for setting the register. */
#define CORE_MAC_RX_FLOW_CTRL_PFCE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : Reserved_31_9
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register
 * field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_LSB	       9
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register
 * field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_MSB	       31
/* The width in bits of the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_WIDTH      23
/* The mask used to set the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register field value. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_SET_MSK    0xfffffe00
/* The mask used to clear the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register field value. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_CLR_MSK    0x000001ff
/* The reset value of the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register field. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_RESET      0x0
/* Extracts the CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 field value from a register. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_GET(value) (((value)&0xfffffe00) >> 9)
/* Produces a CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9_SET(value) (((value) << 9) & 0xfffffe00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RX_FLOW_CTRL.
 */
struct CORE_MAC_RX_FLOW_CTRL_s {
	volatile uint32_t RFE : 1;		    /* CORE_MAC_RX_FLOW_CTRL_RFE */
	volatile uint32_t UP : 1;		    /* CORE_MAC_RX_FLOW_CTRL_UP */
	const volatile uint32_t Reserved_7_2 : 6;   /* CORE_MAC_RX_FLOW_CTRL_RESERVED_7_2 */
	volatile uint32_t PFCE : 1;		    /* CORE_MAC_RX_FLOW_CTRL_PFCE */
	const volatile uint32_t Reserved_31_9 : 23; /* CORE_MAC_RX_FLOW_CTRL_RESERVED_31_9 */
};

/* The typedef declaration for register CORE_MAC_RX_FLOW_CTRL. */
typedef struct CORE_MAC_RX_FLOW_CTRL_s CORE_MAC_RX_FLOW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RX_FLOW_CTRL register. */
#define CORE_MAC_RX_FLOW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_RX_FLOW_CTRL register from the beginning of the component. */
#define CORE_MAC_RX_FLOW_CTRL_OFST  0x90

/*
 * Register : MAC_RxQ_Ctrl4
 *
 * The Receive Queue Control 4 register controls the routing of
 *
 * * Packets which fail the Destination or Source Address filter and VLAN Filter.
 *   Packets refer to Express packets only when FPE is configured
 *
 * * Preemptive Multicast/Broadcast packets when MCBCQEN of MAC_RxQ_Ctrl1 is
 *   enabled to a separate Rx Queue
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_UFFQE
 *  [3:1]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_UFFQ
 *  [7:4]   | R      | 0x0   | CORE_MAC_RXQ_CTRL4_RESERVED_7_Y
 *  [8]     | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_MFFQE
 *  [11:9]  | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_MFFQ
 *  [15:12] | R      | 0x0   | CORE_MAC_RXQ_CTRL4_RESERVED_15_Y
 *  [16]    | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_VFFQE
 *  [19:17] | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_VFFQ
 *  [23:20] | R      | 0x0   | CORE_MAC_RXQ_CTRL4_RESERVED_23_Y
 *  [26:24] | RW     | 0x0   | CORE_MAC_RXQ_CTRL4_PMCBCQ
 *  [31:27] | R      | 0x0   | CORE_MAC_RXQ_CTRL4_RESERVED_31_Y
 *
 */
/*
 * Field : UFFQE
 *
 * Unicast Filter Fail Packets Queuing Enable.
 *
 * When this bit is set, the Unicast packets which fail the Destination or Source
 * address filter are routed to the Rx Queue Number programmed in the UFFQ.
 *
 * When this bit is reset, the Unicast packets which fail the Destination or Source
 * address filter are routed based on other routing options.
 *
 * This bit is valid only when the RA bit of the MAC_Packet_Filter register is set.
 *
 * values:
 *
 * * 0: Unicast Address Filter Fail Packets Queuing is disabled.
 *
 * * 1: Unicast Address Filter Fail Packets Queuing is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_UFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_UFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_MSB	    0
/* The width in bits of the CORE_MAC_RXQ_CTRL4_UFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_WIDTH	    1
/* The mask used to set the CORE_MAC_RXQ_CTRL4_UFFQE register field value. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_UFFQE register field value. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_RXQ_CTRL4_UFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_UFFQE field value from a register. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_RXQ_CTRL4_UFFQE register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_UFFQE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : UFFQ
 *
 * Unicast Address Filter Fail Packets Queue.
 *
 * This field holds the Rx queue number to which Unicast Pakcets failing the
 * Destination or Source Address filter must be routed. This field is valid only
 * when UFFQE the bit is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_UFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_LSB	   1
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_UFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_MSB	   3
/* The width in bits of the CORE_MAC_RXQ_CTRL4_UFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_WIDTH	   3
/* The mask used to set the CORE_MAC_RXQ_CTRL4_UFFQ register field value. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_SET_MSK	   0x0000000e
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_UFFQ register field value. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_CLR_MSK	   0xfffffff1
/* The reset value of the CORE_MAC_RXQ_CTRL4_UFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_RESET	   0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_UFFQ field value from a register. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a CORE_MAC_RXQ_CTRL4_UFFQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_UFFQ_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : Reserved_7_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_LSB	   4
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_MSB	   7
/* The width in bits of the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_WIDTH	   4
/* The mask used to set the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_SET_MSK	   0x000000f0
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_CLR_MSK	   0xffffff0f
/* The reset value of the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_RESET	   0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_RESERVED_7_Y field value from a register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_GET(value) (((value)&0x000000f0) >> 4)
/* Produces a CORE_MAC_RXQ_CTRL4_RESERVED_7_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_7_Y_SET(value) (((value) << 4) & 0x000000f0)

/*
 * Field : MFFQE
 *
 * Multicast Filter Fail Packets Queuing Enable.
 *
 * When this bit is set, the Multicast packets which fail the Destination or Source
 * address filter are routed to the Rx Queue Number programmed in the MFFQ.
 *
 * When this bit is reset, the Multicast packets which fail the Destination or
 * Source address filter are routed based on other routing options.
 *
 * This bit is valid only when the RA bit of the MAC_Packet_Filter register is set.
 *
 * values:
 *
 * * 0: Multicast Address Filter Fail Packets Queuing is disabled.
 *
 * * 1: Multicast Address Filter Fail Packets Queuing is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_MFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_MFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_MSB	    8
/* The width in bits of the CORE_MAC_RXQ_CTRL4_MFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_WIDTH	    1
/* The mask used to set the CORE_MAC_RXQ_CTRL4_MFFQE register field value. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_MFFQE register field value. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_RXQ_CTRL4_MFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_MFFQE field value from a register. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_RXQ_CTRL4_MFFQE register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_MFFQE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : MFFQ
 *
 * Multicast Address Filter Fail Packets Queue.
 *
 * This field holds the Rx queue number to which Multicast Pakcets failing the
 * Destination or Source Address filter must be routed. This field is valid only
 * when MFFQE the bit is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_MFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_LSB	   9
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_MFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_MSB	   11
/* The width in bits of the CORE_MAC_RXQ_CTRL4_MFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_WIDTH	   3
/* The mask used to set the CORE_MAC_RXQ_CTRL4_MFFQ register field value. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_SET_MSK	   0x00000e00
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_MFFQ register field value. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_CLR_MSK	   0xfffff1ff
/* The reset value of the CORE_MAC_RXQ_CTRL4_MFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_RESET	   0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_MFFQ field value from a register. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_GET(value) (((value)&0x00000e00) >> 9)
/* Produces a CORE_MAC_RXQ_CTRL4_MFFQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_MFFQ_SET(value) (((value) << 9) & 0x00000e00)

/*
 * Field : Reserved_15_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_LSB	    12
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_MSB	    15
/* The width in bits of the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_WIDTH	    4
/* The mask used to set the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_SET_MSK    0x0000f000
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_CLR_MSK    0xffff0fff
/* The reset value of the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_RESERVED_15_Y field value from a register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_GET(value) (((value)&0x0000f000) >> 12)
/* Produces a CORE_MAC_RXQ_CTRL4_RESERVED_15_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_15_Y_SET(value) (((value) << 12) & 0x0000f000)

/*
 * Field : VFFQE
 *
 * VLAN Tag Filter Fail Packets Queuing Enable.
 *
 * When this bit is set, the tagged packets which fail the Destination or Source
 * address filter or fail the VLAN tag filter, are routed to the Rx Queue Number
 * programmed in the VFFQ.
 *
 * When this bit is reset, the tagged packets which fail the Destination or Source
 * address filter or fail the VLAN tag filter are routed based on other routing
 * options.
 *
 * This bit is valid only when the RA bit of the MAC_Packet_Filter register is set.
 *
 * values:
 *
 * * 0: VLAN tag Filter Fail Packets Queuing is disabled.
 *
 * * 1: VLAN tag Filter Fail Packets Queuing is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_VFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_VFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_MSB	    16
/* The width in bits of the CORE_MAC_RXQ_CTRL4_VFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_WIDTH	    1
/* The mask used to set the CORE_MAC_RXQ_CTRL4_VFFQE register field value. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_VFFQE register field value. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_RXQ_CTRL4_VFFQE register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_VFFQE field value from a register. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_RXQ_CTRL4_VFFQE register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_VFFQE_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : VFFQ
 *
 * VLAN Tag Filter Fail Packets Queue.
 *
 * This field holds the Rx queue number to which the tagged packets failing the
 * Destination or Source Address filter (and UFFQE/MFFQE not enabled) or failing
 * the VLAN tag filter must be routed. This field is valid only when the VFFQE bit
 * is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_VFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_LSB	   17
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_VFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_MSB	   19
/* The width in bits of the CORE_MAC_RXQ_CTRL4_VFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_WIDTH	   3
/* The mask used to set the CORE_MAC_RXQ_CTRL4_VFFQ register field value. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_SET_MSK	   0x000e0000
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_VFFQ register field value. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_CLR_MSK	   0xfff1ffff
/* The reset value of the CORE_MAC_RXQ_CTRL4_VFFQ register field. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_RESET	   0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_VFFQ field value from a register. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_GET(value) (((value)&0x000e0000) >> 17)
/* Produces a CORE_MAC_RXQ_CTRL4_VFFQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_VFFQ_SET(value) (((value) << 17) & 0x000e0000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_LSB	    20
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_MSB	    23
/* The width in bits of the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_WIDTH	    4
/* The mask used to set the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_SET_MSK    0x00f00000
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_CLR_MSK    0xff0fffff
/* The reset value of the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_RESERVED_23_Y field value from a register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_GET(value) (((value)&0x00f00000) >> 20)
/* Produces a CORE_MAC_RXQ_CTRL4_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_23_Y_SET(value) (((value) << 20) & 0x00f00000)

/*
 * Field : PMCBCQ
 *
 * Preemption Multicast/Broadcast Queue.
 *
 * This field holds the Rx queue number to which the preemptive Multicast/Broadcast
 * packets passing the Destination or Source Address filter or the VLAN tag filter
 * must be routed. This field is valid only when the MCBCQEN bit of MAC_RxQ_Ctrl1
 * register is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_PMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_LSB	     24
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_PMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_MSB	     26
/* The width in bits of the CORE_MAC_RXQ_CTRL4_PMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_WIDTH	     3
/* The mask used to set the CORE_MAC_RXQ_CTRL4_PMCBCQ register field value. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_SET_MSK    0x07000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_PMCBCQ register field value. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_CLR_MSK    0xf8ffffff
/* The reset value of the CORE_MAC_RXQ_CTRL4_PMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_PMCBCQ field value from a register. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_GET(value) (((value)&0x07000000) >> 24)
/* Produces a CORE_MAC_RXQ_CTRL4_PMCBCQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL4_PMCBCQ_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_LSB	    27
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field.
 */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_MSB	    31
/* The width in bits of the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_WIDTH	    5
/* The mask used to set the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_SET_MSK    0xf8000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field value. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_CLR_MSK    0x07ffffff
/* The reset value of the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL4_RESERVED_31_Y field value from a register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_GET(value) (((value)&0xf8000000) >> 27)
/* Produces a CORE_MAC_RXQ_CTRL4_RESERVED_31_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL4_RESERVED_31_Y_SET(value) (((value) << 27) & 0xf8000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RXQ_CTRL4.
 */
struct CORE_MAC_RXQ_CTRL4_s {
	volatile uint32_t UFFQE : 1;		   /* CORE_MAC_RXQ_CTRL4_UFFQE */
	volatile uint32_t UFFQ : 3;		   /* CORE_MAC_RXQ_CTRL4_UFFQ */
	const volatile uint32_t Reserved_7_y : 4;  /* CORE_MAC_RXQ_CTRL4_RESERVED_7_Y */
	volatile uint32_t MFFQE : 1;		   /* CORE_MAC_RXQ_CTRL4_MFFQE */
	volatile uint32_t MFFQ : 3;		   /* CORE_MAC_RXQ_CTRL4_MFFQ */
	const volatile uint32_t Reserved_15_y : 4; /* CORE_MAC_RXQ_CTRL4_RESERVED_15_Y */
	volatile uint32_t VFFQE : 1;		   /* CORE_MAC_RXQ_CTRL4_VFFQE */
	volatile uint32_t VFFQ : 3;		   /* CORE_MAC_RXQ_CTRL4_VFFQ */
	const volatile uint32_t Reserved_23_y : 4; /* CORE_MAC_RXQ_CTRL4_RESERVED_23_Y */
	volatile uint32_t PMCBCQ : 3;		   /* CORE_MAC_RXQ_CTRL4_PMCBCQ */
	const volatile uint32_t Reserved_31_y : 5; /* CORE_MAC_RXQ_CTRL4_RESERVED_31_Y */
};

/* The typedef declaration for register CORE_MAC_RXQ_CTRL4. */
typedef struct CORE_MAC_RXQ_CTRL4_s CORE_MAC_RXQ_CTRL4_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RXQ_CTRL4 register. */
#define CORE_MAC_RXQ_CTRL4_RESET 0x00000000
/* The byte offset of the CORE_MAC_RXQ_CTRL4 register from the beginning of the component. */
#define CORE_MAC_RXQ_CTRL4_OFST	 0x94

/*
 * Register : MAC_RxQ_Ctrl5
 *
 * The Receive Queue Control 5 register allows selection of start offset of the
 * Receive queue from which received packets are routed based on VLAN Tag Priority
 * field.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------
 *  [3:0]  | RW     | 0x0   | CORE_MAC_RXQ_CTRL5_PRQSO
 *  [31:4] | R      | 0x0   | CORE_MAC_RXQ_CTRL5_RESERVED_31_4
 *
 */
/*
 * Field : PRQSO
 *
 * Priority Receive Queue Start Offset.
 *
 * This field holds the Receive queue number from which received packets are routed
 * based on VLAN Tag Priority field. For example, value of 0 indicates PSRQ0,
 * PSRQ1, .. PSRQ7 fields in MAC_RxQ_Ctrl2 and MAC_RxQ_Ctrl3 registers are mapped
 * to Receive Queue 0, Receive Queue 1, .. Receive Queue 7 respectively. Similarly,
 * value of 3 indicates PSRQ0, PSRQ1, .. PSRQ7 fields in MAC_RxQ_Ctrl2 and
 * MAC_RxQ_Ctrl3 registers are mapped to Receive Queue 3, Receive Queue 4, ..
 * Receive Queue 10 respectively. The Receive queue number programmed in this field
 * must not be more than number of Receive queues selected in configuration.
 *
 * Note:  When this field is programmed to a value such that Receive queues
 * selected in configuration are lesser than the sum of programmed value and 7, all
 * the PSRQx fields cannot be mapped to the Receive queues. For example, if number
 * of Receive queues selected in configuration is 8 and this field is programmed to
 * 5, only the PSRQ0, PSRQ1 and PSRQ2 can be mapped to Receive Queue 5, Receive
 * Queue 6 and Receive Queue 7 respectively.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL5_PRQSO register field. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL5_PRQSO register field. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_MSB	    3
/* The width in bits of the CORE_MAC_RXQ_CTRL5_PRQSO register field. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_WIDTH	    4
/* The mask used to set the CORE_MAC_RXQ_CTRL5_PRQSO register field value. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_SET_MSK    0x0000000f
/* The mask used to clear the CORE_MAC_RXQ_CTRL5_PRQSO register field value. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_CLR_MSK    0xfffffff0
/* The reset value of the CORE_MAC_RXQ_CTRL5_PRQSO register field. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL5_PRQSO field value from a register. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a CORE_MAC_RXQ_CTRL5_PRQSO register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL5_PRQSO_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : Reserved_31_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field.
 */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_LSB	    4
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field.
 */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_MSB	    31
/* The width in bits of the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field. */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_WIDTH	    28
/* The mask used to set the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field value. */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_SET_MSK    0xfffffff0
/* The mask used to clear the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field value. */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_CLR_MSK    0x0000000f
/* The reset value of the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field. */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL5_RESERVED_31_4 field value from a register. */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_GET(value) (((value)&0xfffffff0) >> 4)
/* Produces a CORE_MAC_RXQ_CTRL5_RESERVED_31_4 register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL5_RESERVED_31_4_SET(value) (((value) << 4) & 0xfffffff0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RXQ_CTRL5.
 */
struct CORE_MAC_RXQ_CTRL5_s {
	volatile uint32_t PRQSO : 4;		    /* CORE_MAC_RXQ_CTRL5_PRQSO */
	const volatile uint32_t Reserved_31_4 : 28; /* CORE_MAC_RXQ_CTRL5_RESERVED_31_4 */
};

/* The typedef declaration for register CORE_MAC_RXQ_CTRL5. */
typedef struct CORE_MAC_RXQ_CTRL5_s CORE_MAC_RXQ_CTRL5_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RXQ_CTRL5 register. */
#define CORE_MAC_RXQ_CTRL5_RESET 0x00000000
/* The byte offset of the CORE_MAC_RXQ_CTRL5 register from the beginning of the component. */
#define CORE_MAC_RXQ_CTRL5_OFST	 0x98

/*
 * Register : MAC_RxQ_Ctrl0
 *
 * The Receive Queue Control 0 register activates the queue management in the MAC
 * Receiver. This register is present only when you select multiple queues in the
 * Receive path.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------
 *  [1:0]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ0EN
 *  [3:2]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ1EN
 *  [5:4]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ2EN
 *  [7:6]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ3EN
 *  [9:8]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ4EN
 *  [11:10] | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ5EN
 *  [13:12] | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ6EN
 *  [15:14] | RW     | 0x0   | CORE_MAC_RXQ_CTRL0_RXQ7EN
 *  [17:16] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN
 *  [19:18] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN
 *  [21:20] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN
 *  [23:22] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN
 *  [25:24] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN
 *  [27:26] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN
 *  [29:28] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN
 *  [31:30] | R      | 0x0   | CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN
 *
 */
/*
 * Field : RXQ0EN
 *
 * Receive Queue 0 Enable.
 *
 * This field indicates whether Rx Queue 0 is enabled.
 *
 * * 2'b00: Not enabled
 *
 * * 2'b01: Queue 0 enabled for Audio Video Bridging
 *
 * * 2'b10: Queue 0 enabled for Data Center Bridging/Generic
 *
 * * 2'b11: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ0EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ0EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_MSB	     1
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ0EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ0EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_SET_MSK    0x00000003
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ0EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_CLR_MSK    0xfffffffc
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ0EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ0EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_GET(value) (((value)&0x00000003) >> 0)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ0EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ0EN_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : RXQ1EN
 *
 * Receive Queue 1 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ1EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_LSB	     2
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ1EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_MSB	     3
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ1EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ1EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_SET_MSK    0x0000000c
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ1EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_CLR_MSK    0xfffffff3
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ1EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ1EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ1EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ1EN_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : RXQ2EN
 *
 * Receive Queue 2 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ2EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ2EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_MSB	     5
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ2EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ2EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_SET_MSK    0x00000030
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ2EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_CLR_MSK    0xffffffcf
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ2EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ2EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_GET(value) (((value)&0x00000030) >> 4)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ2EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ2EN_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : RXQ3EN
 *
 * Receive Queue 3 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ3EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ3EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_MSB	     7
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ3EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ3EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_SET_MSK    0x000000c0
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ3EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_CLR_MSK    0xffffff3f
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ3EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ3EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ3EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ3EN_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : RXQ4EN
 *
 * Receive Queue 4 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ4EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ4EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_MSB	     9
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ4EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ4EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_SET_MSK    0x00000300
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ4EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_CLR_MSK    0xfffffcff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ4EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ4EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_GET(value) (((value)&0x00000300) >> 8)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ4EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ4EN_SET(value) (((value) << 8) & 0x00000300)

/*
 * Field : RXQ5EN
 *
 * Receive Queue 5 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ5EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_LSB	     10
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ5EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_MSB	     11
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ5EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ5EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_SET_MSK    0x00000c00
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ5EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_CLR_MSK    0xfffff3ff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ5EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ5EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_GET(value) (((value)&0x00000c00) >> 10)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ5EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ5EN_SET(value) (((value) << 10) & 0x00000c00)

/*
 * Field : RXQ6EN
 *
 * Receive Queue 6 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ6EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_LSB	     12
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ6EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_MSB	     13
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ6EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ6EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_SET_MSK    0x00003000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ6EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_CLR_MSK    0xffffcfff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ6EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ6EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_GET(value) (((value)&0x00003000) >> 12)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ6EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ6EN_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : RXQ7EN
 *
 * Receive Queue 7 Enable.
 *
 * This field is similar to the RXQ0EN field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RXQ7EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_LSB	     14
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RXQ7EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_MSB	     15
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RXQ7EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_WIDTH	     2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RXQ7EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_SET_MSK    0x0000c000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RXQ7EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_CLR_MSK    0xffff3fff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RXQ7EN register field. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RXQ7EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MAC_RXQ_CTRL0_RXQ7EN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL0_RXQ7EN_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : Reserved_RXQ8EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register field.
 */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_MSB	      17
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_SET_MSK    0x00030000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_CLR_MSK    0xfffcffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_GET(value) (((value)&0x00030000) >> 16)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN_SET(value) (((value) << 16) & 0x00030000)

/*
 * Field : Reserved_RXQ9EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register field.
 */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_MSB	      19
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_SET_MSK    0x000c0000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_CLR_MSK    0xfff3ffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_GET(value) (((value)&0x000c0000) >> 18)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN_SET(value) (((value) << 18) & 0x000c0000)

/*
 * Field : Reserved_RXQ10EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_LSB	       20
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_MSB	       21
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_SET_MSK    0x00300000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_CLR_MSK    0xffcfffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_GET(value) (((value)&0x00300000) >> 20)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN_SET(value) (((value) << 20) & 0x00300000)

/*
 * Field : Reserved_RXQ11EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_LSB	       22
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_MSB	       23
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_SET_MSK    0x00c00000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_CLR_MSK    0xff3fffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_GET(value) (((value)&0x00c00000) >> 22)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN_SET(value) (((value) << 22) & 0x00c00000)

/*
 * Field : Reserved_RXQ12EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_MSB	       25
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_SET_MSK    0x03000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_CLR_MSK    0xfcffffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_GET(value) (((value)&0x03000000) >> 24)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN_SET(value) (((value) << 24) & 0x03000000)

/*
 * Field : Reserved_RXQ13EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_LSB	       26
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_MSB	       27
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_SET_MSK    0x0c000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_CLR_MSK    0xf3ffffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_GET(value) (((value)&0x0c000000) >> 26)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN_SET(value) (((value) << 26) & 0x0c000000)

/*
 * Field : Reserved_RXQ14EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_LSB	       28
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_MSB	       29
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_SET_MSK    0x30000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_CLR_MSK    0xcfffffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_GET(value) (((value)&0x30000000) >> 28)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN_SET(value) (((value) << 28) & 0x30000000)

/*
 * Field : Reserved_RXQ15EN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register
 * field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_MSB	       31
/* The width in bits of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_WIDTH      2
/* The mask used to set the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_SET_MSK    0xc0000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register field value. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_CLR_MSK    0x3fffffff
/* The reset value of the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register field. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN field value from a register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RXQ_CTRL0.
 */
struct CORE_MAC_RXQ_CTRL0_s {
	volatile uint32_t RXQ0EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ0EN */
	volatile uint32_t RXQ1EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ1EN */
	volatile uint32_t RXQ2EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ2EN */
	volatile uint32_t RXQ3EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ3EN */
	volatile uint32_t RXQ4EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ4EN */
	volatile uint32_t RXQ5EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ5EN */
	volatile uint32_t RXQ6EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ6EN */
	volatile uint32_t RXQ7EN : 2;		      /* CORE_MAC_RXQ_CTRL0_RXQ7EN */
	const volatile uint32_t Reserved_RXQ8EN : 2;  /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ8EN */
	const volatile uint32_t Reserved_RXQ9EN : 2;  /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ9EN */
	const volatile uint32_t Reserved_RXQ10EN : 2; /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ10EN */
	const volatile uint32_t Reserved_RXQ11EN : 2; /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ11EN */
	const volatile uint32_t Reserved_RXQ12EN : 2; /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ12EN */
	const volatile uint32_t Reserved_RXQ13EN : 2; /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ13EN */
	const volatile uint32_t Reserved_RXQ14EN : 2; /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ14EN */
	const volatile uint32_t Reserved_RXQ15EN : 2; /* CORE_MAC_RXQ_CTRL0_RESERVED_RXQ15EN */
};

/* The typedef declaration for register CORE_MAC_RXQ_CTRL0. */
typedef struct CORE_MAC_RXQ_CTRL0_s CORE_MAC_RXQ_CTRL0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RXQ_CTRL0 register. */
#define CORE_MAC_RXQ_CTRL0_RESET 0x00000000
/* The byte offset of the CORE_MAC_RXQ_CTRL0 register from the beginning of the component. */
#define CORE_MAC_RXQ_CTRL0_OFST	 0xa0

/*
 * Register : MAC_RxQ_Ctrl1
 *
 * This register allows the selection of the Receive queues to which the received
 * untagged or special packets are routed or written. This register is present only
 * when you select multiple queues in the Receive path.
 *
 * Note:
 *
 * * Program the queue number in the fields within the range of Rx Queues that you
 *   have selected in your controller.
 *
 * * PFC-based flow control is limited only to Rx Queues 0 to 7.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------
 *  [3:0]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_UPQ
 *  [7:4]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_RQ
 *  [11:8]  | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_MCBCQ
 *  [14:12] | R      | 0x0   | CORE_MAC_RXQ_CTRL1_RESERVED_14_12
 *  [15]    | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_MCBCQEN
 *  [19:16] | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_DCBCPQ
 *  [20]    | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_OMCBCQ
 *  [22:21] | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_TPQC
 *  [23]    | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_TACPQE
 *  [27:24] | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_PTPQ
 *  [31:28] | RW     | 0x0   | CORE_MAC_RXQ_CTRL1_AVCPQ
 *
 */
/*
 * Field : UPQ
 *
 * Untagged Packet Queue.
 *
 * This field specifies the Rx queue on which the received untagged packets are
 * routed.
 *
 * * 4'b0000: Rx Queue 0
 *
 * * 4'b0001: Rx Queue 1
 *
 * * ...
 *
 * * 4'b1011: Rx Queue 11
 *
 * * 4'b1100 - 4'b1111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_UPQ register field. */
#define CORE_MAC_RXQ_CTRL1_UPQ_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_UPQ register field. */
#define CORE_MAC_RXQ_CTRL1_UPQ_MSB	  3
/* The width in bits of the CORE_MAC_RXQ_CTRL1_UPQ register field. */
#define CORE_MAC_RXQ_CTRL1_UPQ_WIDTH	  4
/* The mask used to set the CORE_MAC_RXQ_CTRL1_UPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_UPQ_SET_MSK	  0x0000000f
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_UPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_UPQ_CLR_MSK	  0xfffffff0
/* The reset value of the CORE_MAC_RXQ_CTRL1_UPQ register field. */
#define CORE_MAC_RXQ_CTRL1_UPQ_RESET	  0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_UPQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_UPQ_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a CORE_MAC_RXQ_CTRL1_UPQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_UPQ_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : RQ
 *
 * Frame Preemption Residue Queue
 *
 * This field holds the Rx queue number to which the residual preemption frames
 * must be forwarded. Preemption frames that are tagged and pass the SA/DA/VLAN
 * filtering are routed based on PSRQ. All other frames are treated as residual
 * frames and are routed to the queue number mentioned in this field.
 *
 * Queue-0 is used as a default queue for express frames, so this field cannot be
 * programmed to a value 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_RQ register field. */
#define CORE_MAC_RXQ_CTRL1_RQ_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_RQ register field. */
#define CORE_MAC_RXQ_CTRL1_RQ_MSB	 7
/* The width in bits of the CORE_MAC_RXQ_CTRL1_RQ register field. */
#define CORE_MAC_RXQ_CTRL1_RQ_WIDTH	 4
/* The mask used to set the CORE_MAC_RXQ_CTRL1_RQ register field value. */
#define CORE_MAC_RXQ_CTRL1_RQ_SET_MSK	 0x000000f0
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_RQ register field value. */
#define CORE_MAC_RXQ_CTRL1_RQ_CLR_MSK	 0xffffff0f
/* The reset value of the CORE_MAC_RXQ_CTRL1_RQ register field. */
#define CORE_MAC_RXQ_CTRL1_RQ_RESET	 0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_RQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_RQ_GET(value) (((value)&0x000000f0) >> 4)
/* Produces a CORE_MAC_RXQ_CTRL1_RQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_RQ_SET(value) (((value) << 4) & 0x000000f0)

/*
 * Field : MCBCQ
 *
 * Multicast or Broadcast Queue.
 *
 * This field specifies the Rx queue on which the Multicast or Broadcast packets
 * are routed.
 *
 * * 4'b0000: Rx Queue 0
 *
 * * 4'b0001: Rx Queue 1
 *
 * * ...
 *
 * * 4'b1011: Rx Queue 11
 *
 * * 4'b1100 - 4'b1111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_MCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_MCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_MSB	    11
/* The width in bits of the CORE_MAC_RXQ_CTRL1_MCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_WIDTH	    4
/* The mask used to set the CORE_MAC_RXQ_CTRL1_MCBCQ register field value. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_SET_MSK    0x00000f00
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_MCBCQ register field value. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_CLR_MSK    0xfffff0ff
/* The reset value of the CORE_MAC_RXQ_CTRL1_MCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_MCBCQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a CORE_MAC_RXQ_CTRL1_MCBCQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_MCBCQ_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : Reserved_14_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field.
 */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_LSB	     12
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field.
 */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_MSB	     14
/* The width in bits of the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field. */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_WIDTH	     3
/* The mask used to set the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field value. */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_SET_MSK    0x00007000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field value. */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_CLR_MSK    0xffff8fff
/* The reset value of the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field. */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_RESERVED_14_12 field value from a register. */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_GET(value) (((value)&0x00007000) >> 12)
/* Produces a CORE_MAC_RXQ_CTRL1_RESERVED_14_12 register field value suitable for setting the
 * register. */
#define CORE_MAC_RXQ_CTRL1_RESERVED_14_12_SET(value) (((value) << 12) & 0x00007000)

/*
 * Field : MCBCQEN
 *
 * Multicast or Broadcast Queue Enable.
 *
 * This bit specifies that Multicast or Broadcast packets routing to the Rx Queue
 * is enabled and the Multicast or Broadcast packets must be routed to Rx Queue
 * specified in MCBCQ field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_MCBCQEN register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_LSB	      15
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_MCBCQEN register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_MSB	      15
/* The width in bits of the CORE_MAC_RXQ_CTRL1_MCBCQEN register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_WIDTH      1
/* The mask used to set the CORE_MAC_RXQ_CTRL1_MCBCQEN register field value. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_SET_MSK    0x00008000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_MCBCQEN register field value. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MAC_RXQ_CTRL1_MCBCQEN register field. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_RESET      0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_MCBCQEN field value from a register. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_RXQ_CTRL1_MCBCQEN register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_MCBCQEN_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : DCBCPQ
 *
 * DCB Control Packets Queue.
 *
 * This field specifies the Rx queue on which the received DCB control packets are
 * routed.
 *
 * * 4'b0000: Rx Queue 0
 *
 * * 4'b0001: Rx Queue 1
 *
 * * ...
 *
 * * 4'b1011: Rx Queue 11
 *
 * * 4'b1100 - 4'b1111: Reserved
 *
 * The DCB data packets are routed based on the setting of the PSRQ field
 * corresponding to its USP (User Priority) field in the MAC_RxQ_Ctrl2/3 registers.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_DCBCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_LSB	     16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_DCBCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_MSB	     19
/* The width in bits of the CORE_MAC_RXQ_CTRL1_DCBCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_WIDTH	     4
/* The mask used to set the CORE_MAC_RXQ_CTRL1_DCBCPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_SET_MSK    0x000f0000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_DCBCPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_CLR_MSK    0xfff0ffff
/* The reset value of the CORE_MAC_RXQ_CTRL1_DCBCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_DCBCPQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a CORE_MAC_RXQ_CTRL1_DCBCPQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_DCBCPQ_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : OMCBCQ
 *
 * Programmable control for Over-riding MCBCQ Priority.
 *
 * When set to 1, this field enables over-riding the MCBC Queue priority. When set
 * to 0, this field disables over-riding the MCBC Queue priority.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_OMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_LSB	     20
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_OMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_MSB	     20
/* The width in bits of the CORE_MAC_RXQ_CTRL1_OMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_WIDTH	     1
/* The mask used to set the CORE_MAC_RXQ_CTRL1_OMCBCQ register field value. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_SET_MSK    0x00100000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_OMCBCQ register field value. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_CLR_MSK    0xffefffff
/* The reset value of the CORE_MAC_RXQ_CTRL1_OMCBCQ register field. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_OMCBCQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_RXQ_CTRL1_OMCBCQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_OMCBCQ_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : TPQC
 *
 * Tagged PTP over Ethernet Packets Queuing Control.
 *
 * This field controls the routing of the VLAN Tagged PTP over Ethernet packets.
 *
 * If Audio Video Bridging Feature is selected in the configuration, the following
 * programmable options are allowed.
 *
 * * 2'b00: VLAN Tagged PTP over Ethernet packets are routed as generic VLAN Tagged
 *   packet (based on PSRQ for only non-AV enabled Rx Queues).
 *
 * * 2'b01: VLAN Tagged PTP over Ethernet packets are routed to Rx Queue specified
 *   by PTPQ field (That Rx Queue can be enabled for AV or non-AV traffic).
 *
 * * 2'b10: VLAN Tagged PTP over Ethernet packets are routed to only AV enabled Rx
 *   Queues based on PSRQ.
 *
 * * 2'b11: Reserved
 *
 * If Audio Video Bridging Feature is not selected in the configuration, the
 * following programmable options are allowed.
 *
 * * 1'b0: VLAN Tagged PTP over Ethernet packets are routed as generic VLAN Tagged
 *   packet (based on PSRQ for Data Center Bridging/Generic enabled Rx Queues).
 *
 * * 1'b1: VLAN Tagged PTP over Ethernet packets are routed to Rx Queues specified
 *   by PTPQ field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_TPQC register field. */
#define CORE_MAC_RXQ_CTRL1_TPQC_LSB	   21
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_TPQC register field. */
#define CORE_MAC_RXQ_CTRL1_TPQC_MSB	   22
/* The width in bits of the CORE_MAC_RXQ_CTRL1_TPQC register field. */
#define CORE_MAC_RXQ_CTRL1_TPQC_WIDTH	   2
/* The mask used to set the CORE_MAC_RXQ_CTRL1_TPQC register field value. */
#define CORE_MAC_RXQ_CTRL1_TPQC_SET_MSK	   0x00600000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_TPQC register field value. */
#define CORE_MAC_RXQ_CTRL1_TPQC_CLR_MSK	   0xff9fffff
/* The reset value of the CORE_MAC_RXQ_CTRL1_TPQC register field. */
#define CORE_MAC_RXQ_CTRL1_TPQC_RESET	   0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_TPQC field value from a register. */
#define CORE_MAC_RXQ_CTRL1_TPQC_GET(value) (((value)&0x00600000) >> 21)
/* Produces a CORE_MAC_RXQ_CTRL1_TPQC register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_TPQC_SET(value) (((value) << 21) & 0x00600000)

/*
 * Field : TACPQE
 *
 * Tagged AV Control Packets Queuing Enable.
 *
 * When set, the MAC routes the received Tagged AV Control packets to the Rx queue
 * specified by AVCPQ field. If Tagged AV Control packets received are expected to
 * be preempted then do not set the TACPQE bit to enable a separate queue.
 *
 * When reset, the MAC routes the received Tagged AV Control packets based on the
 * tag priority matching the PSRQ fields in MAC_RxQ_Ctrl2 and MAC_RxQ_Ctrl3
 * registers.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_TACPQE register field. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_LSB	     23
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_TACPQE register field. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_MSB	     23
/* The width in bits of the CORE_MAC_RXQ_CTRL1_TACPQE register field. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_WIDTH	     1
/* The mask used to set the CORE_MAC_RXQ_CTRL1_TACPQE register field value. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_SET_MSK    0x00800000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_TACPQE register field value. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MAC_RXQ_CTRL1_TACPQE register field. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_RESET	     0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_TACPQE field value from a register. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_RXQ_CTRL1_TACPQE register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_TACPQE_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : PTPQ
 *
 * PTP Packets Queue.
 *
 * This field specifies the Rx queue on which the untagged PTP packets sent over
 * the Ethernet payload (not over IPv4 or IPv6) are routed.
 *
 * * 4'b0000: Rx Queue 0
 *
 * * 4'b0001: Rx Queue 1
 *
 * * ...
 *
 * * 4'b1011: Rx Queue 11
 *
 * * 4'b1100 - 4'b1111: Reserved
 *
 * When the AV8021ASMEN bit of MAC_Timestamp_Control register is reset, even though
 * VLAN tagged PTP over Ethernet packets are processed, it is routed based on VLAN
 * Tag priority.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_PTPQ register field. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_LSB	   24
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_PTPQ register field. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_MSB	   27
/* The width in bits of the CORE_MAC_RXQ_CTRL1_PTPQ register field. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_WIDTH	   4
/* The mask used to set the CORE_MAC_RXQ_CTRL1_PTPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_SET_MSK	   0x0f000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_PTPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_CLR_MSK	   0xf0ffffff
/* The reset value of the CORE_MAC_RXQ_CTRL1_PTPQ register field. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_RESET	   0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_PTPQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_GET(value) (((value)&0x0f000000) >> 24)
/* Produces a CORE_MAC_RXQ_CTRL1_PTPQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_PTPQ_SET(value) (((value) << 24) & 0x0f000000)

/*
 * Field : AVCPQ
 *
 * AV Control Packets Queue.
 *
 * This field specifies the Rx queue on which the received AV Control packets
 * (tagged and untagged) are routed.
 *
 * * 4'b0000: Rx Queue 0
 *
 * * 4'b0001: Rx Queue 1
 *
 * * ...
 *
 * * 4'b1011: Rx Queue 11
 *
 * * 4'b1100 - 4'b1111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL1_AVCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_LSB	    28
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL1_AVCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_MSB	    31
/* The width in bits of the CORE_MAC_RXQ_CTRL1_AVCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_WIDTH	    4
/* The mask used to set the CORE_MAC_RXQ_CTRL1_AVCPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_SET_MSK    0xf0000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL1_AVCPQ register field value. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_CLR_MSK    0x0fffffff
/* The reset value of the CORE_MAC_RXQ_CTRL1_AVCPQ register field. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL1_AVCPQ field value from a register. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_GET(value) (((value)&0xf0000000) >> 28)
/* Produces a CORE_MAC_RXQ_CTRL1_AVCPQ register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL1_AVCPQ_SET(value) (((value) << 28) & 0xf0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RXQ_CTRL1.
 */
struct CORE_MAC_RXQ_CTRL1_s {
	volatile uint32_t UPQ : 4;		    /* CORE_MAC_RXQ_CTRL1_UPQ */
	volatile uint32_t RQ : 4;		    /* CORE_MAC_RXQ_CTRL1_RQ */
	volatile uint32_t MCBCQ : 4;		    /* CORE_MAC_RXQ_CTRL1_MCBCQ */
	const volatile uint32_t Reserved_14_12 : 3; /* CORE_MAC_RXQ_CTRL1_RESERVED_14_12 */
	volatile uint32_t MCBCQEN : 1;		    /* CORE_MAC_RXQ_CTRL1_MCBCQEN */
	volatile uint32_t DCBCPQ : 4;		    /* CORE_MAC_RXQ_CTRL1_DCBCPQ */
	volatile uint32_t OMCBCQ : 1;		    /* CORE_MAC_RXQ_CTRL1_OMCBCQ */
	volatile uint32_t TPQC : 2;		    /* CORE_MAC_RXQ_CTRL1_TPQC */
	volatile uint32_t TACPQE : 1;		    /* CORE_MAC_RXQ_CTRL1_TACPQE */
	volatile uint32_t PTPQ : 4;		    /* CORE_MAC_RXQ_CTRL1_PTPQ */
	volatile uint32_t AVCPQ : 4;		    /* CORE_MAC_RXQ_CTRL1_AVCPQ */
};

/* The typedef declaration for register CORE_MAC_RXQ_CTRL1. */
typedef struct CORE_MAC_RXQ_CTRL1_s CORE_MAC_RXQ_CTRL1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RXQ_CTRL1 register. */
#define CORE_MAC_RXQ_CTRL1_RESET 0x00000000
/* The byte offset of the CORE_MAC_RXQ_CTRL1 register from the beginning of the component. */
#define CORE_MAC_RXQ_CTRL1_OFST	 0xa4

/*
 * Register : MAC_RxQ_Ctrl2
 *
 * This register controls the routing of tagged packets based on the USP (user
 * Priority) field of the received packets to the Rx Queues 0 to 3. This register
 * is present when multiple Rx Queues are selected while configuring the
 * controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------
 *  [7:0]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL2_PSRQ0
 *  [15:8]  | RW     | 0x0   | CORE_MAC_RXQ_CTRL2_PSRQ1
 *  [23:16] | RW     | 0x0   | CORE_MAC_RXQ_CTRL2_PSRQ2
 *  [31:24] | RW     | 0x0   | CORE_MAC_RXQ_CTRL2_PSRQ3
 *
 */
/*
 * Field : PSRQ0
 *
 * Priorities Selected in the Receive Queue 0.
 *
 * This field decides the priorities assigned to Rx Queue 0. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 0. For
 * example, if PSRQ0[5] is set, packets with USP field equal to 5 are routed to Rx
 * Queue 0. The software must ensure that the content of this field is mutually
 * exclusive to the PSRQ fields for other queues, that is, the same priority is not
 * mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 0 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ0 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ0 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_MSB	    7
/* The width in bits of the CORE_MAC_RXQ_CTRL2_PSRQ0 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL2_PSRQ0 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_SET_MSK    0x000000ff
/* The mask used to clear the CORE_MAC_RXQ_CTRL2_PSRQ0 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_CLR_MSK    0xffffff00
/* The reset value of the CORE_MAC_RXQ_CTRL2_PSRQ0 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL2_PSRQ0 field value from a register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_RXQ_CTRL2_PSRQ0 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ0_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : PSRQ1
 *
 * Priorities Selected in the Receive Queue 1.
 *
 * This field decides the priorities assigned to Rx Queue 1. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 1.
 *
 * For example, if PSRQ1[4] is set, packets with USP field equal to 4 are routed to
 * Rx Queue 1. The software must ensure that the content of this field is mutually
 * exclusive to the PSRQ fields for other queues, that is, the same priority is not
 * mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 1 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ1 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ1 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_MSB	    15
/* The width in bits of the CORE_MAC_RXQ_CTRL2_PSRQ1 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL2_PSRQ1 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_SET_MSK    0x0000ff00
/* The mask used to clear the CORE_MAC_RXQ_CTRL2_PSRQ1 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_CLR_MSK    0xffff00ff
/* The reset value of the CORE_MAC_RXQ_CTRL2_PSRQ1 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL2_PSRQ1 field value from a register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_RXQ_CTRL2_PSRQ1 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ1_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PSRQ2
 *
 * Priorities Selected in the Receive Queue 2.
 *
 * This field decides the priorities assigned to Rx Queue 2. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 2.
 *
 * For example, if PSRQ2[1, 0] are set, packets with USP field equal to 1 or 0 are
 * routed to Rx Queue 2. The software must ensure that the content of this field is
 * mutually exclusive to the PSRQ fields for other queues, that is, the same
 * priority is not mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 2 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ2 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ2 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_MSB	    23
/* The width in bits of the CORE_MAC_RXQ_CTRL2_PSRQ2 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL2_PSRQ2 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_SET_MSK    0x00ff0000
/* The mask used to clear the CORE_MAC_RXQ_CTRL2_PSRQ2 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_CLR_MSK    0xff00ffff
/* The reset value of the CORE_MAC_RXQ_CTRL2_PSRQ2 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL2_PSRQ2 field value from a register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a CORE_MAC_RXQ_CTRL2_PSRQ2 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ2_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : PSRQ3
 *
 * Priorities Selected in the Receive Queue 3.
 *
 * This field decides the priorities assigned to Rx Queue 3. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 3.
 *
 * For example, if PSRQ3[6, 3] are set, packets with USP field equal to 3 or 6 are
 * routed to Rx Queue 3. The software must ensure that the content of this field is
 * mutually exclusive to the PSRQ fields for other queues, that is, the same
 * priority is not mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 3 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ3 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_LSB	    24
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL2_PSRQ3 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_MSB	    31
/* The width in bits of the CORE_MAC_RXQ_CTRL2_PSRQ3 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL2_PSRQ3 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_SET_MSK    0xff000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL2_PSRQ3 register field value. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_CLR_MSK    0x00ffffff
/* The reset value of the CORE_MAC_RXQ_CTRL2_PSRQ3 register field. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL2_PSRQ3 field value from a register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_GET(value) (((value)&0xff000000) >> 24)
/* Produces a CORE_MAC_RXQ_CTRL2_PSRQ3 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL2_PSRQ3_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RXQ_CTRL2.
 */
struct CORE_MAC_RXQ_CTRL2_s {
	volatile uint32_t PSRQ0 : 8; /* CORE_MAC_RXQ_CTRL2_PSRQ0 */
	volatile uint32_t PSRQ1 : 8; /* CORE_MAC_RXQ_CTRL2_PSRQ1 */
	volatile uint32_t PSRQ2 : 8; /* CORE_MAC_RXQ_CTRL2_PSRQ2 */
	volatile uint32_t PSRQ3 : 8; /* CORE_MAC_RXQ_CTRL2_PSRQ3 */
};

/* The typedef declaration for register CORE_MAC_RXQ_CTRL2. */
typedef struct CORE_MAC_RXQ_CTRL2_s CORE_MAC_RXQ_CTRL2_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RXQ_CTRL2 register. */
#define CORE_MAC_RXQ_CTRL2_RESET 0x00000000
/* The byte offset of the CORE_MAC_RXQ_CTRL2 register from the beginning of the component. */
#define CORE_MAC_RXQ_CTRL2_OFST	 0xa8

/*
 * Register : MAC_RxQ_Ctrl3
 *
 * This register controls the routing of tagged packets based on the USP (user
 * Priority) field of the received packets to the Rx Queues 4 to 7. This register
 * is present when the "Enable Data Center Bridging" option is selected and with
 * more than four Rx queues, while configuring the controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------
 *  [7:0]   | RW     | 0x0   | CORE_MAC_RXQ_CTRL3_PSRQ4
 *  [15:8]  | RW     | 0x0   | CORE_MAC_RXQ_CTRL3_PSRQ5
 *  [23:16] | RW     | 0x0   | CORE_MAC_RXQ_CTRL3_PSRQ6
 *  [31:24] | RW     | 0x0   | CORE_MAC_RXQ_CTRL3_PSRQ7
 *
 */
/*
 * Field : PSRQ4
 *
 * Priorities Selected in the Receive Queue 4.
 *
 * This field decides the priorities assigned to Rx Queue 4. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 4.
 *
 * For example, if PSRQ4[7:4] is set, packets with USP field equal to 7, 6, 5, or 4
 * are routed to Rx Queue 4. The software must ensure that the content of this
 * field is mutually exclusive to the PSRQ fields for other queues, that is, the
 * same priority is not mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 4 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ4 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ4 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_MSB	    7
/* The width in bits of the CORE_MAC_RXQ_CTRL3_PSRQ4 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL3_PSRQ4 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_SET_MSK    0x000000ff
/* The mask used to clear the CORE_MAC_RXQ_CTRL3_PSRQ4 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_CLR_MSK    0xffffff00
/* The reset value of the CORE_MAC_RXQ_CTRL3_PSRQ4 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL3_PSRQ4 field value from a register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_RXQ_CTRL3_PSRQ4 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ4_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : PSRQ5
 *
 * Priorities Selected in the Receive Queue 5.
 *
 * This field decides the priorities assigned to Rx Queue 5. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 5.
 *
 * For example, if PSRQ5[6] is set, packets with USP field equal to 6 are routed to
 * Rx Queue 5. The software must ensure that the content of this field is mutually
 * exclusive to the PSRQ fields for other queues, that is, the same priority is not
 * mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 5 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ5 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ5 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_MSB	    15
/* The width in bits of the CORE_MAC_RXQ_CTRL3_PSRQ5 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL3_PSRQ5 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_SET_MSK    0x0000ff00
/* The mask used to clear the CORE_MAC_RXQ_CTRL3_PSRQ5 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_CLR_MSK    0xffff00ff
/* The reset value of the CORE_MAC_RXQ_CTRL3_PSRQ5 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL3_PSRQ5 field value from a register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_RXQ_CTRL3_PSRQ5 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ5_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PSRQ6
 *
 * Priorities Selected in the Receive Queue 6.
 *
 * This field decides the priorities assigned to Rx Queue 6. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 6.
 *
 * For example, if PSRQ6[5] are set, packets with USP field equal to 5 are routed
 * to Rx Queue 6. The software must ensure that the content of this field is
 * mutually exclusive to the PSRQ fields for other queues, that is, the same
 * priority is not mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 6 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ6 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ6 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_MSB	    23
/* The width in bits of the CORE_MAC_RXQ_CTRL3_PSRQ6 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL3_PSRQ6 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_SET_MSK    0x00ff0000
/* The mask used to clear the CORE_MAC_RXQ_CTRL3_PSRQ6 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_CLR_MSK    0xff00ffff
/* The reset value of the CORE_MAC_RXQ_CTRL3_PSRQ6 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL3_PSRQ6 field value from a register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a CORE_MAC_RXQ_CTRL3_PSRQ6 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ6_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : PSRQ7
 *
 * Priorities Selected in the Receive Queue 7.
 *
 * This field decides the priorities assigned to Rx Queue 7. All packets with
 * priorities that match the values set in this field are routed to Rx Queue 7.
 *
 * For example, if PSRQ7[7, 4] are set, packets with USP field equal to 7 or 4 are
 * routed to Rx Queue 7. The software must ensure that the content of this field is
 * mutually exclusive to the PSRQ fields for other queues, that is, the same
 * priority is not mapped to multiple Rx queues.
 *
 * When the Data Center Bridging feature is selected, this field also determines
 * the priorities to be included in the PFC packet sent to remote station when Rx
 * Queue 7 crosses the flow control threshold settings.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ7 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_LSB	    24
/* The Most Significant Bit (MSB) position of the CORE_MAC_RXQ_CTRL3_PSRQ7 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_MSB	    31
/* The width in bits of the CORE_MAC_RXQ_CTRL3_PSRQ7 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_WIDTH	    8
/* The mask used to set the CORE_MAC_RXQ_CTRL3_PSRQ7 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_SET_MSK    0xff000000
/* The mask used to clear the CORE_MAC_RXQ_CTRL3_PSRQ7 register field value. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_CLR_MSK    0x00ffffff
/* The reset value of the CORE_MAC_RXQ_CTRL3_PSRQ7 register field. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_RESET	    0x0
/* Extracts the CORE_MAC_RXQ_CTRL3_PSRQ7 field value from a register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_GET(value) (((value)&0xff000000) >> 24)
/* Produces a CORE_MAC_RXQ_CTRL3_PSRQ7 register field value suitable for setting the register. */
#define CORE_MAC_RXQ_CTRL3_PSRQ7_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RXQ_CTRL3.
 */
struct CORE_MAC_RXQ_CTRL3_s {
	volatile uint32_t PSRQ4 : 8; /* CORE_MAC_RXQ_CTRL3_PSRQ4 */
	volatile uint32_t PSRQ5 : 8; /* CORE_MAC_RXQ_CTRL3_PSRQ5 */
	volatile uint32_t PSRQ6 : 8; /* CORE_MAC_RXQ_CTRL3_PSRQ6 */
	volatile uint32_t PSRQ7 : 8; /* CORE_MAC_RXQ_CTRL3_PSRQ7 */
};

/* The typedef declaration for register CORE_MAC_RXQ_CTRL3. */
typedef struct CORE_MAC_RXQ_CTRL3_s CORE_MAC_RXQ_CTRL3_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RXQ_CTRL3 register. */
#define CORE_MAC_RXQ_CTRL3_RESET 0x00000000
/* The byte offset of the CORE_MAC_RXQ_CTRL3 register from the beginning of the component. */
#define CORE_MAC_RXQ_CTRL3_OFST	 0xac

/*
 * Register : MAC_Interrupt_Status
 *
 * The Interrupt Status register contains the status of interrupts.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_LSI
 *  [1]     | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_SMI
 *  [3:2]   | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2
 *  [4]     | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS
 *  [5]     | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_LPIIS
 *  [8:6]   | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6
 *  [9]     | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_MMCRXIS
 *  [10]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_MMCTXIS
 *  [11]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS
 *  [12]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_TSIS
 *  [13]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_TXESIS
 *  [14]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RXESIS
 *  [15]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_GPIIS
 *  [16]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_FPEIS
 *  [17]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_MFTIS
 *  [18]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_MFRIS
 *  [22:19] | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19
 *  [23]    | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS
 *  [25:24] | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_LS
 *  [31:26] | R      | 0x0   | CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26
 *
 */
/*
 * Field : LSI
 *
 * Link Status change Interrupt.
 *
 * This bit is set when the LS (Link Status) bits change their value. It is cleared
 * when this register is read.
 *
 * This interrupt is generated in RGMII mode when the link status change is
 * detected in the RGMII Rx Interface.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_LSI register field. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_LSI register field. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_MSB	 0
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_LSI register field. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_WIDTH	 1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_LSI register field value. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_SET_MSK	 0x00000001
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_LSI register field value. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_CLR_MSK	 0xfffffffe
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_LSI register field. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_RESET	 0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_LSI field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_LSI_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_INTERRUPT_STATUS_LSI register field value suitable for setting the register.
 */
#define CORE_MAC_INTERRUPT_STATUS_LSI_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : SMI
 *
 * SMA Interrupt.
 *
 * This bit is set when any of the bits in the MDIO Interrupt Status register is
 * set. This bit is the logical OR of all the bits in that register and is cleared
 * only when all the bits in the MDIO Interrupt register are cleared
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_SMI register field. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_SMI register field. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_MSB	 1
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_SMI register field. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_WIDTH	 1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_SMI register field value. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_SMI register field value. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_SMI register field. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_RESET	 0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_SMI field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_SMI_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_INTERRUPT_STATUS_SMI register field value suitable for setting the register.
 */
#define CORE_MAC_INTERRUPT_STATUS_SMI_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_LSB	  2
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_MSB	  3
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_WIDTH	  2
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_SET_MSK	  0x0000000c
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_CLR_MSK	  0xfffffff3
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_RESET	  0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : Reserved_PMTIS
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_LSB	    4
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_MSB	    4
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_WIDTH	    1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : LPIIS
 *
 * LPI Interrupt Status.
 *
 * When the Energy Efficient Ethernet feature is enabled, this bit is set for any
 * LPI state entry or exit in the MAC Transmitter or Receiver. In all other modes,
 * this bit is reserved.
 *
 * Note: On the transmit side the Exit Interrupt is generate only when the
 *
 * XGMII/GMII interface comes out of the LPI and TW timer expires.
 *
 * Access restriction applies.This bit is cleared when the corresponding interrupt
 * source bit of MAC_LPI_Control_Status register is read (or corresponding
 * interrupt source bit of MAC_LPI_Control_Status register is written to 1 when
 * RCWE bit of MAC_CSR_SW_Ctrl register is set).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_LPIIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_LSB	   5
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_LPIIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_MSB	   5
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_LPIIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_LPIIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_SET_MSK	   0x00000020
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_LPIIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_CLR_MSK	   0xffffffdf
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_LPIIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_LPIIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_INTERRUPT_STATUS_LPIIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_LPIIS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_8_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_LSB	  6
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_MSB	  8
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_WIDTH	  3
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_SET_MSK	  0x000001c0
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_CLR_MSK	  0xfffffe3f
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_RESET	  0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_GET(value) (((value)&0x000001c0) >> 6)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6_SET(value) (((value) << 6) & 0x000001c0)

/*
 * Field : MMCRXIS
 *
 * MMC Receive Interrupt Status.
 *
 * This bit is set high when an interrupt is generated in the MMC Receive Interrupt
 * register. This bit is cleared when all bits in this interrupt register are
 * cleared.
 *
 * This bit is valid only when you select the Enable DWC_xgmac Management Counter
 * (MMC) option.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_LSB	     9
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_MSB	     9
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_WIDTH	     1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_SET_MSK    0x00000200
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_RESET	     0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_MMCRXIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_INTERRUPT_STATUS_MMCRXIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIS_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : MMCTXIS
 *
 * MMC Transmit Interrupt Status.
 *
 * This bit is set high when an interrupt is generated in the MMC Transmit
 * Interrupt register. This bit is cleared when all bits in this interrupt register
 * are cleared.
 *
 * This bit is valid only when you select the Enable DWC_xgmac Management Counter
 * (MMC) option.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_LSB	     10
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_MSB	     10
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_WIDTH	     1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_SET_MSK    0x00000400
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_RESET	     0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_MMCTXIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MAC_INTERRUPT_STATUS_MMCTXIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_MMCTXIS_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : MMCRXIPIS
 *
 * MMC Receive Checksum Offload Interrupt Status
 *
 * This bit is set high when an interrupt is generated in the MMC Receive Checksum
 * Offload Interrupt Register. This bit is cleared when all bits in this interrupt
 * register are cleared.
 *
 * This bit is valid only when you select the Enable MAC Management Counters (MMC)
 * and Enable Receive TCP/IP Checksum Check options.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_E_INACTIVE | 0x0   | MMC Receive Checksum Offload Interrupt
 * status :                                                                 |       | not active
 *  CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_E_ACTIVE   | 0x1   | MMC Receive Checksum Offload Interrupt
 * status :                                                                 |       | active
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS
 *
 * MMC Receive Checksum Offload Interrupt status not active
 */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS
 *
 * MMC Receive Checksum Offload Interrupt status active
 */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_LSB	       11
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_MSB	       11
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_WIDTH      1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_SET_MSK    0x00000800
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_RESET      0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : TSIS
 *
 * Timestamp Interrupt Status.
 *
 * If the Timestamp feature is enabled, this bit is set when any of the following
 * conditions is true:
 *
 * * The system time value is equal to or exceeds the value specified in the Target
 *   Time High and Low registers.
 *
 * * There is an overflow in the Seconds register.
 *
 * * The Target Time Error occurred, that is, programmed target time already
 *   elapsed.
 *
 * * When a timestamp of a transmitted PTP packet is available in the
 *   MAC_TxTimestamp_Status_Seconds register.
 *
 * If the Auxiliary Snapshot feature is enabled, this bit is set when the auxiliary
 * snapshot trigger is asserted.
 *
 * Access restriction applies.This bit is cleared when the corresponding interrupt
 * source bit is read (or corresponding interrupt source bit is written to 1 when
 * RCWE bit of MAC_CSR_SW_Ctrl register is set) in the MAC_Timestamp_Status
 * register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_TSIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_LSB	  12
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_TSIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_MSB	  12
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_TSIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_WIDTH	  1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_TSIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_SET_MSK	  0x00001000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_TSIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_CLR_MSK	  0xffffefff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_TSIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_RESET	  0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_TSIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_INTERRUPT_STATUS_TSIS register field value suitable for setting the register.
 */
#define CORE_MAC_INTERRUPT_STATUS_TSIS_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : TXESIS
 *
 * Transmit Error Status Interrupt.
 *
 * * This bit indicates the error status of transmitted packets. This bit is set
 *   when any of the following bits is set in the MAC_Rx_Tx_Status during
 *   transmission.
 *
 * * Excessive Collision (EXCOL)
 *
 * * Late Collision (LCOL)
 *
 * * Excessive Deferral (EXDEF)
 *
 * * Loss of Carrier (LCARR)
 *
 * * No Carrier (NCARR)
 *
 * * Jabber Timeout (TJT)
 *
 * Access restriction applies.This bit is cleared when the corresponding interrupt
 * source bit is read (or corresponding interrupt source bit is written to 1 when
 * RCWE bit of MAC_CSR_SW_Ctrl register is set) in the MAC_Rx_Tx_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_TXESIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_LSB	    13
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_TXESIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_MSB	    13
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_TXESIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_WIDTH	    1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_TXESIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_SET_MSK    0x00002000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_TXESIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_TXESIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_TXESIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_INTERRUPT_STATUS_TXESIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_TXESIS_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : RXESIS
 *
 * Receive Error Status Interrupt.
 *
 * This bit indicates the error status of received packets. This bit is set when
 * the Watchdog Timeout (WDT) event occurs during reception.
 *
 * Access restriction applies.This bit is cleared when the corresponding interrupt
 * source bit is read (or corresponding interrupt source bit is written to 1 when
 * RCWE bit of MAC_CSR_SW_Ctrl register is set) in the MAC_Rx_Tx_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RXESIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_LSB	    14
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RXESIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_MSB	    14
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RXESIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_WIDTH	    1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RXESIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_SET_MSK    0x00004000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RXESIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_CLR_MSK    0xffffbfff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RXESIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RXESIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RXESIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RXESIS_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : GPIIS
 *
 * GPI Interrupt Status.
 *
 * When the GPIO feature is enabled, this bit is set when an active event (LL or
 * LH) occurs on the GPIS field of the MAC_GPIO_Status register and the
 * corresponding GPIE bit is enabled in the MAC_GPIO_Control register. This bit is
 * cleared on reading lane 0 (GPIS) of the MAC_GPIO_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_GPIIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_LSB	   15
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_GPIIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_MSB	   15
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_GPIIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_GPIIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_SET_MSK	   0x00008000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_GPIIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_CLR_MSK	   0xffff7fff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_GPIIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_GPIIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_INTERRUPT_STATUS_GPIIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_GPIIS_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : FPEIS
 *
 * Frame Preemption Interrupt Status
 *
 * This bit indicates an interrupt event during the operation of Frame Preemption
 * (Bits[19:16] of MAC_FPE_CTRL_STS register is set). To reset this bit, the
 * application must clear the event in MAC_FPE_CTRL_STS that has caused the
 * interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                         | Value | Description
 * :-------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MAC_INTERRUPT_STATUS_FPEIS_E_INACTIVE | 0x0   | Frame Preemption Interrupt status not
 * active CORE_MAC_INTERRUPT_STATUS_FPEIS_E_ACTIVE   | 0x1   | Frame Preemption Interrupt status
 * active
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_FPEIS
 *
 * Frame Preemption Interrupt status not active
 */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_FPEIS
 *
 * Frame Preemption Interrupt status active
 */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_FPEIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_LSB	   16
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_FPEIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_MSB	   16
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_FPEIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_FPEIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_SET_MSK	   0x00010000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_FPEIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_CLR_MSK	   0xfffeffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_FPEIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_FPEIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_INTERRUPT_STATUS_FPEIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_FPEIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : MFTIS
 *
 * MMC FPE Transmit Interrupt Status
 *
 * This bit is set high when an interrupt is generated in the MMC FPE Transmit
 * Interrupt Register. This bit is cleared when all bits in this interrupt register
 * are cleared. This bit is valid only when you select the Enable MAC Management
 * Counters (MMC) option along with FPE support.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                         | Value | Description
 * :-------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MAC_INTERRUPT_STATUS_MFTIS_E_INACTIVE | 0x0   | MMC FPE Transmit Interrupt status not
 * active CORE_MAC_INTERRUPT_STATUS_MFTIS_E_ACTIVE   | 0x1   | MMC FPE Transmit Interrupt status
 * active
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_MFTIS
 *
 * MMC FPE Transmit Interrupt status not active
 */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_MFTIS
 *
 * MMC FPE Transmit Interrupt status active
 */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_MFTIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_LSB	   17
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_MFTIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_MSB	   17
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_MFTIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_MFTIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_SET_MSK	   0x00020000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_MFTIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_CLR_MSK	   0xfffdffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_MFTIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_MFTIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_INTERRUPT_STATUS_MFTIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_MFTIS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : MFRIS
 *
 * MMC FPE Receive Interrupt Status
 *
 * This bit is set high when an interrupt is generated in the MMC FPE Receive
 * Interrupt Register. This bit is cleared when all bits in this interrupt register
 * are cleared. This bit is valid only when you select the Enable MAC Management
 * Counters (MMC) option along with FPE support.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                         | Value | Description
 * :-------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MAC_INTERRUPT_STATUS_MFRIS_E_INACTIVE | 0x0   | MMC FPE Receive Interrupt status not active
 *  CORE_MAC_INTERRUPT_STATUS_MFRIS_E_ACTIVE   | 0x1   | MMC FPE Receive Interrupt status active
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_MFRIS
 *
 * MMC FPE Receive Interrupt status not active
 */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_STATUS_MFRIS
 *
 * MMC FPE Receive Interrupt status active
 */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_MFRIS register field.
 */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_LSB	   18
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_MFRIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_MSB	   18
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_MFRIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_MFRIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_SET_MSK	   0x00040000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_MFRIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_CLR_MSK	   0xfffbffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_MFRIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_MFRIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_INTERRUPT_STATUS_MFRIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_MFRIS_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : Reserved_22_19
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_LSB	    19
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_MSB	    22
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_WIDTH	    4
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_SET_MSK    0x00780000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_CLR_MSK    0xff87ffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_GET(value) (((value)&0x00780000) >> 19)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19_SET(value) (((value) << 19) & 0x00780000)

/*
 * Field : Reserved_PCIS
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_LSB	   23
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_MSB	   23
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_SET_MSK	   0x00800000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_CLR_MSK	   0xff7fffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : LS
 *
 * Link Status.
 *
 * When current Mode is not RGMII :
 *
 * These bits indicate the current link status received on the XGMII receive
 * interface.
 *
 * * 2'b00: Link OK
 *
 * * 2'b01: Reserved
 *
 * * 2'b10: Local link fault
 *
 * * 2'b11: Remote link fault
 *
 * The bits [27:26] are reserved
 *
 * When current mode is RGMII:
 *
 * Bit[27]:
 *
 * * 0: Link Down
 *
 * * 1: Link Up
 *
 * Bit[26:25]:
 *
 * * 2'b00: 10Mbps
 *
 * * 2'b01: 100Mbps
 *
 * * 2'b10: 1Gbps
 *
 * * 2'b11: Reserved
 *
 * Bit[24]:
 *
 * * 0: Half Duplex
 *
 * * 1: Full Duplex
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_LS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LS_LSB	24
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_LS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LS_MSB	25
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_LS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LS_WIDTH	2
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_LS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_LS_SET_MSK	0x03000000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_LS register field value. */
#define CORE_MAC_INTERRUPT_STATUS_LS_CLR_MSK	0xfcffffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_LS register field. */
#define CORE_MAC_INTERRUPT_STATUS_LS_RESET	0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_LS field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_LS_GET(value) (((value)&0x03000000) >> 24)
/* Produces a CORE_MAC_INTERRUPT_STATUS_LS register field value suitable for setting the register.
 */
#define CORE_MAC_INTERRUPT_STATUS_LS_SET(value) (((value) << 24) & 0x03000000)

/*
 * Field : Reserved_31_26
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_LSB	    26
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register
 * field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_MSB	    31
/* The width in bits of the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_WIDTH	    6
/* The mask used to set the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_SET_MSK    0xfc000000
/* The mask used to clear the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register field value. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_CLR_MSK    0x03ffffff
/* The reset value of the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register field. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 field value from a register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_GET(value) (((value)&0xfc000000) >> 26)
/* Produces a CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26_SET(value) (((value) << 26) & 0xfc000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_INTERRUPT_STATUS.
 */
struct CORE_MAC_INTERRUPT_STATUS_s {
	const volatile uint32_t LSI : 1;	    /* CORE_MAC_INTERRUPT_STATUS_LSI */
	const volatile uint32_t SMI : 1;	    /* CORE_MAC_INTERRUPT_STATUS_SMI */
	const volatile uint32_t Reserved_3_2 : 2;   /* CORE_MAC_INTERRUPT_STATUS_RESERVED_3_2 */
	const volatile uint32_t Reserved_PMTIS : 1; /* CORE_MAC_INTERRUPT_STATUS_RESERVED_PMTIS */
	const volatile uint32_t LPIIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_LPIIS */
	const volatile uint32_t Reserved_8_6 : 3;   /* CORE_MAC_INTERRUPT_STATUS_RESERVED_8_6 */
	const volatile uint32_t MMCRXIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_MMCRXIS */
	const volatile uint32_t MMCTXIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_MMCTXIS */
	const volatile uint32_t MMCRXIPIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_MMCRXIPIS */
	const volatile uint32_t TSIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_TSIS */
	const volatile uint32_t TXESIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_TXESIS */
	const volatile uint32_t RXESIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_RXESIS */
	const volatile uint32_t GPIIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_GPIIS */
	const volatile uint32_t FPEIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_FPEIS */
	const volatile uint32_t MFTIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_MFTIS */
	const volatile uint32_t MFRIS : 1;	    /* CORE_MAC_INTERRUPT_STATUS_MFRIS */
	const volatile uint32_t Reserved_22_19 : 4; /* CORE_MAC_INTERRUPT_STATUS_RESERVED_22_19 */
	const volatile uint32_t Reserved_PCIS : 1;  /* CORE_MAC_INTERRUPT_STATUS_RESERVED_PCIS */
	const volatile uint32_t LS : 2;		    /* CORE_MAC_INTERRUPT_STATUS_LS */
	const volatile uint32_t Reserved_31_26 : 6; /* CORE_MAC_INTERRUPT_STATUS_RESERVED_31_26 */
};

/* The typedef declaration for register CORE_MAC_INTERRUPT_STATUS. */
typedef struct CORE_MAC_INTERRUPT_STATUS_s CORE_MAC_INTERRUPT_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_INTERRUPT_STATUS register. */
#define CORE_MAC_INTERRUPT_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MAC_INTERRUPT_STATUS register from the beginning of the component. */
#define CORE_MAC_INTERRUPT_STATUS_OFST	0xb0

/*
 * Register : MAC_Interrupt_Enable
 *
 * The Interrupt Enable register contains the masks for generating the interrupts.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [0]     | RW     | 0x1   | CORE_MAC_INTERRUPT_ENABLE_LSIE
 *  [3:1]   | R      | 0x0   | CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1
 *  [4]     | R      | 0x0   | CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE
 *  [5]     | RW     | 0x0   | CORE_MAC_INTERRUPT_ENABLE_LPIIE
 *  [11:6]  | R      | 0x0   | CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6
 *  [12]    | RW     | 0x0   | CORE_MAC_INTERRUPT_ENABLE_TSIE
 *  [13]    | RW     | 0x0   | CORE_MAC_INTERRUPT_ENABLE_TXESIE
 *  [14]    | RW     | 0x0   | CORE_MAC_INTERRUPT_ENABLE_RXESIE
 *  [15]    | RW     | 0x0   | CORE_MAC_INTERRUPT_ENABLE_FPEIE
 *  [31:16] | R      | 0x0   | CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16
 *
 */
/*
 * Field : LSIE
 *
 * Link Status Change Interrupt Enable.
 *
 * When this bit is set, it enables the assertion of the interrupt signal because
 * of the setting of LSI bit in MAC_Interrupt_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_LSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_LSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_MSB	  0
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_LSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_WIDTH	  1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_LSIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_SET_MSK	  0x00000001
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_LSIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_CLR_MSK	  0xfffffffe
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_LSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_RESET	  0x1
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_LSIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_LSIE register field value suitable for setting the register.
 */
#define CORE_MAC_INTERRUPT_ENABLE_LSIE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_MSB	  3
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_WIDTH	  3
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_SET_MSK	  0x0000000e
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_CLR_MSK	  0xfffffff1
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_RESET	  0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : Reserved_PMTIE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_LSB	    4
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_MSB	    4
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_WIDTH	    1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : LPIIE
 *
 * LPI Interrupt Enable.
 *
 * When this bit is set, it enables the assertion of the interrupt signal because
 * of the setting of LPIIS bit in MAC_Interrupt_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_LPIIE register field.
 */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_LSB	   5
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_LPIIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_MSB	   5
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_LPIIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_LPIIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_SET_MSK	   0x00000020
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_LPIIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_CLR_MSK	   0xffffffdf
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_LPIIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_LPIIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_LPIIE register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_LPIIE_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_11_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_MSB	   11
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_WIDTH	   6
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_SET_MSK	   0x00000fc0
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_CLR_MSK	   0xfffff03f
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_GET(value) (((value)&0x00000fc0) >> 6)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6_SET(value) (((value) << 6) & 0x00000fc0)

/*
 * Field : TSIE
 *
 * Timestamp Interrupt Enable.
 *
 * When this bit is set, it enables the assertion of the interrupt signal because
 * of the setting of TSIS bit in MAC_Interrupt_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_TSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_LSB	  12
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_TSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_MSB	  12
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_TSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_WIDTH	  1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_TSIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_SET_MSK	  0x00001000
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_TSIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_CLR_MSK	  0xffffefff
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_TSIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_RESET	  0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_TSIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_TSIE register field value suitable for setting the register.
 */
#define CORE_MAC_INTERRUPT_ENABLE_TSIE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : TXESIE
 *
 * Transmit Error Status Interrupt Enable.
 *
 * When this bit is set, it enables the assertion of the interrupt signal because
 * of the setting of the TXESIS bit in the MAC_Interrupt_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_TXESIE register field.
 */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_LSB	    13
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_TXESIE register field.
 */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_MSB	    13
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_TXESIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_WIDTH	    1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_TXESIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_SET_MSK    0x00002000
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_TXESIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_TXESIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_TXESIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_TXESIE register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_TXESIE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : RXESIE
 *
 * Receive Error Status Interrupt Enable.
 *
 * When this bit is set, it enables the assertion of the interrupt signal because
 * of the setting of the RXESIS bit in the MAC_Interrupt_Status register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_RXESIE register field.
 */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_LSB	    14
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_RXESIE register field.
 */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_MSB	    14
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_RXESIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_WIDTH	    1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_RXESIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_SET_MSK    0x00004000
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_RXESIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_CLR_MSK    0xffffbfff
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_RXESIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_RXESIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_RXESIE register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_RXESIE_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : FPEIE
 *
 * Frame Preemption Interrupt Enable
 *
 * When this bit is set, it enables the assertion of the interrupt when FPEIS field
 * is set in the MAC_Interrupt_Status register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                        | Value | Description
 * :------------------------------------------------------------|:------|:---------------------------------------
 *  CORE_MAC_INTERRUPT_ENABLE_FPEIE_E_DISABLE | 0x0   | Frame Preemption Interrupt is disabled
 *  CORE_MAC_INTERRUPT_ENABLE_FPEIE_E_ENABLE  | 0x1   | Frame Preemption Interrupt is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_ENABLE_FPEIE
 *
 * Frame Preemption Interrupt is disabled
 */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_INTERRUPT_ENABLE_FPEIE
 *
 * Frame Preemption Interrupt is enabled
 */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_FPEIE register field.
 */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_LSB	   15
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_FPEIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_MSB	   15
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_FPEIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_WIDTH	   1
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_FPEIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_SET_MSK	   0x00008000
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_FPEIE register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_CLR_MSK	   0xffff7fff
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_FPEIE register field. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_RESET	   0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_FPEIE field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_FPEIE register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_FPEIE_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register
 * field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_MSB	    31
/* The width in bits of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_WIDTH	    16
/* The mask used to set the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register field value. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register field. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_RESET	    0x0
/* Extracts the CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 field value from a register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 register field value suitable for setting the
 * register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_INTERRUPT_ENABLE.
 */
struct CORE_MAC_INTERRUPT_ENABLE_s {
	volatile uint32_t LSIE : 1;		     /* CORE_MAC_INTERRUPT_ENABLE_LSIE */
	const volatile uint32_t Reserved_3_1 : 3;    /* CORE_MAC_INTERRUPT_ENABLE_RESERVED_3_1 */
	const volatile uint32_t Reserved_PMTIE : 1;  /* CORE_MAC_INTERRUPT_ENABLE_RESERVED_PMTIE */
	volatile uint32_t LPIIE : 1;		     /* CORE_MAC_INTERRUPT_ENABLE_LPIIE */
	const volatile uint32_t Reserved_11_6 : 6;   /* CORE_MAC_INTERRUPT_ENABLE_RESERVED_11_6 */
	volatile uint32_t TSIE : 1;		     /* CORE_MAC_INTERRUPT_ENABLE_TSIE */
	volatile uint32_t TXESIE : 1;		     /* CORE_MAC_INTERRUPT_ENABLE_TXESIE */
	volatile uint32_t RXESIE : 1;		     /* CORE_MAC_INTERRUPT_ENABLE_RXESIE */
	volatile uint32_t FPEIE : 1;		     /* CORE_MAC_INTERRUPT_ENABLE_FPEIE */
	const volatile uint32_t Reserved_31_16 : 16; /* CORE_MAC_INTERRUPT_ENABLE_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_INTERRUPT_ENABLE. */
typedef struct CORE_MAC_INTERRUPT_ENABLE_s CORE_MAC_INTERRUPT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_INTERRUPT_ENABLE register. */
#define CORE_MAC_INTERRUPT_ENABLE_RESET 0x00000001
/* The byte offset of the CORE_MAC_INTERRUPT_ENABLE register from the beginning of the component. */
#define CORE_MAC_INTERRUPT_ENABLE_OFST	0xb4

/*
 * Register : MAC_Rx_Tx_Status
 *
 * The Receive Transmit Status register contains the Receive and Transmit Error
 * status.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_TJT
 *  [1]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_NCARR
 *  [2]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_LCARR
 *  [3]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_EXDEF
 *  [4]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_LCOL
 *  [5]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_EXCOL
 *  [7:6]   | R      | 0x0   | CORE_MAC_RX_TX_STATUS_RESERVED_7_6
 *  [8]     | R      | 0x0   | CORE_MAC_RX_TX_STATUS_RWT
 *  [11:9]  | R      | 0x0   | CORE_MAC_RX_TX_STATUS_RESERVED_11_9
 *  [12]    | R      | 0x0   | CORE_MAC_RX_TX_STATUS_IHE
 *  [13]    | R      | 0x0   | CORE_MAC_RX_TX_STATUS_PCE
 *  [31:14] | R      | 0x0   | CORE_MAC_RX_TX_STATUS_RESERVED_31_14
 *
 */
/*
 * Field : TJT
 *
 * Transmit Jabber Timeout.
 *
 * This bit indicates that the Transmit Jabber Timer expired, which happens when
 * the packet size exceeds 2048 bytes (10240 bytes when the Jumbo packet is
 * enabled) and the JD bit is reset in the MAC_Tx_Configuration register. This bit
 * is set when the packet size exceeds 16383 bytes and the JD bit is set in the
 * MAC_Tx_Configuration register.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_TJT register field. */
#define CORE_MAC_RX_TX_STATUS_TJT_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_TJT register field. */
#define CORE_MAC_RX_TX_STATUS_TJT_MSB	     0
/* The width in bits of the CORE_MAC_RX_TX_STATUS_TJT register field. */
#define CORE_MAC_RX_TX_STATUS_TJT_WIDTH	     1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_TJT register field value. */
#define CORE_MAC_RX_TX_STATUS_TJT_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_TJT register field value. */
#define CORE_MAC_RX_TX_STATUS_TJT_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_RX_TX_STATUS_TJT register field. */
#define CORE_MAC_RX_TX_STATUS_TJT_RESET	     0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_TJT field value from a register. */
#define CORE_MAC_RX_TX_STATUS_TJT_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_RX_TX_STATUS_TJT register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_TJT_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : NCARR
 *
 * No Carrier
 *
 * When the FTS bit is reset in the MTL_Operation_Mode register, this bit indicates
 * that the carrier signal from the PHY is not present at the end of preamble
 * transmission.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:-------------------
 *  CORE_MAC_RX_TX_STATUS_NCARR_E_INACTIVE | 0x0   | Carrier is present
 *  CORE_MAC_RX_TX_STATUS_NCARR_E_ACTIVE   | 0x1   | No carrier
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_NCARR
 *
 * Carrier is present
 */
#define CORE_MAC_RX_TX_STATUS_NCARR_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_NCARR
 *
 * No carrier
 */
#define CORE_MAC_RX_TX_STATUS_NCARR_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_NCARR register field. */
#define CORE_MAC_RX_TX_STATUS_NCARR_LSB	       1
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_NCARR register field. */
#define CORE_MAC_RX_TX_STATUS_NCARR_MSB	       1
/* The width in bits of the CORE_MAC_RX_TX_STATUS_NCARR register field. */
#define CORE_MAC_RX_TX_STATUS_NCARR_WIDTH      1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_NCARR register field value. */
#define CORE_MAC_RX_TX_STATUS_NCARR_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_NCARR register field value. */
#define CORE_MAC_RX_TX_STATUS_NCARR_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_RX_TX_STATUS_NCARR register field. */
#define CORE_MAC_RX_TX_STATUS_NCARR_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_NCARR field value from a register. */
#define CORE_MAC_RX_TX_STATUS_NCARR_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_RX_TX_STATUS_NCARR register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_NCARR_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : LCARR
 *
 * Loss of Carrier
 *
 * When the FTS bit is reset in the MTL_Operation_Mode register, this bit indicates
 * that the loss of carrier occurred during packet transmission, that is, the
 * phy_crs_i signal was inactive for one or more transmission clock periods during
 * packet transmission. This bit is valid only for packets transmitted without
 * collision.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:-------------------
 *  CORE_MAC_RX_TX_STATUS_LCARR_E_INACTIVE | 0x0   | Carrier is present
 *  CORE_MAC_RX_TX_STATUS_LCARR_E_ACTIVE   | 0x1   | Loss of carrier
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_LCARR
 *
 * Carrier is present
 */
#define CORE_MAC_RX_TX_STATUS_LCARR_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_LCARR
 *
 * Loss of carrier
 */
#define CORE_MAC_RX_TX_STATUS_LCARR_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_LCARR register field. */
#define CORE_MAC_RX_TX_STATUS_LCARR_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_LCARR register field. */
#define CORE_MAC_RX_TX_STATUS_LCARR_MSB	       2
/* The width in bits of the CORE_MAC_RX_TX_STATUS_LCARR register field. */
#define CORE_MAC_RX_TX_STATUS_LCARR_WIDTH      1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_LCARR register field value. */
#define CORE_MAC_RX_TX_STATUS_LCARR_SET_MSK    0x00000004
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_LCARR register field value. */
#define CORE_MAC_RX_TX_STATUS_LCARR_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MAC_RX_TX_STATUS_LCARR register field. */
#define CORE_MAC_RX_TX_STATUS_LCARR_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_LCARR field value from a register. */
#define CORE_MAC_RX_TX_STATUS_LCARR_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_RX_TX_STATUS_LCARR register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_LCARR_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : EXDEF
 *
 * Excessive Deferral
 *
 * When the FTS bit is reset in the MTL_Operation_Mode register and the DC bit is
 * set in the MAC_Extended_Configuration register, this bit indicates that the
 * transmission ended because of excessive deferral of over 24,288 bit times (when
 * Jumbo packet is enabled).
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:----------------------
 *  CORE_MAC_RX_TX_STATUS_EXDEF_E_INACTIVE | 0x0   | No Excessive deferral
 *  CORE_MAC_RX_TX_STATUS_EXDEF_E_ACTIVE   | 0x1   | Excessive deferral
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_EXDEF
 *
 * No Excessive deferral
 */
#define CORE_MAC_RX_TX_STATUS_EXDEF_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_EXDEF
 *
 * Excessive deferral
 */
#define CORE_MAC_RX_TX_STATUS_EXDEF_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_EXDEF register field. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_EXDEF register field. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_MSB	       3
/* The width in bits of the CORE_MAC_RX_TX_STATUS_EXDEF register field. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_WIDTH      1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_EXDEF register field value. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_EXDEF register field value. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_RX_TX_STATUS_EXDEF register field. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_EXDEF field value from a register. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_RX_TX_STATUS_EXDEF register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_EXDEF_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : LCOL
 *
 * Late Collision
 *
 * When the FTS bit is reset in the MTL_Operation_Mode register, this bit indicates
 * that the packet transmission aborted because a collision occurred after the
 * collision window (64 bytes including Preamble in MII mode).
 *
 * This bit is not valid if the Underflow error occurs.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:-------------------------
 *  CORE_MAC_RX_TX_STATUS_LCOL_E_INACTIVE | 0x0   | No collision
 *  CORE_MAC_RX_TX_STATUS_LCOL_E_ACTIVE   | 0x1   | Late collision is sensed
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_LCOL
 *
 * No collision
 */
#define CORE_MAC_RX_TX_STATUS_LCOL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_LCOL
 *
 * Late collision is sensed
 */
#define CORE_MAC_RX_TX_STATUS_LCOL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_LCOL register field. */
#define CORE_MAC_RX_TX_STATUS_LCOL_LSB	      4
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_LCOL register field. */
#define CORE_MAC_RX_TX_STATUS_LCOL_MSB	      4
/* The width in bits of the CORE_MAC_RX_TX_STATUS_LCOL register field. */
#define CORE_MAC_RX_TX_STATUS_LCOL_WIDTH      1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_LCOL register field value. */
#define CORE_MAC_RX_TX_STATUS_LCOL_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_LCOL register field value. */
#define CORE_MAC_RX_TX_STATUS_LCOL_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_RX_TX_STATUS_LCOL register field. */
#define CORE_MAC_RX_TX_STATUS_LCOL_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_LCOL field value from a register. */
#define CORE_MAC_RX_TX_STATUS_LCOL_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_RX_TX_STATUS_LCOL register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_LCOL_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : EXCOL
 *
 * Excessive Collisions
 *
 * When the FTS bit is reset in the MTL_Operation_Mode register, this bit indicates
 * that the transmission aborted after 16 successive collisions while attempting to
 * transmit the current packet. If the DR bit is set in the MAC_Configuration
 * register, this bit is set after the first collision and the packet transmission
 * is aborted.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:------------------------------
 *  CORE_MAC_RX_TX_STATUS_EXCOL_E_INACTIVE | 0x0   | No collision
 *  CORE_MAC_RX_TX_STATUS_EXCOL_E_ACTIVE   | 0x1   | Excessive collision is sensed
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_EXCOL
 *
 * No collision
 */
#define CORE_MAC_RX_TX_STATUS_EXCOL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_RX_TX_STATUS_EXCOL
 *
 * Excessive collision is sensed
 */
#define CORE_MAC_RX_TX_STATUS_EXCOL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_EXCOL register field. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_LSB	       5
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_EXCOL register field. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_MSB	       5
/* The width in bits of the CORE_MAC_RX_TX_STATUS_EXCOL register field. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_WIDTH      1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_EXCOL register field value. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_SET_MSK    0x00000020
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_EXCOL register field value. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MAC_RX_TX_STATUS_EXCOL register field. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_EXCOL field value from a register. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_RX_TX_STATUS_EXCOL register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_EXCOL_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register
 * field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register field.
 */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_MSB	      7
/* The width in bits of the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_WIDTH      2
/* The mask used to set the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register field value. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_SET_MSK    0x000000c0
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register field value. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_CLR_MSK    0xffffff3f
/* The reset value of the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_RESERVED_7_6 field value from a register. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a CORE_MAC_RX_TX_STATUS_RESERVED_7_6 register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : RWT
 *
 * Receive Watchdog Timeout.
 *
 * This bit is set when a packet with length greater than 2048 bytes is received
 * (10240 bytes when Jumbo Packet mode is enabled) and the WD bit is reset in the
 * MAC_Rx_Configuration register or when a packet with length greater than 16383
 * bytes is received and the WD bit is set in the MAC_Rx_Configuration register.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_RWT register field. */
#define CORE_MAC_RX_TX_STATUS_RWT_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_RWT register field. */
#define CORE_MAC_RX_TX_STATUS_RWT_MSB	     8
/* The width in bits of the CORE_MAC_RX_TX_STATUS_RWT register field. */
#define CORE_MAC_RX_TX_STATUS_RWT_WIDTH	     1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_RWT register field value. */
#define CORE_MAC_RX_TX_STATUS_RWT_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_RWT register field value. */
#define CORE_MAC_RX_TX_STATUS_RWT_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_RX_TX_STATUS_RWT register field. */
#define CORE_MAC_RX_TX_STATUS_RWT_RESET	     0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_RWT field value from a register. */
#define CORE_MAC_RX_TX_STATUS_RWT_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_RX_TX_STATUS_RWT register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_RWT_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : Reserved_11_9
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register
 * field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_LSB	       9
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register
 * field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_MSB	       11
/* The width in bits of the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_WIDTH      3
/* The mask used to set the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register field value. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_SET_MSK    0x00000e00
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register field value. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_CLR_MSK    0xfffff1ff
/* The reset value of the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_RESET      0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_RESERVED_11_9 field value from a register. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_GET(value) (((value)&0x00000e00) >> 9)
/* Produces a CORE_MAC_RX_TX_STATUS_RESERVED_11_9 register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_11_9_SET(value) (((value) << 9) & 0x00000e00)

/*
 * Field : IHE
 *
 * IP Header Error.
 *
 * This bit indicates that the Checksum Offload engine detected IP header error.
 * This failure can be either because of received Ethernet type is 0x0800 but
 * Version field of IPv4 header is not equal to 0x4, IPv4 Header Length field
 * indicates a value less than 0x5 (20 bytes), total packet length is less than the
 * value given in the IPv4 Header Length field, received Ethernet type is 0x86dd
 * but IPv6 header Version field is not equal to 0x6, packet ends before the IPv6
 * header (40 bytes) or extension header (as given in the corresponding Header
 * Length field in an extension header) is completely received.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_IHE register field. */
#define CORE_MAC_RX_TX_STATUS_IHE_LSB	     12
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_IHE register field. */
#define CORE_MAC_RX_TX_STATUS_IHE_MSB	     12
/* The width in bits of the CORE_MAC_RX_TX_STATUS_IHE register field. */
#define CORE_MAC_RX_TX_STATUS_IHE_WIDTH	     1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_IHE register field value. */
#define CORE_MAC_RX_TX_STATUS_IHE_SET_MSK    0x00001000
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_IHE register field value. */
#define CORE_MAC_RX_TX_STATUS_IHE_CLR_MSK    0xffffefff
/* The reset value of the CORE_MAC_RX_TX_STATUS_IHE register field. */
#define CORE_MAC_RX_TX_STATUS_IHE_RESET	     0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_IHE field value from a register. */
#define CORE_MAC_RX_TX_STATUS_IHE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_RX_TX_STATUS_IHE register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_IHE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : PCE
 *
 * Payload Checksum Error.
 *
 * This bit indicates that the Checksum Offload engine detected IP payload error
 * and did not insert any checksum into the encapsulated TCP, UDP, or ICMP payload.
 * This failure can be either because of insufficient bytes, as indicated by the
 * Payload Length field of the IP Header or the MTL starting to forward the packet
 * to the MAC transmitter in Store-and-Forward mode without the checksum having
 * been calculated yet. This second error condition only occurs when the Transmit
 * Queue depth is less than the length of the IP packet being transmitted to avoid
 * deadlock, the MTL starts forwarding the packet when the FIFO is full, even in
 * the store-and-forward mode.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_PCE register field. */
#define CORE_MAC_RX_TX_STATUS_PCE_LSB	     13
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_PCE register field. */
#define CORE_MAC_RX_TX_STATUS_PCE_MSB	     13
/* The width in bits of the CORE_MAC_RX_TX_STATUS_PCE register field. */
#define CORE_MAC_RX_TX_STATUS_PCE_WIDTH	     1
/* The mask used to set the CORE_MAC_RX_TX_STATUS_PCE register field value. */
#define CORE_MAC_RX_TX_STATUS_PCE_SET_MSK    0x00002000
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_PCE register field value. */
#define CORE_MAC_RX_TX_STATUS_PCE_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MAC_RX_TX_STATUS_PCE register field. */
#define CORE_MAC_RX_TX_STATUS_PCE_RESET	     0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_PCE field value from a register. */
#define CORE_MAC_RX_TX_STATUS_PCE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_RX_TX_STATUS_PCE register field value suitable for setting the register. */
#define CORE_MAC_RX_TX_STATUS_PCE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Reserved_31_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register
 * field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_LSB	14
/* The Most Significant Bit (MSB) position of the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register
 * field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_MSB	31
/* The width in bits of the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_WIDTH	18
/* The mask used to set the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register field value. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_SET_MSK	0xffffc000
/* The mask used to clear the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register field value. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_CLR_MSK	0x00003fff
/* The reset value of the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register field. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_RESET	0x0
/* Extracts the CORE_MAC_RX_TX_STATUS_RESERVED_31_14 field value from a register. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_GET(value) (((value)&0xffffc000) >> 14)
/* Produces a CORE_MAC_RX_TX_STATUS_RESERVED_31_14 register field value suitable for setting the
 * register. */
#define CORE_MAC_RX_TX_STATUS_RESERVED_31_14_SET(value) (((value) << 14) & 0xffffc000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_RX_TX_STATUS.
 */
struct CORE_MAC_RX_TX_STATUS_s {
	const volatile uint32_t TJT : 1;	     /* CORE_MAC_RX_TX_STATUS_TJT */
	const volatile uint32_t NCARR : 1;	     /* CORE_MAC_RX_TX_STATUS_NCARR */
	const volatile uint32_t LCARR : 1;	     /* CORE_MAC_RX_TX_STATUS_LCARR */
	const volatile uint32_t EXDEF : 1;	     /* CORE_MAC_RX_TX_STATUS_EXDEF */
	const volatile uint32_t LCOL : 1;	     /* CORE_MAC_RX_TX_STATUS_LCOL */
	const volatile uint32_t EXCOL : 1;	     /* CORE_MAC_RX_TX_STATUS_EXCOL */
	const volatile uint32_t Reserved_7_6 : 2;    /* CORE_MAC_RX_TX_STATUS_RESERVED_7_6 */
	const volatile uint32_t RWT : 1;	     /* CORE_MAC_RX_TX_STATUS_RWT */
	const volatile uint32_t Reserved_11_9 : 3;   /* CORE_MAC_RX_TX_STATUS_RESERVED_11_9 */
	const volatile uint32_t IHE : 1;	     /* CORE_MAC_RX_TX_STATUS_IHE */
	const volatile uint32_t PCE : 1;	     /* CORE_MAC_RX_TX_STATUS_PCE */
	const volatile uint32_t Reserved_31_14 : 18; /* CORE_MAC_RX_TX_STATUS_RESERVED_31_14 */
};

/* The typedef declaration for register CORE_MAC_RX_TX_STATUS. */
typedef struct CORE_MAC_RX_TX_STATUS_s CORE_MAC_RX_TX_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_RX_TX_STATUS register. */
#define CORE_MAC_RX_TX_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MAC_RX_TX_STATUS register from the beginning of the component. */
#define CORE_MAC_RX_TX_STATUS_OFST  0xb8

/*
 * Register : MAC_LPI_Control_Status
 *
 * The LPI Control and Status register controls the LPI functions and provides the
 * LPI interrupt status. The status bits are cleared when this register is read.
 * This register is present only when you select the Energy Efficient Ethernet
 * feature while configuring the controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_TLPIEN
 *  [1]     | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_TLPIEX
 *  [2]     | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RLPIEN
 *  [3]     | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RLPIEX
 *  [7:4]   | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4
 *  [8]     | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_TLPIST
 *  [9]     | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RLPIST
 *  [10]    | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RXRSTP
 *  [11]    | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_TXRSTP
 *  [15:12] | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12
 *  [16]    | RW     | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_LPITXEN
 *  [17]    | RW     | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_PLS
 *  [18]    | RW     | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_PLSDIS
 *  [19]    | RW     | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_LPITXA
 *  [20]    | RW     | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_LPIATE
 *  [21]    | RW     | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_LPITCSE
 *  [31:22] | R      | 0x0   | CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22
 *
 */
/*
 * Field : TLPIEN
 *
 * Transmit LPI Entry.
 *
 * When this bit is set, it indicates that the MAC Transmitter has entered the LPI
 * state because of the setting of the LPITXEN bit.
 *
 * Access restriction applies.This bit is cleared by a read into this register (or
 * this bit is written to 1 when RCWE bit in MAC_CSR_SW_Ctrl register is set).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_MSB	      0
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_TLPIEN field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_TLPIEN register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEN_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TLPIEX
 *
 * Transmit LPI Exit.
 *
 * When this bit is set, it indicates that the MAC transmitter exited the LPI state
 * after the application cleared the LPITXEN bit and the LPI TW Timer has expired.
 *
 * Access restriction applies.This bit is cleared by a read into this register (or
 * this bit is written to 1 when RCWE bit in MAC_CSR_SW_Ctrl register is set).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_LSB	      1
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_MSB	      1
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_TLPIEX field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_TLPIEX register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIEX_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RLPIEN
 *
 * Receive LPI Entry.
 *
 * When this bit is set, it indicates that the MAC Receiver has received an LPI
 * pattern and entered the LPI state.
 *
 * Access restriction applies.This bit is cleared by a read into this register (or
 * this bit is written to 1 when RCWE bit in MAC_CSR_SW_Ctrl register is set).
 *
 * Note: This bit might not be set if the MAC receives the LPI pattern for a very
 * short duration, such as, less than three clock cycles of CSR clock.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_MSB	      2
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_SET_MSK    0x00000004
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RLPIEN field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RLPIEN register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEN_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : RLPIEX
 *
 * Receive LPI Exit.
 *
 * When this bit is set, it indicates that the MAC Receiver has stopped receiving
 * the LPI pattern on the GMII or XGMII interface, exited the LPI state, and
 * resumed the normal reception.
 *
 * Access restriction applies.This bit is cleared by a read into this register (or
 * this bit is written to 1 when RCWE bit in MAC_CSR_SW_Ctrl register is set).
 *
 * Note: This bit might not be set if the MAC stops receiving the LPI pattern for a
 * very short duration, such as, less than three clock cycles of CSR clock.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_MSB	      3
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RLPIEX field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RLPIEX register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIEX_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_7_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_LSB	    4
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_MSB	    7
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_WIDTH	    4
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_SET_MSK    0x000000f0
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_CLR_MSK    0xffffff0f
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_RESET	    0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_GET(value) (((value)&0x000000f0) >> 4)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4_SET(value) (((value) << 4) & 0x000000f0)

/*
 * Field : TLPIST
 *
 * Transmit LPI State.
 *
 * When this bit is set, it indicates that the MAC is transmitting the LPI pattern
 * on the GMII or XGMII interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TLPIST register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_LSB	      8
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TLPIST register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_MSB	      8
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_TLPIST register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_TLPIST register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_TLPIST register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_TLPIST register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_TLPIST field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_TLPIST register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TLPIST_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : RLPIST
 *
 * Receive LPI State.
 *
 * When this bit is set, it indicates that the MAC is receiving the LPI pattern on
 * the GMII or XGMII interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RLPIST register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_LSB	      9
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RLPIST register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_MSB	      9
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RLPIST register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RLPIST register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_SET_MSK    0x00000200
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RLPIST register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RLPIST register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RLPIST field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RLPIST register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RLPIST_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : RXRSTP
 *
 * Rx Reset in progress.
 *
 * This bit indicates that the receive EEE specific reset is in progress. This bit
 * is present only when the controller is configured for the DDR and DDW mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_LSB	      10
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_MSB	      10
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_SET_MSK    0x00000400
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RXRSTP field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RXRSTP register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RXRSTP_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : TXRSTP
 *
 * Tx Reset in Progress.
 *
 * This bit indicates that the transmit EEE specific reset is in progress. This bit
 * is present only when the controller is configured for the DDR and DDW mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_MSB	      11
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_SET_MSK    0x00000800
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_TXRSTP field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_TXRSTP register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_TXRSTP_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : Reserved_15_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12
 * register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_LSB	      12
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12
 * register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_MSB	      15
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_WIDTH      4
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_SET_MSK    0x0000f000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_CLR_MSK    0xffff0fff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_GET(value) (((value)&0x0000f000) >> 12)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 register field value suitable for setting
 * the register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12_SET(value) (((value) << 12) & 0x0000f000)

/*
 * Field : LPITXEN
 *
 * LPI Transmit Enable.
 *
 * When this bit is set, it instructs the MAC Transmitter to enter the LPI state.
 * When this bit is reset, it instructs the MAC to exit the LPI state and resume
 * normal transmission.
 *
 * This bit is cleared when the LPITXA bit is set and the MAC exits the LPI state
 * because of the arrival of a new packet for transmission.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_MSB	       16
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_LPITXEN field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_LPITXEN register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXEN_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : PLS
 *
 * PHY Link Status.
 *
 * This bit indicates the link status of the PHY. The MAC Transmitter asserts the
 * LPI pattern only when the link status is up (OKAY) at least for the time
 * indicated by the LPI LS TIMER.
 *
 * When this bit is set, the link is considered to be okay (UP) and when this bit
 * is reset, the link is considered to be down.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_PLS register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_LSB	   17
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_PLS register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_MSB	   17
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_PLS register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_WIDTH	   1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_PLS register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_SET_MSK	   0x00020000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_PLS register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_CLR_MSK	   0xfffdffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_PLS register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_RESET	   0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_PLS field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_PLS register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : PLSDIS
 *
 * PHY Link Status Disable.
 *
 * This bit disables the link status received on the XGMII receive paths, which are
 * used for activating the LPI LS TIMER.
 *
 * When set to 1, the MAC ignores the link status from the XGMII interface and uses
 * the link status from bit 17 (PLS).
 *
 * When set to 0, the MAC uses the link status from the XGMII in the 10G mode. In
 * the GMII or 1G mode, the controller does not use this bit. The controller
 * depends on bit 17 (PLS) for activating the LPI LS TIMER.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_MSB	      18
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_SET_MSK    0x00040000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_PLSDIS field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_PLSDIS register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_PLSDIS_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : LPITXA
 *
 * LPI Tx Automate.
 *
 * This bit controls the behavior of the MAC when it is entering or coming out of
 * the LPI mode on the Transmit side. This bit is not functional in the XGMAC-CORE
 * configurations in which the Tx clock gating is done during the LPI mode.
 *
 * If the LPITXA and LPITXEN bits are set to 1, the MAC enters the LPI mode only
 * after all outstanding packets (in the controller) and pending packets (in the
 * application interface) have been transmitted. The MAC comes out of the LPI mode
 * when the application sends any packet for transmission or the application issues
 * a Tx FIFO Flush command. In addition, the MAC automatically clears the LPITXEN
 * bit when it exits the LPI state. If Tx FIFO Flush is set in the FTQ bit of
 * MTL_TxQ0_Operation_Mode register, when the MAC is in the LPI mode, it exits the
 * LPI mode.
 *
 * When this bit is 0, the LPITXEN bit directly controls the behavior of the MAC
 * when it enters or comes out of the LPI mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPITXA register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_LSB	      19
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPITXA register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_MSB	      19
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_LPITXA register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_LPITXA register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_SET_MSK    0x00080000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_LPITXA register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_LPITXA register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_LPITXA field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_LPITXA register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITXA_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : LPIATE
 *
 * LPI Auto Timer Enable.
 *
 * This bit controls the automatic entry of the MAC Transmitter into and exit out
 * of the LPI state. When LPIATE, LPITXA, and LPITXEN bits are set, the MAC
 * Transmitter enters LPI state only when the complete MAC Tx data path is IDLE for
 * a period indicated by the MAC_LPI_Auto_Entry_Timer register. After entering LPI
 * state, if the data path becomes non-IDLE (due to a new packet being accepted for
 * transmission), the Transmitter exits LPI state but does not clear LPITXEN bit.
 * This enables the re-entry into LPI state when it is IDLE again.
 *
 * When LPIATE is 0, the LPI Auto timer is disabled and MAC Transmitter enters LPI
 * state based on the settings of LPITXA and LPITXEN bit descriptions.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPIATE register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_LSB	      20
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPIATE register field.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_MSB	      20
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_LPIATE register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_LPIATE register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_SET_MSK    0x00100000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_LPIATE register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_CLR_MSK    0xffefffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_LPIATE register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_LPIATE field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_LPIATE register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPIATE_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : LPITCSE
 *
 * LPI Tx Clock Stop Enable.
 *
 * When this bit is 0, output sbd_tx_clk_gating_ctrl_o is not asserted. When this
 * bit is 1, output sbd_tx_clk_gating_ctrl_o is asserted during Transmit LPI mode
 * which can be used to Gate the Transmit Clock.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_LSB	       21
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register
 * field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_MSB	       21
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_WIDTH      1
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_SET_MSK    0x00200000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_LPITCSE field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_LPITCSE register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_CONTROL_STATUS_LPITCSE_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : Reserved_31_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22
 * register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_LSB	      22
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22
 * register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_MSB	      31
/* The width in bits of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_WIDTH      10
/* The mask used to set the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_SET_MSK    0xffc00000
/* The mask used to clear the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 register field value. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_CLR_MSK    0x003fffff
/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 register field. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_RESET      0x0
/* Extracts the CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 field value from a register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_GET(value) (((value)&0xffc00000) >> 22)
/* Produces a CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 register field value suitable for setting
 * the register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22_SET(value) (((value) << 22) & 0xffc00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_LPI_CONTROL_STATUS.
 */
struct CORE_MAC_LPI_CONTROL_STATUS_s {
	const volatile uint32_t TLPIEN : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_TLPIEN */
	const volatile uint32_t TLPIEX : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_TLPIEX */
	const volatile uint32_t RLPIEN : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_RLPIEN */
	const volatile uint32_t RLPIEX : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_RLPIEX */
	const volatile uint32_t Reserved_7_4 : 4;   /* CORE_MAC_LPI_CONTROL_STATUS_RESERVED_7_4 */
	const volatile uint32_t TLPIST : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_TLPIST */
	const volatile uint32_t RLPIST : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_RLPIST */
	const volatile uint32_t RXRSTP : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_RXRSTP */
	const volatile uint32_t TXRSTP : 1;	    /* CORE_MAC_LPI_CONTROL_STATUS_TXRSTP */
	const volatile uint32_t Reserved_15_12 : 4; /* CORE_MAC_LPI_CONTROL_STATUS_RESERVED_15_12 */
	volatile uint32_t LPITXEN : 1;		    /* CORE_MAC_LPI_CONTROL_STATUS_LPITXEN */
	volatile uint32_t PLS : 1;		    /* CORE_MAC_LPI_CONTROL_STATUS_PLS */
	volatile uint32_t PLSDIS : 1;		    /* CORE_MAC_LPI_CONTROL_STATUS_PLSDIS */
	volatile uint32_t LPITXA : 1;		    /* CORE_MAC_LPI_CONTROL_STATUS_LPITXA */
	volatile uint32_t LPIATE : 1;		    /* CORE_MAC_LPI_CONTROL_STATUS_LPIATE */
	volatile uint32_t LPITCSE : 1;		    /* CORE_MAC_LPI_CONTROL_STATUS_LPITCSE */
	const volatile uint32_t
		Reserved_31_22 : 10; /* CORE_MAC_LPI_CONTROL_STATUS_RESERVED_31_22 */
};

/* The typedef declaration for register CORE_MAC_LPI_CONTROL_STATUS. */
typedef struct CORE_MAC_LPI_CONTROL_STATUS_s CORE_MAC_LPI_CONTROL_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_LPI_CONTROL_STATUS register. */
#define CORE_MAC_LPI_CONTROL_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MAC_LPI_CONTROL_STATUS register from the beginning of the component.
 */
#define CORE_MAC_LPI_CONTROL_STATUS_OFST  0xd0

/*
 * Register : MAC_LPI_Timers_Control
 *
 * The LPI Timers Control register controls the timeout values in the LPI states.
 * It specifies the time for which the MAC transmits the LPI pattern and also the
 * time for which the MAC waits before resuming the normal transmission. This
 * register is present only when you select the Energy Efficient Ethernet feature
 * while configuring the controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_LPI_TIMERS_CONTROL_TWT
 *  [25:16] | RW     | 0x3e8 | CORE_MAC_LPI_TIMERS_CONTROL_LST
 *  [31:26] | R      | 0x0   | CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26
 *
 */
/*
 * Field : TWT
 *
 * LPI TW TIMER.
 *
 * This field specifies the minimum time (in microseconds) for which the MAC waits
 * after it stops transmitting the LPI pattern to the PHY and before it resumes the
 * normal transmission. The TLPIEX status bit is set after the expiry of this
 * timer.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_TIMERS_CONTROL_TWT register field.
 */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_TIMERS_CONTROL_TWT register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_MSB	   15
/* The width in bits of the CORE_MAC_LPI_TIMERS_CONTROL_TWT register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_WIDTH	   16
/* The mask used to set the CORE_MAC_LPI_TIMERS_CONTROL_TWT register field value. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_SET_MSK	   0x0000ffff
/* The mask used to clear the CORE_MAC_LPI_TIMERS_CONTROL_TWT register field value. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_CLR_MSK	   0xffff0000
/* The reset value of the CORE_MAC_LPI_TIMERS_CONTROL_TWT register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_RESET	   0x0
/* Extracts the CORE_MAC_LPI_TIMERS_CONTROL_TWT field value from a register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_LPI_TIMERS_CONTROL_TWT register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_TWT_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : LST
 *
 * LPI LS TIMER.
 *
 * This field specifies the minimum time (in milliseconds) for which the link
 * status from the PHY should be up (OKAY) before the LPI pattern can be
 * transmitted to the PHY. The MAC does not transmit the LPI pattern even when the
 * LPITXEN bit is set unless the LPI LS Timer reaches the programmed terminal
 * count. The default value of the LPI LS Timer is 1000 (1 sec) as defined in the
 * IEEE standard.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_TIMERS_CONTROL_LST register field.
 */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_LSB	   16
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_TIMERS_CONTROL_LST register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_MSB	   25
/* The width in bits of the CORE_MAC_LPI_TIMERS_CONTROL_LST register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_WIDTH	   10
/* The mask used to set the CORE_MAC_LPI_TIMERS_CONTROL_LST register field value. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_SET_MSK	   0x03ff0000
/* The mask used to clear the CORE_MAC_LPI_TIMERS_CONTROL_LST register field value. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_CLR_MSK	   0xfc00ffff
/* The reset value of the CORE_MAC_LPI_TIMERS_CONTROL_LST register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_RESET	   0x3e8
/* Extracts the CORE_MAC_LPI_TIMERS_CONTROL_LST field value from a register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_GET(value) (((value)&0x03ff0000) >> 16)
/* Produces a CORE_MAC_LPI_TIMERS_CONTROL_LST register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_LST_SET(value) (((value) << 16) & 0x03ff0000)

/*
 * Field : Reserved_31_26
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26
 * register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_LSB	      26
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26
 * register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_MSB	      31
/* The width in bits of the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_WIDTH      6
/* The mask used to set the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 register field value. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_SET_MSK    0xfc000000
/* The mask used to clear the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 register field value. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_CLR_MSK    0x03ffffff
/* The reset value of the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 register field. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_RESET      0x0
/* Extracts the CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 field value from a register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_GET(value) (((value)&0xfc000000) >> 26)
/* Produces a CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 register field value suitable for setting
 * the register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26_SET(value) (((value) << 26) & 0xfc000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_LPI_TIMERS_CONTROL.
 */
struct CORE_MAC_LPI_TIMERS_CONTROL_s {
	volatile uint32_t TWT : 16;		    /* CORE_MAC_LPI_TIMERS_CONTROL_TWT */
	volatile uint32_t LST : 10;		    /* CORE_MAC_LPI_TIMERS_CONTROL_LST */
	const volatile uint32_t Reserved_31_26 : 6; /* CORE_MAC_LPI_TIMERS_CONTROL_RESERVED_31_26 */
};

/* The typedef declaration for register CORE_MAC_LPI_TIMERS_CONTROL. */
typedef struct CORE_MAC_LPI_TIMERS_CONTROL_s CORE_MAC_LPI_TIMERS_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_LPI_TIMERS_CONTROL register. */
#define CORE_MAC_LPI_TIMERS_CONTROL_RESET 0x03e80000
/* The byte offset of the CORE_MAC_LPI_TIMERS_CONTROL register from the beginning of the component.
 */
#define CORE_MAC_LPI_TIMERS_CONTROL_OFST  0xd4

/*
 * Register : MAC_LPI_Auto_Entry_Timer
 *
 * This register is used to store the LPI Auto Entry Timer Value in Micro-Seconds.
 * This register is present only when you select the Energy Efficient Ethernet
 * feature while configuring the controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------
 *  [2:0]   | R      | 0x0   | CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0
 *  [19:3]  | RW     | 0x0   | CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET
 *  [31:20] | R      | 0x0   | CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20
 *
 */
/*
 * Field : Reserved_2_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0
 * register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0
 * register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_MSB	      2
/* The width in bits of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_WIDTH      3
/* The mask used to set the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 register field value. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_SET_MSK    0x00000007
/* The mask used to clear the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 register field value. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_CLR_MSK    0xfffffff8
/* The reset value of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_RESET      0x0
/* Extracts the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 field value from a register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_GET(value) (((value)&0x00000007) >> 0)
/* Produces a CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 register field value suitable for setting
 * the register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : LPIET
 *
 * LPI Entry Timer.
 *
 * This field is programmed with a value in micro-seconds.
 *
 * When LPIATE, LPITXA, and LPITXEN bits of the MAC_LPI_Control_Status are set,
 * DWC_xgmac automatically enters Tx LPI mode after transmitter is IDLE for LPIET
 * amount of time. Bits[2:0] are read-only such that the granularity of this timer
 * is 8 micro-seconds.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register
 * field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register
 * field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_MSB	       19
/* The width in bits of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_WIDTH      17
/* The mask used to set the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register field value. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_SET_MSK    0x000ffff8
/* The mask used to clear the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register field value. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_CLR_MSK    0xfff00007
/* The reset value of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_RESET      0x0
/* Extracts the CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET field value from a register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_GET(value) (((value)&0x000ffff8) >> 3)
/* Produces a CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET register field value suitable for setting the
 * register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_SET(value) (((value) << 3) & 0x000ffff8)

/*
 * Field : Reserved_31_20
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20
 * register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_LSB	20
/* The Most Significant Bit (MSB) position of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20
 * register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_MSB	31
/* The width in bits of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_WIDTH	12
/* The mask used to set the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 register field value. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_SET_MSK	0xfff00000
/* The mask used to clear the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 register field value. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_CLR_MSK	0x000fffff
/* The reset value of the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 register field. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_RESET	0x0
/* Extracts the CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 field value from a register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_GET(value) (((value)&0xfff00000) >> 20)
/* Produces a CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 register field value suitable for setting
 * the register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20_SET(value) (((value) << 20) & 0xfff00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_LPI_AUTO_ENTRY_TIMER.
 */
struct CORE_MAC_LPI_AUTO_ENTRY_TIMER_s {
	const volatile uint32_t Reserved_2_0 : 3; /* CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_2_0 */
	volatile uint32_t LPIET : 17;		  /* CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET */
	const volatile uint32_t
		Reserved_31_20 : 12; /* CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESERVED_31_20 */
};

/* The typedef declaration for register CORE_MAC_LPI_AUTO_ENTRY_TIMER. */
typedef struct CORE_MAC_LPI_AUTO_ENTRY_TIMER_s CORE_MAC_LPI_AUTO_ENTRY_TIMER_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_LPI_AUTO_ENTRY_TIMER register. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_RESET 0x00000000
/* The byte offset of the CORE_MAC_LPI_AUTO_ENTRY_TIMER register from the beginning of the
 * component. */
#define CORE_MAC_LPI_AUTO_ENTRY_TIMER_OFST  0xd8

/*
 * Register : MAC_1US_Tic_Counter
 *
 * This register controls the generation of the Reference time (1micro-second tic)
 * for all the LPI timers. This timer has to be programmed by the software
 * initially. This register is present only when you select the Energy Efficient
 * Ethernet feature while configuring the controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------
 *  [11:0]  | RW     | 0x63  | CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR
 *  [31:12] | R      | 0x0   | CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12
 *
 */
/*
 * Field : TIC_1US_CNTR
 *
 * 1US TIC Counter.
 *
 * This counter should be programmed with the number of clock cycles of CSR clock
 * that constitutes a period of 1us. (Subtract 1 from the value before
 * programming). For example if the CSR clock frequency is 100MHz, then this field
 * needs to be programmed to value 100 - 1 = 99 (which is 0x63).
 *
 * This is required to generate the 1US events which are used to update some of the
 * EEE related timers and counters.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register
 * field. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register
 * field. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_MSB	 11
/* The width in bits of the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register field. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_WIDTH	 12
/* The mask used to set the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register field value. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_SET_MSK	 0x00000fff
/* The mask used to clear the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register field value. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_CLR_MSK	 0xfffff000
/* The reset value of the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register field. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_RESET	 0x63
/* Extracts the CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR field value from a register. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_GET(value) (((value)&0x00000fff) >> 0)
/* Produces a CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR register field value suitable for setting the
 * register. */
#define CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR_SET(value) (((value) << 0) & 0x00000fff)

/*
 * Field : Reserved_31_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register
 * field. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_LSB	   12
/* The Most Significant Bit (MSB) position of the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register
 * field. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_MSB	   31
/* The width in bits of the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register field. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_WIDTH	   20
/* The mask used to set the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register field value. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_SET_MSK	   0xfffff000
/* The mask used to clear the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register field value. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_CLR_MSK	   0x00000fff
/* The reset value of the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register field. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_RESET	   0x0
/* Extracts the CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 field value from a register. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_GET(value) (((value)&0xfffff000) >> 12)
/* Produces a CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 register field value suitable for setting the
 * register. */
#define CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12_SET(value) (((value) << 12) & 0xfffff000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_1US_TIC_COUNTER.
 */
struct CORE_MAC_1US_TIC_COUNTER_s {
	volatile uint32_t TIC_1US_CNTR : 12;	     /* CORE_MAC_1US_TIC_COUNTER_TIC_1US_CNTR */
	const volatile uint32_t Reserved_31_12 : 20; /* CORE_MAC_1US_TIC_COUNTER_RESERVED_31_12 */
};

/* The typedef declaration for register CORE_MAC_1US_TIC_COUNTER. */
typedef struct CORE_MAC_1US_TIC_COUNTER_s CORE_MAC_1US_TIC_COUNTER_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_1US_TIC_COUNTER register. */
#define CORE_MAC_1US_TIC_COUNTER_RESET 0x00000063
/* The byte offset of the CORE_MAC_1US_TIC_COUNTER register from the beginning of the component. */
#define CORE_MAC_1US_TIC_COUNTER_OFST  0xdc

/*
 * Register : MAC_Version
 *
 * The version register identifies the version of DWC_xgmac. This register contains
 * two bytes: one that Synopsys uses to identify the controller release number, and
 * the other that you set while configuring the controller.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------
 *  [7:0]   | R      | 0x31  | CORE_MAC_VERSION_SNPSVER
 *  [15:8]  | R      | 0x76  | CORE_MAC_VERSION_DEVID
 *  [23:16] | R      | 0x10  | CORE_MAC_VERSION_USERVER
 *  [31:24] | R      | 0x0   | CORE_MAC_VERSION_RESERVED_31_24
 *
 */
/*
 * Field : SNPSVER
 *
 * Synopsys-defined Version (2.0)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VERSION_SNPSVER register field. */
#define CORE_MAC_VERSION_SNPSVER_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_VERSION_SNPSVER register field. */
#define CORE_MAC_VERSION_SNPSVER_MSB	    7
/* The width in bits of the CORE_MAC_VERSION_SNPSVER register field. */
#define CORE_MAC_VERSION_SNPSVER_WIDTH	    8
/* The mask used to set the CORE_MAC_VERSION_SNPSVER register field value. */
#define CORE_MAC_VERSION_SNPSVER_SET_MSK    0x000000ff
/* The mask used to clear the CORE_MAC_VERSION_SNPSVER register field value. */
#define CORE_MAC_VERSION_SNPSVER_CLR_MSK    0xffffff00
/* The reset value of the CORE_MAC_VERSION_SNPSVER register field. */
#define CORE_MAC_VERSION_SNPSVER_RESET	    0x31
/* Extracts the CORE_MAC_VERSION_SNPSVER field value from a register. */
#define CORE_MAC_VERSION_SNPSVER_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_VERSION_SNPSVER register field value suitable for setting the register. */
#define CORE_MAC_VERSION_SNPSVER_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : DEVID
 *
 * Indicates the Device family
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VERSION_DEVID register field. */
#define CORE_MAC_VERSION_DEVID_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_VERSION_DEVID register field. */
#define CORE_MAC_VERSION_DEVID_MSB	  15
/* The width in bits of the CORE_MAC_VERSION_DEVID register field. */
#define CORE_MAC_VERSION_DEVID_WIDTH	  8
/* The mask used to set the CORE_MAC_VERSION_DEVID register field value. */
#define CORE_MAC_VERSION_DEVID_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MAC_VERSION_DEVID register field value. */
#define CORE_MAC_VERSION_DEVID_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MAC_VERSION_DEVID register field. */
#define CORE_MAC_VERSION_DEVID_RESET	  0x76
/* Extracts the CORE_MAC_VERSION_DEVID field value from a register. */
#define CORE_MAC_VERSION_DEVID_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_VERSION_DEVID register field value suitable for setting the register. */
#define CORE_MAC_VERSION_DEVID_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : USERVER
 *
 * User-defined Version (configured with coreConsultant)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VERSION_USERVER register field. */
#define CORE_MAC_VERSION_USERVER_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_VERSION_USERVER register field. */
#define CORE_MAC_VERSION_USERVER_MSB	    23
/* The width in bits of the CORE_MAC_VERSION_USERVER register field. */
#define CORE_MAC_VERSION_USERVER_WIDTH	    8
/* The mask used to set the CORE_MAC_VERSION_USERVER register field value. */
#define CORE_MAC_VERSION_USERVER_SET_MSK    0x00ff0000
/* The mask used to clear the CORE_MAC_VERSION_USERVER register field value. */
#define CORE_MAC_VERSION_USERVER_CLR_MSK    0xff00ffff
/* The reset value of the CORE_MAC_VERSION_USERVER register field. */
#define CORE_MAC_VERSION_USERVER_RESET	    0x10
/* Extracts the CORE_MAC_VERSION_USERVER field value from a register. */
#define CORE_MAC_VERSION_USERVER_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a CORE_MAC_VERSION_USERVER register field value suitable for setting the register. */
#define CORE_MAC_VERSION_USERVER_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : Reserved_31_24
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_VERSION_RESERVED_31_24 register field.
 */
#define CORE_MAC_VERSION_RESERVED_31_24_LSB	   24
/* The Most Significant Bit (MSB) position of the CORE_MAC_VERSION_RESERVED_31_24 register field. */
#define CORE_MAC_VERSION_RESERVED_31_24_MSB	   31
/* The width in bits of the CORE_MAC_VERSION_RESERVED_31_24 register field. */
#define CORE_MAC_VERSION_RESERVED_31_24_WIDTH	   8
/* The mask used to set the CORE_MAC_VERSION_RESERVED_31_24 register field value. */
#define CORE_MAC_VERSION_RESERVED_31_24_SET_MSK	   0xff000000
/* The mask used to clear the CORE_MAC_VERSION_RESERVED_31_24 register field value. */
#define CORE_MAC_VERSION_RESERVED_31_24_CLR_MSK	   0x00ffffff
/* The reset value of the CORE_MAC_VERSION_RESERVED_31_24 register field. */
#define CORE_MAC_VERSION_RESERVED_31_24_RESET	   0x0
/* Extracts the CORE_MAC_VERSION_RESERVED_31_24 field value from a register. */
#define CORE_MAC_VERSION_RESERVED_31_24_GET(value) (((value)&0xff000000) >> 24)
/* Produces a CORE_MAC_VERSION_RESERVED_31_24 register field value suitable for setting the
 * register. */
#define CORE_MAC_VERSION_RESERVED_31_24_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_VERSION.
 */
struct CORE_MAC_VERSION_s {
	const volatile uint32_t SNPSVER : 8;	    /* CORE_MAC_VERSION_SNPSVER */
	const volatile uint32_t DEVID : 8;	    /* CORE_MAC_VERSION_DEVID */
	const volatile uint32_t USERVER : 8;	    /* CORE_MAC_VERSION_USERVER */
	const volatile uint32_t Reserved_31_24 : 8; /* CORE_MAC_VERSION_RESERVED_31_24 */
};

/* The typedef declaration for register CORE_MAC_VERSION. */
typedef struct CORE_MAC_VERSION_s CORE_MAC_VERSION_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_VERSION register. */
#define CORE_MAC_VERSION_RESET 0x00107631
/* The byte offset of the CORE_MAC_VERSION register from the beginning of the component. */
#define CORE_MAC_VERSION_OFST  0x110

/*
 * Register : MAC_Debug
 *
 * The Debug register provides the debug status of various MAC blocks.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MAC_DEBUG_RPESTS
 *  [2:1]   | R      | 0x0   | CORE_MAC_DEBUG_RFCFCSTS
 *  [15:3]  | R      | 0x0   | CORE_MAC_DEBUG_RESERVED_15_3
 *  [16]    | R      | 0x0   | CORE_MAC_DEBUG_TPESTS
 *  [18:17] | R      | 0x0   | CORE_MAC_DEBUG_TFCSTS
 *  [31:19] | R      | 0x0   | CORE_MAC_DEBUG_RESERVED_31_19
 *
 */
/*
 * Field : RPESTS
 *
 * MAC, GMII, or XGMII Receive Protocol Engine Status.
 *
 * When this bit is set, it indicates that the MAC, GMII, or XGMII receive protocol
 * engine is actively receiving data, and it is not in the Idle state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_DEBUG_RPESTS register field. */
#define CORE_MAC_DEBUG_RPESTS_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_DEBUG_RPESTS register field. */
#define CORE_MAC_DEBUG_RPESTS_MSB	 0
/* The width in bits of the CORE_MAC_DEBUG_RPESTS register field. */
#define CORE_MAC_DEBUG_RPESTS_WIDTH	 1
/* The mask used to set the CORE_MAC_DEBUG_RPESTS register field value. */
#define CORE_MAC_DEBUG_RPESTS_SET_MSK	 0x00000001
/* The mask used to clear the CORE_MAC_DEBUG_RPESTS register field value. */
#define CORE_MAC_DEBUG_RPESTS_CLR_MSK	 0xfffffffe
/* The reset value of the CORE_MAC_DEBUG_RPESTS register field. */
#define CORE_MAC_DEBUG_RPESTS_RESET	 0x0
/* Extracts the CORE_MAC_DEBUG_RPESTS field value from a register. */
#define CORE_MAC_DEBUG_RPESTS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_DEBUG_RPESTS register field value suitable for setting the register. */
#define CORE_MAC_DEBUG_RPESTS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RFCFCSTS
 *
 * MAC Receive Packet Controller FIFO Status.
 *
 * This field indicates the active state of the small FIFO Read and Write
 * controllers of the MAC Receive Packet Controller module. When bit 2 is set,
 * small FIFO Read controller is active. When bit 1 is set, small FIFO Write
 * controller is active.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_DEBUG_RFCFCSTS register field. */
#define CORE_MAC_DEBUG_RFCFCSTS_LSB	   1
/* The Most Significant Bit (MSB) position of the CORE_MAC_DEBUG_RFCFCSTS register field. */
#define CORE_MAC_DEBUG_RFCFCSTS_MSB	   2
/* The width in bits of the CORE_MAC_DEBUG_RFCFCSTS register field. */
#define CORE_MAC_DEBUG_RFCFCSTS_WIDTH	   2
/* The mask used to set the CORE_MAC_DEBUG_RFCFCSTS register field value. */
#define CORE_MAC_DEBUG_RFCFCSTS_SET_MSK	   0x00000006
/* The mask used to clear the CORE_MAC_DEBUG_RFCFCSTS register field value. */
#define CORE_MAC_DEBUG_RFCFCSTS_CLR_MSK	   0xfffffff9
/* The reset value of the CORE_MAC_DEBUG_RFCFCSTS register field. */
#define CORE_MAC_DEBUG_RFCFCSTS_RESET	   0x0
/* Extracts the CORE_MAC_DEBUG_RFCFCSTS field value from a register. */
#define CORE_MAC_DEBUG_RFCFCSTS_GET(value) (((value)&0x00000006) >> 1)
/* Produces a CORE_MAC_DEBUG_RFCFCSTS register field value suitable for setting the register. */
#define CORE_MAC_DEBUG_RFCFCSTS_SET(value) (((value) << 1) & 0x00000006)

/*
 * Field : Reserved_15_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_DEBUG_RESERVED_15_3 register field. */
#define CORE_MAC_DEBUG_RESERVED_15_3_LSB	3
/* The Most Significant Bit (MSB) position of the CORE_MAC_DEBUG_RESERVED_15_3 register field. */
#define CORE_MAC_DEBUG_RESERVED_15_3_MSB	15
/* The width in bits of the CORE_MAC_DEBUG_RESERVED_15_3 register field. */
#define CORE_MAC_DEBUG_RESERVED_15_3_WIDTH	13
/* The mask used to set the CORE_MAC_DEBUG_RESERVED_15_3 register field value. */
#define CORE_MAC_DEBUG_RESERVED_15_3_SET_MSK	0x0000fff8
/* The mask used to clear the CORE_MAC_DEBUG_RESERVED_15_3 register field value. */
#define CORE_MAC_DEBUG_RESERVED_15_3_CLR_MSK	0xffff0007
/* The reset value of the CORE_MAC_DEBUG_RESERVED_15_3 register field. */
#define CORE_MAC_DEBUG_RESERVED_15_3_RESET	0x0
/* Extracts the CORE_MAC_DEBUG_RESERVED_15_3 field value from a register. */
#define CORE_MAC_DEBUG_RESERVED_15_3_GET(value) (((value)&0x0000fff8) >> 3)
/* Produces a CORE_MAC_DEBUG_RESERVED_15_3 register field value suitable for setting the register.
 */
#define CORE_MAC_DEBUG_RESERVED_15_3_SET(value) (((value) << 3) & 0x0000fff8)

/*
 * Field : TPESTS
 *
 * MAC GMII or XGMII Transmit Protocol Engine Status.
 *
 * When this bit is set, it indicates that the MAC GMII or XGMII transmit protocol
 * engine is actively transmitting data, and it is not in the Idle state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_DEBUG_TPESTS register field. */
#define CORE_MAC_DEBUG_TPESTS_LSB	 16
/* The Most Significant Bit (MSB) position of the CORE_MAC_DEBUG_TPESTS register field. */
#define CORE_MAC_DEBUG_TPESTS_MSB	 16
/* The width in bits of the CORE_MAC_DEBUG_TPESTS register field. */
#define CORE_MAC_DEBUG_TPESTS_WIDTH	 1
/* The mask used to set the CORE_MAC_DEBUG_TPESTS register field value. */
#define CORE_MAC_DEBUG_TPESTS_SET_MSK	 0x00010000
/* The mask used to clear the CORE_MAC_DEBUG_TPESTS register field value. */
#define CORE_MAC_DEBUG_TPESTS_CLR_MSK	 0xfffeffff
/* The reset value of the CORE_MAC_DEBUG_TPESTS register field. */
#define CORE_MAC_DEBUG_TPESTS_RESET	 0x0
/* Extracts the CORE_MAC_DEBUG_TPESTS field value from a register. */
#define CORE_MAC_DEBUG_TPESTS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_DEBUG_TPESTS register field value suitable for setting the register. */
#define CORE_MAC_DEBUG_TPESTS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : TFCSTS
 *
 * MAC Transmit Packet Controller Status.
 *
 * This field indicates the state of the MAC Transmit Packet Controller module:
 *
 * * 2'b00: Idle state
 *
 * * 2'b01: Waiting for one of the following:
 *
 * * - Status of the previous packet or
 *
 * * - IPG period to be over
 *
 * * 2'b10: Generating and transmitting a Pause control packet
 *
 * * 2'b11: Transferring input packet for transmission
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_DEBUG_TFCSTS register field. */
#define CORE_MAC_DEBUG_TFCSTS_LSB	 17
/* The Most Significant Bit (MSB) position of the CORE_MAC_DEBUG_TFCSTS register field. */
#define CORE_MAC_DEBUG_TFCSTS_MSB	 18
/* The width in bits of the CORE_MAC_DEBUG_TFCSTS register field. */
#define CORE_MAC_DEBUG_TFCSTS_WIDTH	 2
/* The mask used to set the CORE_MAC_DEBUG_TFCSTS register field value. */
#define CORE_MAC_DEBUG_TFCSTS_SET_MSK	 0x00060000
/* The mask used to clear the CORE_MAC_DEBUG_TFCSTS register field value. */
#define CORE_MAC_DEBUG_TFCSTS_CLR_MSK	 0xfff9ffff
/* The reset value of the CORE_MAC_DEBUG_TFCSTS register field. */
#define CORE_MAC_DEBUG_TFCSTS_RESET	 0x0
/* Extracts the CORE_MAC_DEBUG_TFCSTS field value from a register. */
#define CORE_MAC_DEBUG_TFCSTS_GET(value) (((value)&0x00060000) >> 17)
/* Produces a CORE_MAC_DEBUG_TFCSTS register field value suitable for setting the register. */
#define CORE_MAC_DEBUG_TFCSTS_SET(value) (((value) << 17) & 0x00060000)

/*
 * Field : Reserved_31_19
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_DEBUG_RESERVED_31_19 register field. */
#define CORE_MAC_DEBUG_RESERVED_31_19_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_DEBUG_RESERVED_31_19 register field. */
#define CORE_MAC_DEBUG_RESERVED_31_19_MSB	 31
/* The width in bits of the CORE_MAC_DEBUG_RESERVED_31_19 register field. */
#define CORE_MAC_DEBUG_RESERVED_31_19_WIDTH	 13
/* The mask used to set the CORE_MAC_DEBUG_RESERVED_31_19 register field value. */
#define CORE_MAC_DEBUG_RESERVED_31_19_SET_MSK	 0xfff80000
/* The mask used to clear the CORE_MAC_DEBUG_RESERVED_31_19 register field value. */
#define CORE_MAC_DEBUG_RESERVED_31_19_CLR_MSK	 0x0007ffff
/* The reset value of the CORE_MAC_DEBUG_RESERVED_31_19 register field. */
#define CORE_MAC_DEBUG_RESERVED_31_19_RESET	 0x0
/* Extracts the CORE_MAC_DEBUG_RESERVED_31_19 field value from a register. */
#define CORE_MAC_DEBUG_RESERVED_31_19_GET(value) (((value)&0xfff80000) >> 19)
/* Produces a CORE_MAC_DEBUG_RESERVED_31_19 register field value suitable for setting the register.
 */
#define CORE_MAC_DEBUG_RESERVED_31_19_SET(value) (((value) << 19) & 0xfff80000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_DEBUG.
 */
struct CORE_MAC_DEBUG_s {
	const volatile uint32_t RPESTS : 1;	     /* CORE_MAC_DEBUG_RPESTS */
	const volatile uint32_t RFCFCSTS : 2;	     /* CORE_MAC_DEBUG_RFCFCSTS */
	const volatile uint32_t Reserved_15_3 : 13;  /* CORE_MAC_DEBUG_RESERVED_15_3 */
	const volatile uint32_t TPESTS : 1;	     /* CORE_MAC_DEBUG_TPESTS */
	const volatile uint32_t TFCSTS : 2;	     /* CORE_MAC_DEBUG_TFCSTS */
	const volatile uint32_t Reserved_31_19 : 13; /* CORE_MAC_DEBUG_RESERVED_31_19 */
};

/* The typedef declaration for register CORE_MAC_DEBUG. */
typedef struct CORE_MAC_DEBUG_s CORE_MAC_DEBUG_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_DEBUG register. */
#define CORE_MAC_DEBUG_RESET 0x00000000
/* The byte offset of the CORE_MAC_DEBUG register from the beginning of the component. */
#define CORE_MAC_DEBUG_OFST  0x114

/*
 * Register : MAC_HW_Feature0
 *
 * This register indicates the presence of the first set of optional features or
 * functions of DWC_xgmac. The software driver can use this register to dynamically
 * enable or disable the programs related to the optional blocks.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------
 *  [0]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_RGMIISEL
 *  [1]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_GMIISEL
 *  [2]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_RMIISEL
 *  [3]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_HDSEL
 *  [4]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_VLHASH
 *  [5]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_SMASEL
 *  [6]     | R      | 0x0   | CORE_MAC_HW_FEATURE0_RWKSEL
 *  [7]     | R      | 0x0   | CORE_MAC_HW_FEATURE0_MGKSEL
 *  [8]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_MMCSEL
 *  [9]     | R      | 0x1   | CORE_MAC_HW_FEATURE0_ARPOFFSEL
 *  [10]    | R      | 0x0   | CORE_MAC_HW_FEATURE0_RAVSEL
 *  [11]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_AVSEL
 *  [12]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_TSSEL
 *  [13]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_EEESEL
 *  [14]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_TXCOESEL
 *  [15]    | R      | 0x0   | CORE_MAC_HW_FEATURE0_RESERVED_15
 *  [16]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_RXCOESEL
 *  [17]    | R      | 0x0   | CORE_MAC_HW_FEATURE0_RESERVED_17
 *  [22:18] | R      | 0x1f  | CORE_MAC_HW_FEATURE0_ADDMACADRSEL
 *  [24:23] | R      | 0x0   | CORE_MAC_HW_FEATURE0_PHYSEL
 *  [26:25] | R      | 0x1   | CORE_MAC_HW_FEATURE0_TSSTSSEL
 *  [27]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_SAVLANINS
 *  [28]    | R      | 0x0   | CORE_MAC_HW_FEATURE0_RESERVED_28
 *  [29]    | R      | 0x0   | CORE_MAC_HW_FEATURE0_VXN
 *  [30]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_EDIFFC
 *  [31]    | R      | 0x1   | CORE_MAC_HW_FEATURE0_EDMA
 *
 */
/*
 * Field : RGMIISEL
 *
 * RGMII Support.
 *
 * This bit is set to 1 when the RGMII Interface option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RGMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RGMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_MSB	 0
/* The width in bits of the CORE_MAC_HW_FEATURE0_RGMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_WIDTH	 1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RGMIISEL register field value. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_SET_MSK	 0x00000001
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RGMIISEL register field value. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_CLR_MSK	 0xfffffffe
/* The reset value of the CORE_MAC_HW_FEATURE0_RGMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_RESET	 0x1
/* Extracts the CORE_MAC_HW_FEATURE0_RGMIISEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_HW_FEATURE0_RGMIISEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_RGMIISEL_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : GMIISEL
 *
 * 1000/100/10 Mbps Support.
 *
 * This bit is set to 1 when the GMII Interface option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_GMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_GMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_MSB	1
/* The width in bits of the CORE_MAC_HW_FEATURE0_GMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_WIDTH	1
/* The mask used to set the CORE_MAC_HW_FEATURE0_GMIISEL register field value. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_HW_FEATURE0_GMIISEL register field value. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_HW_FEATURE0_GMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_RESET	0x1
/* Extracts the CORE_MAC_HW_FEATURE0_GMIISEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_GMIISEL_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_HW_FEATURE0_GMIISEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_GMIISEL_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RMIISEL
 *
 * RMII Support.
 *
 * This bit is set to 1 when the RMII Interface option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_LSB	2
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_MSB	2
/* The width in bits of the CORE_MAC_HW_FEATURE0_RMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_WIDTH	1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RMIISEL register field value. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_SET_MSK	0x00000004
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RMIISEL register field value. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_CLR_MSK	0xfffffffb
/* The reset value of the CORE_MAC_HW_FEATURE0_RMIISEL register field. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_RESET	0x1
/* Extracts the CORE_MAC_HW_FEATURE0_RMIISEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_RMIISEL_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_HW_FEATURE0_RMIISEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_RMIISEL_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : HDSEL
 *
 * Half-duplex Support
 *
 * This bit is set to 1 when the half-duplex mode is selected.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:-----------------------
 *  CORE_MAC_HW_FEATURE0_HDSEL_E_INACTIVE | 0x0   | No Half-duplex support
 *  CORE_MAC_HW_FEATURE0_HDSEL_E_ACTIVE   | 0x1   | Half-duplex support
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE0_HDSEL
 *
 * No Half-duplex support
 */
#define CORE_MAC_HW_FEATURE0_HDSEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE0_HDSEL
 *
 * Half-duplex support
 */
#define CORE_MAC_HW_FEATURE0_HDSEL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_HDSEL register field. */
#define CORE_MAC_HW_FEATURE0_HDSEL_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_HDSEL register field. */
#define CORE_MAC_HW_FEATURE0_HDSEL_MSB	      3
/* The width in bits of the CORE_MAC_HW_FEATURE0_HDSEL register field. */
#define CORE_MAC_HW_FEATURE0_HDSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_HDSEL register field value. */
#define CORE_MAC_HW_FEATURE0_HDSEL_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_HW_FEATURE0_HDSEL register field value. */
#define CORE_MAC_HW_FEATURE0_HDSEL_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_HW_FEATURE0_HDSEL register field. */
#define CORE_MAC_HW_FEATURE0_HDSEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_HDSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_HDSEL_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_HW_FEATURE0_HDSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_HDSEL_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : VLHASH
 *
 * VLAN Hash Filter Selected.
 *
 * This bit is set to 1 when the Enable Address Filter VLAN Hash Table option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_VLHASH register field. */
#define CORE_MAC_HW_FEATURE0_VLHASH_LSB	       4
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_VLHASH register field. */
#define CORE_MAC_HW_FEATURE0_VLHASH_MSB	       4
/* The width in bits of the CORE_MAC_HW_FEATURE0_VLHASH register field. */
#define CORE_MAC_HW_FEATURE0_VLHASH_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_VLHASH register field value. */
#define CORE_MAC_HW_FEATURE0_VLHASH_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_HW_FEATURE0_VLHASH register field value. */
#define CORE_MAC_HW_FEATURE0_VLHASH_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_HW_FEATURE0_VLHASH register field. */
#define CORE_MAC_HW_FEATURE0_VLHASH_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_VLHASH field value from a register. */
#define CORE_MAC_HW_FEATURE0_VLHASH_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_HW_FEATURE0_VLHASH register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_VLHASH_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : SMASEL
 *
 * SMA (MDIO) Interface.
 *
 * This bit is set to 1 when the Enable Station Management Block (MDIO Interface)
 * option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_SMASEL register field. */
#define CORE_MAC_HW_FEATURE0_SMASEL_LSB	       5
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_SMASEL register field. */
#define CORE_MAC_HW_FEATURE0_SMASEL_MSB	       5
/* The width in bits of the CORE_MAC_HW_FEATURE0_SMASEL register field. */
#define CORE_MAC_HW_FEATURE0_SMASEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_SMASEL register field value. */
#define CORE_MAC_HW_FEATURE0_SMASEL_SET_MSK    0x00000020
/* The mask used to clear the CORE_MAC_HW_FEATURE0_SMASEL register field value. */
#define CORE_MAC_HW_FEATURE0_SMASEL_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MAC_HW_FEATURE0_SMASEL register field. */
#define CORE_MAC_HW_FEATURE0_SMASEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_SMASEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_SMASEL_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_HW_FEATURE0_SMASEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_SMASEL_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : RWKSEL
 *
 * PMT Remote Wake-up Packet Enable.
 *
 * This bit is set to 1 when the Enable Remote Wake-Up Packet Detection option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RWKSEL register field. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_LSB	       6
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RWKSEL register field. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_MSB	       6
/* The width in bits of the CORE_MAC_HW_FEATURE0_RWKSEL register field. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RWKSEL register field value. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_SET_MSK    0x00000040
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RWKSEL register field value. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MAC_HW_FEATURE0_RWKSEL register field. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE0_RWKSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MAC_HW_FEATURE0_RWKSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_RWKSEL_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : MGKSEL
 *
 * PMT Magic Packet Enable.
 *
 * This bit is set to 1 when the Enable Magic Packet Detection option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_MGKSEL register field. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_LSB	       7
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_MGKSEL register field. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_MSB	       7
/* The width in bits of the CORE_MAC_HW_FEATURE0_MGKSEL register field. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_MGKSEL register field value. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_SET_MSK    0x00000080
/* The mask used to clear the CORE_MAC_HW_FEATURE0_MGKSEL register field value. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MAC_HW_FEATURE0_MGKSEL register field. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE0_MGKSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_HW_FEATURE0_MGKSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_MGKSEL_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : MMCSEL
 *
 * RMON Module Enable.
 *
 * This bit is set to 1 when the Enable XGMAC Management Counter (MMC) option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_MMCSEL register field. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_LSB	       8
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_MMCSEL register field. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_MSB	       8
/* The width in bits of the CORE_MAC_HW_FEATURE0_MMCSEL register field. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_MMCSEL register field value. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_HW_FEATURE0_MMCSEL register field value. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_HW_FEATURE0_MMCSEL register field. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_MMCSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_HW_FEATURE0_MMCSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_MMCSEL_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : ARPOFFSEL
 *
 * ARP Offload Enabled.
 *
 * This bit is set to 1 when the Enable IPv4 ARP Offload option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_ARPOFFSEL register field. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_LSB	  9
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_ARPOFFSEL register field. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_MSB	  9
/* The width in bits of the CORE_MAC_HW_FEATURE0_ARPOFFSEL register field. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_WIDTH	  1
/* The mask used to set the CORE_MAC_HW_FEATURE0_ARPOFFSEL register field value. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_SET_MSK	  0x00000200
/* The mask used to clear the CORE_MAC_HW_FEATURE0_ARPOFFSEL register field value. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_CLR_MSK	  0xfffffdff
/* The reset value of the CORE_MAC_HW_FEATURE0_ARPOFFSEL register field. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_RESET	  0x1
/* Extracts the CORE_MAC_HW_FEATURE0_ARPOFFSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_HW_FEATURE0_ARPOFFSEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_ARPOFFSEL_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : RAVSEL
 *
 * Rx Side Only AV Feature Enable.
 *
 * This bit is set to 1 when the Enable Audio Video Bridging option on Rx Side Only
 * is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RAVSEL register field. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_LSB	       10
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RAVSEL register field. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_MSB	       10
/* The width in bits of the CORE_MAC_HW_FEATURE0_RAVSEL register field. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RAVSEL register field value. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_SET_MSK    0x00000400
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RAVSEL register field value. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MAC_HW_FEATURE0_RAVSEL register field. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE0_RAVSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MAC_HW_FEATURE0_RAVSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_RAVSEL_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : AVSEL
 *
 * AV Feature Enabled.
 *
 * This bit is set to 1 when the Enable Audio Video Bridging option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_AVSEL register field. */
#define CORE_MAC_HW_FEATURE0_AVSEL_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_AVSEL register field. */
#define CORE_MAC_HW_FEATURE0_AVSEL_MSB	      11
/* The width in bits of the CORE_MAC_HW_FEATURE0_AVSEL register field. */
#define CORE_MAC_HW_FEATURE0_AVSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_AVSEL register field value. */
#define CORE_MAC_HW_FEATURE0_AVSEL_SET_MSK    0x00000800
/* The mask used to clear the CORE_MAC_HW_FEATURE0_AVSEL register field value. */
#define CORE_MAC_HW_FEATURE0_AVSEL_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MAC_HW_FEATURE0_AVSEL register field. */
#define CORE_MAC_HW_FEATURE0_AVSEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_AVSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_AVSEL_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_HW_FEATURE0_AVSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_AVSEL_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : TSSEL
 *
 * IEEE 1588-2008 Timestamp Enabled.
 *
 * This bit is set to 1 when the Enable IEEE 1588 Timestamp Support option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_TSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSEL_LSB	      12
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_TSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSEL_MSB	      12
/* The width in bits of the CORE_MAC_HW_FEATURE0_TSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_TSSEL register field value. */
#define CORE_MAC_HW_FEATURE0_TSSEL_SET_MSK    0x00001000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_TSSEL register field value. */
#define CORE_MAC_HW_FEATURE0_TSSEL_CLR_MSK    0xffffefff
/* The reset value of the CORE_MAC_HW_FEATURE0_TSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_TSSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_TSSEL_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_HW_FEATURE0_TSSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_TSSEL_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : EEESEL
 *
 * Energy Efficient Ethernet Enabled.
 *
 * This bit is set to 1 when the Enable Energy Efficient Ethernet (EEE) option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_EEESEL register field. */
#define CORE_MAC_HW_FEATURE0_EEESEL_LSB	       13
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_EEESEL register field. */
#define CORE_MAC_HW_FEATURE0_EEESEL_MSB	       13
/* The width in bits of the CORE_MAC_HW_FEATURE0_EEESEL register field. */
#define CORE_MAC_HW_FEATURE0_EEESEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_EEESEL register field value. */
#define CORE_MAC_HW_FEATURE0_EEESEL_SET_MSK    0x00002000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_EEESEL register field value. */
#define CORE_MAC_HW_FEATURE0_EEESEL_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MAC_HW_FEATURE0_EEESEL register field. */
#define CORE_MAC_HW_FEATURE0_EEESEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_EEESEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_EEESEL_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_HW_FEATURE0_EEESEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_EEESEL_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : TXCOESEL
 *
 * Transmit Checksum Offload Enabled.
 *
 * This bit is set to 1 when the Enable Transmit TCP/IP Checksum Offload option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_TXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_LSB	 14
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_TXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_MSB	 14
/* The width in bits of the CORE_MAC_HW_FEATURE0_TXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_WIDTH	 1
/* The mask used to set the CORE_MAC_HW_FEATURE0_TXCOESEL register field value. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_SET_MSK	 0x00004000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_TXCOESEL register field value. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_CLR_MSK	 0xffffbfff
/* The reset value of the CORE_MAC_HW_FEATURE0_TXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_RESET	 0x1
/* Extracts the CORE_MAC_HW_FEATURE0_TXCOESEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MAC_HW_FEATURE0_TXCOESEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_TXCOESEL_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : Reserved_15
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RESERVED_15 register field.
 */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_LSB	    15
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RESERVED_15 register field.
 */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_MSB	    15
/* The width in bits of the CORE_MAC_HW_FEATURE0_RESERVED_15 register field. */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RESERVED_15 register field value. */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_SET_MSK    0x00008000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RESERVED_15 register field value. */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MAC_HW_FEATURE0_RESERVED_15 register field. */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE0_RESERVED_15 field value from a register. */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_HW_FEATURE0_RESERVED_15 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE0_RESERVED_15_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : RXCOESEL
 *
 * Receive Checksum Offload Enabled.
 *
 * This bit is set to 1 when the Enable Receive TCP/IP Checksum Check option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_LSB	 16
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_MSB	 16
/* The width in bits of the CORE_MAC_HW_FEATURE0_RXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_WIDTH	 1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RXCOESEL register field value. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_SET_MSK	 0x00010000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RXCOESEL register field value. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_CLR_MSK	 0xfffeffff
/* The reset value of the CORE_MAC_HW_FEATURE0_RXCOESEL register field. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_RESET	 0x1
/* Extracts the CORE_MAC_HW_FEATURE0_RXCOESEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_HW_FEATURE0_RXCOESEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_RXCOESEL_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : Reserved_17
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RESERVED_17 register field.
 */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_LSB	    17
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RESERVED_17 register field.
 */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_MSB	    17
/* The width in bits of the CORE_MAC_HW_FEATURE0_RESERVED_17 register field. */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RESERVED_17 register field value. */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_SET_MSK    0x00020000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RESERVED_17 register field value. */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MAC_HW_FEATURE0_RESERVED_17 register field. */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE0_RESERVED_17 field value from a register. */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_HW_FEATURE0_RESERVED_17 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE0_RESERVED_17_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : ADDMACADRSEL
 *
 * MAC Addresses 1-31 Selected.
 *
 * This field gives the number of additional MAC addresses selected using the
 * Enable Additional 1-31 MAC Address Registers option.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field.
 */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_LSB	     18
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field.
 */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_MSB	     22
/* The width in bits of the CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field. */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_WIDTH	     5
/* The mask used to set the CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field value. */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_SET_MSK    0x007c0000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field value. */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_CLR_MSK    0xff83ffff
/* The reset value of the CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field. */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_RESET	     0x1f
/* Extracts the CORE_MAC_HW_FEATURE0_ADDMACADRSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_GET(value) (((value)&0x007c0000) >> 18)
/* Produces a CORE_MAC_HW_FEATURE0_ADDMACADRSEL register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE0_ADDMACADRSEL_SET(value) (((value) << 18) & 0x007c0000)

/*
 * Field : PHYSEL
 *
 * RGMII Interface Select
 *
 * This field reflect the IO value of phy_intf_sel_i which when set to 1 indicates
 * RGMII interface is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_PHYSEL register field. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_LSB	       23
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_PHYSEL register field. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_MSB	       24
/* The width in bits of the CORE_MAC_HW_FEATURE0_PHYSEL register field. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE0_PHYSEL register field value. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_SET_MSK    0x01800000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_PHYSEL register field value. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_CLR_MSK    0xfe7fffff
/* The reset value of the CORE_MAC_HW_FEATURE0_PHYSEL register field. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE0_PHYSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_GET(value) (((value)&0x01800000) >> 23)
/* Produces a CORE_MAC_HW_FEATURE0_PHYSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_PHYSEL_SET(value) (((value) << 23) & 0x01800000)

/*
 * Field : TSSTSSEL
 *
 * Timestamp System Time Source.
 *
 * This bit indicates the source of the Timestamp system time:
 *
 * * 01: Internal
 *
 * * 10: External
 *
 * * 11: Both
 *
 * * 00: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_TSSTSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_LSB	 25
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_TSSTSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_MSB	 26
/* The width in bits of the CORE_MAC_HW_FEATURE0_TSSTSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_WIDTH	 2
/* The mask used to set the CORE_MAC_HW_FEATURE0_TSSTSSEL register field value. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_SET_MSK	 0x06000000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_TSSTSSEL register field value. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_CLR_MSK	 0xf9ffffff
/* The reset value of the CORE_MAC_HW_FEATURE0_TSSTSSEL register field. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_RESET	 0x1
/* Extracts the CORE_MAC_HW_FEATURE0_TSSTSSEL field value from a register. */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_GET(value) (((value)&0x06000000) >> 25)
/* Produces a CORE_MAC_HW_FEATURE0_TSSTSSEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_TSSTSSEL_SET(value) (((value) << 25) & 0x06000000)

/*
 * Field : SAVLANINS
 *
 * Source Address or VLAN Insertion Enable.
 *
 * This bit is set to 1 when the Enable SA and VLAN Insertion on Tx option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_SAVLANINS register field. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_LSB	  27
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_SAVLANINS register field. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_MSB	  27
/* The width in bits of the CORE_MAC_HW_FEATURE0_SAVLANINS register field. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_WIDTH	  1
/* The mask used to set the CORE_MAC_HW_FEATURE0_SAVLANINS register field value. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_SET_MSK	  0x08000000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_SAVLANINS register field value. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_CLR_MSK	  0xf7ffffff
/* The reset value of the CORE_MAC_HW_FEATURE0_SAVLANINS register field. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_RESET	  0x1
/* Extracts the CORE_MAC_HW_FEATURE0_SAVLANINS field value from a register. */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MAC_HW_FEATURE0_SAVLANINS register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE0_SAVLANINS_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : Reserved_28
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_RESERVED_28 register field.
 */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_LSB	    28
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_RESERVED_28 register field.
 */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_MSB	    28
/* The width in bits of the CORE_MAC_HW_FEATURE0_RESERVED_28 register field. */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE0_RESERVED_28 register field value. */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_SET_MSK    0x10000000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_RESERVED_28 register field value. */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_CLR_MSK    0xefffffff
/* The reset value of the CORE_MAC_HW_FEATURE0_RESERVED_28 register field. */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE0_RESERVED_28 field value from a register. */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MAC_HW_FEATURE0_RESERVED_28 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE0_RESERVED_28_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : VXN
 *
 * VxLAN/NVGRE Support.
 *
 * When set to 1 then the support for VxLAN/NVGRE is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_VXN register field. */
#define CORE_MAC_HW_FEATURE0_VXN_LSB	    29
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_VXN register field. */
#define CORE_MAC_HW_FEATURE0_VXN_MSB	    29
/* The width in bits of the CORE_MAC_HW_FEATURE0_VXN register field. */
#define CORE_MAC_HW_FEATURE0_VXN_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE0_VXN register field value. */
#define CORE_MAC_HW_FEATURE0_VXN_SET_MSK    0x20000000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_VXN register field value. */
#define CORE_MAC_HW_FEATURE0_VXN_CLR_MSK    0xdfffffff
/* The reset value of the CORE_MAC_HW_FEATURE0_VXN register field. */
#define CORE_MAC_HW_FEATURE0_VXN_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE0_VXN field value from a register. */
#define CORE_MAC_HW_FEATURE0_VXN_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MAC_HW_FEATURE0_VXN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_VXN_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : EDIFFC
 *
 * Different Descriptor Cache.
 *
 * When set to 1, then DMA mode Separate Memory is selected for the Descriptor
 * Cache.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_EDIFFC register field. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_EDIFFC register field. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_MSB	       30
/* The width in bits of the CORE_MAC_HW_FEATURE0_EDIFFC register field. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE0_EDIFFC register field value. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_EDIFFC register field value. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_HW_FEATURE0_EDIFFC register field. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE0_EDIFFC field value from a register. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_HW_FEATURE0_EDIFFC register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_EDIFFC_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : EDMA
 *
 * Enhanced DMA.
 *
 * This bit is set to 1 when the "Enhanced DMA" option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE0_EDMA register field. */
#define CORE_MAC_HW_FEATURE0_EDMA_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE0_EDMA register field. */
#define CORE_MAC_HW_FEATURE0_EDMA_MSB	     31
/* The width in bits of the CORE_MAC_HW_FEATURE0_EDMA register field. */
#define CORE_MAC_HW_FEATURE0_EDMA_WIDTH	     1
/* The mask used to set the CORE_MAC_HW_FEATURE0_EDMA register field value. */
#define CORE_MAC_HW_FEATURE0_EDMA_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_HW_FEATURE0_EDMA register field value. */
#define CORE_MAC_HW_FEATURE0_EDMA_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_HW_FEATURE0_EDMA register field. */
#define CORE_MAC_HW_FEATURE0_EDMA_RESET	     0x1
/* Extracts the CORE_MAC_HW_FEATURE0_EDMA field value from a register. */
#define CORE_MAC_HW_FEATURE0_EDMA_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_HW_FEATURE0_EDMA register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE0_EDMA_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HW_FEATURE0.
 */
struct CORE_MAC_HW_FEATURE0_s {
	const volatile uint32_t RGMIISEL : 1;	  /* CORE_MAC_HW_FEATURE0_RGMIISEL */
	const volatile uint32_t GMIISEL : 1;	  /* CORE_MAC_HW_FEATURE0_GMIISEL */
	const volatile uint32_t RMIISEL : 1;	  /* CORE_MAC_HW_FEATURE0_RMIISEL */
	const volatile uint32_t HDSEL : 1;	  /* CORE_MAC_HW_FEATURE0_HDSEL */
	const volatile uint32_t VLHASH : 1;	  /* CORE_MAC_HW_FEATURE0_VLHASH */
	const volatile uint32_t SMASEL : 1;	  /* CORE_MAC_HW_FEATURE0_SMASEL */
	const volatile uint32_t RWKSEL : 1;	  /* CORE_MAC_HW_FEATURE0_RWKSEL */
	const volatile uint32_t MGKSEL : 1;	  /* CORE_MAC_HW_FEATURE0_MGKSEL */
	const volatile uint32_t MMCSEL : 1;	  /* CORE_MAC_HW_FEATURE0_MMCSEL */
	const volatile uint32_t ARPOFFSEL : 1;	  /* CORE_MAC_HW_FEATURE0_ARPOFFSEL */
	const volatile uint32_t RAVSEL : 1;	  /* CORE_MAC_HW_FEATURE0_RAVSEL */
	const volatile uint32_t AVSEL : 1;	  /* CORE_MAC_HW_FEATURE0_AVSEL */
	const volatile uint32_t TSSEL : 1;	  /* CORE_MAC_HW_FEATURE0_TSSEL */
	const volatile uint32_t EEESEL : 1;	  /* CORE_MAC_HW_FEATURE0_EEESEL */
	const volatile uint32_t TXCOESEL : 1;	  /* CORE_MAC_HW_FEATURE0_TXCOESEL */
	const volatile uint32_t Reserved_15 : 1;  /* CORE_MAC_HW_FEATURE0_RESERVED_15 */
	const volatile uint32_t RXCOESEL : 1;	  /* CORE_MAC_HW_FEATURE0_RXCOESEL */
	const volatile uint32_t Reserved_17 : 1;  /* CORE_MAC_HW_FEATURE0_RESERVED_17 */
	const volatile uint32_t ADDMACADRSEL : 5; /* CORE_MAC_HW_FEATURE0_ADDMACADRSEL */
	const volatile uint32_t PHYSEL : 2;	  /* CORE_MAC_HW_FEATURE0_PHYSEL */
	const volatile uint32_t TSSTSSEL : 2;	  /* CORE_MAC_HW_FEATURE0_TSSTSSEL */
	const volatile uint32_t SAVLANINS : 1;	  /* CORE_MAC_HW_FEATURE0_SAVLANINS */
	const volatile uint32_t Reserved_28 : 1;  /* CORE_MAC_HW_FEATURE0_RESERVED_28 */
	const volatile uint32_t VXN : 1;	  /* CORE_MAC_HW_FEATURE0_VXN */
	const volatile uint32_t EDIFFC : 1;	  /* CORE_MAC_HW_FEATURE0_EDIFFC */
	const volatile uint32_t EDMA : 1;	  /* CORE_MAC_HW_FEATURE0_EDMA */
};

/* The typedef declaration for register CORE_MAC_HW_FEATURE0. */
typedef struct CORE_MAC_HW_FEATURE0_s CORE_MAC_HW_FEATURE0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HW_FEATURE0 register. */
#define CORE_MAC_HW_FEATURE0_RESET 0xca7d7b3f
/* The byte offset of the CORE_MAC_HW_FEATURE0 register from the beginning of the component. */
#define CORE_MAC_HW_FEATURE0_OFST  0x11c

/*
 * Register : MAC_HW_Feature1
 *
 * This register indicates the presence of second set of the optional features or
 * functions of DWC_xgmac. The software driver can use this register to dynamically
 * enable or disable the programs related to the optional blocks.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------
 *  [4:0]   | R      | 0x7   | CORE_MAC_HW_FEATURE1_RXFIFOSIZE
 *  [5]     | R      | 0x1   | CORE_MAC_HW_FEATURE1_PFCEN
 *  [10:6]  | R      | 0x8   | CORE_MAC_HW_FEATURE1_TXFIFOSIZE
 *  [11]    | R      | 0x1   | CORE_MAC_HW_FEATURE1_OSTEN
 *  [12]    | R      | 0x1   | CORE_MAC_HW_FEATURE1_PTOEN
 *  [13]    | R      | 0x1   | CORE_MAC_HW_FEATURE1_ADVTHWORD
 *  [15:14] | R      | 0x1   | CORE_MAC_HW_FEATURE1_ADDR64
 *  [16]    | R      | 0x1   | CORE_MAC_HW_FEATURE1_DCBEN
 *  [17]    | R      | 0x1   | CORE_MAC_HW_FEATURE1_SPHEN
 *  [18]    | R      | 0x1   | CORE_MAC_HW_FEATURE1_TSOEN
 *  [19]    | R      | 0x0   | CORE_MAC_HW_FEATURE1_DBGMEMA
 *  [20]    | R      | 0x0   | CORE_MAC_HW_FEATURE1_RSSEN
 *  [23:21] | R      | 0x7   | CORE_MAC_HW_FEATURE1_NUMTC
 *  [26:24] | R      | 0x1   | CORE_MAC_HW_FEATURE1_HASHTBLSZ
 *  [30:27] | R      | 0x9   | CORE_MAC_HW_FEATURE1_L3L4FNUM
 *  [31]    | R      | 0x0   | CORE_MAC_HW_FEATURE1_RESERVED_31
 *
 */
/*
 * Field : RXFIFOSIZE
 *
 * MTL Receive FIFO Size.
 *
 * This field contains the configured value of MTL Rx FIFO in bytes expressed as
 * Log to base 2 minus 7, that is, Log2(MTL Receive FIFO Size in bytes) - 7:
 *
 * * 4'b00011: 1024 bytes
 *
 * * 4'b00100: 2048 bytes
 *
 * * 4'b00101: 4096 bytes
 *
 * * 4'b00110: 8192 bytes
 *
 * * 4'b00111: 16384 bytes
 *
 * * 4'b01000: 32 KB
 *
 * * 4'b01001: 64 KB
 *
 * * 4'b01010: 128 KB
 *
 * * 4'b01011: 256 KB
 *
 * * 4'b01100-4'b11111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field.
 */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_MSB	   4
/* The width in bits of the CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_WIDTH	   5
/* The mask used to set the CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field value. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_SET_MSK	   0x0000001f
/* The mask used to clear the CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field value. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_CLR_MSK	   0xffffffe0
/* The reset value of the CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_RESET	   0x7
/* Extracts the CORE_MAC_HW_FEATURE1_RXFIFOSIZE field value from a register. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_GET(value) (((value)&0x0000001f) >> 0)
/* Produces a CORE_MAC_HW_FEATURE1_RXFIFOSIZE register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE1_RXFIFOSIZE_SET(value) (((value) << 0) & 0x0000001f)

/*
 * Field : PFCEN
 *
 * PFC Enable
 *
 * This bit is set to 1 when the Enable PFC Feature is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_PFCEN register field. */
#define CORE_MAC_HW_FEATURE1_PFCEN_LSB	      5
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_PFCEN register field. */
#define CORE_MAC_HW_FEATURE1_PFCEN_MSB	      5
/* The width in bits of the CORE_MAC_HW_FEATURE1_PFCEN register field. */
#define CORE_MAC_HW_FEATURE1_PFCEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_PFCEN register field value. */
#define CORE_MAC_HW_FEATURE1_PFCEN_SET_MSK    0x00000020
/* The mask used to clear the CORE_MAC_HW_FEATURE1_PFCEN register field value. */
#define CORE_MAC_HW_FEATURE1_PFCEN_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MAC_HW_FEATURE1_PFCEN register field. */
#define CORE_MAC_HW_FEATURE1_PFCEN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_PFCEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_PFCEN_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_HW_FEATURE1_PFCEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_PFCEN_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : TXFIFOSIZE
 *
 * MTL Transmit FIFO Size.
 *
 * This field contains the configured value of MTL Tx FIFO in bytes expressed as
 * Log to base 2 minus 7, that is, Log2(MTL Transmit FIFO Size in bytes) - 7:
 *
 * * 4'b00011: 1024 bytes
 *
 * * 4'b00100: 2048 bytes
 *
 * * 4'b00101: 4096 bytes
 *
 * * 4'b00110: 8192 bytes
 *
 * * 4'b00111: 16384 bytes
 *
 * * 4'b01000: 32 KB
 *
 * * 4'b01001: 64 KB
 *
 * * 4'b01010: 128 KB
 *
 * * 4'b01011: 256 KB
 *
 * * 4'b01100-4'b11111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field.
 */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_MSB	   10
/* The width in bits of the CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_WIDTH	   5
/* The mask used to set the CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field value. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_SET_MSK	   0x000007c0
/* The mask used to clear the CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field value. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_CLR_MSK	   0xfffff83f
/* The reset value of the CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_RESET	   0x8
/* Extracts the CORE_MAC_HW_FEATURE1_TXFIFOSIZE field value from a register. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_GET(value) (((value)&0x000007c0) >> 6)
/* Produces a CORE_MAC_HW_FEATURE1_TXFIFOSIZE register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE1_TXFIFOSIZE_SET(value) (((value) << 6) & 0x000007c0)

/*
 * Field : OSTEN
 *
 * One-Step Timestamping Enable.
 *
 * This bit is set to 1 when the Enable One-Step Timestamp Feature is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_OSTEN register field. */
#define CORE_MAC_HW_FEATURE1_OSTEN_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_OSTEN register field. */
#define CORE_MAC_HW_FEATURE1_OSTEN_MSB	      11
/* The width in bits of the CORE_MAC_HW_FEATURE1_OSTEN register field. */
#define CORE_MAC_HW_FEATURE1_OSTEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_OSTEN register field value. */
#define CORE_MAC_HW_FEATURE1_OSTEN_SET_MSK    0x00000800
/* The mask used to clear the CORE_MAC_HW_FEATURE1_OSTEN register field value. */
#define CORE_MAC_HW_FEATURE1_OSTEN_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MAC_HW_FEATURE1_OSTEN register field. */
#define CORE_MAC_HW_FEATURE1_OSTEN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_OSTEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_OSTEN_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_HW_FEATURE1_OSTEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_OSTEN_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : PTOEN
 *
 * PTP Offload Enable.
 *
 * This bit is set to 1 when the Enable PTP Timestamp Offload Feature is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_PTOEN register field. */
#define CORE_MAC_HW_FEATURE1_PTOEN_LSB	      12
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_PTOEN register field. */
#define CORE_MAC_HW_FEATURE1_PTOEN_MSB	      12
/* The width in bits of the CORE_MAC_HW_FEATURE1_PTOEN register field. */
#define CORE_MAC_HW_FEATURE1_PTOEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_PTOEN register field value. */
#define CORE_MAC_HW_FEATURE1_PTOEN_SET_MSK    0x00001000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_PTOEN register field value. */
#define CORE_MAC_HW_FEATURE1_PTOEN_CLR_MSK    0xffffefff
/* The reset value of the CORE_MAC_HW_FEATURE1_PTOEN register field. */
#define CORE_MAC_HW_FEATURE1_PTOEN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_PTOEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_PTOEN_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_HW_FEATURE1_PTOEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_PTOEN_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : ADVTHWORD
 *
 * IEEE 1588 High Word Register Enable.
 *
 * This bit is set to 1 when the Add IEEE 1588 Higher Word Register option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_ADVTHWORD register field. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_LSB	  13
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_ADVTHWORD register field. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_MSB	  13
/* The width in bits of the CORE_MAC_HW_FEATURE1_ADVTHWORD register field. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_WIDTH	  1
/* The mask used to set the CORE_MAC_HW_FEATURE1_ADVTHWORD register field value. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_SET_MSK	  0x00002000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_ADVTHWORD register field value. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_CLR_MSK	  0xffffdfff
/* The reset value of the CORE_MAC_HW_FEATURE1_ADVTHWORD register field. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_RESET	  0x1
/* Extracts the CORE_MAC_HW_FEATURE1_ADVTHWORD field value from a register. */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_HW_FEATURE1_ADVTHWORD register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE1_ADVTHWORD_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : ADDR64
 *
 * Address Width.
 *
 * This field indicates the configured address width:
 *
 * * 2'b00: 32
 *
 * * 2'b01: 40
 *
 * * 2'b10: 48
 *
 * * 2'b11: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_ADDR64 register field. */
#define CORE_MAC_HW_FEATURE1_ADDR64_LSB	       14
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_ADDR64 register field. */
#define CORE_MAC_HW_FEATURE1_ADDR64_MSB	       15
/* The width in bits of the CORE_MAC_HW_FEATURE1_ADDR64 register field. */
#define CORE_MAC_HW_FEATURE1_ADDR64_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE1_ADDR64 register field value. */
#define CORE_MAC_HW_FEATURE1_ADDR64_SET_MSK    0x0000c000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_ADDR64 register field value. */
#define CORE_MAC_HW_FEATURE1_ADDR64_CLR_MSK    0xffff3fff
/* The reset value of the CORE_MAC_HW_FEATURE1_ADDR64 register field. */
#define CORE_MAC_HW_FEATURE1_ADDR64_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_ADDR64 field value from a register. */
#define CORE_MAC_HW_FEATURE1_ADDR64_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MAC_HW_FEATURE1_ADDR64 register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_ADDR64_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : DCBEN
 *
 * DCB Feature Enable.
 *
 * This bit is set to 1 when the Enable Data Center Bridging option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_DCBEN register field. */
#define CORE_MAC_HW_FEATURE1_DCBEN_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_DCBEN register field. */
#define CORE_MAC_HW_FEATURE1_DCBEN_MSB	      16
/* The width in bits of the CORE_MAC_HW_FEATURE1_DCBEN register field. */
#define CORE_MAC_HW_FEATURE1_DCBEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_DCBEN register field value. */
#define CORE_MAC_HW_FEATURE1_DCBEN_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_DCBEN register field value. */
#define CORE_MAC_HW_FEATURE1_DCBEN_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_HW_FEATURE1_DCBEN register field. */
#define CORE_MAC_HW_FEATURE1_DCBEN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_DCBEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_DCBEN_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_HW_FEATURE1_DCBEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_DCBEN_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : SPHEN
 *
 * Header-Payload Split Feature Enable.
 *
 * This bit is set to 1 when the Enable Header-Payload Split Structure option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_SPHEN register field. */
#define CORE_MAC_HW_FEATURE1_SPHEN_LSB	      17
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_SPHEN register field. */
#define CORE_MAC_HW_FEATURE1_SPHEN_MSB	      17
/* The width in bits of the CORE_MAC_HW_FEATURE1_SPHEN register field. */
#define CORE_MAC_HW_FEATURE1_SPHEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_SPHEN register field value. */
#define CORE_MAC_HW_FEATURE1_SPHEN_SET_MSK    0x00020000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_SPHEN register field value. */
#define CORE_MAC_HW_FEATURE1_SPHEN_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MAC_HW_FEATURE1_SPHEN register field. */
#define CORE_MAC_HW_FEATURE1_SPHEN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_SPHEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_SPHEN_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_HW_FEATURE1_SPHEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_SPHEN_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : TSOEN
 *
 * TCP Segmentation Offload Enable.
 *
 * This bit is set to 1 when the Enable TCP Segmentation Offloading for TCP/IP
 * Packets option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_TSOEN register field. */
#define CORE_MAC_HW_FEATURE1_TSOEN_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_TSOEN register field. */
#define CORE_MAC_HW_FEATURE1_TSOEN_MSB	      18
/* The width in bits of the CORE_MAC_HW_FEATURE1_TSOEN register field. */
#define CORE_MAC_HW_FEATURE1_TSOEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_TSOEN register field value. */
#define CORE_MAC_HW_FEATURE1_TSOEN_SET_MSK    0x00040000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_TSOEN register field value. */
#define CORE_MAC_HW_FEATURE1_TSOEN_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MAC_HW_FEATURE1_TSOEN register field. */
#define CORE_MAC_HW_FEATURE1_TSOEN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE1_TSOEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_TSOEN_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_HW_FEATURE1_TSOEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_TSOEN_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : DBGMEMA
 *
 * Debug Memory Interface Enabled.
 *
 * This bit is set to 1 when the Enable Debug Memory Access option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_DBGMEMA register field. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_DBGMEMA register field. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_MSB	19
/* The width in bits of the CORE_MAC_HW_FEATURE1_DBGMEMA register field. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_WIDTH	1
/* The mask used to set the CORE_MAC_HW_FEATURE1_DBGMEMA register field value. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_SET_MSK	0x00080000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_DBGMEMA register field value. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_CLR_MSK	0xfff7ffff
/* The reset value of the CORE_MAC_HW_FEATURE1_DBGMEMA register field. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_RESET	0x0
/* Extracts the CORE_MAC_HW_FEATURE1_DBGMEMA field value from a register. */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_HW_FEATURE1_DBGMEMA register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE1_DBGMEMA_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : RSSEN
 *
 * Internal Register based RSS Feature Enabled
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_RSSEN register field. */
#define CORE_MAC_HW_FEATURE1_RSSEN_LSB	      20
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_RSSEN register field. */
#define CORE_MAC_HW_FEATURE1_RSSEN_MSB	      20
/* The width in bits of the CORE_MAC_HW_FEATURE1_RSSEN register field. */
#define CORE_MAC_HW_FEATURE1_RSSEN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE1_RSSEN register field value. */
#define CORE_MAC_HW_FEATURE1_RSSEN_SET_MSK    0x00100000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_RSSEN register field value. */
#define CORE_MAC_HW_FEATURE1_RSSEN_CLR_MSK    0xffefffff
/* The reset value of the CORE_MAC_HW_FEATURE1_RSSEN register field. */
#define CORE_MAC_HW_FEATURE1_RSSEN_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE1_RSSEN field value from a register. */
#define CORE_MAC_HW_FEATURE1_RSSEN_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_HW_FEATURE1_RSSEN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_RSSEN_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : NUMTC
 *
 * Number of Traffic Classes.
 *
 * This field indicates the number of traffic classes selected:
 *
 * * 3'b000: 1 Traffic Class
 *
 * * 3'b001: 2 Traffic Classes
 *
 * * 3'b010: 3 Traffic Classes
 *
 * * ...
 *
 * * 3'b111: 8 Traffic
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_NUMTC register field. */
#define CORE_MAC_HW_FEATURE1_NUMTC_LSB	      21
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_NUMTC register field. */
#define CORE_MAC_HW_FEATURE1_NUMTC_MSB	      23
/* The width in bits of the CORE_MAC_HW_FEATURE1_NUMTC register field. */
#define CORE_MAC_HW_FEATURE1_NUMTC_WIDTH      3
/* The mask used to set the CORE_MAC_HW_FEATURE1_NUMTC register field value. */
#define CORE_MAC_HW_FEATURE1_NUMTC_SET_MSK    0x00e00000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_NUMTC register field value. */
#define CORE_MAC_HW_FEATURE1_NUMTC_CLR_MSK    0xff1fffff
/* The reset value of the CORE_MAC_HW_FEATURE1_NUMTC register field. */
#define CORE_MAC_HW_FEATURE1_NUMTC_RESET      0x7
/* Extracts the CORE_MAC_HW_FEATURE1_NUMTC field value from a register. */
#define CORE_MAC_HW_FEATURE1_NUMTC_GET(value) (((value)&0x00e00000) >> 21)
/* Produces a CORE_MAC_HW_FEATURE1_NUMTC register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE1_NUMTC_SET(value) (((value) << 21) & 0x00e00000)

/*
 * Field : HASHTBLSZ
 *
 * Hash Table Size.
 *
 * This field indicates the size of the hash table:
 *
 * * 3'b000: No hash table selected
 *
 * * 3'b001: 64
 *
 * * 3'b010: 128
 *
 * * 3'b011: 256
 *
 * * 3'b100: 512
 *
 * * 3'b101: 1024
 *
 * * 3'b110: 2048
 *
 * * 3'b111: 4096
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_HASHTBLSZ register field. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_LSB	  24
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_HASHTBLSZ register field. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_MSB	  26
/* The width in bits of the CORE_MAC_HW_FEATURE1_HASHTBLSZ register field. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_WIDTH	  3
/* The mask used to set the CORE_MAC_HW_FEATURE1_HASHTBLSZ register field value. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_SET_MSK	  0x07000000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_HASHTBLSZ register field value. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_CLR_MSK	  0xf8ffffff
/* The reset value of the CORE_MAC_HW_FEATURE1_HASHTBLSZ register field. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_RESET	  0x1
/* Extracts the CORE_MAC_HW_FEATURE1_HASHTBLSZ field value from a register. */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_GET(value) (((value)&0x07000000) >> 24)
/* Produces a CORE_MAC_HW_FEATURE1_HASHTBLSZ register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE1_HASHTBLSZ_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : L3L4FNUM
 *
 * Total number of L3 or L4 Filters.
 *
 * This field indicates the total number of L3 or L4 filters:
 *
 * * 4'b0000: No L3 or L4 Filter
 *
 * * 4'b0001: 1 L3 or L4 Filter
 *
 * * 4'b0010: 2 L3 or L4 Filters
 *
 * * ...
 *
 * * 4'b1000: 8 L3 or L4
 *
 * * 4'b1001: 16 L3 or L4
 *
 * * 4'b1010: 32 L3 or L4
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_L3L4FNUM register field. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_LSB	 27
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_L3L4FNUM register field. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_MSB	 30
/* The width in bits of the CORE_MAC_HW_FEATURE1_L3L4FNUM register field. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_WIDTH	 4
/* The mask used to set the CORE_MAC_HW_FEATURE1_L3L4FNUM register field value. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_SET_MSK	 0x78000000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_L3L4FNUM register field value. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_CLR_MSK	 0x87ffffff
/* The reset value of the CORE_MAC_HW_FEATURE1_L3L4FNUM register field. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_RESET	 0x9
/* Extracts the CORE_MAC_HW_FEATURE1_L3L4FNUM field value from a register. */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_GET(value) (((value)&0x78000000) >> 27)
/* Produces a CORE_MAC_HW_FEATURE1_L3L4FNUM register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE1_L3L4FNUM_SET(value) (((value) << 27) & 0x78000000)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE1_RESERVED_31 register field.
 */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_LSB	    31
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE1_RESERVED_31 register field.
 */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_MSB	    31
/* The width in bits of the CORE_MAC_HW_FEATURE1_RESERVED_31 register field. */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE1_RESERVED_31 register field value. */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_HW_FEATURE1_RESERVED_31 register field value. */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_HW_FEATURE1_RESERVED_31 register field. */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE1_RESERVED_31 field value from a register. */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_HW_FEATURE1_RESERVED_31 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE1_RESERVED_31_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HW_FEATURE1.
 */
struct CORE_MAC_HW_FEATURE1_s {
	const volatile uint32_t RXFIFOSIZE : 5;	 /* CORE_MAC_HW_FEATURE1_RXFIFOSIZE */
	const volatile uint32_t PFCEN : 1;	 /* CORE_MAC_HW_FEATURE1_PFCEN */
	const volatile uint32_t TXFIFOSIZE : 5;	 /* CORE_MAC_HW_FEATURE1_TXFIFOSIZE */
	const volatile uint32_t OSTEN : 1;	 /* CORE_MAC_HW_FEATURE1_OSTEN */
	const volatile uint32_t PTOEN : 1;	 /* CORE_MAC_HW_FEATURE1_PTOEN */
	const volatile uint32_t ADVTHWORD : 1;	 /* CORE_MAC_HW_FEATURE1_ADVTHWORD */
	const volatile uint32_t ADDR64 : 2;	 /* CORE_MAC_HW_FEATURE1_ADDR64 */
	const volatile uint32_t DCBEN : 1;	 /* CORE_MAC_HW_FEATURE1_DCBEN */
	const volatile uint32_t SPHEN : 1;	 /* CORE_MAC_HW_FEATURE1_SPHEN */
	const volatile uint32_t TSOEN : 1;	 /* CORE_MAC_HW_FEATURE1_TSOEN */
	const volatile uint32_t DBGMEMA : 1;	 /* CORE_MAC_HW_FEATURE1_DBGMEMA */
	const volatile uint32_t RSSEN : 1;	 /* CORE_MAC_HW_FEATURE1_RSSEN */
	const volatile uint32_t NUMTC : 3;	 /* CORE_MAC_HW_FEATURE1_NUMTC */
	const volatile uint32_t HASHTBLSZ : 3;	 /* CORE_MAC_HW_FEATURE1_HASHTBLSZ */
	const volatile uint32_t L3L4FNUM : 4;	 /* CORE_MAC_HW_FEATURE1_L3L4FNUM */
	const volatile uint32_t Reserved_31 : 1; /* CORE_MAC_HW_FEATURE1_RESERVED_31 */
};

/* The typedef declaration for register CORE_MAC_HW_FEATURE1. */
typedef struct CORE_MAC_HW_FEATURE1_s CORE_MAC_HW_FEATURE1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HW_FEATURE1 register. */
#define CORE_MAC_HW_FEATURE1_RESET 0x49e77a27
/* The byte offset of the CORE_MAC_HW_FEATURE1 register from the beginning of the component. */
#define CORE_MAC_HW_FEATURE1_OFST  0x120

/*
 * Register : MAC_HW_Feature2
 *
 * This register indicates the presence of the third set of optional features or
 * functions of DWC_xgmac. The software driver can use this register to dynamically
 * enable or disable the programs related to the optional blocks.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------
 *  [3:0]   | R      | 0x7   | CORE_MAC_HW_FEATURE2_RXQCNT
 *  [5:4]   | R      | 0x0   | CORE_MAC_HW_FEATURE2_RESERVED_5_4
 *  [9:6]   | R      | 0x7   | CORE_MAC_HW_FEATURE2_TXQCNT
 *  [11:10] | R      | 0x0   | CORE_MAC_HW_FEATURE2_RESERVED_11_10
 *  [15:12] | R      | 0x7   | CORE_MAC_HW_FEATURE2_RXCHCNT
 *  [17:16] | R      | 0x0   | CORE_MAC_HW_FEATURE2_RESERVED_17_16
 *  [21:18] | R      | 0x7   | CORE_MAC_HW_FEATURE2_TXCHCNT
 *  [23:22] | R      | 0x0   | CORE_MAC_HW_FEATURE2_RESERVED_23_22
 *  [26:24] | R      | 0x2   | CORE_MAC_HW_FEATURE2_PPSOUTNUM
 *  [27]    | R      | 0x0   | CORE_MAC_HW_FEATURE2_RESERVED_27
 *  [30:28] | R      | 0x2   | CORE_MAC_HW_FEATURE2_AUXSNAPNUM
 *  [31]    | R      | 0x0   | CORE_MAC_HW_FEATURE2_RESERVED_31
 *
 */
/*
 * Field : RXQCNT
 *
 * Number of MTL Receive Queues.
 *
 * This field indicates the number of MTL Receive queues:
 *
 * * 4'b0000: 1 MTL Rx Queue
 *
 * * 4'b0001: 2 MTL Rx Queues
 *
 * * ...
 *
 * * 4'b1011: 12 MTL Rx Queues
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_MSB	       3
/* The width in bits of the CORE_MAC_HW_FEATURE2_RXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_WIDTH      4
/* The mask used to set the CORE_MAC_HW_FEATURE2_RXQCNT register field value. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_SET_MSK    0x0000000f
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RXQCNT register field value. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_CLR_MSK    0xfffffff0
/* The reset value of the CORE_MAC_HW_FEATURE2_RXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_RESET      0x7
/* Extracts the CORE_MAC_HW_FEATURE2_RXQCNT field value from a register. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a CORE_MAC_HW_FEATURE2_RXQCNT register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE2_RXQCNT_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : Reserved_5_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field.
 */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field.
 */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_MSB	     5
/* The width in bits of the CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_WIDTH	     2
/* The mask used to set the CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_SET_MSK    0x00000030
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_CLR_MSK    0xffffffcf
/* The reset value of the CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_RESET	     0x0
/* Extracts the CORE_MAC_HW_FEATURE2_RESERVED_5_4 field value from a register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_GET(value) (((value)&0x00000030) >> 4)
/* Produces a CORE_MAC_HW_FEATURE2_RESERVED_5_4 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_5_4_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : TXQCNT
 *
 * Number of MTL Transmit Queues.
 *
 * This field indicates the number of MTL Transmit queues:
 *
 * * 4'b0000: 1 MTL Tx Queue
 *
 * * 4'b0001: 2 MTL Tx Queues
 *
 * * ...
 *
 * * 4'b1111: 16 MTL Tx Queues
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_TXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_LSB	       6
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_TXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_MSB	       9
/* The width in bits of the CORE_MAC_HW_FEATURE2_TXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_WIDTH      4
/* The mask used to set the CORE_MAC_HW_FEATURE2_TXQCNT register field value. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_SET_MSK    0x000003c0
/* The mask used to clear the CORE_MAC_HW_FEATURE2_TXQCNT register field value. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_CLR_MSK    0xfffffc3f
/* The reset value of the CORE_MAC_HW_FEATURE2_TXQCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_RESET      0x7
/* Extracts the CORE_MAC_HW_FEATURE2_TXQCNT field value from a register. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_GET(value) (((value)&0x000003c0) >> 6)
/* Produces a CORE_MAC_HW_FEATURE2_TXQCNT register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE2_TXQCNT_SET(value) (((value) << 6) & 0x000003c0)

/*
 * Field : Reserved_11_10
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_11_10 register
 * field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_LSB	       10
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_11_10 register
 * field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_MSB	       11
/* The width in bits of the CORE_MAC_HW_FEATURE2_RESERVED_11_10 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE2_RESERVED_11_10 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_SET_MSK    0x00000c00
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RESERVED_11_10 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_CLR_MSK    0xfffff3ff
/* The reset value of the CORE_MAC_HW_FEATURE2_RESERVED_11_10 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE2_RESERVED_11_10 field value from a register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_GET(value) (((value)&0x00000c00) >> 10)
/* Produces a CORE_MAC_HW_FEATURE2_RESERVED_11_10 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_11_10_SET(value) (((value) << 10) & 0x00000c00)

/*
 * Field : RXCHCNT
 *
 * Number of DMA Receive Channels.
 *
 * This field indicates the number of DMA Receive channels:
 *
 * * 4'b0000: 1 DMA Rx Channel
 *
 * * 4'b0001: 2 DMA Rx Channels
 *
 * * ...
 *
 * * 4'b1111: 16 DMA Rx Channels
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_LSB	12
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_MSB	15
/* The width in bits of the CORE_MAC_HW_FEATURE2_RXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_WIDTH	4
/* The mask used to set the CORE_MAC_HW_FEATURE2_RXCHCNT register field value. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_SET_MSK	0x0000f000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RXCHCNT register field value. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_CLR_MSK	0xffff0fff
/* The reset value of the CORE_MAC_HW_FEATURE2_RXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_RESET	0x7
/* Extracts the CORE_MAC_HW_FEATURE2_RXCHCNT field value from a register. */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_GET(value) (((value)&0x0000f000) >> 12)
/* Produces a CORE_MAC_HW_FEATURE2_RXCHCNT register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE2_RXCHCNT_SET(value) (((value) << 12) & 0x0000f000)

/*
 * Field : Reserved_17_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_17_16 register
 * field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_17_16 register
 * field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_MSB	       17
/* The width in bits of the CORE_MAC_HW_FEATURE2_RESERVED_17_16 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE2_RESERVED_17_16 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_SET_MSK    0x00030000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RESERVED_17_16 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_CLR_MSK    0xfffcffff
/* The reset value of the CORE_MAC_HW_FEATURE2_RESERVED_17_16 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE2_RESERVED_17_16 field value from a register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_GET(value) (((value)&0x00030000) >> 16)
/* Produces a CORE_MAC_HW_FEATURE2_RESERVED_17_16 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_17_16_SET(value) (((value) << 16) & 0x00030000)

/*
 * Field : TXCHCNT
 *
 * Number of DMA Transmit Channels.
 *
 * This field indicates the number of DMA Transmit channels:
 *
 * * 4'b0000: 1 DMA Tx Channel
 *
 * * 4'b0001: 2 DMA Tx Channels
 *
 * * ...
 *
 * * 4'b1111: 16 DMA Tx Channels
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_TXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_LSB	18
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_TXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_MSB	21
/* The width in bits of the CORE_MAC_HW_FEATURE2_TXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_WIDTH	4
/* The mask used to set the CORE_MAC_HW_FEATURE2_TXCHCNT register field value. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_SET_MSK	0x003c0000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_TXCHCNT register field value. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_CLR_MSK	0xffc3ffff
/* The reset value of the CORE_MAC_HW_FEATURE2_TXCHCNT register field. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_RESET	0x7
/* Extracts the CORE_MAC_HW_FEATURE2_TXCHCNT field value from a register. */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_GET(value) (((value)&0x003c0000) >> 18)
/* Produces a CORE_MAC_HW_FEATURE2_TXCHCNT register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE2_TXCHCNT_SET(value) (((value) << 18) & 0x003c0000)

/*
 * Field : Reserved_23_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_23_22 register
 * field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_LSB	       22
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_23_22 register
 * field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_MSB	       23
/* The width in bits of the CORE_MAC_HW_FEATURE2_RESERVED_23_22 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE2_RESERVED_23_22 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_SET_MSK    0x00c00000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RESERVED_23_22 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_CLR_MSK    0xff3fffff
/* The reset value of the CORE_MAC_HW_FEATURE2_RESERVED_23_22 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE2_RESERVED_23_22 field value from a register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_GET(value) (((value)&0x00c00000) >> 22)
/* Produces a CORE_MAC_HW_FEATURE2_RESERVED_23_22 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_23_22_SET(value) (((value) << 22) & 0x00c00000)

/*
 * Field : PPSOUTNUM
 *
 * Number of PPS Outputs.
 *
 * This field indicates the number of PPS outputs:
 *
 * * 3'b000: No PPS output
 *
 * * 3'b001: 1 PPS output
 *
 * * 3'b010: 2 PPS outputs
 *
 * * 3'b011: 3 PPS outputs
 *
 * * 3'b100: 4 PPS outputs
 *
 * * 3'b101 - 3'b111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_PPSOUTNUM register field. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_LSB	  24
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_PPSOUTNUM register field. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_MSB	  26
/* The width in bits of the CORE_MAC_HW_FEATURE2_PPSOUTNUM register field. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_WIDTH	  3
/* The mask used to set the CORE_MAC_HW_FEATURE2_PPSOUTNUM register field value. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_SET_MSK	  0x07000000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_PPSOUTNUM register field value. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_CLR_MSK	  0xf8ffffff
/* The reset value of the CORE_MAC_HW_FEATURE2_PPSOUTNUM register field. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_RESET	  0x2
/* Extracts the CORE_MAC_HW_FEATURE2_PPSOUTNUM field value from a register. */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_GET(value) (((value)&0x07000000) >> 24)
/* Produces a CORE_MAC_HW_FEATURE2_PPSOUTNUM register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE2_PPSOUTNUM_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : Reserved_27
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_27 register field.
 */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_LSB	    27
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_27 register field.
 */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_MSB	    27
/* The width in bits of the CORE_MAC_HW_FEATURE2_RESERVED_27 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE2_RESERVED_27 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_SET_MSK    0x08000000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RESERVED_27 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MAC_HW_FEATURE2_RESERVED_27 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE2_RESERVED_27 field value from a register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MAC_HW_FEATURE2_RESERVED_27 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_27_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : AUXSNAPNUM
 *
 * Number of Auxiliary Snapshot Inputs.
 *
 * This field indicates the number of auxiliary snapshot inputs:
 *
 * * 3'b000: No auxiliary input
 *
 * * 3'b001: 1 auxiliary input
 *
 * * 3'b010: 2 auxiliary inputs
 *
 * * 3'b011: 3 auxiliary inputs
 *
 * * 3'b100: 4 auxiliary inputs
 *
 * * 3'b101 - 3'b111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field.
 */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_LSB	   28
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_MSB	   30
/* The width in bits of the CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_WIDTH	   3
/* The mask used to set the CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field value. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_SET_MSK	   0x70000000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field value. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_CLR_MSK	   0x8fffffff
/* The reset value of the CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_RESET	   0x2
/* Extracts the CORE_MAC_HW_FEATURE2_AUXSNAPNUM field value from a register. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_GET(value) (((value)&0x70000000) >> 28)
/* Produces a CORE_MAC_HW_FEATURE2_AUXSNAPNUM register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_AUXSNAPNUM_SET(value) (((value) << 28) & 0x70000000)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_31 register field.
 */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_LSB	    31
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE2_RESERVED_31 register field.
 */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_MSB	    31
/* The width in bits of the CORE_MAC_HW_FEATURE2_RESERVED_31 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_WIDTH	    1
/* The mask used to set the CORE_MAC_HW_FEATURE2_RESERVED_31 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_HW_FEATURE2_RESERVED_31 register field value. */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_HW_FEATURE2_RESERVED_31 register field. */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE2_RESERVED_31 field value from a register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_HW_FEATURE2_RESERVED_31 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE2_RESERVED_31_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HW_FEATURE2.
 */
struct CORE_MAC_HW_FEATURE2_s {
	const volatile uint32_t RXQCNT : 4;	    /* CORE_MAC_HW_FEATURE2_RXQCNT */
	const volatile uint32_t Reserved_5_4 : 2;   /* CORE_MAC_HW_FEATURE2_RESERVED_5_4 */
	const volatile uint32_t TXQCNT : 4;	    /* CORE_MAC_HW_FEATURE2_TXQCNT */
	const volatile uint32_t Reserved_11_10 : 2; /* CORE_MAC_HW_FEATURE2_RESERVED_11_10 */
	const volatile uint32_t RXCHCNT : 4;	    /* CORE_MAC_HW_FEATURE2_RXCHCNT */
	const volatile uint32_t Reserved_17_16 : 2; /* CORE_MAC_HW_FEATURE2_RESERVED_17_16 */
	const volatile uint32_t TXCHCNT : 4;	    /* CORE_MAC_HW_FEATURE2_TXCHCNT */
	const volatile uint32_t Reserved_23_22 : 2; /* CORE_MAC_HW_FEATURE2_RESERVED_23_22 */
	const volatile uint32_t PPSOUTNUM : 3;	    /* CORE_MAC_HW_FEATURE2_PPSOUTNUM */
	const volatile uint32_t Reserved_27 : 1;    /* CORE_MAC_HW_FEATURE2_RESERVED_27 */
	const volatile uint32_t AUXSNAPNUM : 3;	    /* CORE_MAC_HW_FEATURE2_AUXSNAPNUM */
	const volatile uint32_t Reserved_31 : 1;    /* CORE_MAC_HW_FEATURE2_RESERVED_31 */
};

/* The typedef declaration for register CORE_MAC_HW_FEATURE2. */
typedef struct CORE_MAC_HW_FEATURE2_s CORE_MAC_HW_FEATURE2_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HW_FEATURE2 register. */
#define CORE_MAC_HW_FEATURE2_RESET 0x221c71c7
/* The byte offset of the CORE_MAC_HW_FEATURE2 register from the beginning of the component. */
#define CORE_MAC_HW_FEATURE2_OFST  0x124

/*
 * Register : MAC_HW_Feature3
 *
 * This register indicates the presence of the fourth set of optional features or
 * functions of DWC_xgmac. The software driver can use this register to dynamically
 * enable or disable the programs related to the optional blocks.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------
 *  [2:0]   | R      | 0x3   | CORE_MAC_HW_FEATURE3_NRVF
 *  [3]     | R      | 0x0   | CORE_MAC_HW_FEATURE3_FRPSEL
 *  [4]     | R      | 0x1   | CORE_MAC_HW_FEATURE3_CBTISEL
 *  [7:5]   | R      | 0x0   | CORE_MAC_HW_FEATURE3_FRPPIPE
 *  [8]     | R      | 0x1   | CORE_MAC_HW_FEATURE3_POUOST
 *  [10:9]  | R      | 0x0   | CORE_MAC_HW_FEATURE3_FRPPB
 *  [12:11] | R      | 0x0   | CORE_MAC_HW_FEATURE3_FRPES
 *  [13]    | R      | 0x1   | CORE_MAC_HW_FEATURE3_DVLAN
 *  [15:14] | R      | 0x0   | CORE_MAC_HW_FEATURE3_ASP
 *  [18:16] | R      | 0x5   | CORE_MAC_HW_FEATURE3_TTSFD
 *  [19]    | R      | 0x1   | CORE_MAC_HW_FEATURE3_ESTSEL
 *  [22:20] | R      | 0x3   | CORE_MAC_HW_FEATURE3_GCLDEP
 *  [24:23] | R      | 0x3   | CORE_MAC_HW_FEATURE3_GCLWID
 *  [25]    | R      | 0x0   | CORE_MAC_HW_FEATURE3_SGFSEL
 *  [26]    | R      | 0x1   | CORE_MAC_HW_FEATURE3_FPESEL
 *  [27]    | R      | 0x1   | CORE_MAC_HW_FEATURE3_TBSSEL
 *  [31:28] | R      | 0x1   | CORE_MAC_HW_FEATURE3_TBS_CH
 *
 */
/*
 * Field : NRVF
 *
 * Enabled number of Extended VLAN Tag Filters or External VLAN tag lookup size
 *
 * This field indicates selected Number of Extended VLAN Tag Filters or External
 * VLAN tag lookup size:
 *
 * * 3'b000: No Extended Rx VLAN Filters
 *
 * * 3'b001: 4 Extended Rx VLAN Filters
 *
 * * 3'b010: 8 Extended Rx VLAN Filters
 *
 * * 3'b011: 16 Extended Rx VLAN Filters
 *
 * * 3'b100: 24 Extended Rx VLAN Filters
 *
 * * 3'b101: 32 Extended Rx VLAN Filters
 *
 * * 3'b110: Reserved
 *
 * * 3'b111: External Receive 12bit VLAN Tag Lookup is selected
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_NRVF register field. */
#define CORE_MAC_HW_FEATURE3_NRVF_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_NRVF register field. */
#define CORE_MAC_HW_FEATURE3_NRVF_MSB	     2
/* The width in bits of the CORE_MAC_HW_FEATURE3_NRVF register field. */
#define CORE_MAC_HW_FEATURE3_NRVF_WIDTH	     3
/* The mask used to set the CORE_MAC_HW_FEATURE3_NRVF register field value. */
#define CORE_MAC_HW_FEATURE3_NRVF_SET_MSK    0x00000007
/* The mask used to clear the CORE_MAC_HW_FEATURE3_NRVF register field value. */
#define CORE_MAC_HW_FEATURE3_NRVF_CLR_MSK    0xfffffff8
/* The reset value of the CORE_MAC_HW_FEATURE3_NRVF register field. */
#define CORE_MAC_HW_FEATURE3_NRVF_RESET	     0x3
/* Extracts the CORE_MAC_HW_FEATURE3_NRVF field value from a register. */
#define CORE_MAC_HW_FEATURE3_NRVF_GET(value) (((value)&0x00000007) >> 0)
/* Produces a CORE_MAC_HW_FEATURE3_NRVF register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_NRVF_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : FRPSEL
 *
 * Supported Flexible Receive Parser.
 *
 * This bit is set to 1 when the Enable Flexible Programmable Receive Parser option
 * is selected.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MAC_HW_FEATURE3_FRPSEL_E_INACTIVE | 0x0   | Flexible Receive Parser feature is not selected
 *  CORE_MAC_HW_FEATURE3_FRPSEL_E_ACTIVE   | 0x1   | Flexible Receive Parser feature is selected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPSEL
 *
 * Flexible Receive Parser feature is not selected
 */
#define CORE_MAC_HW_FEATURE3_FRPSEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPSEL
 *
 * Flexible Receive Parser feature is selected
 */
#define CORE_MAC_HW_FEATURE3_FRPSEL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_FRPSEL register field. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_FRPSEL register field. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_MSB	       3
/* The width in bits of the CORE_MAC_HW_FEATURE3_FRPSEL register field. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_FRPSEL register field value. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_HW_FEATURE3_FRPSEL register field value. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_HW_FEATURE3_FRPSEL register field. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE3_FRPSEL field value from a register. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_HW_FEATURE3_FRPSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_FRPSEL_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : CBTISEL
 *
 * Queue/Channel based VLAN tag insertion on Tx Enable
 *
 * This bit is set to 1 when the Enable Queue/Channel based VLAN tag insertion on
 * Tx Feature is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_CBTISEL register field. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_CBTISEL register field. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_MSB	4
/* The width in bits of the CORE_MAC_HW_FEATURE3_CBTISEL register field. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_WIDTH	1
/* The mask used to set the CORE_MAC_HW_FEATURE3_CBTISEL register field value. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_SET_MSK	0x00000010
/* The mask used to clear the CORE_MAC_HW_FEATURE3_CBTISEL register field value. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_CLR_MSK	0xffffffef
/* The reset value of the CORE_MAC_HW_FEATURE3_CBTISEL register field. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_RESET	0x1
/* Extracts the CORE_MAC_HW_FEATURE3_CBTISEL field value from a register. */
#define CORE_MAC_HW_FEATURE3_CBTISEL_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_HW_FEATURE3_CBTISEL register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE3_CBTISEL_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : FRPPIPE
 *
 * Supported Parallel Instruction Processor Engines (PIPEs)
 *
 * This field indicates the maximum number of Instruction Processors supported by
 * flexible receive parser.
 *
 * Values:
 *
 * * 0x0: 1 PIPE
 *
 * * 0x1: 2 PIPEs
 *
 * * ...
 *
 * * 0x15: 16 PIPEs
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_FRPPIPE register field. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_FRPPIPE register field. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_MSB	7
/* The width in bits of the CORE_MAC_HW_FEATURE3_FRPPIPE register field. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_WIDTH	3
/* The mask used to set the CORE_MAC_HW_FEATURE3_FRPPIPE register field value. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_SET_MSK	0x000000e0
/* The mask used to clear the CORE_MAC_HW_FEATURE3_FRPPIPE register field value. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_CLR_MSK	0xffffff1f
/* The reset value of the CORE_MAC_HW_FEATURE3_FRPPIPE register field. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_RESET	0x0
/* Extracts the CORE_MAC_HW_FEATURE3_FRPPIPE field value from a register. */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_GET(value) (((value)&0x000000e0) >> 5)
/* Produces a CORE_MAC_HW_FEATURE3_FRPPIPE register field value suitable for setting the register.
 */
#define CORE_MAC_HW_FEATURE3_FRPPIPE_SET(value) (((value) << 5) & 0x000000e0)

/*
 * Field : POUOST
 *
 * One Step for PTP over UDP/IP Feature Enable
 *
 * This bit is set to 1 when the Enable One step timestamp for PTP over UDP/IP
 * feature is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_POUOST register field. */
#define CORE_MAC_HW_FEATURE3_POUOST_LSB	       8
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_POUOST register field. */
#define CORE_MAC_HW_FEATURE3_POUOST_MSB	       8
/* The width in bits of the CORE_MAC_HW_FEATURE3_POUOST register field. */
#define CORE_MAC_HW_FEATURE3_POUOST_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_POUOST register field value. */
#define CORE_MAC_HW_FEATURE3_POUOST_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_HW_FEATURE3_POUOST register field value. */
#define CORE_MAC_HW_FEATURE3_POUOST_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_HW_FEATURE3_POUOST register field. */
#define CORE_MAC_HW_FEATURE3_POUOST_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE3_POUOST field value from a register. */
#define CORE_MAC_HW_FEATURE3_POUOST_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_HW_FEATURE3_POUOST register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_POUOST_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : FRPPB
 *
 * Supported Flexible Receive Parser Parsable Bytes
 *
 * This field indicates the supported Max Number of bytes of the packet data to be
 * Parsed by Flexible Receive Parser.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:------------
 *  CORE_MAC_HW_FEATURE3_FRPPB_E_M_64BYTES  | 0x0   | 64 Bytes
 *  CORE_MAC_HW_FEATURE3_FRPPB_E_M_128BYTES | 0x1   | 128 Bytes
 *  CORE_MAC_HW_FEATURE3_FRPPB_E_M_256BYTES | 0x2   | 256 Bytes
 *  CORE_MAC_HW_FEATURE3_FRPPB_E_RSVD       | 0x3   | Reserved
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPPB
 *
 * 64 Bytes
 */
#define CORE_MAC_HW_FEATURE3_FRPPB_E_M_64BYTES	0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPPB
 *
 * 128 Bytes
 */
#define CORE_MAC_HW_FEATURE3_FRPPB_E_M_128BYTES 0x1
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPPB
 *
 * 256 Bytes
 */
#define CORE_MAC_HW_FEATURE3_FRPPB_E_M_256BYTES 0x2
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPPB
 *
 * Reserved
 */
#define CORE_MAC_HW_FEATURE3_FRPPB_E_RSVD	0x3

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_FRPPB register field. */
#define CORE_MAC_HW_FEATURE3_FRPPB_LSB	      9
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_FRPPB register field. */
#define CORE_MAC_HW_FEATURE3_FRPPB_MSB	      10
/* The width in bits of the CORE_MAC_HW_FEATURE3_FRPPB register field. */
#define CORE_MAC_HW_FEATURE3_FRPPB_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE3_FRPPB register field value. */
#define CORE_MAC_HW_FEATURE3_FRPPB_SET_MSK    0x00000600
/* The mask used to clear the CORE_MAC_HW_FEATURE3_FRPPB register field value. */
#define CORE_MAC_HW_FEATURE3_FRPPB_CLR_MSK    0xfffff9ff
/* The reset value of the CORE_MAC_HW_FEATURE3_FRPPB register field. */
#define CORE_MAC_HW_FEATURE3_FRPPB_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE3_FRPPB field value from a register. */
#define CORE_MAC_HW_FEATURE3_FRPPB_GET(value) (((value)&0x00000600) >> 9)
/* Produces a CORE_MAC_HW_FEATURE3_FRPPB register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_FRPPB_SET(value) (((value) << 9) & 0x00000600)

/*
 * Field : FRPES
 *
 * Supported Flexible Receive Parser Instructions
 *
 * This field indicates the Max Number of Parser Instructions supported by Flexible
 * Receive Parser.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:-----------------
 *  CORE_MAC_HW_FEATURE3_FRPES_E_M_64ENTR  | 0x0   | 64 Instructions
 *  CORE_MAC_HW_FEATURE3_FRPES_E_M_128ENTR | 0x1   | 128 Instructions
 *  CORE_MAC_HW_FEATURE3_FRPES_E_M_256ENTR | 0x2   | 256 Instructions
 *  CORE_MAC_HW_FEATURE3_FRPES_E_RSVD      | 0x3   | Reserved
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPES
 *
 * 64 Instructions
 */
#define CORE_MAC_HW_FEATURE3_FRPES_E_M_64ENTR  0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPES
 *
 * 128 Instructions
 */
#define CORE_MAC_HW_FEATURE3_FRPES_E_M_128ENTR 0x1
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPES
 *
 * 256 Instructions
 */
#define CORE_MAC_HW_FEATURE3_FRPES_E_M_256ENTR 0x2
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FRPES
 *
 * Reserved
 */
#define CORE_MAC_HW_FEATURE3_FRPES_E_RSVD      0x3

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_FRPES register field. */
#define CORE_MAC_HW_FEATURE3_FRPES_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_FRPES register field. */
#define CORE_MAC_HW_FEATURE3_FRPES_MSB	      12
/* The width in bits of the CORE_MAC_HW_FEATURE3_FRPES register field. */
#define CORE_MAC_HW_FEATURE3_FRPES_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE3_FRPES register field value. */
#define CORE_MAC_HW_FEATURE3_FRPES_SET_MSK    0x00001800
/* The mask used to clear the CORE_MAC_HW_FEATURE3_FRPES register field value. */
#define CORE_MAC_HW_FEATURE3_FRPES_CLR_MSK    0xffffe7ff
/* The reset value of the CORE_MAC_HW_FEATURE3_FRPES register field. */
#define CORE_MAC_HW_FEATURE3_FRPES_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE3_FRPES field value from a register. */
#define CORE_MAC_HW_FEATURE3_FRPES_GET(value) (((value)&0x00001800) >> 11)
/* Produces a CORE_MAC_HW_FEATURE3_FRPES register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_FRPES_SET(value) (((value) << 11) & 0x00001800)

/*
 * Field : DVLAN
 *
 * Double VLAN Processing Enabled
 *
 * This bit is set to 1 when the Enable Double VLAN Processing feature is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_DVLAN register field. */
#define CORE_MAC_HW_FEATURE3_DVLAN_LSB	      13
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_DVLAN register field. */
#define CORE_MAC_HW_FEATURE3_DVLAN_MSB	      13
/* The width in bits of the CORE_MAC_HW_FEATURE3_DVLAN register field. */
#define CORE_MAC_HW_FEATURE3_DVLAN_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_DVLAN register field value. */
#define CORE_MAC_HW_FEATURE3_DVLAN_SET_MSK    0x00002000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_DVLAN register field value. */
#define CORE_MAC_HW_FEATURE3_DVLAN_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MAC_HW_FEATURE3_DVLAN register field. */
#define CORE_MAC_HW_FEATURE3_DVLAN_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE3_DVLAN field value from a register. */
#define CORE_MAC_HW_FEATURE3_DVLAN_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_HW_FEATURE3_DVLAN register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_DVLAN_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : ASP
 *
 * Automotive Safety Package
 *
 * Following are the encoding for the different Safety features:
 *
 * * 2'b00: No Safety features selected
 *
 * * 2'b01: All the Automotive Safety features are selected with ECC and Parity
 *   Ports on External Application Interface for Data and Control respectively
 *
 * * 2'b10: All the Automotive Safety features are selected without ECC or Parity
 *   Ports on External Application Interface
 *
 * * 2'b11: All the Automotive Safety features are selected with the Parity Ports
 *   on External Application Interface
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MAC_HW_FEATURE3_ASP_E_NONE     | 0x0   | No Safety features selected
 *  CORE_MAC_HW_FEATURE3_ASP_E_AS_EPPE  | 0x1   | All the Automotive Safety features are selected
 * :                                                      |       | with ECC and Parity Ports on
 * External :                                                      |       | Application Interface
 * for Data and Control :                                                      |       |
 * respectively CORE_MAC_HW_FEATURE3_ASP_E_AS_NEPPE | 0x2   | All the Automotive Safety features are
 * selected :                                                      |       | without ECC or Parity
 * Ports on External :                                                      |       | Application
 * Interface CORE_MAC_HW_FEATURE3_ASP_E_AS_PPE   | 0x3   | All the Automotive Safety features are
 * selected :                                                      |       | with the Parity Ports
 * on External Application :                                                      |       |
 * Interface
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_ASP
 *
 * No Safety features selected
 */
#define CORE_MAC_HW_FEATURE3_ASP_E_NONE	    0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_ASP
 *
 * All the Automotive Safety features are selected with ECC and Parity Ports on
 * External Application Interface for Data and Control respectively
 */
#define CORE_MAC_HW_FEATURE3_ASP_E_AS_EPPE  0x1
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_ASP
 *
 * All the Automotive Safety features are selected without ECC or Parity Ports on
 * External Application Interface
 */
#define CORE_MAC_HW_FEATURE3_ASP_E_AS_NEPPE 0x2
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_ASP
 *
 * All the Automotive Safety features are selected with the Parity Ports on
 * External Application Interface
 */
#define CORE_MAC_HW_FEATURE3_ASP_E_AS_PPE   0x3

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_ASP register field. */
#define CORE_MAC_HW_FEATURE3_ASP_LSB	    14
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_ASP register field. */
#define CORE_MAC_HW_FEATURE3_ASP_MSB	    15
/* The width in bits of the CORE_MAC_HW_FEATURE3_ASP register field. */
#define CORE_MAC_HW_FEATURE3_ASP_WIDTH	    2
/* The mask used to set the CORE_MAC_HW_FEATURE3_ASP register field value. */
#define CORE_MAC_HW_FEATURE3_ASP_SET_MSK    0x0000c000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_ASP register field value. */
#define CORE_MAC_HW_FEATURE3_ASP_CLR_MSK    0xffff3fff
/* The reset value of the CORE_MAC_HW_FEATURE3_ASP register field. */
#define CORE_MAC_HW_FEATURE3_ASP_RESET	    0x0
/* Extracts the CORE_MAC_HW_FEATURE3_ASP field value from a register. */
#define CORE_MAC_HW_FEATURE3_ASP_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MAC_HW_FEATURE3_ASP register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_ASP_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : TTSFD
 *
 * Tx Timestamp FIFO Depth
 *
 * This value indicates the depth of the Tx Timetamp FIFO
 *
 * * 3'b000: Reserved
 *
 * * 3'b001: 1
 *
 * * 3'b010: 2
 *
 * * 3'b011: 4
 *
 * * 3'b100: 8
 *
 * * 3'b101: 16
 *
 * * 3'b110: Reserved
 *
 * * 3'b111: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_TTSFD register field. */
#define CORE_MAC_HW_FEATURE3_TTSFD_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_TTSFD register field. */
#define CORE_MAC_HW_FEATURE3_TTSFD_MSB	      18
/* The width in bits of the CORE_MAC_HW_FEATURE3_TTSFD register field. */
#define CORE_MAC_HW_FEATURE3_TTSFD_WIDTH      3
/* The mask used to set the CORE_MAC_HW_FEATURE3_TTSFD register field value. */
#define CORE_MAC_HW_FEATURE3_TTSFD_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_TTSFD register field value. */
#define CORE_MAC_HW_FEATURE3_TTSFD_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_HW_FEATURE3_TTSFD register field. */
#define CORE_MAC_HW_FEATURE3_TTSFD_RESET      0x5
/* Extracts the CORE_MAC_HW_FEATURE3_TTSFD field value from a register. */
#define CORE_MAC_HW_FEATURE3_TTSFD_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_HW_FEATURE3_TTSFD register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_TTSFD_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : ESTSEL
 *
 * Enhancements to Scheduling Traffic Enable
 *
 * This bit is set to 1 when the Enable Enhancements to Scheduling Traffic feature
 * is selected.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MAC_HW_FEATURE3_ESTSEL_E_INACTIVE | 0x0   | Enable Enhancements to Scheduling Traffic
 * :                                                         |       | feature is not selected
 *  CORE_MAC_HW_FEATURE3_ESTSEL_E_ACTIVE   | 0x1   | Enable Enhancements to Scheduling Traffic
 * :                                                         |       | feature is selected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_ESTSEL
 *
 * Enable Enhancements to Scheduling Traffic feature is not selected
 */
#define CORE_MAC_HW_FEATURE3_ESTSEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_ESTSEL
 *
 * Enable Enhancements to Scheduling Traffic feature is selected
 */
#define CORE_MAC_HW_FEATURE3_ESTSEL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_ESTSEL register field. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_LSB	       19
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_ESTSEL register field. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_MSB	       19
/* The width in bits of the CORE_MAC_HW_FEATURE3_ESTSEL register field. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_ESTSEL register field value. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_SET_MSK    0x00080000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_ESTSEL register field value. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MAC_HW_FEATURE3_ESTSEL register field. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE3_ESTSEL field value from a register. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_HW_FEATURE3_ESTSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_ESTSEL_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : GCLDEP
 *
 * Depth of the Gate Control List
 *
 * This field indicates the depth of Gate Control list expressed as Log2(GCL Depth
 * selected)-5
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:--------------------
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_NODEPTH   | 0x0   | No Depth configured
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH64   | 0x1   | 64
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH128  | 0x2   | 128
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH256  | 0x3   | 256
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH512  | 0x4   | 512
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH1024 | 0x5   | 1024
 *  CORE_MAC_HW_FEATURE3_GCLDEP_E_RSVD      | 0x6   | Reserved
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * No Depth configured
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_NODEPTH	0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * 64
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH64	0x1
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * 128
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH128	0x2
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * 256
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH256	0x3
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * 512
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH512	0x4
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * 1024
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_DEPTH1024 0x5
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLDEP
 *
 * Reserved
 */
#define CORE_MAC_HW_FEATURE3_GCLDEP_E_RSVD	0x6

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_GCLDEP register field. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_LSB	       20
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_GCLDEP register field. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_MSB	       22
/* The width in bits of the CORE_MAC_HW_FEATURE3_GCLDEP register field. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_WIDTH      3
/* The mask used to set the CORE_MAC_HW_FEATURE3_GCLDEP register field value. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_SET_MSK    0x00700000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_GCLDEP register field value. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_CLR_MSK    0xff8fffff
/* The reset value of the CORE_MAC_HW_FEATURE3_GCLDEP register field. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_RESET      0x3
/* Extracts the CORE_MAC_HW_FEATURE3_GCLDEP field value from a register. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_GET(value) (((value)&0x00700000) >> 20)
/* Produces a CORE_MAC_HW_FEATURE3_GCLDEP register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_GCLDEP_SET(value) (((value) << 20) & 0x00700000)

/*
 * Field : GCLWID
 *
 * Width of the Time Interval field in the Gate Control List
 *
 * This field indicates the width of the Configured Time Interval Field
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:---------------------
 *  CORE_MAC_HW_FEATURE3_GCLWID_E_NOWIDTH | 0x0   | Width not configured
 *  CORE_MAC_HW_FEATURE3_GCLWID_E_WIDTH16 | 0x1   | 16
 *  CORE_MAC_HW_FEATURE3_GCLWID_E_WIDTH20 | 0x2   | 20
 *  CORE_MAC_HW_FEATURE3_GCLWID_E_WIDTH24 | 0x3   | 24
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLWID
 *
 * Width not configured
 */
#define CORE_MAC_HW_FEATURE3_GCLWID_E_NOWIDTH 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLWID
 *
 * 16
 */
#define CORE_MAC_HW_FEATURE3_GCLWID_E_WIDTH16 0x1
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLWID
 *
 * 20
 */
#define CORE_MAC_HW_FEATURE3_GCLWID_E_WIDTH20 0x2
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_GCLWID
 *
 * 24
 */
#define CORE_MAC_HW_FEATURE3_GCLWID_E_WIDTH24 0x3

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_GCLWID register field. */
#define CORE_MAC_HW_FEATURE3_GCLWID_LSB	       23
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_GCLWID register field. */
#define CORE_MAC_HW_FEATURE3_GCLWID_MSB	       24
/* The width in bits of the CORE_MAC_HW_FEATURE3_GCLWID register field. */
#define CORE_MAC_HW_FEATURE3_GCLWID_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE3_GCLWID register field value. */
#define CORE_MAC_HW_FEATURE3_GCLWID_SET_MSK    0x01800000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_GCLWID register field value. */
#define CORE_MAC_HW_FEATURE3_GCLWID_CLR_MSK    0xfe7fffff
/* The reset value of the CORE_MAC_HW_FEATURE3_GCLWID register field. */
#define CORE_MAC_HW_FEATURE3_GCLWID_RESET      0x3
/* Extracts the CORE_MAC_HW_FEATURE3_GCLWID field value from a register. */
#define CORE_MAC_HW_FEATURE3_GCLWID_GET(value) (((value)&0x01800000) >> 23)
/* Produces a CORE_MAC_HW_FEATURE3_GCLWID register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_GCLWID_SET(value) (((value) << 23) & 0x01800000)

/*
 * Field : SGFSEL
 *
 * Per-Stream Filtering Select
 *
 * This bit is set to 1 when the Per-Stream Filtering feature is selected.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MAC_HW_FEATURE3_SGFSEL_E_INACTIVE | 0x0   | Per Stream Filtering feature is not selected
 *  CORE_MAC_HW_FEATURE3_SGFSEL_E_ACTIVE   | 0x1   | Per Stream Filtering feature is selected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_SGFSEL
 *
 * Per Stream Filtering feature is not selected
 */
#define CORE_MAC_HW_FEATURE3_SGFSEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_SGFSEL
 *
 * Per Stream Filtering feature is selected
 */
#define CORE_MAC_HW_FEATURE3_SGFSEL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_SGFSEL register field. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_LSB	       25
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_SGFSEL register field. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_MSB	       25
/* The width in bits of the CORE_MAC_HW_FEATURE3_SGFSEL register field. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_SGFSEL register field value. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_SET_MSK    0x02000000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_SGFSEL register field value. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MAC_HW_FEATURE3_SGFSEL register field. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE3_SGFSEL field value from a register. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MAC_HW_FEATURE3_SGFSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_SGFSEL_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : FPESEL
 *
 * Frame Preemption Enable
 *
 * This bit is set to 1 when the Enable Frame preemption feature is selected.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MAC_HW_FEATURE3_FPESEL_E_INACTIVE | 0x0   | Frame Preemption Enable feature is not selected
 *  CORE_MAC_HW_FEATURE3_FPESEL_E_ACTIVE   | 0x1   | Frame Preemption Enable feature is selected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FPESEL
 *
 * Frame Preemption Enable feature is not selected
 */
#define CORE_MAC_HW_FEATURE3_FPESEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_FPESEL
 *
 * Frame Preemption Enable feature is selected
 */
#define CORE_MAC_HW_FEATURE3_FPESEL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_FPESEL register field. */
#define CORE_MAC_HW_FEATURE3_FPESEL_LSB	       26
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_FPESEL register field. */
#define CORE_MAC_HW_FEATURE3_FPESEL_MSB	       26
/* The width in bits of the CORE_MAC_HW_FEATURE3_FPESEL register field. */
#define CORE_MAC_HW_FEATURE3_FPESEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_FPESEL register field value. */
#define CORE_MAC_HW_FEATURE3_FPESEL_SET_MSK    0x04000000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_FPESEL register field value. */
#define CORE_MAC_HW_FEATURE3_FPESEL_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MAC_HW_FEATURE3_FPESEL register field. */
#define CORE_MAC_HW_FEATURE3_FPESEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE3_FPESEL field value from a register. */
#define CORE_MAC_HW_FEATURE3_FPESEL_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MAC_HW_FEATURE3_FPESEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_FPESEL_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : TBSSEL
 *
 * Time Based Scheduling Enable
 *
 * This bit is set to 1 when the Time Based Scheduling feature is selected.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MAC_HW_FEATURE3_TBSSEL_E_INACTIVE | 0x0   | Time Based Scheduling Enable feature is not
 * :                                                         |       | selected
 *  CORE_MAC_HW_FEATURE3_TBSSEL_E_ACTIVE   | 0x1   | Time Based Scheduling Enable feature is
 * selected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_TBSSEL
 *
 * Time Based Scheduling Enable feature is not selected
 */
#define CORE_MAC_HW_FEATURE3_TBSSEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE3_TBSSEL
 *
 * Time Based Scheduling Enable feature is selected
 */
#define CORE_MAC_HW_FEATURE3_TBSSEL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_TBSSEL register field. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_LSB	       27
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_TBSSEL register field. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_MSB	       27
/* The width in bits of the CORE_MAC_HW_FEATURE3_TBSSEL register field. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_WIDTH      1
/* The mask used to set the CORE_MAC_HW_FEATURE3_TBSSEL register field value. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_SET_MSK    0x08000000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_TBSSEL register field value. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MAC_HW_FEATURE3_TBSSEL register field. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE3_TBSSEL field value from a register. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MAC_HW_FEATURE3_TBSSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_TBSSEL_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : TBS_CH
 *
 * The number of DMA channels enabled for TBS (starting from the highest Tx
 * Channel, in descending order)
 *
 * This field provides the number of DMA channels enabled for TBS (starting from
 * the highest Tx Channel, in descending order):
 *
 * * 0000: 1 DMA Tx Channel enabled for TBS
 *
 * * 0001: 2 DMA Tx Channels enabled for TBS
 *
 * * 0010: 3 DMA Tx Channels enabled for TBS
 *
 * * ...
 *
 * * 1111: 16 DMA Tx Channels enabled for TBS
 *
 * Based on the configuration, one or more bits of this field should be treated as
 * Reserved/Read-Only.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE3_TBS_CH register field. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_LSB	       28
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE3_TBS_CH register field. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_MSB	       31
/* The width in bits of the CORE_MAC_HW_FEATURE3_TBS_CH register field. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_WIDTH      4
/* The mask used to set the CORE_MAC_HW_FEATURE3_TBS_CH register field value. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_SET_MSK    0xf0000000
/* The mask used to clear the CORE_MAC_HW_FEATURE3_TBS_CH register field value. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_CLR_MSK    0x0fffffff
/* The reset value of the CORE_MAC_HW_FEATURE3_TBS_CH register field. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_RESET      0x1
/* Extracts the CORE_MAC_HW_FEATURE3_TBS_CH field value from a register. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_GET(value) (((value)&0xf0000000) >> 28)
/* Produces a CORE_MAC_HW_FEATURE3_TBS_CH register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE3_TBS_CH_SET(value) (((value) << 28) & 0xf0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HW_FEATURE3.
 */
struct CORE_MAC_HW_FEATURE3_s {
	const volatile uint32_t NRVF : 3;    /* CORE_MAC_HW_FEATURE3_NRVF */
	const volatile uint32_t FRPSEL : 1;  /* CORE_MAC_HW_FEATURE3_FRPSEL */
	const volatile uint32_t CBTISEL : 1; /* CORE_MAC_HW_FEATURE3_CBTISEL */
	const volatile uint32_t FRPPIPE : 3; /* CORE_MAC_HW_FEATURE3_FRPPIPE */
	const volatile uint32_t POUOST : 1;  /* CORE_MAC_HW_FEATURE3_POUOST */
	const volatile uint32_t FRPPB : 2;   /* CORE_MAC_HW_FEATURE3_FRPPB */
	const volatile uint32_t FRPES : 2;   /* CORE_MAC_HW_FEATURE3_FRPES */
	const volatile uint32_t DVLAN : 1;   /* CORE_MAC_HW_FEATURE3_DVLAN */
	const volatile uint32_t ASP : 2;     /* CORE_MAC_HW_FEATURE3_ASP */
	const volatile uint32_t TTSFD : 3;   /* CORE_MAC_HW_FEATURE3_TTSFD */
	const volatile uint32_t ESTSEL : 1;  /* CORE_MAC_HW_FEATURE3_ESTSEL */
	const volatile uint32_t GCLDEP : 3;  /* CORE_MAC_HW_FEATURE3_GCLDEP */
	const volatile uint32_t GCLWID : 2;  /* CORE_MAC_HW_FEATURE3_GCLWID */
	const volatile uint32_t SGFSEL : 1;  /* CORE_MAC_HW_FEATURE3_SGFSEL */
	const volatile uint32_t FPESEL : 1;  /* CORE_MAC_HW_FEATURE3_FPESEL */
	const volatile uint32_t TBSSEL : 1;  /* CORE_MAC_HW_FEATURE3_TBSSEL */
	const volatile uint32_t TBS_CH : 4;  /* CORE_MAC_HW_FEATURE3_TBS_CH */
};

/* The typedef declaration for register CORE_MAC_HW_FEATURE3. */
typedef struct CORE_MAC_HW_FEATURE3_s CORE_MAC_HW_FEATURE3_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HW_FEATURE3 register. */
#define CORE_MAC_HW_FEATURE3_RESET 0x1dbd2113
/* The byte offset of the CORE_MAC_HW_FEATURE3 register from the beginning of the component. */
#define CORE_MAC_HW_FEATURE3_OFST  0x128

/*
 * Register : MAC_HW_Feature4
 *
 * This register indicates the presence of the fifth set of optional features or
 * functions of DWC_xgmac. The software driver can use this register to dynamically
 * enable or disable the programs related to the optional blocks.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------
 *  [1:0]  | R      | 0x0   | CORE_MAC_HW_FEATURE4_PCSEL
 *  [31:2] | R      | 0x0   | CORE_MAC_HW_FEATURE4_RESERVED_31_2
 *
 */
/*
 * Field : PCSEL
 *
 * Policing Counters
 *
 * This value indicates the number of policing counters implemented when PC is
 * enabled
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:-----------------------------------------
 *  CORE_MAC_HW_FEATURE4_PCSEL_E_INACTIVE | 0x0   | Policing counter feature is not selected
 *  CORE_MAC_HW_FEATURE4_PCSEL_E_PCNUM_16 | 0x1   | 16 Policing counters are selected
 *  CORE_MAC_HW_FEATURE4_PCSEL_E_PCNUM_32 | 0x2   | 32 Policing counters are selected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE4_PCSEL
 *
 * Policing counter feature is not selected
 */
#define CORE_MAC_HW_FEATURE4_PCSEL_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE4_PCSEL
 *
 * 16 Policing counters are selected
 */
#define CORE_MAC_HW_FEATURE4_PCSEL_E_PCNUM_16 0x1
/*
 * Enumerated value for register field CORE_MAC_HW_FEATURE4_PCSEL
 *
 * 32 Policing counters are selected
 */
#define CORE_MAC_HW_FEATURE4_PCSEL_E_PCNUM_32 0x2

/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE4_PCSEL register field. */
#define CORE_MAC_HW_FEATURE4_PCSEL_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE4_PCSEL register field. */
#define CORE_MAC_HW_FEATURE4_PCSEL_MSB	      1
/* The width in bits of the CORE_MAC_HW_FEATURE4_PCSEL register field. */
#define CORE_MAC_HW_FEATURE4_PCSEL_WIDTH      2
/* The mask used to set the CORE_MAC_HW_FEATURE4_PCSEL register field value. */
#define CORE_MAC_HW_FEATURE4_PCSEL_SET_MSK    0x00000003
/* The mask used to clear the CORE_MAC_HW_FEATURE4_PCSEL register field value. */
#define CORE_MAC_HW_FEATURE4_PCSEL_CLR_MSK    0xfffffffc
/* The reset value of the CORE_MAC_HW_FEATURE4_PCSEL register field. */
#define CORE_MAC_HW_FEATURE4_PCSEL_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE4_PCSEL field value from a register. */
#define CORE_MAC_HW_FEATURE4_PCSEL_GET(value) (((value)&0x00000003) >> 0)
/* Produces a CORE_MAC_HW_FEATURE4_PCSEL register field value suitable for setting the register. */
#define CORE_MAC_HW_FEATURE4_PCSEL_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : Reserved_31_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_HW_FEATURE4_RESERVED_31_2 register
 * field. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MAC_HW_FEATURE4_RESERVED_31_2 register field.
 */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_MSB	      31
/* The width in bits of the CORE_MAC_HW_FEATURE4_RESERVED_31_2 register field. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_WIDTH      30
/* The mask used to set the CORE_MAC_HW_FEATURE4_RESERVED_31_2 register field value. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_SET_MSK    0xfffffffc
/* The mask used to clear the CORE_MAC_HW_FEATURE4_RESERVED_31_2 register field value. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_CLR_MSK    0x00000003
/* The reset value of the CORE_MAC_HW_FEATURE4_RESERVED_31_2 register field. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_RESET      0x0
/* Extracts the CORE_MAC_HW_FEATURE4_RESERVED_31_2 field value from a register. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_GET(value) (((value)&0xfffffffc) >> 2)
/* Produces a CORE_MAC_HW_FEATURE4_RESERVED_31_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_HW_FEATURE4_RESERVED_31_2_SET(value) (((value) << 2) & 0xfffffffc)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_HW_FEATURE4.
 */
struct CORE_MAC_HW_FEATURE4_s {
	const volatile uint32_t PCSEL : 2;	    /* CORE_MAC_HW_FEATURE4_PCSEL */
	const volatile uint32_t Reserved_31_2 : 30; /* CORE_MAC_HW_FEATURE4_RESERVED_31_2 */
};

/* The typedef declaration for register CORE_MAC_HW_FEATURE4. */
typedef struct CORE_MAC_HW_FEATURE4_s CORE_MAC_HW_FEATURE4_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_HW_FEATURE4 register. */
#define CORE_MAC_HW_FEATURE4_RESET 0x00000000
/* The byte offset of the CORE_MAC_HW_FEATURE4 register from the beginning of the component. */
#define CORE_MAC_HW_FEATURE4_OFST  0x12c

/*
 * Register : MAC_Extended_Configuration
 *
 * The MAC Extended Configuration register establishes the operating mode of the
 * MAC transmitter.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------------
 *  [6:0]   | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_EIPG
 *  [7]     | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_DDS
 *  [8]     | R      | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE
 *  [9]     | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_TPRE
 *  [15:10] | R      | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10
 *  [16]    | R      | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN
 *  [17]    | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_DC
 *  [19:18] | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_BL
 *  [20]    | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_DR
 *  [21]    | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_DCRS
 *  [22]    | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_DO
 *  [23]    | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD
 *  [24]    | RW     | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_HD
 *  [31:25] | R      | 0x0   | CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25
 *
 */
/*
 * Field : EIPG
 *
 * Extended Inter-Packet Gap.
 *
 * When IFP bit in MAC_Tx_configuration register is set, the minimum IPG is
 * increased in steps of 32bits depending on the programming of this field and IPG
 * field in MAC_Tx_Configuration register.
 *
 * {EIPG,IPG}: Minimum Inter-Packet Gap
 *
 * * 10'h000: 96 bit times
 *
 * * 10'h001: 128 bit times
 *
 * * 10'h010: 160 bit times
 *
 * * 10'h011: 192 bit times
 *
 * * 10'h100: 224 bit times
 *
 * * ...
 *
 * * 10'h3FF: 32832 bit times
 *
 * Note:  The extended inter-packet gap (IPG) feature must be enabled only in full-
 * duplex mode. There might be undesirable effects on back-pressure function and
 * frame transmission if it is enabled in half-duplex mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_EIPG register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_EIPG register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_MSB	6
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_EIPG register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_WIDTH	7
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_EIPG register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_SET_MSK	0x0000007f
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_EIPG register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_CLR_MSK	0xffffff80
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_EIPG register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_RESET	0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_EIPG field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_GET(value) (((value)&0x0000007f) >> 0)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_EIPG register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_EIPG_SET(value) (((value) << 0) & 0x0000007f)

/*
 * Field : DDS
 *
 * DA Duplication Select.
 *
 * * 1: The received packet with Multicast/Broadcast Destination address is routed
 *   to multiple Receive DMA Channels. The Receive DMA Channels is identified by
 *   XDCS field of MAC_DChSel_IndReg(#i) register corresponding to the MAC Address
 *   register that matches the Multicast/Broadcast DA. The XDCS field is
 *   interpreted to be a one-hot value, each bit corresponding to the Receive DMA
 *   Channel.
 *
 * * 0: The received packet is routed to a single Receive DMA Channel. The Receive
 *   DMA Channel is identified by the DCS field of MAC_Address_High register
 *   corresponding to the MAC Address register that matches the Destination address
 *   in the received packet. The DCS field is interpreted as a binary value.
 *
 * Values:
 *
 * * 0x0: DCS field in MAC_Address_High register is interpreted as binary value
 *
 * * 0x1: XDCS field in MAC_DChSel_IndReg register represent the target DMA
 *   Channels using a one-hot like encoding.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DDS register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_LSB	       7
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DDS register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_MSB	       7
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_DDS register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_WIDTH      1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_DDS register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_SET_MSK    0x00000080
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_DDS register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_DDS register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_RESET      0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_DDS field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_DDS register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DDS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_VPRE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_LSB	 8
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_MSB	 8
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_WIDTH	 1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_SET_MSK	 0x00000100
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_CLR_MSK	 0xfffffeff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_RESET	 0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE register field value suitable for
 * setting the register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : TPRE
 *
 * Truncated Preamble Enable.
 *
 * When set, MAC supports processing of packets with 7 bytes preamble on RX side
 * such that SFD is seen on lane2. On reset, packet with truncated preamble are
 * dropped. This field has an impact only if the speed select is set to 3'b110
 * (XGMII 2.5G mode)
 *
 * TPRE = 1
 *
 * For express packets, the supported format is
 *
 * * /S/ + Preamble (6/5)+ SFD (lane3/lane2)
 *
 * For preemptive packets, truncated preamble is not supported. Therefore, the
 * supported format is
 *
 * * /S/ + Preamble (6)+ SFD (lane3)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_TPRE register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_LSB	9
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_TPRE register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_MSB	9
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_TPRE register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_WIDTH	1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_TPRE register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_SET_MSK	0x00000200
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_TPRE register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_CLR_MSK	0xfffffdff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_TPRE register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_RESET	0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_TPRE field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_TPRE register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_TPRE_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : Reserved_15_10
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_LSB	  10
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_MSB	  15
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_WIDTH	  6
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_SET_MSK	  0x0000fc00
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 register field value.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_CLR_MSK	  0xffff03ff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_RESET	  0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_GET(value) (((value)&0x0000fc00) >> 10)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 register field value suitable for
 * setting the register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10_SET(value) (((value) << 10) & 0x0000fc00)

/*
 * Field : Reserved_SBDIOEN
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_MSB	    16
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_WIDTH	    1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN register field value.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN register field value.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_RESET	    0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN register field value suitable for
 * setting the register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : DC
 *
 * Deferral Check
 *
 * When this bit is set, the deferral check function is enabled in the MAC. The MAC
 * issues a Packet Abort status, along with the excessive deferral error bit set in
 * the Tx packet status, when the Tx state machine is deferred for more than 24,288
 * bit times in 10 or 100 Mbps mode.
 *
 * Deferral begins when the transmitter is ready to transmit, but it is prevented
 * because of an active carrier sense signal (CRS) on MII.
 *
 * The defer time is not cumulative. For example, if the transmitter defers for
 * 10,000 bit times, because the CRS signal is active and the CRS signal becomes
 * inactive, the transmitter transmits and collision occurs. Because of collision,
 * the transmitter needs to back off and then defer again after back off is
 * complete. In such a scenario, the deferral timer is reset to 0, and it is
 * restarted.
 *
 * When this bit is reset, the deferral check function is disabled and the MAC
 * defers until the CRS signal goes inactive.
 *
 * This bit is applicable only in the half-duplex mode.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                           | Value | Description
 * :---------------------------------------------------------------|:------|:------------------------------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_DC_E_DISABLE | 0x0   | Deferral check function is disabled
 *  CORE_MAC_EXTENDED_CONFIGURATION_DC_E_ENABLE  | 0x1   | Deferral check function is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DC
 *
 * Deferral check function is disabled
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DC
 *
 * Deferral check function is enabled
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DC register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_LSB	      17
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DC register field.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_MSB	      17
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_DC register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_WIDTH      1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_DC register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_SET_MSK    0x00020000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_DC register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_DC register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_RESET      0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_DC field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_DC register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DC_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : BL
 *
 * Back-Off Limit
 *
 * The back-off limit determines the random integer number (r) of slot time delays
 * (512 bit times for 10/100 Mbps) for which the MAC waits before rescheduling a
 * transmission attempt during retries after a collision.
 *
 * n = retransmission attempt.
 *
 * The random integer r takes the value in the range 0 <= r < 2^k
 *
 * This bit is applicable only in the half-duplex mode.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                            | Value | Description
 * :----------------------------------------------------------------|:------|:--------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_10 | 0x0   | k = min(n,10)
 *  CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_8  | 0x1   | k = min(n,8)
 *  CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_4  | 0x2   | k = min(n,4)
 *  CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_1  | 0x3   | k = min(n,1)
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_BL
 *
 * k = min(n,10)
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_10 0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_BL
 *
 * k = min(n,8)
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_8  0x1
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_BL
 *
 * k = min(n,4)
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_4  0x2
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_BL
 *
 * k = min(n,1)
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_E_MIN_N_1  0x3

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_BL register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_BL register field.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_MSB	      19
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_BL register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_WIDTH      2
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_BL register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_SET_MSK    0x000c0000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_BL register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_CLR_MSK    0xfff3ffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_BL register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_RESET      0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_BL field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_GET(value) (((value)&0x000c0000) >> 18)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_BL register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_BL_SET(value) (((value) << 18) & 0x000c0000)

/*
 * Field : DR
 *
 * Disable Retry
 *
 * When this bit is set, the MAC attempts only one transmission. When a collision
 * occurs on the GMII or MII interface, the MAC ignores the current packet
 * transmission and reports a Packet Abort with excessive collision error in the Tx
 * packet status.
 *
 * When this bit is reset, the MAC retries based on the settings of the BL field.
 * This bit is applicable only in the half-duplex mode.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                           | Value | Description
 * :---------------------------------------------------------------|:------|:--------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_DR_E_ENABLE  | 0x0   | Enable Retry
 *  CORE_MAC_EXTENDED_CONFIGURATION_DR_E_DISABLE | 0x1   | Disable Retry
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DR
 *
 * Enable Retry
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_E_ENABLE  0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DR
 *
 * Disable Retry
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_E_DISABLE 0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DR register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_LSB	      20
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DR register field.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_MSB	      20
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_DR register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_WIDTH      1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_DR register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_SET_MSK    0x00100000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_DR register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_CLR_MSK    0xffefffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_DR register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_RESET      0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_DR field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_DR register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DR_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : DCRS
 *
 * Disable Carrier Sense During Transmission
 *
 * When this bit is set, the MAC transmitter ignores the MII CRS signal during
 * packet transmission in the half-duplex mode. As a result, no errors are
 * generated because of Loss of Carrier or No Carrier during transmission.
 *
 * When this bit is reset, the MAC transmitter generates errors because of Carrier
 * Sense. The MAC can even abort the transmission.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_DCRS_E_ENABLE  | 0x0   | Enable Carrier Sense During
 * Transmission CORE_MAC_EXTENDED_CONFIGURATION_DCRS_E_DISABLE | 0x1   | Disable Carrier Sense
 * During Transmission
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DCRS
 *
 * Enable Carrier Sense During Transmission
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_E_ENABLE  0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DCRS
 *
 * Disable Carrier Sense During Transmission
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_E_DISABLE 0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DCRS register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_LSB	21
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DCRS register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_MSB	21
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_DCRS register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_WIDTH	1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_DCRS register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_SET_MSK	0x00200000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_DCRS register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_CLR_MSK	0xffdfffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_DCRS register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_RESET	0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_DCRS field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_DCRS register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DCRS_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : DO
 *
 * Disable Receive Own
 *
 * When this bit is set, the MAC disables the reception of packets when the
 * gmii_txen_o is asserted in the half-duplex mode. When this bit is reset, the MAC
 * receives all packets given by the PHY.
 *
 * This bit is not applicable in the full-duplex mode.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                           | Value | Description
 * :---------------------------------------------------------------|:------|:--------------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_DO_E_ENABLE  | 0x0   | Enable Receive Own
 *  CORE_MAC_EXTENDED_CONFIGURATION_DO_E_DISABLE | 0x1   | Disable Receive Own
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DO
 *
 * Enable Receive Own
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_E_ENABLE  0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_DO
 *
 * Disable Receive Own
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_E_DISABLE 0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DO register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_LSB	      22
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_DO register field.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_MSB	      22
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_DO register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_WIDTH      1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_DO register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_SET_MSK    0x00400000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_DO register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_DO register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_RESET      0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_DO field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_DO register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_DO_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : ECRSFD
 *
 * Enable Carrier Sense Before Transmission in Full-Duplex Mode
 *
 * When this bit is set, the MAC transmitter checks the CRS signal before packet
 * transmission in the full-duplex mode. The MAC starts the transmission only when
 * the CRS signal is low.
 *
 * When this bit is reset, the MAC transmitter ignores the status of the CRS
 * signal.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                               | Value | Description
 * :-------------------------------------------------------------------|:------|:-------------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_E_DISABLE | 0x0   | ECRSFD is disabled
 *  CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_E_ENABLE  | 0x1   | ECRSFD is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD
 *
 * ECRSFD is disabled
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD
 *
 * ECRSFD is enabled
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_E_ENABLE	 0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_LSB	  23
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_MSB	  23
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_WIDTH	  1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_SET_MSK	  0x00800000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_CLR_MSK	  0xff7fffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_RESET	  0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : HD
 *
 * Duplex Mode
 *
 * When this bit is set, the MAC operates in the half-duplex mode in which it can
 * transmit and receive simultaneously. This bit is RO with default value of 1'b0
 * in the full-duplex-only configurations.
 *
 * This bit is enabled only for 10/100Mbps.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:-----------------
 *  CORE_MAC_EXTENDED_CONFIGURATION_HD_E_FDUPLX | 0x0   | Full-duplex mode
 *  CORE_MAC_EXTENDED_CONFIGURATION_HD_E_HDUPLX | 0x1   | Half-duplex mode
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_HD
 *
 * Full-duplex mode
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_E_FDUPLX 0x0
/*
 * Enumerated value for register field CORE_MAC_EXTENDED_CONFIGURATION_HD
 *
 * Half-duplex mode
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_E_HDUPLX 0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_HD register
 * field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_HD register field.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_MSB	      24
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_HD register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_WIDTH      1
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_HD register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_SET_MSK    0x01000000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_HD register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_HD register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_RESET      0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_HD field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_HD register field value suitable for setting the
 * register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_HD_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : Reserved_31_25
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_LSB	  25
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25
 * register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_MSB	  31
/* The width in bits of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_WIDTH	  7
/* The mask used to set the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 register field value. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_SET_MSK	  0xfe000000
/* The mask used to clear the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 register field value.
 */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_CLR_MSK	  0x01ffffff
/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 register field. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_RESET	  0x0
/* Extracts the CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 field value from a register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_GET(value) (((value)&0xfe000000) >> 25)
/* Produces a CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 register field value suitable for
 * setting the register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25_SET(value) (((value) << 25) & 0xfe000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_EXTENDED_CONFIGURATION.
 */
struct CORE_MAC_EXTENDED_CONFIGURATION_s {
	volatile uint32_t EIPG : 7; /* CORE_MAC_EXTENDED_CONFIGURATION_EIPG */
	volatile uint32_t DDS : 1;  /* CORE_MAC_EXTENDED_CONFIGURATION_DDS */
	const volatile uint32_t
		Reserved_VPRE : 1;  /* CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_VPRE */
	volatile uint32_t TPRE : 1; /* CORE_MAC_EXTENDED_CONFIGURATION_TPRE */
	const volatile uint32_t
		Reserved_15_10 : 6; /* CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_15_10 */
	const volatile uint32_t
		Reserved_SBDIOEN : 1; /* CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_SBDIOEN */
	volatile uint32_t DC : 1;     /* CORE_MAC_EXTENDED_CONFIGURATION_DC */
	volatile uint32_t BL : 2;     /* CORE_MAC_EXTENDED_CONFIGURATION_BL */
	volatile uint32_t DR : 1;     /* CORE_MAC_EXTENDED_CONFIGURATION_DR */
	volatile uint32_t DCRS : 1;   /* CORE_MAC_EXTENDED_CONFIGURATION_DCRS */
	volatile uint32_t DO : 1;     /* CORE_MAC_EXTENDED_CONFIGURATION_DO */
	volatile uint32_t ECRSFD : 1; /* CORE_MAC_EXTENDED_CONFIGURATION_ECRSFD */
	volatile uint32_t HD : 1;     /* CORE_MAC_EXTENDED_CONFIGURATION_HD */
	const volatile uint32_t
		Reserved_31_25 : 7; /* CORE_MAC_EXTENDED_CONFIGURATION_RESERVED_31_25 */
};

/* The typedef declaration for register CORE_MAC_EXTENDED_CONFIGURATION. */
typedef struct CORE_MAC_EXTENDED_CONFIGURATION_s CORE_MAC_EXTENDED_CONFIGURATION_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_EXTENDED_CONFIGURATION register. */
#define CORE_MAC_EXTENDED_CONFIGURATION_RESET 0x00000000
/* The byte offset of the CORE_MAC_EXTENDED_CONFIGURATION register from the beginning of the
 * component. */
#define CORE_MAC_EXTENDED_CONFIGURATION_OFST  0x140

/*
 * Register : MAC_Ext_Cfg1
 *
 * This register contains Split mode control field and offset field for Header-
 * Payload Split feature.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------
 *  [6:0]   | RW     | 0x2   | CORE_MAC_EXT_CFG1_SPLOFST
 *  [7]     | R      | 0x0   | CORE_MAC_EXT_CFG1_RESERVED_7
 *  [9:8]   | RW     | 0x0   | CORE_MAC_EXT_CFG1_SPLM
 *  [15:10] | R      | 0x0   | CORE_MAC_EXT_CFG1_RESERVED_15_10
 *  [22:16] | RW     | 0x2   | CORE_MAC_EXT_CFG1_SAVO
 *  [23]    | R      | 0x0   | CORE_MAC_EXT_CFG1_RESERVED_23
 *  [24]    | RW     | 0x0   | CORE_MAC_EXT_CFG1_SAVE
 *  [31:25] | R      | 0x0   | CORE_MAC_EXT_CFG1_RESERVED_31_25
 *
 */
/*
 * Field : SPLOFST
 *
 * Split Offset
 *
 * These bits indicate the value of offset from the beginning of Length/Type field
 * at which header split should take place when the appropriate SPLM is selected.
 * The reset value of this field is 2 bytes indicating a split at L2 header. Value
 * is in terms of bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_SPLOFST register field. */
#define CORE_MAC_EXT_CFG1_SPLOFST_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_SPLOFST register field. */
#define CORE_MAC_EXT_CFG1_SPLOFST_MSB	     6
/* The width in bits of the CORE_MAC_EXT_CFG1_SPLOFST register field. */
#define CORE_MAC_EXT_CFG1_SPLOFST_WIDTH	     7
/* The mask used to set the CORE_MAC_EXT_CFG1_SPLOFST register field value. */
#define CORE_MAC_EXT_CFG1_SPLOFST_SET_MSK    0x0000007f
/* The mask used to clear the CORE_MAC_EXT_CFG1_SPLOFST register field value. */
#define CORE_MAC_EXT_CFG1_SPLOFST_CLR_MSK    0xffffff80
/* The reset value of the CORE_MAC_EXT_CFG1_SPLOFST register field. */
#define CORE_MAC_EXT_CFG1_SPLOFST_RESET	     0x2
/* Extracts the CORE_MAC_EXT_CFG1_SPLOFST field value from a register. */
#define CORE_MAC_EXT_CFG1_SPLOFST_GET(value) (((value)&0x0000007f) >> 0)
/* Produces a CORE_MAC_EXT_CFG1_SPLOFST register field value suitable for setting the register. */
#define CORE_MAC_EXT_CFG1_SPLOFST_SET(value) (((value) << 0) & 0x0000007f)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_RESERVED_7 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_LSB	7
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_RESERVED_7 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_MSB	7
/* The width in bits of the CORE_MAC_EXT_CFG1_RESERVED_7 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_WIDTH	1
/* The mask used to set the CORE_MAC_EXT_CFG1_RESERVED_7 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_SET_MSK	0x00000080
/* The mask used to clear the CORE_MAC_EXT_CFG1_RESERVED_7 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_CLR_MSK	0xffffff7f
/* The reset value of the CORE_MAC_EXT_CFG1_RESERVED_7 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_RESET	0x0
/* Extracts the CORE_MAC_EXT_CFG1_RESERVED_7 field value from a register. */
#define CORE_MAC_EXT_CFG1_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_EXT_CFG1_RESERVED_7 register field value suitable for setting the register.
 */
#define CORE_MAC_EXT_CFG1_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : SPLM
 *
 * Split Mode
 *
 * These bits indicate the mode of splitting the incoming Rx packets. They are
 *
 * Field Enumeration Values:
 *
 *  Enum                                              | Value | Description
 * :--------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MAC_EXT_CFG1_SPLM_E_L3L4   | 0x0   | Split at L3/L4 header
 *  CORE_MAC_EXT_CFG1_SPLM_E_L2OFST | 0x1   | Split at L2 header with an offset. Always Split
 * :                                                  |       | at SPLOFST bytes from the beginning
 * of :                                                  |       | Length/Type field of the Frame
 *  CORE_MAC_EXT_CFG1_SPLM_E_COMBN  | 0x2   | Combination mode: Split similar to SPLM=00 for
 * :                                                  |       | IP packets that are untagged or
 * tagged and VLAN :                                                  |       | stripped and Split
 * similar to SPLM=01 for non-IP :                                                  |       |
 * packets CORE_MAC_EXT_CFG1_SPLM_E_RSVD   | 0x3   | Reserved
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_EXT_CFG1_SPLM
 *
 * Split at L3/L4 header
 */
#define CORE_MAC_EXT_CFG1_SPLM_E_L3L4	0x0
/*
 * Enumerated value for register field CORE_MAC_EXT_CFG1_SPLM
 *
 * Split at L2 header with an offset. Always Split at SPLOFST bytes from the
 * beginning of Length/Type field of the Frame
 */
#define CORE_MAC_EXT_CFG1_SPLM_E_L2OFST 0x1
/*
 * Enumerated value for register field CORE_MAC_EXT_CFG1_SPLM
 *
 * Combination mode: Split similar to SPLM=00 for IP packets that are untagged or
 * tagged and VLAN stripped and Split similar to SPLM=01 for non-IP packets
 */
#define CORE_MAC_EXT_CFG1_SPLM_E_COMBN	0x2
/*
 * Enumerated value for register field CORE_MAC_EXT_CFG1_SPLM
 *
 * Reserved
 */
#define CORE_MAC_EXT_CFG1_SPLM_E_RSVD	0x3

/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_SPLM register field. */
#define CORE_MAC_EXT_CFG1_SPLM_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_SPLM register field. */
#define CORE_MAC_EXT_CFG1_SPLM_MSB	  9
/* The width in bits of the CORE_MAC_EXT_CFG1_SPLM register field. */
#define CORE_MAC_EXT_CFG1_SPLM_WIDTH	  2
/* The mask used to set the CORE_MAC_EXT_CFG1_SPLM register field value. */
#define CORE_MAC_EXT_CFG1_SPLM_SET_MSK	  0x00000300
/* The mask used to clear the CORE_MAC_EXT_CFG1_SPLM register field value. */
#define CORE_MAC_EXT_CFG1_SPLM_CLR_MSK	  0xfffffcff
/* The reset value of the CORE_MAC_EXT_CFG1_SPLM register field. */
#define CORE_MAC_EXT_CFG1_SPLM_RESET	  0x0
/* Extracts the CORE_MAC_EXT_CFG1_SPLM field value from a register. */
#define CORE_MAC_EXT_CFG1_SPLM_GET(value) (((value)&0x00000300) >> 8)
/* Produces a CORE_MAC_EXT_CFG1_SPLM register field value suitable for setting the register. */
#define CORE_MAC_EXT_CFG1_SPLM_SET(value) (((value) << 8) & 0x00000300)

/*
 * Field : Reserved_15_10
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_RESERVED_15_10 register field.
 */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_LSB	    10
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_RESERVED_15_10 register field.
 */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_MSB	    15
/* The width in bits of the CORE_MAC_EXT_CFG1_RESERVED_15_10 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_WIDTH	    6
/* The mask used to set the CORE_MAC_EXT_CFG1_RESERVED_15_10 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_SET_MSK    0x0000fc00
/* The mask used to clear the CORE_MAC_EXT_CFG1_RESERVED_15_10 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_CLR_MSK    0xffff03ff
/* The reset value of the CORE_MAC_EXT_CFG1_RESERVED_15_10 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_RESET	    0x0
/* Extracts the CORE_MAC_EXT_CFG1_RESERVED_15_10 field value from a register. */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_GET(value) (((value)&0x0000fc00) >> 10)
/* Produces a CORE_MAC_EXT_CFG1_RESERVED_15_10 register field value suitable for setting the
 * register. */
#define CORE_MAC_EXT_CFG1_RESERVED_15_10_SET(value) (((value) << 10) & 0x0000fc00)

/*
 * Field : SAVO
 *
 * Split AV Offset
 *
 * When SAVE bit is set to 1, and the received packet is an AV Type packet, these
 * bits indicate the value of the offset from the beginning of Length/Type field at
 * which header should be split, when appropriate SPLM is selected. The reset value
 * of this field is 2 bytes, indicating a split at L2 header. Value is in terms of
 * bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_SAVO register field. */
#define CORE_MAC_EXT_CFG1_SAVO_LSB	  16
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_SAVO register field. */
#define CORE_MAC_EXT_CFG1_SAVO_MSB	  22
/* The width in bits of the CORE_MAC_EXT_CFG1_SAVO register field. */
#define CORE_MAC_EXT_CFG1_SAVO_WIDTH	  7
/* The mask used to set the CORE_MAC_EXT_CFG1_SAVO register field value. */
#define CORE_MAC_EXT_CFG1_SAVO_SET_MSK	  0x007f0000
/* The mask used to clear the CORE_MAC_EXT_CFG1_SAVO register field value. */
#define CORE_MAC_EXT_CFG1_SAVO_CLR_MSK	  0xff80ffff
/* The reset value of the CORE_MAC_EXT_CFG1_SAVO register field. */
#define CORE_MAC_EXT_CFG1_SAVO_RESET	  0x2
/* Extracts the CORE_MAC_EXT_CFG1_SAVO field value from a register. */
#define CORE_MAC_EXT_CFG1_SAVO_GET(value) (((value)&0x007f0000) >> 16)
/* Produces a CORE_MAC_EXT_CFG1_SAVO register field value suitable for setting the register. */
#define CORE_MAC_EXT_CFG1_SAVO_SET(value) (((value) << 16) & 0x007f0000)

/*
 * Field : Reserved_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_RESERVED_23 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_LSB	 23
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_RESERVED_23 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_MSB	 23
/* The width in bits of the CORE_MAC_EXT_CFG1_RESERVED_23 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_WIDTH	 1
/* The mask used to set the CORE_MAC_EXT_CFG1_RESERVED_23 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_SET_MSK	 0x00800000
/* The mask used to clear the CORE_MAC_EXT_CFG1_RESERVED_23 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_CLR_MSK	 0xff7fffff
/* The reset value of the CORE_MAC_EXT_CFG1_RESERVED_23 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_RESET	 0x0
/* Extracts the CORE_MAC_EXT_CFG1_RESERVED_23 field value from a register. */
#define CORE_MAC_EXT_CFG1_RESERVED_23_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_EXT_CFG1_RESERVED_23 register field value suitable for setting the register.
 */
#define CORE_MAC_EXT_CFG1_RESERVED_23_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : SAVE
 *
 * Split AV Enable
 *
 * * When this bit is set to 1, and the received packet is an AV Type packet, the
 *   header is split at SAVO bytes from the beginning of Length/Type field of the
 *   packet, for L2 Split.
 *
 * * When this bit is set to 0, header is split at SPLOFST bytes from the beginning
 *   of Length/Type field of the frame, for L2 Split.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_SAVE register field. */
#define CORE_MAC_EXT_CFG1_SAVE_LSB	  24
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_SAVE register field. */
#define CORE_MAC_EXT_CFG1_SAVE_MSB	  24
/* The width in bits of the CORE_MAC_EXT_CFG1_SAVE register field. */
#define CORE_MAC_EXT_CFG1_SAVE_WIDTH	  1
/* The mask used to set the CORE_MAC_EXT_CFG1_SAVE register field value. */
#define CORE_MAC_EXT_CFG1_SAVE_SET_MSK	  0x01000000
/* The mask used to clear the CORE_MAC_EXT_CFG1_SAVE register field value. */
#define CORE_MAC_EXT_CFG1_SAVE_CLR_MSK	  0xfeffffff
/* The reset value of the CORE_MAC_EXT_CFG1_SAVE register field. */
#define CORE_MAC_EXT_CFG1_SAVE_RESET	  0x0
/* Extracts the CORE_MAC_EXT_CFG1_SAVE field value from a register. */
#define CORE_MAC_EXT_CFG1_SAVE_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_EXT_CFG1_SAVE register field value suitable for setting the register. */
#define CORE_MAC_EXT_CFG1_SAVE_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : Reserved_31_25
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_EXT_CFG1_RESERVED_31_25 register field.
 */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_LSB	    25
/* The Most Significant Bit (MSB) position of the CORE_MAC_EXT_CFG1_RESERVED_31_25 register field.
 */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_MSB	    31
/* The width in bits of the CORE_MAC_EXT_CFG1_RESERVED_31_25 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_WIDTH	    7
/* The mask used to set the CORE_MAC_EXT_CFG1_RESERVED_31_25 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_SET_MSK    0xfe000000
/* The mask used to clear the CORE_MAC_EXT_CFG1_RESERVED_31_25 register field value. */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_CLR_MSK    0x01ffffff
/* The reset value of the CORE_MAC_EXT_CFG1_RESERVED_31_25 register field. */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_RESET	    0x0
/* Extracts the CORE_MAC_EXT_CFG1_RESERVED_31_25 field value from a register. */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_GET(value) (((value)&0xfe000000) >> 25)
/* Produces a CORE_MAC_EXT_CFG1_RESERVED_31_25 register field value suitable for setting the
 * register. */
#define CORE_MAC_EXT_CFG1_RESERVED_31_25_SET(value) (((value) << 25) & 0xfe000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_EXT_CFG1.
 */
struct CORE_MAC_EXT_CFG1_s {
	volatile uint32_t SPLOFST : 7;		    /* CORE_MAC_EXT_CFG1_SPLOFST */
	const volatile uint32_t Reserved_7 : 1;	    /* CORE_MAC_EXT_CFG1_RESERVED_7 */
	volatile uint32_t SPLM : 2;		    /* CORE_MAC_EXT_CFG1_SPLM */
	const volatile uint32_t Reserved_15_10 : 6; /* CORE_MAC_EXT_CFG1_RESERVED_15_10 */
	volatile uint32_t SAVO : 7;		    /* CORE_MAC_EXT_CFG1_SAVO */
	const volatile uint32_t Reserved_23 : 1;    /* CORE_MAC_EXT_CFG1_RESERVED_23 */
	volatile uint32_t SAVE : 1;		    /* CORE_MAC_EXT_CFG1_SAVE */
	const volatile uint32_t Reserved_31_25 : 7; /* CORE_MAC_EXT_CFG1_RESERVED_31_25 */
};

/* The typedef declaration for register CORE_MAC_EXT_CFG1. */
typedef struct CORE_MAC_EXT_CFG1_s CORE_MAC_EXT_CFG1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_EXT_CFG1 register. */
#define CORE_MAC_EXT_CFG1_RESET 0x00020002
/* The byte offset of the CORE_MAC_EXT_CFG1 register from the beginning of the component. */
#define CORE_MAC_EXT_CFG1_OFST	0x144

/*
 * Register : MDIO_Single_Command_Address
 *
 * This register contains the addresses of the ports, devices, and registers
 * accessed by the SMA during single read or write transfers.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA
 *  [20:16] | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA
 *  [25:21] | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA
 *  [31:26] | R      | 0x0   | CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26
 *
 */
/*
 * Field : RA
 *
 * Register Address
 *
 * Register Address for single read/write. When using Clause 22 frames, only the
 * lower 5 bits of the field are used.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_MSB	       15
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_WIDTH      16
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_SET_MSK    0x0000ffff
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_CLR_MSK    0xffff0000
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_RESET      0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA register field value suitable for setting the
 * register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : PA
 *
 * Port Address
 *
 * Port Address used for indirect single read/write access.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_MSB	       20
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_WIDTH      5
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_SET_MSK    0x001f0000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_CLR_MSK    0xffe0ffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_RESET      0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_GET(value) (((value)&0x001f0000) >> 16)
/* Produces a CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA register field value suitable for setting the
 * register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_SET(value) (((value) << 16) & 0x001f0000)

/*
 * Field : DA
 *
 * Device Address
 *
 * Device Address for indirect addressing of device for single read/write.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_LSB	       21
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_MSB	       25
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_WIDTH      5
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_SET_MSK    0x03e00000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_CLR_MSK    0xfc1fffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_RESET      0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_GET(value) (((value)&0x03e00000) >> 21)
/* Produces a CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA register field value suitable for setting the
 * register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_SET(value) (((value) << 21) & 0x03e00000)

/*
 * Field : Reserved_31_26
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_LSB	   26
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_MSB	   31
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_WIDTH	   6
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 register field value. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_SET_MSK	   0xfc000000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 register field value.
 */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_CLR_MSK	   0x03ffffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 register field. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_RESET	   0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_GET(value) (((value)&0xfc000000) >> 26)
/* Produces a CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 register field value suitable for
 * setting the register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26_SET(value) (((value) << 26) & 0xfc000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_SINGLE_COMMAND_ADDRESS.
 */
struct CORE_MDIO_SINGLE_COMMAND_ADDRESS_s {
	volatile uint32_t RA : 16; /* CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA */
	volatile uint32_t PA : 5;  /* CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA */
	volatile uint32_t DA : 5;  /* CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA */
	const volatile uint32_t
		Reserved_31_26 : 6; /* CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESERVED_31_26 */
};

/* The typedef declaration for register CORE_MDIO_SINGLE_COMMAND_ADDRESS. */
typedef struct CORE_MDIO_SINGLE_COMMAND_ADDRESS_s CORE_MDIO_SINGLE_COMMAND_ADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_SINGLE_COMMAND_ADDRESS register. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_SINGLE_COMMAND_ADDRESS register from the beginning of the
 * component. */
#define CORE_MDIO_SINGLE_COMMAND_ADDRESS_OFST  0x200

/*
 * Register : MDIO_Single_Command_Control_Data
 *
 * This register controls single read/write operations, and contains the data bits
 * read on a single-read operation and the data to be written during single-write
 * operations.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA
 *  [17:16] | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD
 *  [18]    | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR
 *  [21:19] | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR
 *  [22]    | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY
 *  [29:23] | R      | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23
 *  [30]    | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE
 *  [31]    | RW     | 0x0   | CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS
 *
 */
/*
 * Field : SDATA
 *
 * Single Write Data
 *
 * For single writes, this field contains data to be written.
 *
 * For single reads, this field contains data that has been read.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_MSB	       15
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_WIDTH      16
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_SET_MSK    0x0000ffff
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_CLR_MSK    0xffff0000
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_RESET      0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA register field value suitable for setting
 * the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : CMD
 *
 * Control Command
 *
 * SMA commands are written to these bits. The command codes are:
 *
 * * 2'b11: SINGLE_READ
 *
 * * 2'b01: SINGLE_WRITE
 *
 * * 2'b10: POST INCREMENT READ OPERATION
 *
 * * 2'b00: Reserved (Results are undefined)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_LSB	     16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_MSB	     17
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_WIDTH	     2
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_SET_MSK    0x00030000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_CLR_MSK    0xfffcffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_RESET	     0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_GET(value) (((value)&0x00030000) >> 16)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD register field value suitable for setting
 * the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD_SET(value) (((value) << 16) & 0x00030000)

/*
 * Field : SAADR
 *
 * Skip Address Frame
 *
 * The application sets this bit to prevent the SMA from sending address frames
 * before read, write, or post-increment read frames.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_LSB	       18
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_MSB	       18
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_WIDTH      1
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_SET_MSK    0x00040000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_RESET      0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR register field value suitable for setting
 * the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : CR
 *
 * Application Clock Range
 *
 * The Application Clock Range selection determines the relationship between the
 * CSR and MDC clocks. Do not change the value of CR bits unless there is no
 * operation (continuous write or scan) in progress on the SMA interface.
 *
 * When CRS bit is set to 0:
 *
 * * 3'b000
 *
 * * - clk_csr_i: 100-150 MHz
 *
 * * - MDC clock: clk_csr_i/62
 *
 * * 3'b001
 *
 * * - clk_csr_i: 150-250 MHz
 *
 * * - MDC clock: clk_csr_i/102
 *
 * * 3'b010
 *
 * * - clk_csr_i: 250-300 MHz
 *
 * * - MDC clock: clk_csr_i/122
 *
 * * 3'b011
 *
 * * - clk_csr_i: 300-350 MHz
 *
 * * - MDC clock: clk_csr_i/142
 *
 * * 3'b100
 *
 * * - clk_csr_i: 350-400 MHz
 *
 * * - MDC clock: clk_csr_i/162
 *
 * * 3'b101
 *
 * * - clk_csr_i: 400-500 MHz
 *
 * * - MDC clock: clk_csr_i/202
 *
 * * 3'b110
 *
 * * - clk_csr_i: Reserved
 *
 * * - MDC clock: Reserved
 *
 * * 3'b111
 *
 * * - clk_csr_i: Reserved
 *
 * * - MDC clock: Reserved
 *
 * When CRS bit is set to 1, MDIO clock is derived based on CSR clock as follows:
 *
 * * 3'b000: MDC clock: clk_csr_i/4
 *
 * * 3'b001: MDC clock: clk_csr_i/6
 *
 * * 3'b010: MDC clock: clk_csr_i/8
 *
 * * 3'b011: MDC clock: clk_csr_i/10
 *
 * * 3'b100: MDC clock: clk_csr_i/10
 *
 * * 3'b101: MDC clock: clk_csr_i/14
 *
 * * 3'b110: MDC clock: clk_csr_i/16
 *
 * * 3'b111: MDC clock: clk_csr_i/18
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_LSB	    19
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_MSB	    21
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_WIDTH	    3
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_SET_MSK    0x00380000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_CLR_MSK    0xffc7ffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_RESET	    0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_GET(value) (((value)&0x00380000) >> 19)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR register field value suitable for setting the
 * register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR_SET(value) (((value) << 19) & 0x00380000)

/*
 * Field : SBusy
 *
 * Busy
 *
 * When you set this bit, it triggers a single read, single write, or post-
 * increment read operation. DWC_xgmac clears this bit when the triggered operation
 * is completed.
 *
 * During the MDIO transfer cycle, this bit remains high to indicate the cycle in
 * progress. When the Busy bit is high, do not modify any bits in SMA registers 1
 * or 2.
 *
 * When this bit is set high, bits[15:0] of MDIO_Single_Command_Control_Data must
 * be kept valid for MDIO write access or bits[15:0] of
 * MDIO_Single_Command_Control_Data are invalid (for MDIO read access).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_LSB	       22
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_MSB	       22
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_WIDTH      1
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_SET_MSK    0x00400000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_RESET      0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY register field value suitable for setting
 * the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : Reserved_29_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_LSB	23
/* The Most Significant Bit (MSB) position of the
 * CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_MSB	29
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_WIDTH	7
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field
 * value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_SET_MSK	0x3f800000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field
 * value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_CLR_MSK	0xc07fffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_RESET	0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_GET(value) (((value)&0x3f800000) >> 23)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 register field value suitable for
 * setting the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23_SET(value)                            \
	(((value) << 23) & 0x3f800000)

/*
 * Field : PSE
 *
 * Preamble Suppression Enable.
 *
 * When this bit is set, the SMA suppresses the 32-bit preamble and transmits MDIO
 * packets with only 1 preamble bit. When this bit is 0, the MDIO packet always has
 * 32 bits of preamble as defined in the IEEE specifications.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_MSB	     30
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_WIDTH	     1
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_RESET	     0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE register field value suitable for setting
 * the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : CRS
 *
 * Clock Range Select.
 *
 * When this set overrides the default MDIO clock generation based on CSR clock.
 * When this bit is set MDIO Clock generation using CSR clock such that MDIO
 * frequency is equals to CSR clock divided by 4, 6, 8, 10, 12, 14, 16, 18.
 * Therefore, this mode enables faster clock on MDIO.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS
 * register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS register
 * field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_MSB	     31
/* The width in bits of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_WIDTH	     1
/* The mask used to set the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS register field value. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS register field. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_RESET	     0x0
/* Extracts the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS field value from a register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS register field value suitable for setting
 * the register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA.
 */
struct CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_s {
	volatile uint32_t SDATA : 16; /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA */
	volatile uint32_t CMD : 2;    /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD */
	volatile uint32_t SAADR : 1;  /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SAADR */
	volatile uint32_t CR : 3;     /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR */
	volatile uint32_t SBusy : 1;  /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY */
	const volatile uint32_t
		Reserved_29_23 : 7; /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESERVED_29_23 */
	volatile uint32_t PSE : 1;  /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_PSE */
	volatile uint32_t CRS : 1;  /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CRS */
};

/* The typedef declaration for register CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA. */
typedef struct CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_s CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA register. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_RESET 0x00000000
/* The byte offset of the CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA register from the beginning of the
 * component. */
#define CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_OFST  0x204

/*
 * Register : MDIO_Continuous_Write_Address
 *
 * You can program this register to start continuous write operation.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR
 *  [20:16] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR
 *  [21]    | RW     | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT
 *  [22]    | RW     | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY
 *  [31:23] | R      | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23
 *
 */
/*
 * Field : CREGADDR
 *
 * Continuous Register Address
 *
 * Register address to which continuous writes are performed. For Clause 22 ports,
 * only the five least significant bits are valid.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR
 * register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR
 * register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_MSB	       15
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_WIDTH      16
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_SET_MSK    0x0000ffff
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_CLR_MSK    0xffff0000
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_RESET      0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR register field value suitable for setting
 * the register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : CADDR
 *
 * Continuous Port or Device Address
 *
 * Common address to which continuous writes are applied. Used either as a device
 * address or a port address, depending on the CPRT setting. As a port address, the
 * valid range is 0-3 only.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_MSB	    20
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_WIDTH	    5
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_SET_MSK    0x001f0000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_CLR_MSK    0xffe0ffff
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_RESET	    0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_GET(value) (((value)&0x001f0000) >> 16)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR register field value suitable for setting the
 * register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR_SET(value) (((value) << 16) & 0x001f0000)

/*
 * Field : CPRT
 *
 * Continuous Port or Device Address Select
 *
 * When this bit is set, the CADDR is used as the port address and continuous
 * writes are performed on all port devices.
 *
 * When this bit is unset, CADDR is used as the device address and continuous
 * writes are performed on all ports.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_LSB	   21
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_MSB	   21
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_SET_MSK	   0x00200000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_CLR_MSK	   0xffdfffff
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT register field value suitable for setting the
 * register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : CBUSY
 *
 * Continuous Write Busy
 *
 * When this bit is set, continuous write operation starts. When continuous write
 * operation is complete, this bit is reset.
 *
 * This bit must read as 0 before the next continuous write command is issued.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_LSB	    22
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_MSB	    22
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_WIDTH	    1
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_SET_MSK    0x00400000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_RESET	    0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY register field value suitable for setting the
 * register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : Reserved_31_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23
 * register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_LSB	     23
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23
 * register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_MSB	     31
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_WIDTH	     9
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 register field value.
 */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_SET_MSK    0xff800000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 register field
 * value. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_CLR_MSK    0x007fffff
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_RESET	     0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_GET(value) (((value)&0xff800000) >> 23)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23_SET(value) (((value) << 23) & 0xff800000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_CONTINUOUS_WRITE_ADDRESS.
 */
struct CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_s {
	volatile uint32_t CREGADDR : 16; /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CREGADDR */
	volatile uint32_t CADDR : 5;	 /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CADDR */
	volatile uint32_t CPRT : 1;	 /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CPRT */
	volatile uint32_t CBUSY : 1;	 /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_CBUSY */
	const volatile uint32_t
		Reserved_31_23 : 9; /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESERVED_31_23 */
};

/* The typedef declaration for register CORE_MDIO_CONTINUOUS_WRITE_ADDRESS. */
typedef struct CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_s CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS register. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_CONTINUOUS_WRITE_ADDRESS register from the beginning of the
 * component. */
#define CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_OFST	 0x208

/*
 * Register : MDIO_Continuous_Write_Data
 *
 * This register contains the data to be written during continuous write operation.
 * Do not change the register's contents until the Continuous Write Busy bit
 * (CBUSY) is cleared.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA
 *  [31:16] | R      | 0x0   | CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16
 *
 */
/*
 * Field : CDATA
 *
 * Continuous Write Data
 *
 * Data to be used in the MDIO frame during a continuous write. Do not modify the
 * register's contents unless the Continuous Write Busy bit (CBUSY) is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register
 * field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_MSB	 15
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_WIDTH	 16
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_RESET	 0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA register field value suitable for setting the
 * register. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16
 * register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_LSB	  16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16
 * register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_MSB	  31
/* The width in bits of the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_WIDTH	  16
/* The mask used to set the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 register field value. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_SET_MSK	  0xffff0000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 register field value.
 */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_CLR_MSK	  0x0000ffff
/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 register field. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 field value from a register. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_CONTINUOUS_WRITE_DATA.
 */
struct CORE_MDIO_CONTINUOUS_WRITE_DATA_s {
	volatile uint32_t CDATA : 16; /* CORE_MDIO_CONTINUOUS_WRITE_DATA_CDATA */
	const volatile uint32_t
		Reserved_31_16 : 16; /* CORE_MDIO_CONTINUOUS_WRITE_DATA_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MDIO_CONTINUOUS_WRITE_DATA. */
typedef struct CORE_MDIO_CONTINUOUS_WRITE_DATA_s CORE_MDIO_CONTINUOUS_WRITE_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_CONTINUOUS_WRITE_DATA register. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_RESET 0x00000000
/* The byte offset of the CORE_MDIO_CONTINUOUS_WRITE_DATA register from the beginning of the
 * component. */
#define CORE_MDIO_CONTINUOUS_WRITE_DATA_OFST  0x20c

/*
 * Register : MDIO_Continuous_Scan_Port_Enable
 *
 * This register controls the PHY ports and corresponding devices (enabled by the
 * corresponding Device In Use register) to be accessed during the SMA's continuous
 * scan operation. If you change any bit in this register during a continuous scan,
 * it takes effect at the end of the current scan read cycle. In other words, if
 * Bit 2 (Port 2) is enabled while Port 3, 0, or 1 is being scanned, port 2
 * scanning is scheduled at the end of the Port 1 scan. If any bit is cleared by
 * software, it takes effect at the end of the reading the last register of last
 * enabled device.
 *
 * Register Layout
 *
 *  Bits | Access | Reset | Description
 * :-----|:-------|:------|:------------------------------------------------------------------
 *  [0]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE
 *  [1]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE
 *  [2]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE
 *  [3]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE
 *  [4]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE
 *  [5]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE
 *  [6]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE
 *  [7]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE
 *  [8]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE
 *  [9]  | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE
 *  [10] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE
 *  [11] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE
 *  [12] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE
 *  [13] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE
 *  [14] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE
 *  [15] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE
 *  [16] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE
 *  [17] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE
 *  [18] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE
 *  [19] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE
 *  [20] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE
 *  [21] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE
 *  [22] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE
 *  [23] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE
 *  [24] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE
 *  [25] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE
 *  [26] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE
 *  [27] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE
 *  [28] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE
 *  [29] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE
 *  [30] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE
 *  [31] | RW     | 0x0   | CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE
 *
 */
/*
 * Field : PORT0SCE
 *
 * Port 0 Continuous Scan Enable.
 *
 * This bit indicates that Port 0 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_MSB	  0
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_SET_MSK	  0x00000001
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_CLR_MSK	  0xfffffffe
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PORT1SCE
 *
 * Port 1 Continuous Scan Enable.
 *
 * This bit indicates that Port 1 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_MSB	  1
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PORT2SCE
 *
 * Port 2 Continuous Scan Enable.
 *
 * This bit indicates that Port 2 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_LSB	  2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_MSB	  2
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_SET_MSK	  0x00000004
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_CLR_MSK	  0xfffffffb
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : PORT3SCE
 *
 * Port 3 Continuous Scan Enable.
 *
 * This bit indicates that Port 3 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_LSB	  3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_MSB	  3
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_SET_MSK	  0x00000008
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_CLR_MSK	  0xfffffff7
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : PORT4SCE
 *
 * Port 4 Continuous Scan Enable.
 *
 * This bit indicates that Port 4 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_LSB	  4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_MSB	  4
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_SET_MSK	  0x00000010
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_CLR_MSK	  0xffffffef
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : PORT5SCE
 *
 * Port 5 Continuous Scan Enable.
 *
 * This bit indicates that Port 5 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_LSB	  5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_MSB	  5
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_SET_MSK	  0x00000020
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_CLR_MSK	  0xffffffdf
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : PORT6SCE
 *
 * Port 6 Continuous Scan Enable.
 *
 * This bit indicates that Port 6 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_LSB	  6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_MSB	  6
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_SET_MSK	  0x00000040
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_CLR_MSK	  0xffffffbf
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : PORT7SCE
 *
 * Port 7 Continuous Scan Enable.
 *
 * This bit indicates that Port 7 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_LSB	  7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_MSB	  7
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_SET_MSK	  0x00000080
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_CLR_MSK	  0xffffff7f
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PORT8SCE
 *
 * Port 8 Continuous Scan Enable.
 *
 * This bit indicates that Port 8 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_MSB	  8
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_SET_MSK	  0x00000100
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_CLR_MSK	  0xfffffeff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : PORT9SCE
 *
 * Port 9 Continuous Scan Enable.
 *
 * This bit indicates that Port 9 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_LSB	  9
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_MSB	  9
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_WIDTH	  1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_SET_MSK	  0x00000200
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_CLR_MSK	  0xfffffdff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_RESET	  0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : PORT10SCE
 *
 * Port 10 Continuous Scan Enable.
 *
 * This bit indicates that Port 10 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_LSB	   10
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_MSB	   10
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_SET_MSK	   0x00000400
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_CLR_MSK	   0xfffffbff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : PORT11SCE
 *
 * Port 11 Continuous Scan Enable.
 *
 * This bit indicates that Port 11 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_LSB	   11
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_MSB	   11
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_SET_MSK	   0x00000800
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_CLR_MSK	   0xfffff7ff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : PORT12SCE
 *
 * Port 12 Continuous Scan Enable.
 *
 * This bit indicates that Port 12 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_LSB	   12
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_MSB	   12
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_SET_MSK	   0x00001000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_CLR_MSK	   0xffffefff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : PORT13SCE
 *
 * Port 13 Continuous Scan Enable.
 *
 * This bit indicates that Port 13 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_LSB	   13
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_MSB	   13
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_SET_MSK	   0x00002000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_CLR_MSK	   0xffffdfff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : PORT14SCE
 *
 * Port 14 Continuous Scan Enable.
 *
 * This bit indicates that Port 14 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_LSB	   14
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_MSB	   14
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_SET_MSK	   0x00004000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_CLR_MSK	   0xffffbfff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : PORT15SCE
 *
 * Port 15 Continuous Scan Enable.
 *
 * This bit indicates that Port 15 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_LSB	   15
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_MSB	   15
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_SET_MSK	   0x00008000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_CLR_MSK	   0xffff7fff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : PORT16SCE
 *
 * Port 16 Continuous Scan Enable.
 *
 * This bit indicates that Port 16 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_LSB	   16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_MSB	   16
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_SET_MSK	   0x00010000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_CLR_MSK	   0xfffeffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : PORT17SCE
 *
 * Port 17 Continuous Scan Enable.
 *
 * This bit indicates that Port 17 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_LSB	   17
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_MSB	   17
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_SET_MSK	   0x00020000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_CLR_MSK	   0xfffdffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : PORT18SCE
 *
 * Port 18 Continuous Scan Enable.
 *
 * This bit indicates that Port 18 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_LSB	   18
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_MSB	   18
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_SET_MSK	   0x00040000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_CLR_MSK	   0xfffbffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : PORT19SCE
 *
 * Port 19 Continuous Scan Enable.
 *
 * This bit indicates that Port 19 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_LSB	   19
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_MSB	   19
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_SET_MSK	   0x00080000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_CLR_MSK	   0xfff7ffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : PORT20SCE
 *
 * Port 20 Continuous Scan Enable.
 *
 * This bit indicates that Port 20 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_LSB	   20
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_MSB	   20
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_SET_MSK	   0x00100000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_CLR_MSK	   0xffefffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : PORT21SCE
 *
 * Port 21 Continuous Scan Enable.
 *
 * This bit indicates that Port 21 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_LSB	   21
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_MSB	   21
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_SET_MSK	   0x00200000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_CLR_MSK	   0xffdfffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : PORT22SCE
 *
 * Port 22 Continuous Scan Enable.
 *
 * This bit indicates that Port 22 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_LSB	   22
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_MSB	   22
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_SET_MSK	   0x00400000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_CLR_MSK	   0xffbfffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : PORT23SCE
 *
 * Port 23 Continuous Scan Enable.
 *
 * This bit indicates that Port 23 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_LSB	   23
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_MSB	   23
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_SET_MSK	   0x00800000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_CLR_MSK	   0xff7fffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : PORT24SCE
 *
 * Port 24 Continuous Scan Enable.
 *
 * This bit indicates that Port 24 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_LSB	   24
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_MSB	   24
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_SET_MSK	   0x01000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_CLR_MSK	   0xfeffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : PORT25SCE
 *
 * Port 25 Continuous Scan Enable.
 *
 * This bit indicates that Port 25 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_LSB	   25
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_MSB	   25
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_SET_MSK	   0x02000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_CLR_MSK	   0xfdffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : PORT26SCE
 *
 * Port 26 Continuous Scan Enable.
 *
 * This bit indicates that Port 26 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_LSB	   26
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_MSB	   26
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_SET_MSK	   0x04000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_CLR_MSK	   0xfbffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : PORT27SCE
 *
 * Port 27 Continuous Scan Enable.
 *
 * This bit indicates that Port 27 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_LSB	   27
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_MSB	   27
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_SET_MSK	   0x08000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_CLR_MSK	   0xf7ffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : PORT28SCE
 *
 * Port 28 Continuous Scan Enable.
 *
 * This bit indicates that Port 28 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_LSB	   28
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_MSB	   28
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_SET_MSK	   0x10000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_CLR_MSK	   0xefffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : PORT29SCE
 *
 * Port 29 Continuous Scan Enable.
 *
 * This bit indicates that Port 29 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_LSB	   29
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_MSB	   29
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_SET_MSK	   0x20000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_CLR_MSK	   0xdfffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : PORT30SCE
 *
 * Port 30 Continuous Scan Enable.
 *
 * This bit indicates that Port 30 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_LSB	   30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_MSB	   30
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_SET_MSK	   0x40000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_CLR_MSK	   0xbfffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : PORT31SCE
 *
 * Port 31 Continuous Scan Enable.
 *
 * This bit indicates that Port 31 is enabled for continuous scan. Software can
 * disable the port for continuous scan by setting this bit to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE
 * register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_MSB	   31
/* The width in bits of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_WIDTH	   1
/* The mask used to set the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE register field value. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE register field value.
 */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE register field. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_RESET	   0x0
/* Extracts the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE field value from a register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE register field value suitable for
 * setting the register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE.
 */
struct CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_s {
	volatile uint32_t PORT0SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT0SCE */
	volatile uint32_t PORT1SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT1SCE */
	volatile uint32_t PORT2SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT2SCE */
	volatile uint32_t PORT3SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT3SCE */
	volatile uint32_t PORT4SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT4SCE */
	volatile uint32_t PORT5SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT5SCE */
	volatile uint32_t PORT6SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT6SCE */
	volatile uint32_t PORT7SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT7SCE */
	volatile uint32_t PORT8SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT8SCE */
	volatile uint32_t PORT9SCE : 1;	 /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT9SCE */
	volatile uint32_t PORT10SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT10SCE */
	volatile uint32_t PORT11SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT11SCE */
	volatile uint32_t PORT12SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT12SCE */
	volatile uint32_t PORT13SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT13SCE */
	volatile uint32_t PORT14SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT14SCE */
	volatile uint32_t PORT15SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT15SCE */
	volatile uint32_t PORT16SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT16SCE */
	volatile uint32_t PORT17SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT17SCE */
	volatile uint32_t PORT18SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT18SCE */
	volatile uint32_t PORT19SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT19SCE */
	volatile uint32_t PORT20SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT20SCE */
	volatile uint32_t PORT21SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT21SCE */
	volatile uint32_t PORT22SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT22SCE */
	volatile uint32_t PORT23SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT23SCE */
	volatile uint32_t PORT24SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT24SCE */
	volatile uint32_t PORT25SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT25SCE */
	volatile uint32_t PORT26SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT26SCE */
	volatile uint32_t PORT27SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT27SCE */
	volatile uint32_t PORT28SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT28SCE */
	volatile uint32_t PORT29SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT29SCE */
	volatile uint32_t PORT30SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT30SCE */
	volatile uint32_t PORT31SCE : 1; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_PORT31SCE */
};

/* The typedef declaration for register CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE. */
typedef struct CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_s CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE register. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_RESET 0x00000000
/* The byte offset of the CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE register from the beginning of the
 * component. */
#define CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_OFST  0x210

/*
 * Register : MDIO_Interrupt_Status
 *
 * This register gives the source of the interrupt raised by the SMA module on the
 * sbd_intr_o output line. The status bits are cleared when the software reads the
 * corresponding bytes.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT
 *  [1]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT
 *  [2]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT
 *  [3]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT
 *  [4]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT
 *  [5]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT
 *  [6]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT
 *  [7]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT
 *  [8]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT
 *  [9]     | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT
 *  [10]    | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT
 *  [11]    | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT
 *  [12]    | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT
 *  [13]    | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT
 *  [31:14] | R      | 0x0   | CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14
 *
 */
/*
 * Field : PORTNx4P0CONINT
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus0).
 *
 * When set, indicates that Port Nx4 Plus0 caused an interrupt due to a connection
 * or disconnection.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_MSB	      0
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_WIDTH      1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_RESET      0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PORTNx4P1CONINT
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus1).
 *
 * When set, indicates that Port Nx4 Plus1 caused an interrupt due to a connection
 * or disconnection.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_LSB	      1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_MSB	      1
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_WIDTH      1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_SET_MSK    0x00000002
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_RESET      0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PORTNx4P2CONINT
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus2).
 *
 * When set, indicates that Port Nx4 Plus2 caused an interrupt due to a connection
 * or disconnection.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_MSB	      2
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_WIDTH      1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_RESET      0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : PORTNx4P3CONINT
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus3).
 *
 * When set, indicates that Port Nx4 Plus3 caused an interrupt due to a connection
 * or disconnection.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_MSB	      3
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_WIDTH      1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_RESET      0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : PORTNx4P0LSINT
 *
 * Link Status Change Interrupt (Port Nx4 Plus0).
 *
 * When set, indicates that the link status changed on at least one of the Port Nx4
 * Plus0 devices.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_MSB	     4
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_SET_MSK    0x00000010
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_CLR_MSK    0xffffffef
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : PORTNx4P1LSINT
 *
 * Link Status Change Interrupt (Port Nx4 Plus1).
 *
 * When set, indicates that the link status changed on at least one of the Port Nx4
 * Plus1 devices.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_LSB	     5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_MSB	     5
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_SET_MSK    0x00000020
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : PORTNx4P2LSINT
 *
 * Link Status Change Interrupt (Port Nx4 Plus2).
 *
 * When set, indicates that the link status changed on at least one of the Port Nx4
 * Plus2 devices.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_MSB	     6
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : PORTNx4P3LSINT
 *
 * Link Status Change Interrupt (Port Nx4 Plus3).
 *
 * When set, indicates that the link status changed on at least one of the Port Nx4
 * Plus3 devices.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-0 (or when byte-0 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_LSB	     7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_MSB	     7
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_SET_MSK    0x00000080
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PORTNx4P0ALINT
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus0).
 *
 * When set, indicates that an interrupt occurred due to a change in one or more of
 * the Port Nx4 Plus0 device's Alive status.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-1 (or when byte-1 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_MSB	     8
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_SET_MSK    0x00000100
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : PORTNx4P1ALINT
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus1).
 *
 * When set, indicates that an interrupt occurred due to a change in one or more of
 * the Port Nx4 Plus1 device's Alive status.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-1 (or when byte-1 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_LSB	     9
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_MSB	     9
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_SET_MSK    0x00000200
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : PORTNx4P2ALINT
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus2).
 *
 * When set, indicates that an interrupt occurred due to a change in one or more of
 * the Port Nx4 Plus2 device's Alive status.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-1 (or when byte-1 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_LSB	     10
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_MSB	     10
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_SET_MSK    0x00000400
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : PORTNx4P3ALINT
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus3).
 *
 * When set, indicates that an interrupt occurred due to a change in one or more of
 * the Port Nx4 Plus3 device's Alive status.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Access restriction applies. Clears on reading byte-1 (or when byte-1 is written
 * when RCWE bit in MAC_CSR_SW_Ctrl register is set)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_LSB	     11
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_MSB	     11
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_WIDTH	     1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_SET_MSK    0x00000800
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : SNGLCOMPINT
 *
 * Single Command Completion Interrupt.
 *
 * Set when a single command completes.
 *
 * Note:  This bit is available only when PRS field of MDIO Port Nx4 Indirect
 * Control register is 0.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_LSB	  12
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_MSB	  12
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_WIDTH	  1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_SET_MSK	  0x00001000
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_CLR_MSK	  0xffffefff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_RESET	  0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : CWCOMPINT
 *
 * Continuous Write Completion Interrupt.
 *
 * Set when a continuous write completes.
 *
 * Note: This bit is valid only when PRS field of MDIO Port Nx4 Indirect Control
 * register is 0.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_LSB	13
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_MSB	13
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_WIDTH	1
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_SET_MSK	0x00002000
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_CLR_MSK	0xffffdfff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register field. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_RESET	0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Reserved_31_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14
 * register field. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_LSB	     14
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 register
 * field. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_MSB	     31
/* The width in bits of the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 register field. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_WIDTH	     18
/* The mask used to set the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_SET_MSK    0xffffc000
/* The mask used to clear the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 register field value. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_CLR_MSK    0x00003fff
/* The reset value of the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 register field. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 field value from a register. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_GET(value) (((value)&0xffffc000) >> 14)
/* Produces a CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14_SET(value) (((value) << 14) & 0xffffc000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_INTERRUPT_STATUS.
 */
struct CORE_MDIO_INTERRUPT_STATUS_s {
	const volatile uint32_t
		PORTNx4P0CONINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0CONINT */
	const volatile uint32_t
		PORTNx4P1CONINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1CONINT */
	const volatile uint32_t
		PORTNx4P2CONINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2CONINT */
	const volatile uint32_t
		PORTNx4P3CONINT : 1;		    /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3CONINT */
	const volatile uint32_t PORTNx4P0LSINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0LSINT */
	const volatile uint32_t PORTNx4P1LSINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1LSINT */
	const volatile uint32_t PORTNx4P2LSINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2LSINT */
	const volatile uint32_t PORTNx4P3LSINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3LSINT */
	const volatile uint32_t PORTNx4P0ALINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P0ALINT */
	const volatile uint32_t PORTNx4P1ALINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P1ALINT */
	const volatile uint32_t PORTNx4P2ALINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P2ALINT */
	const volatile uint32_t PORTNx4P3ALINT : 1; /* CORE_MDIO_INTERRUPT_STATUS_PORTNX4P3ALINT */
	const volatile uint32_t SNGLCOMPINT : 1;    /* CORE_MDIO_INTERRUPT_STATUS_SNGLCOMPINT */
	const volatile uint32_t CWCOMPINT : 1;	    /* CORE_MDIO_INTERRUPT_STATUS_CWCOMPINT */
	const volatile uint32_t Reserved_31_14 : 18; /* CORE_MDIO_INTERRUPT_STATUS_RESERVED_31_14 */
};

/* The typedef declaration for register CORE_MDIO_INTERRUPT_STATUS. */
typedef struct CORE_MDIO_INTERRUPT_STATUS_s CORE_MDIO_INTERRUPT_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_INTERRUPT_STATUS register. */
#define CORE_MDIO_INTERRUPT_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_INTERRUPT_STATUS register from the beginning of the component.
 */
#define CORE_MDIO_INTERRUPT_STATUS_OFST	 0x214

/*
 * Register : MDIO_Interrupt_Enable
 *
 * This register controls the enabling of interrupt sources in the MDIO Interrupt
 * Status register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE
 *  [1]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE
 *  [2]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE
 *  [3]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE
 *  [4]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE
 *  [5]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE
 *  [6]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE
 *  [7]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE
 *  [8]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE
 *  [9]     | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE
 *  [10]    | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE
 *  [11]    | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE
 *  [12]    | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE
 *  [13]    | RW     | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE
 *  [31:14] | R      | 0x0   | CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14
 *
 */
/*
 * Field : PTRNx4P0CONIE
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus0) Enable.
 *
 * When set, this bit enables Connect/Disconnect Event interrupts on Port Nx4
 * Plus0.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_MSB	    0
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_WIDTH	    1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_RESET	    0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PTRNx4P1CONIE
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus1) Enable.
 *
 * When set, this bit enables Connect/Disconnect Event interrupts on Port Nx4
 * Plus1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_LSB	    1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_MSB	    1
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_WIDTH	    1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_SET_MSK    0x00000002
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_RESET	    0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PTRNx4P2CONIE
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus2) Enable.
 *
 * When set, this bit enables Connect/Disconnect Event interrupts on Port Nx4
 * Plus2.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_LSB	    2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_MSB	    2
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_WIDTH	    1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_RESET	    0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : PTRNx4P3CONIE
 *
 * Connect/Disconnect Event Interrupt (Port Nx4 Plus3) Enable.
 *
 * When set, this bit enables Connect/Disconnect Event interrupts on Port Nx4
 * Plus3.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_LSB	    3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_MSB	    3
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_WIDTH	    1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_RESET	    0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : PTRNx4P0LSIE
 *
 * Link Status Change Interrupt (Port Nx4 Plus0) Enable.
 *
 * When set, this bit enables Link Status Change interrupts on Port Nx4 Plus0.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_LSB	   4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_MSB	   4
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_SET_MSK	   0x00000010
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_CLR_MSK	   0xffffffef
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : PTRNx4P1LSIE
 *
 * Link Status Change Interrupt (Port Nx4 Plus1) Enable.
 *
 * When set, this bit enables Link Status Change interrupts on Port Nx4 Plus1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_LSB	   5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_MSB	   5
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_SET_MSK	   0x00000020
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_CLR_MSK	   0xffffffdf
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : PTRNx4P2LSIE
 *
 * Link Status Change Interrupt (Port Nx4 Plus2) Enable.
 *
 * When set, this bit enables Link Status Change interrupts on Port Nx4 Plus2.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_MSB	   6
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_SET_MSK	   0x00000040
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_CLR_MSK	   0xffffffbf
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : PTRNx4P3LSIE
 *
 * Link Status Change Interrupt (Port Nx4 Plus3) Enable.
 *
 * When set, this bit enables Link Status Change interrupts on Port Nx4 Plus3.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_MSB	   7
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_SET_MSK	   0x00000080
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_CLR_MSK	   0xffffff7f
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PTRNx4P0ALIE
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus0) Enable.
 *
 * When set, this bit enables Device Present Status Change interrupts on Port Nx4
 * Plus0.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_LSB	   8
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_MSB	   8
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_SET_MSK	   0x00000100
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_CLR_MSK	   0xfffffeff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : PTRNx4P1ALIE
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus1) Enable.
 *
 * When set, this bit enables Device Present Status Change interrupts on Port Nx4
 * Plus1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_LSB	   9
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_MSB	   9
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_SET_MSK	   0x00000200
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_CLR_MSK	   0xfffffdff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : PTRNx4P2ALIE
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus2) Enable.
 *
 * When set, this bit enables Device Present Status Change interrupts on Port Nx4
 * Plus2.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_LSB	   10
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_MSB	   10
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_SET_MSK	   0x00000400
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_CLR_MSK	   0xfffffbff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : PTRNx4P3ALIE
 *
 * Device Present Status Change Interrupt (Port Nx4 Plus3) Enable.
 *
 * When set, this bit enables Device Present Status Change interrupts on Port Nx4
 * Plus3.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_LSB	   11
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_MSB	   11
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_WIDTH	   1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_SET_MSK	   0x00000800
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_CLR_MSK	   0xfffff7ff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_RESET	   0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : SNGLCOMPIE
 *
 * Single Command Completion Interrupt Enable.
 *
 * When set, this bit enables Single Command Completion interrupts.
 *
 * Note:  This bit is available only when the PRS field of MDIO Port Nx4 Indirect
 * Control register is 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_LSB	 12
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_MSB	 12
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_WIDTH	 1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_SET_MSK	 0x00001000
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_CLR_MSK	 0xffffefff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_RESET	 0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : CWCOMPIE
 *
 * Continuous Write Completion Interrupt Enable.
 *
 * When set, this bit enables the Continuous Write Completion interrupts.
 *
 * Note:  This bit is available only when the PRS field of MDIO Port Nx4 Indirect
 * Control register is 0
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_LSB	       13
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_MSB	       13
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_WIDTH      1
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_SET_MSK    0x00002000
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_RESET      0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE register field value suitable for setting the
 * register. */
#define CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Reserved_31_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14
 * register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_LSB	     14
/* The Most Significant Bit (MSB) position of the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 register
 * field. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_MSB	     31
/* The width in bits of the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_WIDTH	     18
/* The mask used to set the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_SET_MSK    0xffffc000
/* The mask used to clear the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 register field value. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_CLR_MSK    0x00003fff
/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 register field. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_RESET	     0x0
/* Extracts the CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 field value from a register. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_GET(value) (((value)&0xffffc000) >> 14)
/* Produces a CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 register field value suitable for setting
 * the register. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14_SET(value) (((value) << 14) & 0xffffc000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_INTERRUPT_ENABLE.
 */
struct CORE_MDIO_INTERRUPT_ENABLE_s {
	volatile uint32_t PTRNx4P0CONIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0CONIE */
	volatile uint32_t PTRNx4P1CONIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1CONIE */
	volatile uint32_t PTRNx4P2CONIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2CONIE */
	volatile uint32_t PTRNx4P3CONIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3CONIE */
	volatile uint32_t PTRNx4P0LSIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0LSIE */
	volatile uint32_t PTRNx4P1LSIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1LSIE */
	volatile uint32_t PTRNx4P2LSIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2LSIE */
	volatile uint32_t PTRNx4P3LSIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3LSIE */
	volatile uint32_t PTRNx4P0ALIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P0ALIE */
	volatile uint32_t PTRNx4P1ALIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P1ALIE */
	volatile uint32_t PTRNx4P2ALIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P2ALIE */
	volatile uint32_t PTRNx4P3ALIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_PTRNX4P3ALIE */
	volatile uint32_t SNGLCOMPIE : 1;	     /* CORE_MDIO_INTERRUPT_ENABLE_SNGLCOMPIE */
	volatile uint32_t CWCOMPIE : 1;		     /* CORE_MDIO_INTERRUPT_ENABLE_CWCOMPIE */
	const volatile uint32_t Reserved_31_14 : 18; /* CORE_MDIO_INTERRUPT_ENABLE_RESERVED_31_14 */
};

/* The typedef declaration for register CORE_MDIO_INTERRUPT_ENABLE. */
typedef struct CORE_MDIO_INTERRUPT_ENABLE_s CORE_MDIO_INTERRUPT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_INTERRUPT_ENABLE register. */
#define CORE_MDIO_INTERRUPT_ENABLE_RESET 0x00000000
/* The byte offset of the CORE_MDIO_INTERRUPT_ENABLE register from the beginning of the component.
 */
#define CORE_MDIO_INTERRUPT_ENABLE_OFST	 0x218

/*
 * Register : MDIO_Port_Connect_Disconnect_Status
 *
 * This register gives the hot plug-in status for Ports 0-31. This register is
 * updated at the end of any read operation to any register of the corresponding
 * PHY port. It is updated during single-read transfers or during continuous scan
 * operations. During continuous scan operation, a PHY port is only accessed when
 * the corresponding MDIO Continuous Scan Port Enable register bit is set.
 *
 * Register Layout
 *
 *  Bits | Access | Reset | Description
 * :-----|:-------|:------|:---------------------------------------------------------------------
 *  [0]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON
 *  [1]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON
 *  [2]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON
 *  [3]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON
 *  [4]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON
 *  [5]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON
 *  [6]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON
 *  [7]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON
 *  [8]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON
 *  [9]  | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON
 *  [10] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON
 *  [11] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON
 *  [12] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON
 *  [13] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON
 *  [14] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON
 *  [15] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON
 *  [16] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON
 *  [17] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON
 *  [18] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON
 *  [19] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON
 *  [20] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON
 *  [21] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON
 *  [22] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON
 *  [23] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON
 *  [24] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON
 *  [25] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON
 *  [26] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON
 *  [27] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON
 *  [28] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON
 *  [29] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON
 *  [30] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON
 *  [31] | R      | 0x0   | CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON
 *
 */
/*
 * Field : PORT0CON
 *
 * Port 0 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 0. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_MSB	     0
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PORT1CON
 *
 * Port 1 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 1. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_LSB	     1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_MSB	     1
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_SET_MSK    0x00000002
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PORT2CON
 *
 * Port 2 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 2. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_LSB	     2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_MSB	     2
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : PORT3CON
 *
 * Port 3 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 3. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_LSB	     3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_MSB	     3
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : PORT4CON
 *
 * Port 4 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 4. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_MSB	     4
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_SET_MSK    0x00000010
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_CLR_MSK    0xffffffef
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : PORT5CON
 *
 * Port 5 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 5. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_LSB	     5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_MSB	     5
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_SET_MSK    0x00000020
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : PORT6CON
 *
 * Port 6 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 6. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_MSB	     6
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : PORT7CON
 *
 * Port 7 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 7. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_LSB	     7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_MSB	     7
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_SET_MSK    0x00000080
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PORT8CON
 *
 * Port 8 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 8. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_MSB	     8
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_SET_MSK    0x00000100
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : PORT9CON
 *
 * Port 9 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 9. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_LSB	     9
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_MSB	     9
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_SET_MSK    0x00000200
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : PORT10CON
 *
 * Port 10 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 10. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_LSB	      10
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_MSB	      10
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_SET_MSK    0x00000400
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : PORT11CON
 *
 * Port 11 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 11. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_MSB	      11
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_SET_MSK    0x00000800
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : PORT12CON
 *
 * Port 12 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 12. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_LSB	      12
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_MSB	      12
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_SET_MSK    0x00001000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_CLR_MSK    0xffffefff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : PORT13CON
 *
 * Port 13 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 13. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_LSB	      13
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_MSB	      13
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_SET_MSK    0x00002000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : PORT14CON
 *
 * Port 14 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 14. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_LSB	      14
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_MSB	      14
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_SET_MSK    0x00004000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_CLR_MSK    0xffffbfff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : PORT15CON
 *
 * Port 15 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 15. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_LSB	      15
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_MSB	      15
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_SET_MSK    0x00008000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : PORT16CON
 *
 * Port 16 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 16. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_MSB	      16
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_SET_MSK    0x00010000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : PORT17CON
 *
 * Port 17 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 17. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_LSB	      17
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_MSB	      17
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_SET_MSK    0x00020000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : PORT18CON
 *
 * Port 18 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 18. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_MSB	      18
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_SET_MSK    0x00040000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : PORT19CON
 *
 * Port 19 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 19. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_LSB	      19
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_MSB	      19
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_SET_MSK    0x00080000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : PORT20CON
 *
 * Port 20 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 20. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_LSB	      20
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_MSB	      20
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_SET_MSK    0x00100000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_CLR_MSK    0xffefffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : PORT21CON
 *
 * Port 21 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 21. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_LSB	      21
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_MSB	      21
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_SET_MSK    0x00200000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : PORT22CON
 *
 * Port 22 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 22. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_LSB	      22
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_MSB	      22
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_SET_MSK    0x00400000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : PORT23CON
 *
 * Port 23 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 23. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_LSB	      23
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_MSB	      23
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_SET_MSK    0x00800000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : PORT24CON
 *
 * Port 24 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 24. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_MSB	      24
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_SET_MSK    0x01000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : PORT25CON
 *
 * Port 25 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 25. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_LSB	      25
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_MSB	      25
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_SET_MSK    0x02000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : PORT26CON
 *
 * Port 26 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 26. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_LSB	      26
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_MSB	      26
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_SET_MSK    0x04000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : PORT27CON
 *
 * Port 27 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 27. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_LSB	      27
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_MSB	      27
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_SET_MSK    0x08000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : PORT28CON
 *
 * Port 28 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 28. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_LSB	      28
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_MSB	      28
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_SET_MSK    0x10000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_CLR_MSK    0xefffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : PORT29CON
 *
 * Port 29 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 29. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_LSB	      29
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_MSB	      29
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_SET_MSK    0x20000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_CLR_MSK    0xdfffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : PORT30CON
 *
 * Port 30 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 30. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_MSB	      30
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : PORT31CON
 *
 * Port 31 Connect/Disconnect.
 *
 * The hardware sets this bit when a connection event is detected on Port 31. It is
 * cleared when a disconnection event is detected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON
 * register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_MSB	      31
/* The width in bits of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_WIDTH      1
/* The mask used to set the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON register field value.
 */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON register field
 * value. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON register field. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_RESET      0x0
/* Extracts the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON field value from a register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS.
 */
struct CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_s {
	const volatile uint32_t
		PORT0CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT0CON */
	const volatile uint32_t
		PORT1CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT1CON */
	const volatile uint32_t
		PORT2CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT2CON */
	const volatile uint32_t
		PORT3CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT3CON */
	const volatile uint32_t
		PORT4CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT4CON */
	const volatile uint32_t
		PORT5CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT5CON */
	const volatile uint32_t
		PORT6CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT6CON */
	const volatile uint32_t
		PORT7CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT7CON */
	const volatile uint32_t
		PORT8CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT8CON */
	const volatile uint32_t
		PORT9CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT9CON */
	const volatile uint32_t
		PORT10CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT10CON */
	const volatile uint32_t
		PORT11CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT11CON */
	const volatile uint32_t
		PORT12CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT12CON */
	const volatile uint32_t
		PORT13CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT13CON */
	const volatile uint32_t
		PORT14CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT14CON */
	const volatile uint32_t
		PORT15CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT15CON */
	const volatile uint32_t
		PORT16CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT16CON */
	const volatile uint32_t
		PORT17CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT17CON */
	const volatile uint32_t
		PORT18CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT18CON */
	const volatile uint32_t
		PORT19CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT19CON */
	const volatile uint32_t
		PORT20CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT20CON */
	const volatile uint32_t
		PORT21CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT21CON */
	const volatile uint32_t
		PORT22CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT22CON */
	const volatile uint32_t
		PORT23CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT23CON */
	const volatile uint32_t
		PORT24CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT24CON */
	const volatile uint32_t
		PORT25CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT25CON */
	const volatile uint32_t
		PORT26CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT26CON */
	const volatile uint32_t
		PORT27CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT27CON */
	const volatile uint32_t
		PORT28CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT28CON */
	const volatile uint32_t
		PORT29CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT29CON */
	const volatile uint32_t
		PORT30CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT30CON */
	const volatile uint32_t
		PORT31CON : 1; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_PORT31CON */
};

/* The typedef declaration for register CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS. */
typedef struct CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_s
	CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS register. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS register from the beginning of
 * the component. */
#define CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_OFST  0x21c

/*
 * Register : MDIO_Clause_22_Port
 *
 * This register configures the SMA to access the PHY ports using either the Clause
 * 22 or Clause 45 packet format. All SMA operations (single or continuous) depend
 * on setting these bits correctly.
 *
 * Register Layout
 *
 *  Bits | Access | Reset | Description
 * :-----|:-------|:------|:-----------------------------------------------------
 *  [0]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR0CL22
 *  [1]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR1CL22
 *  [2]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR2CL22
 *  [3]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR3CL22
 *  [4]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR4CL22
 *  [5]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR5CL22
 *  [6]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR6CL22
 *  [7]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR7CL22
 *  [8]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR8CL22
 *  [9]  | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR9CL22
 *  [10] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR10CL22
 *  [11] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR11CL22
 *  [12] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR12CL22
 *  [13] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR13CL22
 *  [14] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR14CL22
 *  [15] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR15CL22
 *  [16] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR16CL22
 *  [17] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR17CL22
 *  [18] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR18CL22
 *  [19] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR19CL22
 *  [20] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR20CL22
 *  [21] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR21CL22
 *  [22] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR22CL22
 *  [23] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR23CL22
 *  [24] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR24CL22
 *  [25] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR25CL22
 *  [26] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR26CL22
 *  [27] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR27CL22
 *  [28] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR28CL22
 *  [29] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR29CL22
 *  [30] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR30CL22
 *  [31] | RW     | 0x0   | CORE_MDIO_CLAUSE_22_PORT_PTR31CL22
 *
 */
/*
 * Field : PTR0CL22
 *
 * Port0CL22 Enable. Indicates that Port 0 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_MSB	     0
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR0CL22_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PTR1CL22
 *
 * Port1CL22 Enable. Indicates that Port 1 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_LSB	     1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_MSB	     1
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_SET_MSK    0x00000002
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR1CL22_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PTR2CL22
 *
 * Port2CL22 Enable. Indicates that Port 2 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_LSB	     2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_MSB	     2
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR2CL22_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : PTR3CL22
 *
 * Port3CL22 Enable. Indicates that Port 3 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_LSB	     3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_MSB	     3
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR3CL22_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : PTR4CL22
 *
 * Port4CL22 Enable. Indicates that Port 4 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_MSB	     4
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_SET_MSK    0x00000010
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_CLR_MSK    0xffffffef
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR4CL22_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : PTR5CL22
 *
 * Port5CL22 Enable. Indicates that Port 5 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_LSB	     5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_MSB	     5
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_SET_MSK    0x00000020
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR5CL22_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : PTR6CL22
 *
 * Port6CL22 Enable. Indicates that Port 6 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_MSB	     6
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR6CL22_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : PTR7CL22
 *
 * Port7CL22 Enable. Indicates that Port 7 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_LSB	     7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_MSB	     7
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_SET_MSK    0x00000080
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR7CL22_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PTR8CL22
 *
 * Port8CL22 Enable. Indicates that Port 8 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_MSB	     8
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_SET_MSK    0x00000100
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR8CL22_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : PTR9CL22
 *
 * Port9CL22 Enable. Indicates that Port 9 is connected to a PHY that only supports
 * Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_LSB	     9
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_MSB	     9
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_WIDTH	     1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_SET_MSK    0x00000200
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_RESET	     0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR9CL22_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : PTR10CL22
 *
 * Port10CL22 Enable. Indicates that Port 10 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_LSB	      10
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_MSB	      10
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_SET_MSK    0x00000400
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR10CL22_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : PTR11CL22
 *
 * Port11CL22 Enable. Indicates that Port 11 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_MSB	      11
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_SET_MSK    0x00000800
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR11CL22_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : PTR12CL22
 *
 * Port12CL22 Enable. Indicates that Port 12 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_LSB	      12
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_MSB	      12
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_SET_MSK    0x00001000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_CLR_MSK    0xffffefff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR12CL22_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : PTR13CL22
 *
 * Port13CL22 Enable. Indicates that Port 13 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_LSB	      13
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_MSB	      13
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_SET_MSK    0x00002000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR13CL22_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : PTR14CL22
 *
 * Port14CL22 Enable. Indicates that Port 14 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_LSB	      14
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_MSB	      14
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_SET_MSK    0x00004000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_CLR_MSK    0xffffbfff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR14CL22_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : PTR15CL22
 *
 * Port15CL22 Enable. Indicates that Port 15 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_LSB	      15
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_MSB	      15
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_SET_MSK    0x00008000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR15CL22_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : PTR16CL22
 *
 * Port16CL22 Enable. Indicates that Port 16 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_MSB	      16
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_SET_MSK    0x00010000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR16CL22_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : PTR17CL22
 *
 * Port17CL22 Enable. Indicates that Port 17 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_LSB	      17
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_MSB	      17
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_SET_MSK    0x00020000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR17CL22_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : PTR18CL22
 *
 * Port18CL22 Enable. Indicates that Port 18 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_MSB	      18
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_SET_MSK    0x00040000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR18CL22_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : PTR19CL22
 *
 * Port19CL22 Enable. Indicates that Port 19 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_LSB	      19
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_MSB	      19
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_SET_MSK    0x00080000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR19CL22_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : PTR20CL22
 *
 * Port20CL22 Enable. Indicates that Port 20 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_LSB	      20
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_MSB	      20
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_SET_MSK    0x00100000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_CLR_MSK    0xffefffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR20CL22_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : PTR21CL22
 *
 * Port21CL22 Enable. Indicates that Port 21 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_LSB	      21
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_MSB	      21
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_SET_MSK    0x00200000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR21CL22_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : PTR22CL22
 *
 * Port22CL22 Enable. Indicates that Port 22 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_LSB	      22
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_MSB	      22
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_SET_MSK    0x00400000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR22CL22_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : PTR23CL22
 *
 * Port23CL22 Enable. Indicates that Port 23 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_LSB	      23
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_MSB	      23
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_SET_MSK    0x00800000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR23CL22_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : PTR24CL22
 *
 * Port24CL22 Enable. Indicates that Port 24 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_MSB	      24
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_SET_MSK    0x01000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR24CL22_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : PTR25CL22
 *
 * Port25CL22 Enable. Indicates that Port 25 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_LSB	      25
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_MSB	      25
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_SET_MSK    0x02000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR25CL22_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : PTR26CL22
 *
 * Port26CL22 Enable. Indicates that Port 26 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_LSB	      26
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_MSB	      26
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_SET_MSK    0x04000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR26CL22_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : PTR27CL22
 *
 * Port27CL22 Enable. Indicates that Port 27 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_LSB	      27
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_MSB	      27
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_SET_MSK    0x08000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR27CL22_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : PTR28CL22
 *
 * Port28CL22 Enable. Indicates that Port 28 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_LSB	      28
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_MSB	      28
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_SET_MSK    0x10000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_CLR_MSK    0xefffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR28CL22_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : PTR29CL22
 *
 * Port29CL22 Enable. Indicates that Port 29 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_LSB	      29
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_MSB	      29
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_SET_MSK    0x20000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_CLR_MSK    0xdfffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR29CL22_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : PTR30CL22
 *
 * Port30CL22 Enable. Indicates that Port 30 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_MSB	      30
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR30CL22_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : PTR31CL22
 *
 * Port31CL22 Enable. Indicates that Port 31 is connected to a PHY that only
 * supports Clause 22. When this bit is reset, the PHY supports Clause 45.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register
 * field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register field.
 */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_MSB	      31
/* The width in bits of the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_WIDTH      1
/* The mask used to set the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register field value. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register field. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_RESET      0x0
/* Extracts the CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 field value from a register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 register field value suitable for setting the
 * register. */
#define CORE_MDIO_CLAUSE_22_PORT_PTR31CL22_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_CLAUSE_22_PORT.
 */
struct CORE_MDIO_CLAUSE_22_PORT_s {
	volatile uint32_t PTR0CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR0CL22 */
	volatile uint32_t PTR1CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR1CL22 */
	volatile uint32_t PTR2CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR2CL22 */
	volatile uint32_t PTR3CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR3CL22 */
	volatile uint32_t PTR4CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR4CL22 */
	volatile uint32_t PTR5CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR5CL22 */
	volatile uint32_t PTR6CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR6CL22 */
	volatile uint32_t PTR7CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR7CL22 */
	volatile uint32_t PTR8CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR8CL22 */
	volatile uint32_t PTR9CL22 : 1;	 /* CORE_MDIO_CLAUSE_22_PORT_PTR9CL22 */
	volatile uint32_t PTR10CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR10CL22 */
	volatile uint32_t PTR11CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR11CL22 */
	volatile uint32_t PTR12CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR12CL22 */
	volatile uint32_t PTR13CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR13CL22 */
	volatile uint32_t PTR14CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR14CL22 */
	volatile uint32_t PTR15CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR15CL22 */
	volatile uint32_t PTR16CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR16CL22 */
	volatile uint32_t PTR17CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR17CL22 */
	volatile uint32_t PTR18CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR18CL22 */
	volatile uint32_t PTR19CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR19CL22 */
	volatile uint32_t PTR20CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR20CL22 */
	volatile uint32_t PTR21CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR21CL22 */
	volatile uint32_t PTR22CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR22CL22 */
	volatile uint32_t PTR23CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR23CL22 */
	volatile uint32_t PTR24CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR24CL22 */
	volatile uint32_t PTR25CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR25CL22 */
	volatile uint32_t PTR26CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR26CL22 */
	volatile uint32_t PTR27CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR27CL22 */
	volatile uint32_t PTR28CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR28CL22 */
	volatile uint32_t PTR29CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR29CL22 */
	volatile uint32_t PTR30CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR30CL22 */
	volatile uint32_t PTR31CL22 : 1; /* CORE_MDIO_CLAUSE_22_PORT_PTR31CL22 */
};

/* The typedef declaration for register CORE_MDIO_CLAUSE_22_PORT. */
typedef struct CORE_MDIO_CLAUSE_22_PORT_s CORE_MDIO_CLAUSE_22_PORT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_CLAUSE_22_PORT register. */
#define CORE_MDIO_CLAUSE_22_PORT_RESET 0x00000000
/* The byte offset of the CORE_MDIO_CLAUSE_22_PORT register from the beginning of the component. */
#define CORE_MDIO_CLAUSE_22_PORT_OFST  0x220

/*
 * Register : MDIO_Port_Nx4_Indirect_Control
 *
 * This register contain fields that control the Port range select for accessing
 * register sets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [2:0]  | RW     | 0x0   | CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS
 *  [31:3] | R      | 0x0   | CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3
 *
 */
/*
 * Field : PRS
 *
 * Port Range Select.
 *
 * This register field controls the Port range select for accessing all the
 * following register sets
 *
 * * MDIO Port Nx4P0/1/2/3 Device In Use register
 *
 * * MDIO Port Nx4P0/1/2/3 Link Status register
 *
 * * MDIO Port Nx4P0/1/2/3 Alive Status register
 *
 * * MDIO Interrupt Status register
 *
 * * MDIO Interrupt Enable register
 *
 * * - 0: Selects the Port address range of 0 to 3
 *
 * * - 1: Selects the Port Address range of 4 to 7
 *
 * * - 2: Selects the Port Address range of 8 to 11
 *
 * * - 3: Selects the Port Address range of 12 to 15
 *
 * * - 4: Selects the Port Address range of 16 to 19
 *
 * * - 5: Selects the Port Address range of 20 to 23
 *
 * * - 6: Selects the Port Address range of 24 to 27
 *
 * * - 7: Selects the Port Address range of 28 to 31
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register
 * field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register
 * field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_MSB	   2
/* The width in bits of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_WIDTH	   3
/* The mask used to set the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register field value. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_SET_MSK	   0x00000007
/* The mask used to clear the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register field value. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_CLR_MSK	   0xfffffff8
/* The reset value of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_RESET	   0x0
/* Extracts the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS field value from a register. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_GET(value) (((value)&0x00000007) >> 0)
/* Produces a CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS register field value suitable for setting the
 * register. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : Reserved_31_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3
 * register field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_LSB	     3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3
 * register field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_MSB	     31
/* The width in bits of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 register field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_WIDTH	     29
/* The mask used to set the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 register field value.
 */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_SET_MSK    0xfffffff8
/* The mask used to clear the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 register field
 * value. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_CLR_MSK    0x00000007
/* The reset value of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 register field. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_RESET	     0x0
/* Extracts the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 field value from a register. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_GET(value) (((value)&0xfffffff8) >> 3)
/* Produces a CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3_SET(value) (((value) << 3) & 0xfffffff8)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORT_NX4_INDIRECT_CONTROL.
 */
struct CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_s {
	volatile uint32_t PRS : 3; /* CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_PRS */
	const volatile uint32_t
		Reserved_31_3 : 29; /* CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESERVED_31_3 */
};

/* The typedef declaration for register CORE_MDIO_PORT_NX4_INDIRECT_CONTROL. */
typedef struct CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_s CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL register. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORT_NX4_INDIRECT_CONTROL register from the beginning of the
 * component. */
#define CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_OFST  0x224

/*
 * Register : MDIO_PortNx4P0_Device_In_Use
 *
 * This register gives the status of each device on Port Nx4 Plus0 (Here N is as
 * per the PRS field of MDIO Port Nx4 Indirect Control register). Set these bits to
 * indicate that a device is present and that the SMA must access it during
 * continuous scan/write operations. If any bit is cleared, the corresponding
 * device is not scanned when the Continuous Scan command is issued nor is it
 * written when the Continuous Write command is issued. This register setting does
 * not affect single read or write commands.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0
 *  [1]    | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA
 *  [2]    | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS
 *  [3]    | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS
 *  [4]    | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS
 *  [5]    | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS
 *  [6]    | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7
 *  [30]   | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1
 *  [31]   | RW     | 0x1   | CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_MSB	0
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_SET_MSK	0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P0PMDPMA
 *
 * PMA Device is in Use
 *
 * When PMD/PMA is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_RESET	 0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P0WIS
 *
 * WIS Device is in Use
 *
 * When WIS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P0PCS
 *
 * PCS Device is in Use
 *
 * When PCS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P0PHYXS
 *
 * PHYXS Device is in Use
 *
 * When PHY XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P0DTEXS
 *
 * DTEXS Device is in Use
 *
 * When DTE XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P0TC
 *
 * TC Device is in Use
 *
 * When TC is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC register
 * field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_RESET	     0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_MSB	   29
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_WIDTH	   23
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_SET_MSK	   0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_CLR_MSK	   0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_RESET	   0x0
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P0VSD1
 *
 * VSD1 Device is in Use
 *
 * When Vendor-Specific Device 1 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P0VSD2
 *
 * VSD2 Device is in Use
 *
 * When Vendor-Specific Device 2 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 register field value. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 register field. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 field value from a register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P0_DEVICE_IN_USE.
 */
struct CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_0 */
	volatile uint32_t Nx4P0PMDPMA : 1;	/* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PMDPMA */
	volatile uint32_t Nx4P0WIS : 1;		/* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0WIS */
	volatile uint32_t Nx4P0PCS : 1;		/* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PCS */
	volatile uint32_t Nx4P0PHYXS : 1;	/* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0PHYXS */
	volatile uint32_t Nx4P0DTEXS : 1;	/* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0DTEXS */
	volatile uint32_t Nx4P0TC : 1;		/* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0TC */
	const volatile uint32_t
		Reserved_29_7 : 23;	 /* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESERVED_29_7 */
	volatile uint32_t Nx4P0VSD1 : 1; /* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD1 */
	volatile uint32_t Nx4P0VSD2 : 1; /* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_NX4P0VSD2 */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P0_DEVICE_IN_USE. */
typedef struct CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_s CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE register. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_RESET 0xc000007e
/* The byte offset of the CORE_MDIO_PORTNX4P0_DEVICE_IN_USE register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_OFST	0x230

/*
 * Register : MDIO_PortNx4P0_Link_Status
 *
 * This register gives the link status of the devices in PHY Port Nx4Plus0 ((Here N
 * is as per the PRS field of MDIO Port Nx4 Indirect Control register) at the end
 * of each continuous scan cycle. Up to eight devices are supported, as specified
 * in IEEE 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus0 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P0 to Nx4P0 (Nx4 Plus 0)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_MSB	      0
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P0PMDPMALS
 *
 * Link Status of PMA Device
 *
 * When the PMD/PMA link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P0WISLS
 *
 * Link Status of WIS Device
 *
 * When the WIS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P0PCSLS
 *
 * Link Status of PCS Device
 *
 * When the PCS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P0PHYXSLS
 *
 * Link Status of PHYXS Device
 *
 * When the PHY XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P0DTEXSLS
 *
 * Link Status of DTEXS Device
 *
 * When the DTE XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P0TCLS
 *
 * Link Status of TC Device
 *
 * When the TC link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS register
 * field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_RESET	     0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_MSB	 29
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_WIDTH	 23
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_SET_MSK	 0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_CLR_MSK	 0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P0VSD1LS
 *
 * Link Status of VCD1 Device
 *
 * When the Vendor-Specific Device 1 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P0VSD2LS
 *
 * Link Status of VSD2 Device
 *
 * When the Vendor-Specific Device 2 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS register field. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P0_LINK_STATUS.
 */
struct CORE_MDIO_PORTNX4P0_LINK_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P0PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PMDPMALS */
	const volatile uint32_t Nx4P0WISLS : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0WISLS */
	const volatile uint32_t Nx4P0PCSLS : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PCSLS */
	const volatile uint32_t Nx4P0PHYXSLS : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0PHYXSLS */
	const volatile uint32_t Nx4P0DTEXSLS : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0DTEXSLS */
	const volatile uint32_t Nx4P0TCLS : 1;	  /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23;		 /* CORE_MDIO_PORTNX4P0_LINK_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P0VSD1LS : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD1LS */
	const volatile uint32_t Nx4P0VSD2LS : 1; /* CORE_MDIO_PORTNX4P0_LINK_STATUS_NX4P0VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P0_LINK_STATUS. */
typedef struct CORE_MDIO_PORTNX4P0_LINK_STATUS_s CORE_MDIO_PORTNX4P0_LINK_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P0_LINK_STATUS register. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P0_LINK_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P0_LINK_STATUS_OFST  0x234

/*
 * Register : MDIO_PortNx4P0_Alive_Status
 *
 * This register gives the device status in PHY Port Nx4Plus0 ((Here N is as per
 * PRS field of "MDIO Port Nx4 Indirect Control" register) at the end of each
 * continuous scan cycle. Up to eight devices are supported, as specified in IEEE
 * 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus0 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P0 to Nx4P0 (Nx4 Plus 0)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_MSB	       0
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P0PMDPMALS
 *
 * Alive Status of PMA Device
 *
 * When PMD/PMA is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_MSB	  1
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_WIDTH	  1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS register field value.
 */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P0WISLS
 *
 * Alive Status of WIS Device
 *
 * When WIS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_MSB	       2
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P0PCSLS
 *
 * Alive Status of PCS Device
 *
 * When PCS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_MSB	       3
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P0PHYXSLS
 *
 * Alive Status of PHYXS Device
 *
 * When PHY XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_MSB	 4
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_SET_MSK	 0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_CLR_MSK	 0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P0DTEXSLS
 *
 * Alive Status of DTEXS Device
 *
 * When DTE XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_LSB	 5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_MSB	 5
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_SET_MSK	 0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_CLR_MSK	 0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P0TCLS
 *
 * Alive Status of TC Device
 *
 * When TC is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_MSB	      6
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_LSB	  7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_MSB	  29
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_WIDTH	  23
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_SET_MSK	  0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_CLR_MSK	  0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P0VSD1LS
 *
 * Alive Status of VSD1 Device
 *
 * When Vendor-Specific Device 1 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_LSB	30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_MSB	30
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_SET_MSK	0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_CLR_MSK	0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P0VSD2LS
 *
 * Alive Status of VSD2 Device
 *
 * When Vendor-Specific Device 2 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_LSB	31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_MSB	31
/* The width in bits of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_SET_MSK	0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS register field. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P0_ALIVE_STATUS.
 */
struct CORE_MDIO_PORTNX4P0_ALIVE_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P0PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PMDPMALS */
	const volatile uint32_t Nx4P0WISLS : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0WISLS */
	const volatile uint32_t Nx4P0PCSLS : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PCSLS */
	const volatile uint32_t
		Nx4P0PHYXSLS : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0PHYXSLS */
	const volatile uint32_t
		Nx4P0DTEXSLS : 1;	       /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0DTEXSLS */
	const volatile uint32_t Nx4P0TCLS : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P0VSD1LS : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD1LS */
	const volatile uint32_t Nx4P0VSD2LS : 1; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS_NX4P0VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P0_ALIVE_STATUS. */
typedef struct CORE_MDIO_PORTNX4P0_ALIVE_STATUS_s CORE_MDIO_PORTNX4P0_ALIVE_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS register. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P0_ALIVE_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P0_ALIVE_STATUS_OFST  0x238

/*
 * Register : MDIO_PortNx4P1_Device_In_Use
 *
 * This register gives the status of each device on Port Nx4 Plus1 (Here N is as
 * per the PRS field of MDIO Port Nx4 Indirect Control register). Set these bits to
 * indicate that a device is present and that the SMA must access it during
 * continuous scan/write operations. If any bit is cleared, the corresponding
 * device is not scanned when the Continuous Scan command is issued nor is it
 * written when the Continuous Write command is issued. This register setting does
 * not affect single read or write commands.
 *
 * Note:  All the register fields are renamed from P1 to Nx4P1 (Nx4 Plus 1)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0
 *  [1]    | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA
 *  [2]    | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS
 *  [3]    | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS
 *  [4]    | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS
 *  [5]    | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS
 *  [6]    | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7
 *  [30]   | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1
 *  [31]   | RW     | 0x1   | CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_MSB	0
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_SET_MSK	0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P1PMDPMA
 *
 * PMA Device is in Use
 *
 * When PMD/PMA is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_RESET	 0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P1WIS
 *
 * WIS Device is in Use
 *
 * When WIS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P1PCS
 *
 * PCS Device is in Use
 *
 * When PCS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P1PHYXS
 *
 * PHYXS Device is in Use
 *
 * When PHY XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P1DTEXS
 *
 * DTEXS Device is in Use
 *
 * When DTE XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P1TC
 *
 * TC Device is in Use
 *
 * When TC is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC register
 * field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_RESET	     0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_MSB	   29
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_WIDTH	   23
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_SET_MSK	   0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_CLR_MSK	   0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_RESET	   0x0
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P1VSD1
 *
 * VSD1 Device is in Use
 *
 * When Vendor-Specific Device 1 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P1VSD2
 *
 * VSD2 Device is in Use
 *
 * When Vendor-Specific Device 2 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 register field value. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 register field. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 field value from a register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P1_DEVICE_IN_USE.
 */
struct CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_0 */
	volatile uint32_t Nx4P1PMDPMA : 1;	/* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PMDPMA */
	volatile uint32_t Nx4P1WIS : 1;		/* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1WIS */
	volatile uint32_t Nx4P1PCS : 1;		/* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PCS */
	volatile uint32_t Nx4P1PHYXS : 1;	/* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1PHYXS */
	volatile uint32_t Nx4P1DTEXS : 1;	/* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1DTEXS */
	volatile uint32_t Nx4P1TC : 1;		/* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1TC */
	const volatile uint32_t
		Reserved_29_7 : 23;	 /* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESERVED_29_7 */
	volatile uint32_t Nx4P1VSD1 : 1; /* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD1 */
	volatile uint32_t Nx4P1VSD2 : 1; /* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_NX4P1VSD2 */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P1_DEVICE_IN_USE. */
typedef struct CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_s CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE register. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_RESET 0xc000007e
/* The byte offset of the CORE_MDIO_PORTNX4P1_DEVICE_IN_USE register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_OFST	0x240

/*
 * Register : MDIO_PortNx4P1_Link_Status
 *
 * This register gives the link status of the devices in PHY Port Nx4Plus1 ((Here N
 * is as per PRS field of MDIO Port Nx4 Indirect Control register) at the end of
 * each continuous scan cycle. Up to eight devices are supported, as specified in
 * IEEE 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus1 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P1 to Nx4P1 (Nx4 Plus 1)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_MSB	      0
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P1PMDPMALS
 *
 * Link Status of PMA Device
 *
 * When the PMD/PMA link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P1WISLS
 *
 * Link Status of WIS Device
 *
 * When the WIS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P1PCSLS
 *
 * Link Status of PCS Device
 *
 * When the PCS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P1PHYXSLS
 *
 * Link Status of PHYXS Device
 *
 * When the PHY XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P1DTEXSLS
 *
 * Link Status of DTEXS Device
 *
 * When the DTE XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P1TCLS
 *
 * Link Status of TC Device
 *
 * When the TC link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS register
 * field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_RESET	     0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_MSB	 29
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_WIDTH	 23
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_SET_MSK	 0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_CLR_MSK	 0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P1VSD1LS
 *
 * Link Status of VSD1 Device
 *
 * When the Vendor-Specific Device 1 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P1VSD2LS
 *
 * Link Status of VSD2 Device
 *
 * When the Vendor-Specific Device 2 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS register field. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P1_LINK_STATUS.
 */
struct CORE_MDIO_PORTNX4P1_LINK_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P1PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PMDPMALS */
	const volatile uint32_t Nx4P1WISLS : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1WISLS */
	const volatile uint32_t Nx4P1PCSLS : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PCSLS */
	const volatile uint32_t Nx4P1PHYXSLS : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1PHYXSLS */
	const volatile uint32_t Nx4P1DTEXSLS : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1DTEXSLS */
	const volatile uint32_t Nx4P1TCLS : 1;	  /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23;		 /* CORE_MDIO_PORTNX4P1_LINK_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P1VSD1LS : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD1LS */
	const volatile uint32_t Nx4P1VSD2LS : 1; /* CORE_MDIO_PORTNX4P1_LINK_STATUS_NX4P1VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P1_LINK_STATUS. */
typedef struct CORE_MDIO_PORTNX4P1_LINK_STATUS_s CORE_MDIO_PORTNX4P1_LINK_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P1_LINK_STATUS register. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P1_LINK_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P1_LINK_STATUS_OFST  0x244

/*
 * Register : MDIO_PortNx4P1_Alive_Status
 *
 * This register gives the device status in PHY Port Nx4Plus1 ((Here N is as per
 * PRS field of MDIO Port Nx4 Indirect Control register) at the end of each
 * continuous scan cycle. Up to eight devices are supported, as specified in IEEE
 * 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus1 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P1 to Nx4P1 (Nx4 Plus 1)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_MSB	       0
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P1PMDPMALS
 *
 * Alive Status of PMA Device
 *
 * When PMD/PMA is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_MSB	  1
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_WIDTH	  1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS register field value.
 */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P1WISLS
 *
 * Alive Status of WIS Device
 *
 * When WIS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_MSB	       2
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P1PCSLS
 *
 * Alive Status of PCS Device
 *
 * When PCS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_MSB	       3
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P1PHYXSLS
 *
 * Alive Status of PHYXS Device
 *
 * When PHY XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_MSB	 4
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_SET_MSK	 0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_CLR_MSK	 0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P1DTEXSLS
 *
 * Alive Status of DTEXS Device
 *
 * When DTE XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_LSB	 5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_MSB	 5
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_SET_MSK	 0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_CLR_MSK	 0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P1TCLS
 *
 * Alive Status of TC Device
 *
 * When TC is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_MSB	      6
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_LSB	  7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_MSB	  29
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_WIDTH	  23
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_SET_MSK	  0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_CLR_MSK	  0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P1VSD1LS
 *
 * Alive Status of VSD1 Device
 *
 * When Vendor-Specific Device 1 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_LSB	30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_MSB	30
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_SET_MSK	0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_CLR_MSK	0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P1VSD2LS
 *
 * Alive Status of VSD2 Device
 *
 * When Vendor-Specific Device 2 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_LSB	31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_MSB	31
/* The width in bits of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_SET_MSK	0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS register field. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P1_ALIVE_STATUS.
 */
struct CORE_MDIO_PORTNX4P1_ALIVE_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P1PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PMDPMALS */
	const volatile uint32_t Nx4P1WISLS : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1WISLS */
	const volatile uint32_t Nx4P1PCSLS : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PCSLS */
	const volatile uint32_t
		Nx4P1PHYXSLS : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1PHYXSLS */
	const volatile uint32_t
		Nx4P1DTEXSLS : 1;	       /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1DTEXSLS */
	const volatile uint32_t Nx4P1TCLS : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P1VSD1LS : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD1LS */
	const volatile uint32_t Nx4P1VSD2LS : 1; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS_NX4P1VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P1_ALIVE_STATUS. */
typedef struct CORE_MDIO_PORTNX4P1_ALIVE_STATUS_s CORE_MDIO_PORTNX4P1_ALIVE_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS register. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P1_ALIVE_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P1_ALIVE_STATUS_OFST  0x248

/*
 * Register : MDIO_PortNx4P2_Device_In_Use
 *
 * This register gives the status of each device on Port Nx4 Plus2 (Here N is as
 * per the PRS field of MDIO Port Nx4 Indirect Control register). Set these bits to
 * indicate that a device is present and that the SMA must access it during
 * continuous scan/write operations. If any bit is cleared, the corresponding
 * device is not scanned when the Continuous Scan command is issued nor is it
 * written when the Continuous Write command is issued. This register setting does
 * not affect single read or write commands.
 *
 * Note:  All the register fields are renamed from P2 to Nx4P2 (Nx4 Plus 2)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0
 *  [1]    | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA
 *  [2]    | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS
 *  [3]    | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS
 *  [4]    | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS
 *  [5]    | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS
 *  [6]    | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7
 *  [30]   | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1
 *  [31]   | RW     | 0x1   | CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_MSB	0
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_SET_MSK	0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P2PMDPMA
 *
 * PMA Device is in Use
 *
 * When PMD/PMA is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_RESET	 0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P2WIS
 *
 * WIS Device is in Use
 *
 * When WIS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P2PCS
 *
 * PCS Device is in Use
 *
 * When PCS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P2PHYXS
 *
 * PHYXS Device is in Use
 *
 * When PHY XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P2DTEXS
 *
 * DTEXS Device is in Use
 *
 * When DTE XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P2TC
 *
 * TC Device is in Use
 *
 * When TC is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC register
 * field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_RESET	     0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_MSB	   29
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_WIDTH	   23
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_SET_MSK	   0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_CLR_MSK	   0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_RESET	   0x0
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P2VSD1
 *
 * VSD1 Device is in Use
 *
 * When Vendor-Specific Device 1 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P2VSD2
 *
 * VSD2 Device is in Use
 *
 * When Vendor-Specific Device 2 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 register field value. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 register field. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 field value from a register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P2_DEVICE_IN_USE.
 */
struct CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_0 */
	volatile uint32_t Nx4P2PMDPMA : 1;	/* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PMDPMA */
	volatile uint32_t Nx4P2WIS : 1;		/* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2WIS */
	volatile uint32_t Nx4P2PCS : 1;		/* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PCS */
	volatile uint32_t Nx4P2PHYXS : 1;	/* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2PHYXS */
	volatile uint32_t Nx4P2DTEXS : 1;	/* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2DTEXS */
	volatile uint32_t Nx4P2TC : 1;		/* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2TC */
	const volatile uint32_t
		Reserved_29_7 : 23;	 /* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESERVED_29_7 */
	volatile uint32_t Nx4P2VSD1 : 1; /* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD1 */
	volatile uint32_t Nx4P2VSD2 : 1; /* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_NX4P2VSD2 */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P2_DEVICE_IN_USE. */
typedef struct CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_s CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE register. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_RESET 0xc000007e
/* The byte offset of the CORE_MDIO_PORTNX4P2_DEVICE_IN_USE register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_OFST	0x250

/*
 * Register : MDIO_PortNx4P2_Link_Status
 *
 * This register gives the link status of the devices in PHY Port Nx4Plus2 ((Here N
 * is as per the PRS field of MDIO Port Nx4 Indirect Control register) at the end
 * of each continuous scan cycle. Up to eight devices are supported, as specified
 * in IEEE 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus1 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P2 to Nx4P2 (Nx4 Plus 2)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_MSB	      0
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P2PMDPMALS
 *
 * Link Status of PMA Device
 *
 * When the PMD/PMA link is up, this bit is set to 1.
 *
 * Here N is as per PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P2WISLS
 *
 * Link Status of WIS Device
 *
 * When the WIS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P2PCSLS
 *
 * Link Status of PCS Device
 *
 * When the PCS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P2PHYXSLS
 *
 * Link Status of PHYXS Device
 *
 * When the PHY XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P2DTEXSLS
 *
 * Link Status of DTEXS Device
 *
 * When the DTE XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P2TCLS
 *
 * Link Status of TC Device
 *
 * When the TC link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS register
 * field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_RESET	     0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_MSB	 29
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_WIDTH	 23
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_SET_MSK	 0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_CLR_MSK	 0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P2VSD1LS
 *
 * Link Status of VSD1 Device
 *
 * When the Vendor-Specific Device 1 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P2VSD2LS
 *
 * Link Status of VSD2 Device
 *
 * When the Vendor-Specific Device 2 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS register field. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P2_LINK_STATUS.
 */
struct CORE_MDIO_PORTNX4P2_LINK_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P2PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PMDPMALS */
	const volatile uint32_t Nx4P2WISLS : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2WISLS */
	const volatile uint32_t Nx4P2PCSLS : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PCSLS */
	const volatile uint32_t Nx4P2PHYXSLS : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2PHYXSLS */
	const volatile uint32_t Nx4P2DTEXSLS : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2DTEXSLS */
	const volatile uint32_t Nx4P2TCLS : 1;	  /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23;		 /* CORE_MDIO_PORTNX4P2_LINK_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P2VSD1LS : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD1LS */
	const volatile uint32_t Nx4P2VSD2LS : 1; /* CORE_MDIO_PORTNX4P2_LINK_STATUS_NX4P2VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P2_LINK_STATUS. */
typedef struct CORE_MDIO_PORTNX4P2_LINK_STATUS_s CORE_MDIO_PORTNX4P2_LINK_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P2_LINK_STATUS register. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P2_LINK_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P2_LINK_STATUS_OFST  0x254

/*
 * Register : MDIO_PortNx4P2_Alive_Status
 *
 * This register gives the device status in PHY Port Nx4Plus2 ((Here N is as per
 * the PRS field of MDIO Port Nx4 Indirect Control register) at the end of each
 * continuous scan cycle. Up to eight devices are supported, as specified in IEEE
 * 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus2 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P2 to Nx4P2 (Nx4 Plus 2)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_MSB	       0
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P2PMDPMALS
 *
 * Alive Status of PMA Device
 *
 * When PMD/PMA is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_MSB	  1
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_WIDTH	  1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS register field value.
 */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P2WISLS
 *
 * Alive Status of WIS Device
 *
 * When WIS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_MSB	       2
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P2PCSLS
 *
 * Alive Status of PCS Device
 *
 * When PCS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_MSB	       3
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P2PHYXSLS
 *
 * Alive Status of PHYXS Device
 *
 * When PHY XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_MSB	 4
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_SET_MSK	 0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_CLR_MSK	 0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P2DTEXSLS
 *
 * Alive Status of DTEXS Device
 *
 * When DTE XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_LSB	 5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_MSB	 5
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_SET_MSK	 0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_CLR_MSK	 0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P2TCLS
 *
 * Alive Status of TC Device
 *
 * When TC is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_MSB	      6
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_LSB	  7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_MSB	  29
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_WIDTH	  23
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_SET_MSK	  0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_CLR_MSK	  0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P2VSD1LS
 *
 * Alive Status of VSD1 Device
 *
 * When Vendor-Specific Device 1 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_LSB	30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_MSB	30
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_SET_MSK	0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_CLR_MSK	0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P2VSD2LS
 *
 * Alive Status of VSD2 Device
 *
 * When Vendor-Specific Device 2 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_LSB	31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_MSB	31
/* The width in bits of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_SET_MSK	0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS register field. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P2_ALIVE_STATUS.
 */
struct CORE_MDIO_PORTNX4P2_ALIVE_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P2PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PMDPMALS */
	const volatile uint32_t Nx4P2WISLS : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2WISLS */
	const volatile uint32_t Nx4P2PCSLS : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PCSLS */
	const volatile uint32_t
		Nx4P2PHYXSLS : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2PHYXSLS */
	const volatile uint32_t
		Nx4P2DTEXSLS : 1;	       /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2DTEXSLS */
	const volatile uint32_t Nx4P2TCLS : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P2VSD1LS : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD1LS */
	const volatile uint32_t Nx4P2VSD2LS : 1; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS_NX4P2VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P2_ALIVE_STATUS. */
typedef struct CORE_MDIO_PORTNX4P2_ALIVE_STATUS_s CORE_MDIO_PORTNX4P2_ALIVE_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS register. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P2_ALIVE_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P2_ALIVE_STATUS_OFST  0x258

/*
 * Register : MDIO_PortNx4P3_Device_In_Use
 *
 * This register gives the status of each device on Port Nx4 Plus3 (Here N is as
 * per the PRS field of MDIO Port Nx4 Indirect Control register). Set these bits to
 * indicate that a device is present and that the SMA must access it during
 * continuous scan/write operations. If any bit is cleared, the corresponding
 * device is not scanned when the Continuous Scan command is issued nor is it
 * written when the Continuous Write command is issued. This register setting does
 * not affect single read or write commands.
 *
 * Note:  All the register fields are renamed from P3 to Nx4P3 (Nx4 Plus 3)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0
 *  [1]    | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA
 *  [2]    | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS
 *  [3]    | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS
 *  [4]    | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS
 *  [5]    | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS
 *  [6]    | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7
 *  [30]   | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1
 *  [31]   | RW     | 0x1   | CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_MSB	0
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_SET_MSK	0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P3PMDPMA
 *
 * PMA Device is in Use
 *
 * When PMD/PMA is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_RESET	 0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P3WIS
 *
 * WIS Device is in Use
 *
 * When WIS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P3PCS
 *
 * PCS Device is in Use
 *
 * When PCS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P3PHYXS
 *
 * PHYXS Device is in Use
 *
 * When PHY XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P3DTEXS
 *
 * DTEXS Device is in Use
 *
 * When DTE XS is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_RESET	0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P3TC
 *
 * TC Device is in Use
 *
 * When TC is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC register
 * field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_RESET	     0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_MSB	   29
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_WIDTH	   23
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_SET_MSK	   0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_CLR_MSK	   0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_RESET	   0x0
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P3VSD1
 *
 * VSD1 Device is in Use
 *
 * When Vendor-Specific Device 1 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P3VSD2
 *
 * VSD2 Device is in Use
 *
 * When Vendor-Specific Device 2 is present, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2
 * register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 register field value. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 register field. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_RESET      0x1
/* Extracts the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 field value from a register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P3_DEVICE_IN_USE.
 */
struct CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_0 */
	volatile uint32_t Nx4P3PMDPMA : 1;	/* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PMDPMA */
	volatile uint32_t Nx4P3WIS : 1;		/* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3WIS */
	volatile uint32_t Nx4P3PCS : 1;		/* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PCS */
	volatile uint32_t Nx4P3PHYXS : 1;	/* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3PHYXS */
	volatile uint32_t Nx4P3DTEXS : 1;	/* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3DTEXS */
	volatile uint32_t Nx4P3TC : 1;		/* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3TC */
	const volatile uint32_t
		Reserved_29_7 : 23;	 /* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESERVED_29_7 */
	volatile uint32_t Nx4P3VSD1 : 1; /* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD1 */
	volatile uint32_t Nx4P3VSD2 : 1; /* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_NX4P3VSD2 */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P3_DEVICE_IN_USE. */
typedef struct CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_s CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE register. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_RESET 0xc000007e
/* The byte offset of the CORE_MDIO_PORTNX4P3_DEVICE_IN_USE register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_OFST	0x260

/*
 * Register : MDIO_PortNx4P3_Link_Status
 *
 * This register gives the link status of the devices in PHY Port Nx4Plus3 ((Here N
 * is as per the PRS field of MDIO Port Nx4 Indirect Control register) at the end
 * of each continuous scan cycle. Up to eight devices are supported, as specified
 * in IEEE 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus3 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P3 to Nx4P3 (Nx4 Plus 3)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_MSB	      0
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P3PMDPMALS
 *
 * Link Status of PMA Device
 *
 * When the PMD/PMA link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_MSB	 1
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P3WISLS
 *
 * Link Status of WIS Device
 *
 * When the WIS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_MSB	      2
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P3PCSLS
 *
 * Link Status of PCS Device
 *
 * When the PCS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_MSB	      3
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P3PHYXSLS
 *
 * Link Status of PHYXS Device
 *
 * When the PHY XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_MSB	4
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_SET_MSK	0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_CLR_MSK	0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P3DTEXSLS
 *
 * Link Status of DTEXS Device
 *
 * When the DTE XS link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_MSB	5
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P3TCLS
 *
 * Link Status of TC Device
 *
 * When the TC link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_LSB	     6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS register
 * field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_MSB	     6
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_WIDTH	     1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_RESET	     0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_MSB	 29
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_WIDTH	 23
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_SET_MSK	 0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_CLR_MSK	 0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P3VSD1LS
 *
 * Link Status of VSD1 Device
 *
 * When the Vendor-Specific Device 1 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_LSB	       30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_MSB	       30
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_SET_MSK    0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P3VSD2LS
 *
 * Link Status of VSD2 Device
 *
 * When the Vendor-Specific Device 2 link is up, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_LSB	       31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_MSB	       31
/* The width in bits of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_SET_MSK    0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS register field. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P3_LINK_STATUS.
 */
struct CORE_MDIO_PORTNX4P3_LINK_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P3PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PMDPMALS */
	const volatile uint32_t Nx4P3WISLS : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3WISLS */
	const volatile uint32_t Nx4P3PCSLS : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PCSLS */
	const volatile uint32_t Nx4P3PHYXSLS : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3PHYXSLS */
	const volatile uint32_t Nx4P3DTEXSLS : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3DTEXSLS */
	const volatile uint32_t Nx4P3TCLS : 1;	  /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23;		 /* CORE_MDIO_PORTNX4P3_LINK_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P3VSD1LS : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD1LS */
	const volatile uint32_t Nx4P3VSD2LS : 1; /* CORE_MDIO_PORTNX4P3_LINK_STATUS_NX4P3VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P3_LINK_STATUS. */
typedef struct CORE_MDIO_PORTNX4P3_LINK_STATUS_s CORE_MDIO_PORTNX4P3_LINK_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P3_LINK_STATUS register. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P3_LINK_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P3_LINK_STATUS_OFST  0x264

/*
 * Register : MDIO_PortNx4P3_Alive_Status
 *
 * This register gives the device status in PHY Port Nx4Plus3 ((Here N is as per
 * the PRS field of MDIO Port Nx4 Indirect Control register) at the end of each
 * continuous scan cycle. Up to eight devices are supported, as specified in IEEE
 * 802.3-2018. You can disable the polling of any device by clearing its
 * corresponding MDIO Port Nx4Plus0 Device In Use register bit.
 *
 * Note:  All the register fields are renamed from P3 to Nx4P3 (Nx4 Plus 3)
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0
 *  [1]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS
 *  [2]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS
 *  [3]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS
 *  [4]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS
 *  [5]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS
 *  [6]    | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS
 *  [29:7] | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7
 *  [30]   | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS
 *  [31]   | R      | 0x0   | CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_MSB	       0
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Nx4P3PMDPMALS
 *
 * Alive Status of PMA Device
 *
 * When PMD/PMA is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_MSB	  1
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_WIDTH	  1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS register field value.
 */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Nx4P3WISLS
 *
 * Alive Status of WIS Device
 *
 * When WIS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_MSB	       2
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Nx4P3PCSLS
 *
 * Alive Status of PCS Device
 *
 * When PCS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_MSB	       3
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_SET_MSK    0x00000008
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Nx4P3PHYXSLS
 *
 * Alive Status of PHYXS Device
 *
 * When PHY XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_MSB	 4
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_SET_MSK	 0x00000010
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_CLR_MSK	 0xffffffef
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Nx4P3DTEXSLS
 *
 * Alive Status of DTEXS Device
 *
 * When DTE XS is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_LSB	 5
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_MSB	 5
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_WIDTH	 1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_SET_MSK	 0x00000020
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_CLR_MSK	 0xffffffdf
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_RESET	 0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Nx4P3TCLS
 *
 * Alive Status of TC Device
 *
 * When TC is present and functioning properly, this bit is set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_MSB	      6
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_WIDTH      1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_RESET      0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_29_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_LSB	  7
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_MSB	  29
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_WIDTH	  23
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_SET_MSK	  0x3fffff80
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 register field value.
 */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_CLR_MSK	  0xc000007f
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_RESET	  0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_GET(value) (((value)&0x3fffff80) >> 7)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 register field value suitable for
 * setting the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7_SET(value) (((value) << 7) & 0x3fffff80)

/*
 * Field : Nx4P3VSD1LS
 *
 * Alive Status of VSD1 Device
 *
 * When Vendor-Specific Device 1 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_LSB	30
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_MSB	30
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_SET_MSK	0x40000000
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_CLR_MSK	0xbfffffff
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Nx4P3VSD2LS
 *
 * Alive Status of VSD2 Device
 *
 * When Vendor-Specific Device 2 is present and functioning properly, this bit is
 * set to 1.
 *
 * Here N is as per the PRS field of MDIO Port Nx4 Indirect Control register
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_LSB	31
/* The Most Significant Bit (MSB) position of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS
 * register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_MSB	31
/* The width in bits of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_WIDTH	1
/* The mask used to set the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_SET_MSK	0x80000000
/* The mask used to clear the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS register field value. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS register field. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_RESET	0x0
/* Extracts the CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS field value from a register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS register field value suitable for setting
 * the register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MDIO_PORTNX4P3_ALIVE_STATUS.
 */
struct CORE_MDIO_PORTNX4P3_ALIVE_STATUS_s {
	const volatile uint32_t Reserved_0 : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_0 */
	const volatile uint32_t
		Nx4P3PMDPMALS : 1;		/* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PMDPMALS */
	const volatile uint32_t Nx4P3WISLS : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3WISLS */
	const volatile uint32_t Nx4P3PCSLS : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PCSLS */
	const volatile uint32_t
		Nx4P3PHYXSLS : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3PHYXSLS */
	const volatile uint32_t
		Nx4P3DTEXSLS : 1;	       /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3DTEXSLS */
	const volatile uint32_t Nx4P3TCLS : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3TCLS */
	const volatile uint32_t
		Reserved_29_7 : 23; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESERVED_29_7 */
	const volatile uint32_t Nx4P3VSD1LS : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD1LS */
	const volatile uint32_t Nx4P3VSD2LS : 1; /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS_NX4P3VSD2LS */
};

/* The typedef declaration for register CORE_MDIO_PORTNX4P3_ALIVE_STATUS. */
typedef struct CORE_MDIO_PORTNX4P3_ALIVE_STATUS_s CORE_MDIO_PORTNX4P3_ALIVE_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS register. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MDIO_PORTNX4P3_ALIVE_STATUS register from the beginning of the
 * component. */
#define CORE_MDIO_PORTNX4P3_ALIVE_STATUS_OFST  0x268

/*
 * Register : MAC_FPE_CTRL_STS
 *
 * This register controls the operation of Frame Preemption.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_FPE_CTRL_STS_EFPE
 *  [1]     | RW     | 0x0   | CORE_MAC_FPE_CTRL_STS_SVER
 *  [2]     | RW     | 0x0   | CORE_MAC_FPE_CTRL_STS_SRSP
 *  [3]     | RW     | 0x0   | CORE_MAC_FPE_CTRL_STS_ARV
 *  [15:4]  | R      | 0x0   | CORE_MAC_FPE_CTRL_STS_RESERVED_15_4
 *  [16]    | R      | 0x0   | CORE_MAC_FPE_CTRL_STS_RVER
 *  [17]    | R      | 0x0   | CORE_MAC_FPE_CTRL_STS_RRSP
 *  [18]    | R      | 0x0   | CORE_MAC_FPE_CTRL_STS_TVER
 *  [19]    | R      | 0x0   | CORE_MAC_FPE_CTRL_STS_TRSP
 *  [31:20] | R      | 0x0   | CORE_MAC_FPE_CTRL_STS_RESERVED_31_20
 *
 */
/*
 * Field : EFPE
 *
 * Enable Tx Frame Preemption
 *
 * When set, Frame Preemption Tx functionality is enabled.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                   | Value | Description
 * :-------------------------------------------------------|:------|:--------------------------------
 *  CORE_MAC_FPE_CTRL_STS_EFPE_E_DISABLE | 0x0   | Tx Frame Preemption is disabled
 *  CORE_MAC_FPE_CTRL_STS_EFPE_E_ENABLE  | 0x1   | Tx Frame Preemption is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_EFPE
 *
 * Tx Frame Preemption is disabled
 */
#define CORE_MAC_FPE_CTRL_STS_EFPE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_EFPE
 *
 * Tx Frame Preemption is enabled
 */
#define CORE_MAC_FPE_CTRL_STS_EFPE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_EFPE register field. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_EFPE register field. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_MSB	      0
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_EFPE register field. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_EFPE register field value. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_EFPE register field value. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_FPE_CTRL_STS_EFPE register field. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_EFPE field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_FPE_CTRL_STS_EFPE register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_EFPE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : SVER
 *
 * Send Verify mPacket
 *
 * When set, indicates to the hardware to send a verify mPacket. Reset by hardware
 * after sending the Verify mPacket.
 *
 * Access restriction applies. Writing 1 sets the bit. Self-cleared. Writing 0 has
 * no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                   | Value | Description
 * :-------------------------------------------------------|:------|:--------------------------------
 *  CORE_MAC_FPE_CTRL_STS_SVER_E_DISABLE | 0x0   | Send Verify mPacket is disabled
 *  CORE_MAC_FPE_CTRL_STS_SVER_E_ENABLE  | 0x1   | Send Verify mPacket is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_SVER
 *
 * Send Verify mPacket is disabled
 */
#define CORE_MAC_FPE_CTRL_STS_SVER_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_SVER
 *
 * Send Verify mPacket is enabled
 */
#define CORE_MAC_FPE_CTRL_STS_SVER_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_SVER register field. */
#define CORE_MAC_FPE_CTRL_STS_SVER_LSB	      1
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_SVER register field. */
#define CORE_MAC_FPE_CTRL_STS_SVER_MSB	      1
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_SVER register field. */
#define CORE_MAC_FPE_CTRL_STS_SVER_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_SVER register field value. */
#define CORE_MAC_FPE_CTRL_STS_SVER_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_SVER register field value. */
#define CORE_MAC_FPE_CTRL_STS_SVER_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_FPE_CTRL_STS_SVER register field. */
#define CORE_MAC_FPE_CTRL_STS_SVER_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_SVER field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_SVER_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_FPE_CTRL_STS_SVER register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_SVER_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : SRSP
 *
 * Send Respond mPacket
 *
 * When set, indicates to the hardware to send a Respond mPacket. Reset by hardware
 * after sending the Respond mPacket.
 *
 * Access restriction applies. Can be set by software or by hardware when ARV bit
 * is set and a verify mPacket is received. Self-cleared. Writing 0 has no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                   | Value | Description
 * :-------------------------------------------------------|:------|:---------------------------------
 *  CORE_MAC_FPE_CTRL_STS_SRSP_E_DISABLE | 0x0   | Send Respond mPacket is disabled
 *  CORE_MAC_FPE_CTRL_STS_SRSP_E_ENABLE  | 0x1   | Send Respond mPacket is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_SRSP
 *
 * Send Respond mPacket is disabled
 */
#define CORE_MAC_FPE_CTRL_STS_SRSP_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_SRSP
 *
 * Send Respond mPacket is enabled
 */
#define CORE_MAC_FPE_CTRL_STS_SRSP_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_SRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_SRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_MSB	      2
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_SRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_SRSP register field value. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_SET_MSK    0x00000004
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_SRSP register field value. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MAC_FPE_CTRL_STS_SRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_SRSP field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_FPE_CTRL_STS_SRSP register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_SRSP_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : ARV
 *
 * Autogenerate Respond mPacket on receiving Verify mPacket
 *
 * When set, enable the function that autogenerate a Respond mPacket on receiving
 * Verify mPacket.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MAC_FPE_CTRL_STS_ARV_E_DISABLE | 0x0   | Autogenerate Respond mPacket on receiving Verify
 * :                                                      |       | mPakcet is disabled
 *  CORE_MAC_FPE_CTRL_STS_ARV_E_ENABLE  | 0x1   | Autogenerate Respond mPacket on receiving Verify
 * :                                                      |       | mPakcet is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_ARV
 *
 * Autogenerate Respond mPacket on receiving Verify mPakcet is disabled
 */
#define CORE_MAC_FPE_CTRL_STS_ARV_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_ARV
 *
 * Autogenerate Respond mPacket on receiving Verify mPakcet is enabled
 */
#define CORE_MAC_FPE_CTRL_STS_ARV_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_ARV register field. */
#define CORE_MAC_FPE_CTRL_STS_ARV_LSB	     3
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_ARV register field. */
#define CORE_MAC_FPE_CTRL_STS_ARV_MSB	     3
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_ARV register field. */
#define CORE_MAC_FPE_CTRL_STS_ARV_WIDTH	     1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_ARV register field value. */
#define CORE_MAC_FPE_CTRL_STS_ARV_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_ARV register field value. */
#define CORE_MAC_FPE_CTRL_STS_ARV_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_FPE_CTRL_STS_ARV register field. */
#define CORE_MAC_FPE_CTRL_STS_ARV_RESET	     0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_ARV field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_ARV_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_FPE_CTRL_STS_ARV register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_ARV_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_15_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register
 * field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_LSB	       4
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register
 * field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_MSB	       15
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_WIDTH      12
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register field value. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_SET_MSK    0x0000fff0
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register field value. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_CLR_MSK    0xffff000f
/* The reset value of the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_GET(value) (((value)&0x0000fff0) >> 4)
/* Produces a CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 register field value suitable for setting the
 * register. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_15_4_SET(value) (((value) << 4) & 0x0000fff0)

/*
 * Field : RVER
 *
 * Received Verify Frame
 *
 * This field is set when a Verify mPacket is received. An interrupt can be
 * generated for this event if FPEIE bit of MAC_Interrupt_Enable is set.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:--------------------------
 *  CORE_MAC_FPE_CTRL_STS_RVER_E_INACTIVE | 0x0   | Not received Verify Frame
 *  CORE_MAC_FPE_CTRL_STS_RVER_E_ACTIVE   | 0x1   | Received Verify Frame
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_RVER
 *
 * Not received Verify Frame
 */
#define CORE_MAC_FPE_CTRL_STS_RVER_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_RVER
 *
 * Received Verify Frame
 */
#define CORE_MAC_FPE_CTRL_STS_RVER_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_RVER register field. */
#define CORE_MAC_FPE_CTRL_STS_RVER_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_RVER register field. */
#define CORE_MAC_FPE_CTRL_STS_RVER_MSB	      16
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_RVER register field. */
#define CORE_MAC_FPE_CTRL_STS_RVER_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_RVER register field value. */
#define CORE_MAC_FPE_CTRL_STS_RVER_SET_MSK    0x00010000
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_RVER register field value. */
#define CORE_MAC_FPE_CTRL_STS_RVER_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MAC_FPE_CTRL_STS_RVER register field. */
#define CORE_MAC_FPE_CTRL_STS_RVER_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_RVER field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_RVER_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MAC_FPE_CTRL_STS_RVER register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_RVER_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : RRSP
 *
 * Received Respond Frame
 *
 * This field is set when a Respond mPacket is received. An interrupt can be
 * generated for this event if FPEIE bit of MAC_Interrupt_Enable is set.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:---------------------------
 *  CORE_MAC_FPE_CTRL_STS_RRSP_E_INACTIVE | 0x0   | Not received Respond Frame
 *  CORE_MAC_FPE_CTRL_STS_RRSP_E_ACTIVE   | 0x1   | Received Respond Frame
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_RRSP
 *
 * Not received Respond Frame
 */
#define CORE_MAC_FPE_CTRL_STS_RRSP_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_RRSP
 *
 * Received Respond Frame
 */
#define CORE_MAC_FPE_CTRL_STS_RRSP_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_RRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_LSB	      17
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_RRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_MSB	      17
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_RRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_RRSP register field value. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_SET_MSK    0x00020000
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_RRSP register field value. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MAC_FPE_CTRL_STS_RRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_RRSP field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MAC_FPE_CTRL_STS_RRSP register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_RRSP_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : TVER
 *
 * Transmitted Verify Frame
 *
 * This field is set when a Verify mPacket is transmitted (triggered by setting
 * SVER field). An interrupt can be generated for this event if FPEIE bit of
 * MAC_Interrupt_Enable is set.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:-----------------------------
 *  CORE_MAC_FPE_CTRL_STS_TVER_E_INACTIVE | 0x0   | Not transmitted Verify Frame
 *  CORE_MAC_FPE_CTRL_STS_TVER_E_ACTIVE   | 0x1   | transmitted Verify Frame
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_TVER
 *
 * Not transmitted Verify Frame
 */
#define CORE_MAC_FPE_CTRL_STS_TVER_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_TVER
 *
 * transmitted Verify Frame
 */
#define CORE_MAC_FPE_CTRL_STS_TVER_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_TVER register field. */
#define CORE_MAC_FPE_CTRL_STS_TVER_LSB	      18
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_TVER register field. */
#define CORE_MAC_FPE_CTRL_STS_TVER_MSB	      18
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_TVER register field. */
#define CORE_MAC_FPE_CTRL_STS_TVER_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_TVER register field value. */
#define CORE_MAC_FPE_CTRL_STS_TVER_SET_MSK    0x00040000
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_TVER register field value. */
#define CORE_MAC_FPE_CTRL_STS_TVER_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MAC_FPE_CTRL_STS_TVER register field. */
#define CORE_MAC_FPE_CTRL_STS_TVER_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_TVER field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_TVER_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_FPE_CTRL_STS_TVER register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_TVER_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : TRSP
 *
 * Transmitted Respond Frame
 *
 * This field is set when a Respond mPacket is transmitted (triggered by setting
 * SRSP field). An interrupt can be generated for this event if FPEIE bit of
 * MAC_Interrupt_Enable is set.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:------------------------------
 *  CORE_MAC_FPE_CTRL_STS_TRSP_E_INACTIVE | 0x0   | Not transmitted Respond Frame
 *  CORE_MAC_FPE_CTRL_STS_TRSP_E_ACTIVE   | 0x1   | transmitted Respond Frame
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_TRSP
 *
 * Not transmitted Respond Frame
 */
#define CORE_MAC_FPE_CTRL_STS_TRSP_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MAC_FPE_CTRL_STS_TRSP
 *
 * transmitted Respond Frame
 */
#define CORE_MAC_FPE_CTRL_STS_TRSP_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_TRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_LSB	      19
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_TRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_MSB	      19
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_TRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_WIDTH      1
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_TRSP register field value. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_SET_MSK    0x00080000
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_TRSP register field value. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MAC_FPE_CTRL_STS_TRSP register field. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_RESET      0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_TRSP field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_FPE_CTRL_STS_TRSP register field value suitable for setting the register. */
#define CORE_MAC_FPE_CTRL_STS_TRSP_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : Reserved_31_20
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register
 * field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_LSB	20
/* The Most Significant Bit (MSB) position of the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register
 * field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_MSB	31
/* The width in bits of the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_WIDTH	12
/* The mask used to set the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register field value. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_SET_MSK	0xfff00000
/* The mask used to clear the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register field value. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_CLR_MSK	0x000fffff
/* The reset value of the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register field. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_RESET	0x0
/* Extracts the CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 field value from a register. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_GET(value) (((value)&0xfff00000) >> 20)
/* Produces a CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 register field value suitable for setting the
 * register. */
#define CORE_MAC_FPE_CTRL_STS_RESERVED_31_20_SET(value) (((value) << 20) & 0xfff00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_FPE_CTRL_STS.
 */
struct CORE_MAC_FPE_CTRL_STS_s {
	volatile uint32_t EFPE : 1;		     /* CORE_MAC_FPE_CTRL_STS_EFPE */
	volatile uint32_t SVER : 1;		     /* CORE_MAC_FPE_CTRL_STS_SVER */
	volatile uint32_t SRSP : 1;		     /* CORE_MAC_FPE_CTRL_STS_SRSP */
	volatile uint32_t ARV : 1;		     /* CORE_MAC_FPE_CTRL_STS_ARV */
	const volatile uint32_t Reserved_15_4 : 12;  /* CORE_MAC_FPE_CTRL_STS_RESERVED_15_4 */
	const volatile uint32_t RVER : 1;	     /* CORE_MAC_FPE_CTRL_STS_RVER */
	const volatile uint32_t RRSP : 1;	     /* CORE_MAC_FPE_CTRL_STS_RRSP */
	const volatile uint32_t TVER : 1;	     /* CORE_MAC_FPE_CTRL_STS_TVER */
	const volatile uint32_t TRSP : 1;	     /* CORE_MAC_FPE_CTRL_STS_TRSP */
	const volatile uint32_t Reserved_31_20 : 12; /* CORE_MAC_FPE_CTRL_STS_RESERVED_31_20 */
};

/* The typedef declaration for register CORE_MAC_FPE_CTRL_STS. */
typedef struct CORE_MAC_FPE_CTRL_STS_s CORE_MAC_FPE_CTRL_STS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_FPE_CTRL_STS register. */
#define CORE_MAC_FPE_CTRL_STS_RESET 0x00000000
/* The byte offset of the CORE_MAC_FPE_CTRL_STS register from the beginning of the component. */
#define CORE_MAC_FPE_CTRL_STS_OFST  0x280

/*
 * Register : MAC_CSR_SW_Ctrl
 *
 * This register contains software programmable controls for changing the CSR
 * access response and status bits clearing.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------
 *  [0]    | RW     | 0x0   | CORE_MAC_CSR_SW_CTRL_RCWE
 *  [7:1]  | R      | 0x0   | CORE_MAC_CSR_SW_CTRL_RESERVED_7_1
 *  [8]    | RW     | 0x0   | CORE_MAC_CSR_SW_CTRL_SEEN
 *  [31:9] | R      | 0x0   | CORE_MAC_CSR_SW_CTRL_RESERVED_31_9
 *
 */
/*
 * Field : RCWE
 *
 * Register Clear on Write 1 Enable
 *
 * When this bit is set, the access mode of list of register fields provided in
 * Appendix F changes to Clear on Write 1, the application needs to set that
 * respective bit to 1 to clear it.
 *
 * When this bit is reset, the access mode of list of register fields provided in
 * Appendix F remain as Clear on Read.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:----------------------------------
 *  CORE_MAC_CSR_SW_CTRL_RCWE_E_DISABLE | 0x0   | Register Clear on Write 1 Disable
 *  CORE_MAC_CSR_SW_CTRL_RCWE_E_ENABLE  | 0x1   | Register Clear on Write 1 Enable
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_CSR_SW_CTRL_RCWE
 *
 * Register Clear on Write 1 Disable
 */
#define CORE_MAC_CSR_SW_CTRL_RCWE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_CSR_SW_CTRL_RCWE
 *
 * Register Clear on Write 1 Enable
 */
#define CORE_MAC_CSR_SW_CTRL_RCWE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_CSR_SW_CTRL_RCWE register field. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_CSR_SW_CTRL_RCWE register field. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_MSB	     0
/* The width in bits of the CORE_MAC_CSR_SW_CTRL_RCWE register field. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_WIDTH	     1
/* The mask used to set the CORE_MAC_CSR_SW_CTRL_RCWE register field value. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_CSR_SW_CTRL_RCWE register field value. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_CSR_SW_CTRL_RCWE register field. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_RESET	     0x0
/* Extracts the CORE_MAC_CSR_SW_CTRL_RCWE field value from a register. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_CSR_SW_CTRL_RCWE register field value suitable for setting the register. */
#define CORE_MAC_CSR_SW_CTRL_RCWE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_7_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field.
 */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_LSB	     1
/* The Most Significant Bit (MSB) position of the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field.
 */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_MSB	     7
/* The width in bits of the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_WIDTH	     7
/* The mask used to set the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field value. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_SET_MSK    0x000000fe
/* The mask used to clear the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field value. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_CLR_MSK    0xffffff01
/* The reset value of the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_RESET	     0x0
/* Extracts the CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 field value from a register. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_GET(value) (((value)&0x000000fe) >> 1)
/* Produces a CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 register field value suitable for setting the
 * register. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_7_1_SET(value) (((value) << 1) & 0x000000fe)

/*
 * Field : SEEN
 *
 * Slave Error Response Enable
 *
 * * When this bit is set, the MAC responds with Slave Error for accesses to
 *   reserved registers in CSR space.
 *
 * * When this bit is reset, the MAC responds with Okay response to any register
 *   accessed from CSR space.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:------------------------------
 *  CORE_MAC_CSR_SW_CTRL_SEEN_E_DISABLE | 0x0   | Slave Error response Disabled
 *  CORE_MAC_CSR_SW_CTRL_SEEN_E_ENABLE  | 0x1   | Slave Error response Enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_CSR_SW_CTRL_SEEN
 *
 * Slave Error response Disabled
 */
#define CORE_MAC_CSR_SW_CTRL_SEEN_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MAC_CSR_SW_CTRL_SEEN
 *
 * Slave Error response Enabled
 */
#define CORE_MAC_CSR_SW_CTRL_SEEN_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_CSR_SW_CTRL_SEEN register field. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MAC_CSR_SW_CTRL_SEEN register field. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_MSB	     8
/* The width in bits of the CORE_MAC_CSR_SW_CTRL_SEEN register field. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_WIDTH	     1
/* The mask used to set the CORE_MAC_CSR_SW_CTRL_SEEN register field value. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_CSR_SW_CTRL_SEEN register field value. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_CSR_SW_CTRL_SEEN register field. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_RESET	     0x0
/* Extracts the CORE_MAC_CSR_SW_CTRL_SEEN field value from a register. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_CSR_SW_CTRL_SEEN register field value suitable for setting the register. */
#define CORE_MAC_CSR_SW_CTRL_SEEN_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : Reserved_31_9
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register
 * field. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_LSB	      9
/* The Most Significant Bit (MSB) position of the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register field.
 */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_MSB	      31
/* The width in bits of the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register field. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_WIDTH      23
/* The mask used to set the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register field value. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_SET_MSK    0xfffffe00
/* The mask used to clear the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register field value. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_CLR_MSK    0x000001ff
/* The reset value of the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register field. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_RESET      0x0
/* Extracts the CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 field value from a register. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_GET(value) (((value)&0xfffffe00) >> 9)
/* Produces a CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 register field value suitable for setting the
 * register. */
#define CORE_MAC_CSR_SW_CTRL_RESERVED_31_9_SET(value) (((value) << 9) & 0xfffffe00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_CSR_SW_CTRL.
 */
struct CORE_MAC_CSR_SW_CTRL_s {
	volatile uint32_t RCWE : 1;		    /* CORE_MAC_CSR_SW_CTRL_RCWE */
	const volatile uint32_t Reserved_7_1 : 7;   /* CORE_MAC_CSR_SW_CTRL_RESERVED_7_1 */
	volatile uint32_t SEEN : 1;		    /* CORE_MAC_CSR_SW_CTRL_SEEN */
	const volatile uint32_t Reserved_31_9 : 23; /* CORE_MAC_CSR_SW_CTRL_RESERVED_31_9 */
};

/* The typedef declaration for register CORE_MAC_CSR_SW_CTRL. */
typedef struct CORE_MAC_CSR_SW_CTRL_s CORE_MAC_CSR_SW_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_CSR_SW_CTRL register. */
#define CORE_MAC_CSR_SW_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_CSR_SW_CTRL register from the beginning of the component. */
#define CORE_MAC_CSR_SW_CTRL_OFST  0x290

/*
 * Register : MAC_Address0_High
 *
 * The MAC Address0 High register holds the upper 16 bits of the first 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address0 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address0
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain or Power Management feature is selected, then the
 * synchronization is triggered only when Bits[31:24] (in little-endian mode) or
 * Bits[7:0] (in big-endian mode) of the MAC Address0 Low register are written, so
 * MAC Address0 High register must be written prior to MAC Address0 Low register.
 * For proper synchronization updates, the consecutive writes to MAC Address0 Low
 * register should be performed after at least four clock cycles of the slowest
 * clock between the source and the destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS0_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS0_HIGH_DCS
 *  [30:19] | R      | 0x0    | CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y
 *  [31]    | R      | 0x1    | CORE_MAC_ADDRESS0_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address0[47:32].
 *
 * This field contains the upper 16 bits[47:32] of the first 6-byte MAC address.
 *
 * The MAC uses this field for filtering the received packets and inserting the MAC
 * address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS0_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS0_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS0_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS0_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS0_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS0_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS0_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS0_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS0_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * XDCS field of MAC_DChSel_IndReg register contains the one-hot representation of
 * one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC
 * Address0 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS0_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS0_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS0_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS0_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS0_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS0_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS0_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS0_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS0_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_30_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register
 * field. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register
 * field. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_MSB	30
/* The width in bits of the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register field. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_WIDTH	12
/* The mask used to set the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register field value. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_SET_MSK	0x7ff80000
/* The mask used to clear the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register field value. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_CLR_MSK	0x8007ffff
/* The reset value of the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register field. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y field value from a register. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_GET(value) (((value)&0x7ff80000) >> 19)
/* Produces a CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y_SET(value) (((value) << 19) & 0x7ff80000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * This bit is always set to 1.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS0_HIGH_AE register field. */
#define CORE_MAC_ADDRESS0_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS0_HIGH_AE register field. */
#define CORE_MAC_ADDRESS0_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS0_HIGH_AE register field. */
#define CORE_MAC_ADDRESS0_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS0_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS0_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS0_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS0_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS0_HIGH_AE register field. */
#define CORE_MAC_ADDRESS0_HIGH_AE_RESET	     0x1
/* Extracts the CORE_MAC_ADDRESS0_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS0_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS0_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS0_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS0_HIGH.
 */
struct CORE_MAC_ADDRESS0_HIGH_s {
	volatile uint32_t ADDRHI : 16;		    /* CORE_MAC_ADDRESS0_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		    /* CORE_MAC_ADDRESS0_HIGH_DCS */
	const volatile uint32_t Reserved_30_y : 12; /* CORE_MAC_ADDRESS0_HIGH_RESERVED_30_Y */
	const volatile uint32_t AE : 1;		    /* CORE_MAC_ADDRESS0_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS0_HIGH. */
typedef struct CORE_MAC_ADDRESS0_HIGH_s CORE_MAC_ADDRESS0_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS0_HIGH register. */
#define CORE_MAC_ADDRESS0_HIGH_RESET 0x8000ffff
/* The byte offset of the CORE_MAC_ADDRESS0_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS0_HIGH_OFST  0x300

/*
 * Register : MAC_Address0_Low
 *
 * The MAC Address0 Low register holds the lower 32 bits of the 0th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS0_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address0 [31:0].
 *
 * This field contains the lower 32 bits of 0th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS0_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS0_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS0_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS0_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS0_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS0_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS0_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS0_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS0_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS0_LOW.
 */
struct CORE_MAC_ADDRESS0_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS0_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS0_LOW. */
typedef struct CORE_MAC_ADDRESS0_LOW_s CORE_MAC_ADDRESS0_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS0_LOW register. */
#define CORE_MAC_ADDRESS0_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS0_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS0_LOW_OFST  0x304

/*
 * Register : MAC_Address1_High
 *
 * The MAC Address1 High register holds the upper 16 bits of the 1th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address1 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address1
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address1_Low register are written, so MAC Address1 High register must be
 * written prior to MAC Address1 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address1 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS1_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS1_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS1_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS1_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS1_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address1 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 1th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS1_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS1_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS1_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS1_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS1_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS1_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS1_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address1 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS1_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS1_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS1_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS1_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS1_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS1_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS1_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address1 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS1_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS1_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS1_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS1_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS1_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS1_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS1_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address1[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address1[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_HIGH_SA register field. */
#define CORE_MAC_ADDRESS1_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_HIGH_SA register field. */
#define CORE_MAC_ADDRESS1_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS1_HIGH_SA register field. */
#define CORE_MAC_ADDRESS1_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS1_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS1_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS1_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS1_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS1_HIGH_SA register field. */
#define CORE_MAC_ADDRESS1_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS1_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS1_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS1_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS1_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 1th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_HIGH_AE register field. */
#define CORE_MAC_ADDRESS1_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_HIGH_AE register field. */
#define CORE_MAC_ADDRESS1_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS1_HIGH_AE register field. */
#define CORE_MAC_ADDRESS1_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS1_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS1_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS1_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS1_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS1_HIGH_AE register field. */
#define CORE_MAC_ADDRESS1_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS1_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS1_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS1_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS1_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS1_HIGH.
 */
struct CORE_MAC_ADDRESS1_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS1_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS1_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS1_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS1_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS1_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS1_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS1_HIGH. */
typedef struct CORE_MAC_ADDRESS1_HIGH_s CORE_MAC_ADDRESS1_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS1_HIGH register. */
#define CORE_MAC_ADDRESS1_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS1_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS1_HIGH_OFST  0x308

/*
 * Register : MAC_Address1_Low
 *
 * The MAC Address1 Low register holds the lower 32 bits of the 1th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS1_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address1 [31:0].
 *
 * This field contains the lower 32 bits of 1th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS1_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS1_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS1_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS1_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS1_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS1_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS1_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS1_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS1_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS1_LOW.
 */
struct CORE_MAC_ADDRESS1_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS1_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS1_LOW. */
typedef struct CORE_MAC_ADDRESS1_LOW_s CORE_MAC_ADDRESS1_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS1_LOW register. */
#define CORE_MAC_ADDRESS1_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS1_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS1_LOW_OFST  0x30c

/*
 * Register : MAC_Address2_High
 *
 * The MAC Address2 High register holds the upper 16 bits of the 2th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address2 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address2
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address2_Low register are written, so MAC Address2 High register must be
 * written prior to MAC Address2 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address2 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS2_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS2_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS2_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS2_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS2_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address2 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 2th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS2_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS2_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS2_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS2_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS2_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS2_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS2_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address2 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS2_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS2_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS2_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS2_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS2_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS2_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS2_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address2 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS2_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS2_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS2_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS2_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS2_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS2_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS2_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address2[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address2[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_HIGH_SA register field. */
#define CORE_MAC_ADDRESS2_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_HIGH_SA register field. */
#define CORE_MAC_ADDRESS2_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS2_HIGH_SA register field. */
#define CORE_MAC_ADDRESS2_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS2_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS2_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS2_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS2_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS2_HIGH_SA register field. */
#define CORE_MAC_ADDRESS2_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS2_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS2_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS2_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS2_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 2th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_HIGH_AE register field. */
#define CORE_MAC_ADDRESS2_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_HIGH_AE register field. */
#define CORE_MAC_ADDRESS2_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS2_HIGH_AE register field. */
#define CORE_MAC_ADDRESS2_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS2_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS2_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS2_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS2_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS2_HIGH_AE register field. */
#define CORE_MAC_ADDRESS2_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS2_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS2_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS2_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS2_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS2_HIGH.
 */
struct CORE_MAC_ADDRESS2_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS2_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS2_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS2_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS2_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS2_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS2_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS2_HIGH. */
typedef struct CORE_MAC_ADDRESS2_HIGH_s CORE_MAC_ADDRESS2_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS2_HIGH register. */
#define CORE_MAC_ADDRESS2_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS2_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS2_HIGH_OFST  0x310

/*
 * Register : MAC_Address2_Low
 *
 * The MAC Address2 Low register holds the lower 32 bits of the 2th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS2_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address2 [31:0].
 *
 * This field contains the lower 32 bits of 2th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS2_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS2_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS2_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS2_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS2_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS2_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS2_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS2_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS2_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS2_LOW.
 */
struct CORE_MAC_ADDRESS2_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS2_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS2_LOW. */
typedef struct CORE_MAC_ADDRESS2_LOW_s CORE_MAC_ADDRESS2_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS2_LOW register. */
#define CORE_MAC_ADDRESS2_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS2_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS2_LOW_OFST  0x314

/*
 * Register : MAC_Address3_High
 *
 * The MAC Address3 High register holds the upper 16 bits of the 3th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address3 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address3
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address3_Low register are written, so MAC Address3 High register must be
 * written prior to MAC Address3 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address3 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS3_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS3_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS3_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS3_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS3_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address3 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 3th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS3_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS3_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS3_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS3_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS3_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS3_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS3_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address3 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS3_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS3_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS3_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS3_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS3_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS3_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS3_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address3 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS3_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS3_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS3_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS3_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS3_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS3_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS3_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address3[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address3[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_HIGH_SA register field. */
#define CORE_MAC_ADDRESS3_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_HIGH_SA register field. */
#define CORE_MAC_ADDRESS3_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS3_HIGH_SA register field. */
#define CORE_MAC_ADDRESS3_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS3_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS3_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS3_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS3_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS3_HIGH_SA register field. */
#define CORE_MAC_ADDRESS3_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS3_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS3_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS3_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS3_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 3th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_HIGH_AE register field. */
#define CORE_MAC_ADDRESS3_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_HIGH_AE register field. */
#define CORE_MAC_ADDRESS3_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS3_HIGH_AE register field. */
#define CORE_MAC_ADDRESS3_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS3_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS3_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS3_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS3_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS3_HIGH_AE register field. */
#define CORE_MAC_ADDRESS3_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS3_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS3_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS3_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS3_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS3_HIGH.
 */
struct CORE_MAC_ADDRESS3_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS3_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS3_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS3_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS3_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS3_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS3_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS3_HIGH. */
typedef struct CORE_MAC_ADDRESS3_HIGH_s CORE_MAC_ADDRESS3_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS3_HIGH register. */
#define CORE_MAC_ADDRESS3_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS3_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS3_HIGH_OFST  0x318

/*
 * Register : MAC_Address3_Low
 *
 * The MAC Address3 Low register holds the lower 32 bits of the 3th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS3_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address3 [31:0].
 *
 * This field contains the lower 32 bits of 3th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS3_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS3_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS3_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS3_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS3_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS3_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS3_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS3_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS3_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS3_LOW.
 */
struct CORE_MAC_ADDRESS3_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS3_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS3_LOW. */
typedef struct CORE_MAC_ADDRESS3_LOW_s CORE_MAC_ADDRESS3_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS3_LOW register. */
#define CORE_MAC_ADDRESS3_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS3_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS3_LOW_OFST  0x31c

/*
 * Register : MAC_Address4_High
 *
 * The MAC Address4 High register holds the upper 16 bits of the 4th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address4 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address4
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address4_Low register are written, so MAC Address4 High register must be
 * written prior to MAC Address4 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address4 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS4_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS4_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS4_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS4_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS4_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address4 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 4th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS4_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS4_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS4_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS4_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS4_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS4_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS4_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address4 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS4_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS4_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS4_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS4_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS4_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS4_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS4_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address4 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS4_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS4_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS4_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS4_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS4_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS4_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS4_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address4[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address4[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_HIGH_SA register field. */
#define CORE_MAC_ADDRESS4_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_HIGH_SA register field. */
#define CORE_MAC_ADDRESS4_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS4_HIGH_SA register field. */
#define CORE_MAC_ADDRESS4_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS4_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS4_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS4_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS4_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS4_HIGH_SA register field. */
#define CORE_MAC_ADDRESS4_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS4_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS4_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS4_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS4_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 4th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_HIGH_AE register field. */
#define CORE_MAC_ADDRESS4_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_HIGH_AE register field. */
#define CORE_MAC_ADDRESS4_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS4_HIGH_AE register field. */
#define CORE_MAC_ADDRESS4_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS4_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS4_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS4_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS4_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS4_HIGH_AE register field. */
#define CORE_MAC_ADDRESS4_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS4_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS4_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS4_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS4_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS4_HIGH.
 */
struct CORE_MAC_ADDRESS4_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS4_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS4_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS4_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS4_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS4_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS4_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS4_HIGH. */
typedef struct CORE_MAC_ADDRESS4_HIGH_s CORE_MAC_ADDRESS4_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS4_HIGH register. */
#define CORE_MAC_ADDRESS4_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS4_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS4_HIGH_OFST  0x320

/*
 * Register : MAC_Address4_Low
 *
 * The MAC Address4 Low register holds the lower 32 bits of the 4th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS4_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address4 [31:0].
 *
 * This field contains the lower 32 bits of 4th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS4_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS4_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS4_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS4_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS4_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS4_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS4_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS4_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS4_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS4_LOW.
 */
struct CORE_MAC_ADDRESS4_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS4_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS4_LOW. */
typedef struct CORE_MAC_ADDRESS4_LOW_s CORE_MAC_ADDRESS4_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS4_LOW register. */
#define CORE_MAC_ADDRESS4_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS4_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS4_LOW_OFST  0x324

/*
 * Register : MAC_Address5_High
 *
 * The MAC Address5 High register holds the upper 16 bits of the 5th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address5 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address5
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address5_Low register are written, so MAC Address5 High register must be
 * written prior to MAC Address5 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address5 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS5_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS5_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS5_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS5_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS5_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address5 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 5th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS5_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS5_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS5_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS5_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS5_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS5_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS5_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address5 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS5_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS5_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS5_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS5_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS5_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS5_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS5_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address5 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS5_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS5_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS5_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS5_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS5_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS5_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS5_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address5[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address5[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_HIGH_SA register field. */
#define CORE_MAC_ADDRESS5_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_HIGH_SA register field. */
#define CORE_MAC_ADDRESS5_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS5_HIGH_SA register field. */
#define CORE_MAC_ADDRESS5_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS5_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS5_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS5_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS5_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS5_HIGH_SA register field. */
#define CORE_MAC_ADDRESS5_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS5_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS5_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS5_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS5_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 5th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_HIGH_AE register field. */
#define CORE_MAC_ADDRESS5_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_HIGH_AE register field. */
#define CORE_MAC_ADDRESS5_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS5_HIGH_AE register field. */
#define CORE_MAC_ADDRESS5_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS5_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS5_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS5_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS5_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS5_HIGH_AE register field. */
#define CORE_MAC_ADDRESS5_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS5_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS5_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS5_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS5_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS5_HIGH.
 */
struct CORE_MAC_ADDRESS5_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS5_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS5_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS5_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS5_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS5_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS5_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS5_HIGH. */
typedef struct CORE_MAC_ADDRESS5_HIGH_s CORE_MAC_ADDRESS5_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS5_HIGH register. */
#define CORE_MAC_ADDRESS5_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS5_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS5_HIGH_OFST  0x328

/*
 * Register : MAC_Address5_Low
 *
 * The MAC Address5 Low register holds the lower 32 bits of the 5th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS5_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address5 [31:0].
 *
 * This field contains the lower 32 bits of 5th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS5_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS5_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS5_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS5_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS5_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS5_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS5_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS5_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS5_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS5_LOW.
 */
struct CORE_MAC_ADDRESS5_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS5_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS5_LOW. */
typedef struct CORE_MAC_ADDRESS5_LOW_s CORE_MAC_ADDRESS5_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS5_LOW register. */
#define CORE_MAC_ADDRESS5_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS5_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS5_LOW_OFST  0x32c

/*
 * Register : MAC_Address6_High
 *
 * The MAC Address6 High register holds the upper 16 bits of the 6th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address6 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address6
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address6_Low register are written, so MAC Address6 High register must be
 * written prior to MAC Address6 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address6 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS6_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS6_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS6_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS6_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS6_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address6 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 6th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS6_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS6_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS6_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS6_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS6_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS6_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS6_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address6 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS6_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS6_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS6_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS6_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS6_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS6_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS6_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address6 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS6_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS6_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS6_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS6_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS6_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS6_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS6_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address6[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address6[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_HIGH_SA register field. */
#define CORE_MAC_ADDRESS6_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_HIGH_SA register field. */
#define CORE_MAC_ADDRESS6_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS6_HIGH_SA register field. */
#define CORE_MAC_ADDRESS6_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS6_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS6_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS6_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS6_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS6_HIGH_SA register field. */
#define CORE_MAC_ADDRESS6_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS6_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS6_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS6_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS6_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 6th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_HIGH_AE register field. */
#define CORE_MAC_ADDRESS6_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_HIGH_AE register field. */
#define CORE_MAC_ADDRESS6_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS6_HIGH_AE register field. */
#define CORE_MAC_ADDRESS6_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS6_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS6_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS6_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS6_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS6_HIGH_AE register field. */
#define CORE_MAC_ADDRESS6_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS6_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS6_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS6_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS6_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS6_HIGH.
 */
struct CORE_MAC_ADDRESS6_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS6_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS6_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS6_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS6_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS6_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS6_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS6_HIGH. */
typedef struct CORE_MAC_ADDRESS6_HIGH_s CORE_MAC_ADDRESS6_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS6_HIGH register. */
#define CORE_MAC_ADDRESS6_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS6_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS6_HIGH_OFST  0x330

/*
 * Register : MAC_Address6_Low
 *
 * The MAC Address6 Low register holds the lower 32 bits of the 6th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS6_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address6 [31:0].
 *
 * This field contains the lower 32 bits of 6th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS6_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS6_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS6_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS6_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS6_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS6_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS6_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS6_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS6_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS6_LOW.
 */
struct CORE_MAC_ADDRESS6_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS6_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS6_LOW. */
typedef struct CORE_MAC_ADDRESS6_LOW_s CORE_MAC_ADDRESS6_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS6_LOW register. */
#define CORE_MAC_ADDRESS6_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS6_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS6_LOW_OFST  0x334

/*
 * Register : MAC_Address7_High
 *
 * The MAC Address7 High register holds the upper 16 bits of the 7th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address7 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address7
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address7_Low register are written, so MAC Address7 High register must be
 * written prior to MAC Address7 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address7 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS7_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS7_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS7_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS7_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS7_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address7 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 7th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS7_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS7_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS7_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS7_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS7_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS7_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS7_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address7 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS7_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS7_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS7_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS7_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS7_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS7_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS7_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address7 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS7_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS7_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS7_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS7_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS7_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS7_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS7_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address7[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address7[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_HIGH_SA register field. */
#define CORE_MAC_ADDRESS7_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_HIGH_SA register field. */
#define CORE_MAC_ADDRESS7_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS7_HIGH_SA register field. */
#define CORE_MAC_ADDRESS7_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS7_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS7_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS7_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS7_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS7_HIGH_SA register field. */
#define CORE_MAC_ADDRESS7_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS7_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS7_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS7_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS7_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 7th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_HIGH_AE register field. */
#define CORE_MAC_ADDRESS7_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_HIGH_AE register field. */
#define CORE_MAC_ADDRESS7_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS7_HIGH_AE register field. */
#define CORE_MAC_ADDRESS7_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS7_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS7_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS7_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS7_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS7_HIGH_AE register field. */
#define CORE_MAC_ADDRESS7_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS7_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS7_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS7_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS7_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS7_HIGH.
 */
struct CORE_MAC_ADDRESS7_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS7_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS7_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS7_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS7_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS7_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS7_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS7_HIGH. */
typedef struct CORE_MAC_ADDRESS7_HIGH_s CORE_MAC_ADDRESS7_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS7_HIGH register. */
#define CORE_MAC_ADDRESS7_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS7_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS7_HIGH_OFST  0x338

/*
 * Register : MAC_Address7_Low
 *
 * The MAC Address7 Low register holds the lower 32 bits of the 7th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS7_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address7 [31:0].
 *
 * This field contains the lower 32 bits of 7th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS7_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS7_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS7_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS7_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS7_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS7_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS7_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS7_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS7_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS7_LOW.
 */
struct CORE_MAC_ADDRESS7_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS7_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS7_LOW. */
typedef struct CORE_MAC_ADDRESS7_LOW_s CORE_MAC_ADDRESS7_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS7_LOW register. */
#define CORE_MAC_ADDRESS7_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS7_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS7_LOW_OFST  0x33c

/*
 * Register : MAC_Address8_High
 *
 * The MAC Address8 High register holds the upper 16 bits of the 8th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address8 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address8
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address8_Low register are written, so MAC Address8 High register must be
 * written prior to MAC Address8 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address8 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS8_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS8_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS8_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS8_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS8_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address8 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 8th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS8_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS8_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS8_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS8_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS8_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS8_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS8_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address8 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS8_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS8_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS8_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS8_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS8_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS8_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS8_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address8 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS8_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS8_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS8_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS8_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS8_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS8_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS8_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address8[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address8[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_HIGH_SA register field. */
#define CORE_MAC_ADDRESS8_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_HIGH_SA register field. */
#define CORE_MAC_ADDRESS8_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS8_HIGH_SA register field. */
#define CORE_MAC_ADDRESS8_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS8_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS8_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS8_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS8_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS8_HIGH_SA register field. */
#define CORE_MAC_ADDRESS8_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS8_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS8_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS8_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS8_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 8th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_HIGH_AE register field. */
#define CORE_MAC_ADDRESS8_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_HIGH_AE register field. */
#define CORE_MAC_ADDRESS8_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS8_HIGH_AE register field. */
#define CORE_MAC_ADDRESS8_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS8_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS8_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS8_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS8_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS8_HIGH_AE register field. */
#define CORE_MAC_ADDRESS8_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS8_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS8_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS8_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS8_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS8_HIGH.
 */
struct CORE_MAC_ADDRESS8_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS8_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS8_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS8_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS8_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS8_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS8_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS8_HIGH. */
typedef struct CORE_MAC_ADDRESS8_HIGH_s CORE_MAC_ADDRESS8_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS8_HIGH register. */
#define CORE_MAC_ADDRESS8_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS8_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS8_HIGH_OFST  0x340

/*
 * Register : MAC_Address8_Low
 *
 * The MAC Address8 Low register holds the lower 32 bits of the 8th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS8_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address8 [31:0].
 *
 * This field contains the lower 32 bits of 8th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS8_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS8_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS8_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS8_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS8_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS8_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS8_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS8_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS8_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS8_LOW.
 */
struct CORE_MAC_ADDRESS8_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS8_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS8_LOW. */
typedef struct CORE_MAC_ADDRESS8_LOW_s CORE_MAC_ADDRESS8_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS8_LOW register. */
#define CORE_MAC_ADDRESS8_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS8_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS8_LOW_OFST  0x344

/*
 * Register : MAC_Address9_High
 *
 * The MAC Address9 High register holds the upper 16 bits of the 9th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address9 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address9
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address9_Low register are written, so MAC Address9 High register must be
 * written prior to MAC Address9 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address9 Low register should be performed after at
 * least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:-------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS9_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS9_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS9_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS9_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS9_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address9 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 9th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_MSB	 15
/* The width in bits of the CORE_MAC_ADDRESS9_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_WIDTH	 16
/* The mask used to set the CORE_MAC_ADDRESS9_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_SET_MSK	 0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS9_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_CLR_MSK	 0xffff0000
/* The reset value of the CORE_MAC_ADDRESS9_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_RESET	 0xffff
/* Extracts the CORE_MAC_ADDRESS9_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS9_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS9_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address9 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_MSB	      18
/* The width in bits of the CORE_MAC_ADDRESS9_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS9_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS9_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS9_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS9_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS9_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS9_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_MSB	23
/* The width in bits of the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_WIDTH	5
/* The mask used to set the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_SET_MSK	0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_CLR_MSK	0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_RESET	0x0
/* Extracts the CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address9 registers. Each bit controls the masking of
 * the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_LSB	      24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_MSB	      29
/* The width in bits of the CORE_MAC_ADDRESS9_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS9_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS9_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS9_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS9_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS9_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS9_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address9[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address9[47:0] is
 * used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_HIGH_SA register field. */
#define CORE_MAC_ADDRESS9_HIGH_SA_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_HIGH_SA register field. */
#define CORE_MAC_ADDRESS9_HIGH_SA_MSB	     30
/* The width in bits of the CORE_MAC_ADDRESS9_HIGH_SA register field. */
#define CORE_MAC_ADDRESS9_HIGH_SA_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS9_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS9_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS9_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS9_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS9_HIGH_SA register field. */
#define CORE_MAC_ADDRESS9_HIGH_SA_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS9_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS9_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS9_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS9_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 9th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_HIGH_AE register field. */
#define CORE_MAC_ADDRESS9_HIGH_AE_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_HIGH_AE register field. */
#define CORE_MAC_ADDRESS9_HIGH_AE_MSB	     31
/* The width in bits of the CORE_MAC_ADDRESS9_HIGH_AE register field. */
#define CORE_MAC_ADDRESS9_HIGH_AE_WIDTH	     1
/* The mask used to set the CORE_MAC_ADDRESS9_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS9_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS9_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS9_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS9_HIGH_AE register field. */
#define CORE_MAC_ADDRESS9_HIGH_AE_RESET	     0x0
/* Extracts the CORE_MAC_ADDRESS9_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS9_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS9_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS9_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS9_HIGH.
 */
struct CORE_MAC_ADDRESS9_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS9_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS9_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS9_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS9_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS9_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS9_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS9_HIGH. */
typedef struct CORE_MAC_ADDRESS9_HIGH_s CORE_MAC_ADDRESS9_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS9_HIGH register. */
#define CORE_MAC_ADDRESS9_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS9_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS9_HIGH_OFST  0x348

/*
 * Register : MAC_Address9_Low
 *
 * The MAC Address9 Low register holds the lower 32 bits of the 9th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:-----------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS9_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address9 [31:0].
 *
 * This field contains the lower 32 bits of 9th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS9_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS9_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_MSB	31
/* The width in bits of the CORE_MAC_ADDRESS9_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_WIDTH	32
/* The mask used to set the CORE_MAC_ADDRESS9_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS9_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_ADDRESS9_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_RESET	0xffffffff
/* Extracts the CORE_MAC_ADDRESS9_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS9_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS9_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS9_LOW.
 */
struct CORE_MAC_ADDRESS9_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS9_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS9_LOW. */
typedef struct CORE_MAC_ADDRESS9_LOW_s CORE_MAC_ADDRESS9_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS9_LOW register. */
#define CORE_MAC_ADDRESS9_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS9_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS9_LOW_OFST  0x34c

/*
 * Register : MAC_Address10_High
 *
 * The MAC Address10 High register holds the upper 16 bits of the 10th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address10 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address10
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address10_Low register are written, so MAC Address10 High register must be
 * written prior to MAC Address10 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address10 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS10_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS10_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS10_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS10_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS10_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address10 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 10th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS10_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS10_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS10_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS10_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS10_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS10_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS10_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address10 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS10_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS10_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS10_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS10_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS10_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS10_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS10_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address10 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS10_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS10_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS10_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS10_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS10_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS10_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS10_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address10[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address10[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_HIGH_SA register field. */
#define CORE_MAC_ADDRESS10_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_HIGH_SA register field. */
#define CORE_MAC_ADDRESS10_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS10_HIGH_SA register field. */
#define CORE_MAC_ADDRESS10_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS10_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS10_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS10_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS10_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS10_HIGH_SA register field. */
#define CORE_MAC_ADDRESS10_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS10_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS10_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS10_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS10_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 10th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_HIGH_AE register field. */
#define CORE_MAC_ADDRESS10_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_HIGH_AE register field. */
#define CORE_MAC_ADDRESS10_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS10_HIGH_AE register field. */
#define CORE_MAC_ADDRESS10_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS10_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS10_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS10_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS10_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS10_HIGH_AE register field. */
#define CORE_MAC_ADDRESS10_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS10_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS10_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS10_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS10_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS10_HIGH.
 */
struct CORE_MAC_ADDRESS10_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS10_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS10_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS10_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS10_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS10_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS10_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS10_HIGH. */
typedef struct CORE_MAC_ADDRESS10_HIGH_s CORE_MAC_ADDRESS10_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS10_HIGH register. */
#define CORE_MAC_ADDRESS10_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS10_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS10_HIGH_OFST  0x350

/*
 * Register : MAC_Address10_Low
 *
 * The MAC Address10 Low register holds the lower 32 bits of the 10th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS10_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address10 [31:0].
 *
 * This field contains the lower 32 bits of 10th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS10_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS10_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS10_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS10_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS10_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS10_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS10_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS10_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS10_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS10_LOW.
 */
struct CORE_MAC_ADDRESS10_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS10_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS10_LOW. */
typedef struct CORE_MAC_ADDRESS10_LOW_s CORE_MAC_ADDRESS10_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS10_LOW register. */
#define CORE_MAC_ADDRESS10_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS10_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS10_LOW_OFST  0x354

/*
 * Register : MAC_Address11_High
 *
 * The MAC Address11 High register holds the upper 16 bits of the 11th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address11 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address11
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address11_Low register are written, so MAC Address11 High register must be
 * written prior to MAC Address11 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address11 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS11_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS11_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS11_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS11_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS11_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address11 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 11th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS11_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS11_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS11_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS11_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS11_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS11_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS11_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address11 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS11_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS11_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS11_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS11_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS11_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS11_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS11_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address11 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS11_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS11_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS11_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS11_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS11_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS11_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS11_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address11[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address11[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_HIGH_SA register field. */
#define CORE_MAC_ADDRESS11_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_HIGH_SA register field. */
#define CORE_MAC_ADDRESS11_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS11_HIGH_SA register field. */
#define CORE_MAC_ADDRESS11_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS11_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS11_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS11_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS11_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS11_HIGH_SA register field. */
#define CORE_MAC_ADDRESS11_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS11_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS11_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS11_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS11_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 11th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_HIGH_AE register field. */
#define CORE_MAC_ADDRESS11_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_HIGH_AE register field. */
#define CORE_MAC_ADDRESS11_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS11_HIGH_AE register field. */
#define CORE_MAC_ADDRESS11_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS11_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS11_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS11_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS11_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS11_HIGH_AE register field. */
#define CORE_MAC_ADDRESS11_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS11_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS11_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS11_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS11_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS11_HIGH.
 */
struct CORE_MAC_ADDRESS11_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS11_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS11_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS11_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS11_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS11_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS11_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS11_HIGH. */
typedef struct CORE_MAC_ADDRESS11_HIGH_s CORE_MAC_ADDRESS11_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS11_HIGH register. */
#define CORE_MAC_ADDRESS11_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS11_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS11_HIGH_OFST  0x358

/*
 * Register : MAC_Address11_Low
 *
 * The MAC Address11 Low register holds the lower 32 bits of the 11th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS11_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address11 [31:0].
 *
 * This field contains the lower 32 bits of 11th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS11_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS11_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS11_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS11_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS11_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS11_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS11_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS11_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS11_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS11_LOW.
 */
struct CORE_MAC_ADDRESS11_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS11_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS11_LOW. */
typedef struct CORE_MAC_ADDRESS11_LOW_s CORE_MAC_ADDRESS11_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS11_LOW register. */
#define CORE_MAC_ADDRESS11_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS11_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS11_LOW_OFST  0x35c

/*
 * Register : MAC_Address12_High
 *
 * The MAC Address12 High register holds the upper 16 bits of the 12th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address12 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address12
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address12_Low register are written, so MAC Address12 High register must be
 * written prior to MAC Address12 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address12 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS12_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS12_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS12_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS12_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS12_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address12 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 12th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS12_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS12_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS12_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS12_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS12_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS12_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS12_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address12 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS12_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS12_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS12_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS12_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS12_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS12_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS12_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address12 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS12_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS12_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS12_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS12_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS12_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS12_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS12_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address12[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address12[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_HIGH_SA register field. */
#define CORE_MAC_ADDRESS12_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_HIGH_SA register field. */
#define CORE_MAC_ADDRESS12_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS12_HIGH_SA register field. */
#define CORE_MAC_ADDRESS12_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS12_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS12_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS12_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS12_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS12_HIGH_SA register field. */
#define CORE_MAC_ADDRESS12_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS12_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS12_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS12_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS12_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 12th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_HIGH_AE register field. */
#define CORE_MAC_ADDRESS12_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_HIGH_AE register field. */
#define CORE_MAC_ADDRESS12_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS12_HIGH_AE register field. */
#define CORE_MAC_ADDRESS12_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS12_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS12_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS12_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS12_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS12_HIGH_AE register field. */
#define CORE_MAC_ADDRESS12_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS12_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS12_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS12_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS12_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS12_HIGH.
 */
struct CORE_MAC_ADDRESS12_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS12_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS12_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS12_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS12_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS12_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS12_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS12_HIGH. */
typedef struct CORE_MAC_ADDRESS12_HIGH_s CORE_MAC_ADDRESS12_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS12_HIGH register. */
#define CORE_MAC_ADDRESS12_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS12_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS12_HIGH_OFST  0x360

/*
 * Register : MAC_Address12_Low
 *
 * The MAC Address12 Low register holds the lower 32 bits of the 12th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS12_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address12 [31:0].
 *
 * This field contains the lower 32 bits of 12th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS12_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS12_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS12_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS12_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS12_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS12_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS12_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS12_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS12_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS12_LOW.
 */
struct CORE_MAC_ADDRESS12_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS12_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS12_LOW. */
typedef struct CORE_MAC_ADDRESS12_LOW_s CORE_MAC_ADDRESS12_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS12_LOW register. */
#define CORE_MAC_ADDRESS12_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS12_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS12_LOW_OFST  0x364

/*
 * Register : MAC_Address13_High
 *
 * The MAC Address13 High register holds the upper 16 bits of the 13th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address13 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address13
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address13_Low register are written, so MAC Address13 High register must be
 * written prior to MAC Address13 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address13 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS13_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS13_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS13_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS13_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS13_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address13 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 13th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS13_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS13_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS13_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS13_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS13_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS13_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS13_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address13 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS13_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS13_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS13_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS13_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS13_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS13_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS13_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address13 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS13_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS13_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS13_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS13_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS13_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS13_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS13_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address13[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address13[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_HIGH_SA register field. */
#define CORE_MAC_ADDRESS13_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_HIGH_SA register field. */
#define CORE_MAC_ADDRESS13_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS13_HIGH_SA register field. */
#define CORE_MAC_ADDRESS13_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS13_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS13_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS13_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS13_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS13_HIGH_SA register field. */
#define CORE_MAC_ADDRESS13_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS13_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS13_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS13_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS13_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 13th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_HIGH_AE register field. */
#define CORE_MAC_ADDRESS13_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_HIGH_AE register field. */
#define CORE_MAC_ADDRESS13_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS13_HIGH_AE register field. */
#define CORE_MAC_ADDRESS13_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS13_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS13_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS13_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS13_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS13_HIGH_AE register field. */
#define CORE_MAC_ADDRESS13_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS13_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS13_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS13_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS13_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS13_HIGH.
 */
struct CORE_MAC_ADDRESS13_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS13_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS13_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS13_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS13_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS13_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS13_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS13_HIGH. */
typedef struct CORE_MAC_ADDRESS13_HIGH_s CORE_MAC_ADDRESS13_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS13_HIGH register. */
#define CORE_MAC_ADDRESS13_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS13_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS13_HIGH_OFST  0x368

/*
 * Register : MAC_Address13_Low
 *
 * The MAC Address13 Low register holds the lower 32 bits of the 13th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS13_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address13 [31:0].
 *
 * This field contains the lower 32 bits of 13th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS13_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS13_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS13_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS13_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS13_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS13_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS13_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS13_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS13_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS13_LOW.
 */
struct CORE_MAC_ADDRESS13_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS13_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS13_LOW. */
typedef struct CORE_MAC_ADDRESS13_LOW_s CORE_MAC_ADDRESS13_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS13_LOW register. */
#define CORE_MAC_ADDRESS13_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS13_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS13_LOW_OFST  0x36c

/*
 * Register : MAC_Address14_High
 *
 * The MAC Address14 High register holds the upper 16 bits of the 14th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address14 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address14
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address14_Low register are written, so MAC Address14 High register must be
 * written prior to MAC Address14 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address14 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS14_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS14_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS14_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS14_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS14_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address14 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 14th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS14_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS14_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS14_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS14_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS14_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS14_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS14_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address14 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS14_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS14_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS14_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS14_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS14_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS14_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS14_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address14 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS14_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS14_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS14_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS14_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS14_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS14_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS14_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address14[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address14[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_HIGH_SA register field. */
#define CORE_MAC_ADDRESS14_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_HIGH_SA register field. */
#define CORE_MAC_ADDRESS14_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS14_HIGH_SA register field. */
#define CORE_MAC_ADDRESS14_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS14_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS14_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS14_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS14_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS14_HIGH_SA register field. */
#define CORE_MAC_ADDRESS14_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS14_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS14_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS14_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS14_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 14th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_HIGH_AE register field. */
#define CORE_MAC_ADDRESS14_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_HIGH_AE register field. */
#define CORE_MAC_ADDRESS14_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS14_HIGH_AE register field. */
#define CORE_MAC_ADDRESS14_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS14_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS14_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS14_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS14_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS14_HIGH_AE register field. */
#define CORE_MAC_ADDRESS14_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS14_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS14_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS14_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS14_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS14_HIGH.
 */
struct CORE_MAC_ADDRESS14_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS14_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS14_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS14_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS14_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS14_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS14_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS14_HIGH. */
typedef struct CORE_MAC_ADDRESS14_HIGH_s CORE_MAC_ADDRESS14_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS14_HIGH register. */
#define CORE_MAC_ADDRESS14_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS14_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS14_HIGH_OFST  0x370

/*
 * Register : MAC_Address14_Low
 *
 * The MAC Address14 Low register holds the lower 32 bits of the 14th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS14_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address14 [31:0].
 *
 * This field contains the lower 32 bits of 14th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS14_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS14_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS14_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS14_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS14_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS14_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS14_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS14_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS14_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS14_LOW.
 */
struct CORE_MAC_ADDRESS14_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS14_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS14_LOW. */
typedef struct CORE_MAC_ADDRESS14_LOW_s CORE_MAC_ADDRESS14_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS14_LOW register. */
#define CORE_MAC_ADDRESS14_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS14_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS14_LOW_OFST  0x374

/*
 * Register : MAC_Address15_High
 *
 * The MAC Address15 High register holds the upper 16 bits of the 15th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address15 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address15
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address15_Low register are written, so MAC Address15 High register must be
 * written prior to MAC Address15 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address15 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS15_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS15_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS15_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS15_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS15_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address15 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 15th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS15_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS15_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS15_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS15_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS15_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS15_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS15_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address15 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS15_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS15_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS15_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS15_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS15_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS15_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS15_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address15 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS15_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS15_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS15_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS15_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS15_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS15_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS15_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address15[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address15[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_HIGH_SA register field. */
#define CORE_MAC_ADDRESS15_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_HIGH_SA register field. */
#define CORE_MAC_ADDRESS15_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS15_HIGH_SA register field. */
#define CORE_MAC_ADDRESS15_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS15_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS15_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS15_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS15_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS15_HIGH_SA register field. */
#define CORE_MAC_ADDRESS15_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS15_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS15_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS15_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS15_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 15th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_HIGH_AE register field. */
#define CORE_MAC_ADDRESS15_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_HIGH_AE register field. */
#define CORE_MAC_ADDRESS15_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS15_HIGH_AE register field. */
#define CORE_MAC_ADDRESS15_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS15_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS15_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS15_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS15_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS15_HIGH_AE register field. */
#define CORE_MAC_ADDRESS15_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS15_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS15_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS15_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS15_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS15_HIGH.
 */
struct CORE_MAC_ADDRESS15_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS15_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS15_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS15_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS15_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS15_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS15_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS15_HIGH. */
typedef struct CORE_MAC_ADDRESS15_HIGH_s CORE_MAC_ADDRESS15_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS15_HIGH register. */
#define CORE_MAC_ADDRESS15_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS15_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS15_HIGH_OFST  0x378

/*
 * Register : MAC_Address15_Low
 *
 * The MAC Address15 Low register holds the lower 32 bits of the 15th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS15_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address15 [31:0].
 *
 * This field contains the lower 32 bits of 15th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS15_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS15_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS15_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS15_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS15_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS15_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS15_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS15_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS15_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS15_LOW.
 */
struct CORE_MAC_ADDRESS15_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS15_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS15_LOW. */
typedef struct CORE_MAC_ADDRESS15_LOW_s CORE_MAC_ADDRESS15_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS15_LOW register. */
#define CORE_MAC_ADDRESS15_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS15_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS15_LOW_OFST  0x37c

/*
 * Register : MAC_Address16_High
 *
 * The MAC Address16 High register holds the upper 16 bits of the 16th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address16 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address16
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address16_Low register are written, so MAC Address16 High register must be
 * written prior to MAC Address16 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address16 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS16_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS16_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS16_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS16_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS16_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address16 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 16th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS16_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS16_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS16_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS16_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS16_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS16_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS16_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address16 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS16_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS16_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS16_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS16_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS16_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS16_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS16_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address16 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS16_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS16_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS16_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS16_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS16_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS16_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS16_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address16[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address16[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_HIGH_SA register field. */
#define CORE_MAC_ADDRESS16_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_HIGH_SA register field. */
#define CORE_MAC_ADDRESS16_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS16_HIGH_SA register field. */
#define CORE_MAC_ADDRESS16_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS16_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS16_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS16_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS16_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS16_HIGH_SA register field. */
#define CORE_MAC_ADDRESS16_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS16_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS16_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS16_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS16_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 16th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_HIGH_AE register field. */
#define CORE_MAC_ADDRESS16_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_HIGH_AE register field. */
#define CORE_MAC_ADDRESS16_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS16_HIGH_AE register field. */
#define CORE_MAC_ADDRESS16_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS16_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS16_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS16_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS16_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS16_HIGH_AE register field. */
#define CORE_MAC_ADDRESS16_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS16_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS16_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS16_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS16_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS16_HIGH.
 */
struct CORE_MAC_ADDRESS16_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS16_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS16_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS16_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS16_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS16_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS16_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS16_HIGH. */
typedef struct CORE_MAC_ADDRESS16_HIGH_s CORE_MAC_ADDRESS16_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS16_HIGH register. */
#define CORE_MAC_ADDRESS16_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS16_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS16_HIGH_OFST  0x380

/*
 * Register : MAC_Address16_Low
 *
 * The MAC Address16 Low register holds the lower 32 bits of the 16th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS16_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address16 [31:0].
 *
 * This field contains the lower 32 bits of 16th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS16_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS16_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS16_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS16_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS16_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS16_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS16_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS16_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS16_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS16_LOW.
 */
struct CORE_MAC_ADDRESS16_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS16_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS16_LOW. */
typedef struct CORE_MAC_ADDRESS16_LOW_s CORE_MAC_ADDRESS16_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS16_LOW register. */
#define CORE_MAC_ADDRESS16_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS16_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS16_LOW_OFST  0x384

/*
 * Register : MAC_Address17_High
 *
 * The MAC Address17 High register holds the upper 16 bits of the 17th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address17 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address17
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address17_Low register are written, so MAC Address17 High register must be
 * written prior to MAC Address17 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address17 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS17_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS17_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS17_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS17_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS17_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address17 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 17th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS17_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS17_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS17_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS17_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS17_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS17_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS17_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address17 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS17_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS17_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS17_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS17_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS17_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS17_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS17_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address17 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS17_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS17_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS17_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS17_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS17_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS17_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS17_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address17[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address17[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_HIGH_SA register field. */
#define CORE_MAC_ADDRESS17_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_HIGH_SA register field. */
#define CORE_MAC_ADDRESS17_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS17_HIGH_SA register field. */
#define CORE_MAC_ADDRESS17_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS17_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS17_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS17_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS17_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS17_HIGH_SA register field. */
#define CORE_MAC_ADDRESS17_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS17_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS17_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS17_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS17_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 17th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_HIGH_AE register field. */
#define CORE_MAC_ADDRESS17_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_HIGH_AE register field. */
#define CORE_MAC_ADDRESS17_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS17_HIGH_AE register field. */
#define CORE_MAC_ADDRESS17_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS17_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS17_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS17_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS17_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS17_HIGH_AE register field. */
#define CORE_MAC_ADDRESS17_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS17_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS17_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS17_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS17_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS17_HIGH.
 */
struct CORE_MAC_ADDRESS17_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS17_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS17_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS17_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS17_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS17_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS17_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS17_HIGH. */
typedef struct CORE_MAC_ADDRESS17_HIGH_s CORE_MAC_ADDRESS17_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS17_HIGH register. */
#define CORE_MAC_ADDRESS17_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS17_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS17_HIGH_OFST  0x388

/*
 * Register : MAC_Address17_Low
 *
 * The MAC Address17 Low register holds the lower 32 bits of the 17th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS17_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address17 [31:0].
 *
 * This field contains the lower 32 bits of 17th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS17_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS17_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS17_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS17_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS17_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS17_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS17_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS17_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS17_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS17_LOW.
 */
struct CORE_MAC_ADDRESS17_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS17_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS17_LOW. */
typedef struct CORE_MAC_ADDRESS17_LOW_s CORE_MAC_ADDRESS17_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS17_LOW register. */
#define CORE_MAC_ADDRESS17_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS17_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS17_LOW_OFST  0x38c

/*
 * Register : MAC_Address18_High
 *
 * The MAC Address18 High register holds the upper 16 bits of the 18th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address18 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address18
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address18_Low register are written, so MAC Address18 High register must be
 * written prior to MAC Address18 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address18 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS18_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS18_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS18_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS18_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS18_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address18 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 18th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS18_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS18_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS18_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS18_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS18_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS18_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS18_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address18 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS18_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS18_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS18_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS18_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS18_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS18_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS18_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address18 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS18_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS18_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS18_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS18_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS18_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS18_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS18_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address18[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address18[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_HIGH_SA register field. */
#define CORE_MAC_ADDRESS18_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_HIGH_SA register field. */
#define CORE_MAC_ADDRESS18_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS18_HIGH_SA register field. */
#define CORE_MAC_ADDRESS18_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS18_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS18_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS18_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS18_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS18_HIGH_SA register field. */
#define CORE_MAC_ADDRESS18_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS18_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS18_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS18_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS18_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 18th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_HIGH_AE register field. */
#define CORE_MAC_ADDRESS18_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_HIGH_AE register field. */
#define CORE_MAC_ADDRESS18_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS18_HIGH_AE register field. */
#define CORE_MAC_ADDRESS18_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS18_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS18_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS18_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS18_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS18_HIGH_AE register field. */
#define CORE_MAC_ADDRESS18_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS18_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS18_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS18_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS18_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS18_HIGH.
 */
struct CORE_MAC_ADDRESS18_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS18_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS18_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS18_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS18_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS18_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS18_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS18_HIGH. */
typedef struct CORE_MAC_ADDRESS18_HIGH_s CORE_MAC_ADDRESS18_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS18_HIGH register. */
#define CORE_MAC_ADDRESS18_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS18_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS18_HIGH_OFST  0x390

/*
 * Register : MAC_Address18_Low
 *
 * The MAC Address18 Low register holds the lower 32 bits of the 18th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS18_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address18 [31:0].
 *
 * This field contains the lower 32 bits of 18th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS18_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS18_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS18_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS18_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS18_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS18_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS18_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS18_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS18_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS18_LOW.
 */
struct CORE_MAC_ADDRESS18_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS18_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS18_LOW. */
typedef struct CORE_MAC_ADDRESS18_LOW_s CORE_MAC_ADDRESS18_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS18_LOW register. */
#define CORE_MAC_ADDRESS18_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS18_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS18_LOW_OFST  0x394

/*
 * Register : MAC_Address19_High
 *
 * The MAC Address19 High register holds the upper 16 bits of the 19th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address19 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address19
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address19_Low register are written, so MAC Address19 High register must be
 * written prior to MAC Address19 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address19 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS19_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS19_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS19_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS19_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS19_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address19 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 19th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS19_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS19_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS19_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS19_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS19_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS19_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS19_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address19 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS19_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS19_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS19_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS19_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS19_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS19_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS19_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address19 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS19_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS19_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS19_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS19_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS19_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS19_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS19_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address19[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address19[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_HIGH_SA register field. */
#define CORE_MAC_ADDRESS19_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_HIGH_SA register field. */
#define CORE_MAC_ADDRESS19_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS19_HIGH_SA register field. */
#define CORE_MAC_ADDRESS19_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS19_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS19_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS19_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS19_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS19_HIGH_SA register field. */
#define CORE_MAC_ADDRESS19_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS19_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS19_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS19_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS19_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 19th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_HIGH_AE register field. */
#define CORE_MAC_ADDRESS19_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_HIGH_AE register field. */
#define CORE_MAC_ADDRESS19_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS19_HIGH_AE register field. */
#define CORE_MAC_ADDRESS19_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS19_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS19_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS19_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS19_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS19_HIGH_AE register field. */
#define CORE_MAC_ADDRESS19_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS19_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS19_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS19_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS19_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS19_HIGH.
 */
struct CORE_MAC_ADDRESS19_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS19_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS19_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS19_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS19_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS19_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS19_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS19_HIGH. */
typedef struct CORE_MAC_ADDRESS19_HIGH_s CORE_MAC_ADDRESS19_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS19_HIGH register. */
#define CORE_MAC_ADDRESS19_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS19_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS19_HIGH_OFST  0x398

/*
 * Register : MAC_Address19_Low
 *
 * The MAC Address19 Low register holds the lower 32 bits of the 19th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS19_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address19 [31:0].
 *
 * This field contains the lower 32 bits of 19th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS19_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS19_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS19_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS19_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS19_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS19_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS19_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS19_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS19_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS19_LOW.
 */
struct CORE_MAC_ADDRESS19_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS19_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS19_LOW. */
typedef struct CORE_MAC_ADDRESS19_LOW_s CORE_MAC_ADDRESS19_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS19_LOW register. */
#define CORE_MAC_ADDRESS19_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS19_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS19_LOW_OFST  0x39c

/*
 * Register : MAC_Address20_High
 *
 * The MAC Address20 High register holds the upper 16 bits of the 20th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address20 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address20
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address20_Low register are written, so MAC Address20 High register must be
 * written prior to MAC Address20 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address20 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS20_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS20_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS20_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS20_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS20_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address20 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 20th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS20_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS20_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS20_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS20_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS20_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS20_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS20_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address20 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS20_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS20_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS20_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS20_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS20_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS20_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS20_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address20 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS20_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS20_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS20_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS20_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS20_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS20_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS20_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address20[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address20[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_HIGH_SA register field. */
#define CORE_MAC_ADDRESS20_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_HIGH_SA register field. */
#define CORE_MAC_ADDRESS20_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS20_HIGH_SA register field. */
#define CORE_MAC_ADDRESS20_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS20_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS20_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS20_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS20_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS20_HIGH_SA register field. */
#define CORE_MAC_ADDRESS20_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS20_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS20_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS20_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS20_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 20th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_HIGH_AE register field. */
#define CORE_MAC_ADDRESS20_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_HIGH_AE register field. */
#define CORE_MAC_ADDRESS20_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS20_HIGH_AE register field. */
#define CORE_MAC_ADDRESS20_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS20_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS20_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS20_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS20_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS20_HIGH_AE register field. */
#define CORE_MAC_ADDRESS20_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS20_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS20_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS20_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS20_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS20_HIGH.
 */
struct CORE_MAC_ADDRESS20_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS20_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS20_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS20_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS20_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS20_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS20_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS20_HIGH. */
typedef struct CORE_MAC_ADDRESS20_HIGH_s CORE_MAC_ADDRESS20_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS20_HIGH register. */
#define CORE_MAC_ADDRESS20_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS20_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS20_HIGH_OFST  0x3a0

/*
 * Register : MAC_Address20_Low
 *
 * The MAC Address20 Low register holds the lower 32 bits of the 20th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS20_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address20 [31:0].
 *
 * This field contains the lower 32 bits of 20th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS20_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS20_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS20_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS20_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS20_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS20_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS20_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS20_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS20_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS20_LOW.
 */
struct CORE_MAC_ADDRESS20_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS20_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS20_LOW. */
typedef struct CORE_MAC_ADDRESS20_LOW_s CORE_MAC_ADDRESS20_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS20_LOW register. */
#define CORE_MAC_ADDRESS20_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS20_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS20_LOW_OFST  0x3a4

/*
 * Register : MAC_Address21_High
 *
 * The MAC Address21 High register holds the upper 16 bits of the 21th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address21 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address21
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address21_Low register are written, so MAC Address21 High register must be
 * written prior to MAC Address21 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address21 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS21_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS21_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS21_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS21_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS21_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address21 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 21th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS21_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS21_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS21_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS21_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS21_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS21_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS21_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address21 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS21_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS21_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS21_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS21_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS21_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS21_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS21_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address21 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS21_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS21_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS21_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS21_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS21_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS21_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS21_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address21[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address21[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_HIGH_SA register field. */
#define CORE_MAC_ADDRESS21_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_HIGH_SA register field. */
#define CORE_MAC_ADDRESS21_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS21_HIGH_SA register field. */
#define CORE_MAC_ADDRESS21_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS21_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS21_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS21_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS21_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS21_HIGH_SA register field. */
#define CORE_MAC_ADDRESS21_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS21_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS21_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS21_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS21_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 21th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_HIGH_AE register field. */
#define CORE_MAC_ADDRESS21_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_HIGH_AE register field. */
#define CORE_MAC_ADDRESS21_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS21_HIGH_AE register field. */
#define CORE_MAC_ADDRESS21_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS21_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS21_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS21_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS21_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS21_HIGH_AE register field. */
#define CORE_MAC_ADDRESS21_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS21_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS21_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS21_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS21_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS21_HIGH.
 */
struct CORE_MAC_ADDRESS21_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS21_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS21_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS21_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS21_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS21_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS21_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS21_HIGH. */
typedef struct CORE_MAC_ADDRESS21_HIGH_s CORE_MAC_ADDRESS21_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS21_HIGH register. */
#define CORE_MAC_ADDRESS21_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS21_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS21_HIGH_OFST  0x3a8

/*
 * Register : MAC_Address21_Low
 *
 * The MAC Address21 Low register holds the lower 32 bits of the 21th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS21_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address21 [31:0].
 *
 * This field contains the lower 32 bits of 21th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS21_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS21_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS21_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS21_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS21_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS21_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS21_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS21_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS21_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS21_LOW.
 */
struct CORE_MAC_ADDRESS21_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS21_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS21_LOW. */
typedef struct CORE_MAC_ADDRESS21_LOW_s CORE_MAC_ADDRESS21_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS21_LOW register. */
#define CORE_MAC_ADDRESS21_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS21_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS21_LOW_OFST  0x3ac

/*
 * Register : MAC_Address22_High
 *
 * The MAC Address22 High register holds the upper 16 bits of the 22th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address22 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address22
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address22_Low register are written, so MAC Address22 High register must be
 * written prior to MAC Address22 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address22 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS22_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS22_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS22_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS22_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS22_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address22 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 22th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS22_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS22_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS22_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS22_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS22_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS22_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS22_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address22 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS22_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS22_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS22_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS22_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS22_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS22_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS22_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address22 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS22_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS22_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS22_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS22_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS22_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS22_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS22_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address22[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address22[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_HIGH_SA register field. */
#define CORE_MAC_ADDRESS22_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_HIGH_SA register field. */
#define CORE_MAC_ADDRESS22_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS22_HIGH_SA register field. */
#define CORE_MAC_ADDRESS22_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS22_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS22_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS22_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS22_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS22_HIGH_SA register field. */
#define CORE_MAC_ADDRESS22_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS22_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS22_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS22_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS22_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 22th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_HIGH_AE register field. */
#define CORE_MAC_ADDRESS22_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_HIGH_AE register field. */
#define CORE_MAC_ADDRESS22_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS22_HIGH_AE register field. */
#define CORE_MAC_ADDRESS22_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS22_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS22_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS22_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS22_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS22_HIGH_AE register field. */
#define CORE_MAC_ADDRESS22_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS22_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS22_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS22_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS22_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS22_HIGH.
 */
struct CORE_MAC_ADDRESS22_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS22_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS22_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS22_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS22_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS22_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS22_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS22_HIGH. */
typedef struct CORE_MAC_ADDRESS22_HIGH_s CORE_MAC_ADDRESS22_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS22_HIGH register. */
#define CORE_MAC_ADDRESS22_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS22_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS22_HIGH_OFST  0x3b0

/*
 * Register : MAC_Address22_Low
 *
 * The MAC Address22 Low register holds the lower 32 bits of the 22th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS22_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address22 [31:0].
 *
 * This field contains the lower 32 bits of 22th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS22_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS22_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS22_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS22_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS22_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS22_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS22_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS22_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS22_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS22_LOW.
 */
struct CORE_MAC_ADDRESS22_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS22_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS22_LOW. */
typedef struct CORE_MAC_ADDRESS22_LOW_s CORE_MAC_ADDRESS22_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS22_LOW register. */
#define CORE_MAC_ADDRESS22_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS22_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS22_LOW_OFST  0x3b4

/*
 * Register : MAC_Address23_High
 *
 * The MAC Address23 High register holds the upper 16 bits of the 23th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address23 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address23
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address23_Low register are written, so MAC Address23 High register must be
 * written prior to MAC Address23 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address23 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS23_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS23_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS23_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS23_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS23_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address23 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 23th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS23_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS23_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS23_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS23_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS23_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS23_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS23_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address23 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS23_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS23_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS23_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS23_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS23_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS23_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS23_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address23 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS23_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS23_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS23_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS23_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS23_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS23_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS23_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address23[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address23[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_HIGH_SA register field. */
#define CORE_MAC_ADDRESS23_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_HIGH_SA register field. */
#define CORE_MAC_ADDRESS23_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS23_HIGH_SA register field. */
#define CORE_MAC_ADDRESS23_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS23_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS23_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS23_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS23_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS23_HIGH_SA register field. */
#define CORE_MAC_ADDRESS23_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS23_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS23_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS23_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS23_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 23th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_HIGH_AE register field. */
#define CORE_MAC_ADDRESS23_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_HIGH_AE register field. */
#define CORE_MAC_ADDRESS23_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS23_HIGH_AE register field. */
#define CORE_MAC_ADDRESS23_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS23_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS23_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS23_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS23_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS23_HIGH_AE register field. */
#define CORE_MAC_ADDRESS23_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS23_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS23_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS23_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS23_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS23_HIGH.
 */
struct CORE_MAC_ADDRESS23_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS23_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS23_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS23_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS23_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS23_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS23_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS23_HIGH. */
typedef struct CORE_MAC_ADDRESS23_HIGH_s CORE_MAC_ADDRESS23_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS23_HIGH register. */
#define CORE_MAC_ADDRESS23_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS23_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS23_HIGH_OFST  0x3b8

/*
 * Register : MAC_Address23_Low
 *
 * The MAC Address23 Low register holds the lower 32 bits of the 23th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS23_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address23 [31:0].
 *
 * This field contains the lower 32 bits of 23th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS23_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS23_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS23_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS23_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS23_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS23_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS23_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS23_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS23_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS23_LOW.
 */
struct CORE_MAC_ADDRESS23_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS23_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS23_LOW. */
typedef struct CORE_MAC_ADDRESS23_LOW_s CORE_MAC_ADDRESS23_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS23_LOW register. */
#define CORE_MAC_ADDRESS23_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS23_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS23_LOW_OFST  0x3bc

/*
 * Register : MAC_Address24_High
 *
 * The MAC Address24 High register holds the upper 16 bits of the 24th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address24 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address24
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address24_Low register are written, so MAC Address24 High register must be
 * written prior to MAC Address24 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address24 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS24_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS24_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS24_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS24_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS24_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address24 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 24th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS24_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS24_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS24_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS24_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS24_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS24_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS24_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address24 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS24_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS24_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS24_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS24_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS24_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS24_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS24_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address24 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS24_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS24_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS24_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS24_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS24_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS24_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS24_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address24[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address24[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_HIGH_SA register field. */
#define CORE_MAC_ADDRESS24_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_HIGH_SA register field. */
#define CORE_MAC_ADDRESS24_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS24_HIGH_SA register field. */
#define CORE_MAC_ADDRESS24_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS24_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS24_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS24_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS24_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS24_HIGH_SA register field. */
#define CORE_MAC_ADDRESS24_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS24_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS24_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS24_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS24_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 24th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_HIGH_AE register field. */
#define CORE_MAC_ADDRESS24_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_HIGH_AE register field. */
#define CORE_MAC_ADDRESS24_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS24_HIGH_AE register field. */
#define CORE_MAC_ADDRESS24_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS24_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS24_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS24_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS24_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS24_HIGH_AE register field. */
#define CORE_MAC_ADDRESS24_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS24_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS24_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS24_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS24_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS24_HIGH.
 */
struct CORE_MAC_ADDRESS24_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS24_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS24_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS24_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS24_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS24_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS24_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS24_HIGH. */
typedef struct CORE_MAC_ADDRESS24_HIGH_s CORE_MAC_ADDRESS24_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS24_HIGH register. */
#define CORE_MAC_ADDRESS24_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS24_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS24_HIGH_OFST  0x3c0

/*
 * Register : MAC_Address24_Low
 *
 * The MAC Address24 Low register holds the lower 32 bits of the 24th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS24_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address24 [31:0].
 *
 * This field contains the lower 32 bits of 24th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS24_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS24_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS24_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS24_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS24_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS24_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS24_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS24_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS24_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS24_LOW.
 */
struct CORE_MAC_ADDRESS24_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS24_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS24_LOW. */
typedef struct CORE_MAC_ADDRESS24_LOW_s CORE_MAC_ADDRESS24_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS24_LOW register. */
#define CORE_MAC_ADDRESS24_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS24_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS24_LOW_OFST  0x3c4

/*
 * Register : MAC_Address25_High
 *
 * The MAC Address25 High register holds the upper 16 bits of the 25th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address25 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address25
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address25_Low register are written, so MAC Address25 High register must be
 * written prior to MAC Address25 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address25 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS25_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS25_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS25_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS25_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS25_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address25 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 25th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS25_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS25_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS25_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS25_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS25_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS25_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS25_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address25 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS25_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS25_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS25_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS25_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS25_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS25_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS25_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address25 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS25_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS25_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS25_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS25_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS25_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS25_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS25_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address25[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address25[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_HIGH_SA register field. */
#define CORE_MAC_ADDRESS25_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_HIGH_SA register field. */
#define CORE_MAC_ADDRESS25_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS25_HIGH_SA register field. */
#define CORE_MAC_ADDRESS25_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS25_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS25_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS25_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS25_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS25_HIGH_SA register field. */
#define CORE_MAC_ADDRESS25_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS25_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS25_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS25_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS25_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 25th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_HIGH_AE register field. */
#define CORE_MAC_ADDRESS25_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_HIGH_AE register field. */
#define CORE_MAC_ADDRESS25_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS25_HIGH_AE register field. */
#define CORE_MAC_ADDRESS25_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS25_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS25_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS25_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS25_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS25_HIGH_AE register field. */
#define CORE_MAC_ADDRESS25_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS25_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS25_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS25_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS25_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS25_HIGH.
 */
struct CORE_MAC_ADDRESS25_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS25_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS25_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS25_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS25_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS25_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS25_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS25_HIGH. */
typedef struct CORE_MAC_ADDRESS25_HIGH_s CORE_MAC_ADDRESS25_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS25_HIGH register. */
#define CORE_MAC_ADDRESS25_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS25_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS25_HIGH_OFST  0x3c8

/*
 * Register : MAC_Address25_Low
 *
 * The MAC Address25 Low register holds the lower 32 bits of the 25th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS25_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address25 [31:0].
 *
 * This field contains the lower 32 bits of 25th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS25_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS25_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS25_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS25_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS25_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS25_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS25_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS25_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS25_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS25_LOW.
 */
struct CORE_MAC_ADDRESS25_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS25_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS25_LOW. */
typedef struct CORE_MAC_ADDRESS25_LOW_s CORE_MAC_ADDRESS25_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS25_LOW register. */
#define CORE_MAC_ADDRESS25_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS25_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS25_LOW_OFST  0x3cc

/*
 * Register : MAC_Address26_High
 *
 * The MAC Address26 High register holds the upper 16 bits of the 26th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address26 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address26
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address26_Low register are written, so MAC Address26 High register must be
 * written prior to MAC Address26 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address26 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS26_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS26_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS26_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS26_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS26_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address26 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 26th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS26_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS26_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS26_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS26_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS26_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS26_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS26_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address26 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS26_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS26_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS26_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS26_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS26_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS26_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS26_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address26 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS26_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS26_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS26_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS26_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS26_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS26_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS26_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address26[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address26[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_HIGH_SA register field. */
#define CORE_MAC_ADDRESS26_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_HIGH_SA register field. */
#define CORE_MAC_ADDRESS26_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS26_HIGH_SA register field. */
#define CORE_MAC_ADDRESS26_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS26_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS26_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS26_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS26_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS26_HIGH_SA register field. */
#define CORE_MAC_ADDRESS26_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS26_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS26_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS26_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS26_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 26th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_HIGH_AE register field. */
#define CORE_MAC_ADDRESS26_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_HIGH_AE register field. */
#define CORE_MAC_ADDRESS26_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS26_HIGH_AE register field. */
#define CORE_MAC_ADDRESS26_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS26_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS26_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS26_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS26_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS26_HIGH_AE register field. */
#define CORE_MAC_ADDRESS26_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS26_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS26_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS26_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS26_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS26_HIGH.
 */
struct CORE_MAC_ADDRESS26_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS26_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS26_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS26_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS26_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS26_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS26_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS26_HIGH. */
typedef struct CORE_MAC_ADDRESS26_HIGH_s CORE_MAC_ADDRESS26_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS26_HIGH register. */
#define CORE_MAC_ADDRESS26_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS26_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS26_HIGH_OFST  0x3d0

/*
 * Register : MAC_Address26_Low
 *
 * The MAC Address26 Low register holds the lower 32 bits of the 26th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS26_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address26 [31:0].
 *
 * This field contains the lower 32 bits of 26th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS26_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS26_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS26_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS26_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS26_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS26_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS26_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS26_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS26_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS26_LOW.
 */
struct CORE_MAC_ADDRESS26_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS26_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS26_LOW. */
typedef struct CORE_MAC_ADDRESS26_LOW_s CORE_MAC_ADDRESS26_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS26_LOW register. */
#define CORE_MAC_ADDRESS26_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS26_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS26_LOW_OFST  0x3d4

/*
 * Register : MAC_Address27_High
 *
 * The MAC Address27 High register holds the upper 16 bits of the 27th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address27 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address27
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address27_Low register are written, so MAC Address27 High register must be
 * written prior to MAC Address27 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address27 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS27_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS27_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS27_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS27_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS27_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address27 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 27th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS27_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS27_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS27_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS27_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS27_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS27_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS27_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address27 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS27_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS27_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS27_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS27_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS27_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS27_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS27_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address27 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS27_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS27_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS27_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS27_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS27_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS27_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS27_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address27[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address27[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_HIGH_SA register field. */
#define CORE_MAC_ADDRESS27_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_HIGH_SA register field. */
#define CORE_MAC_ADDRESS27_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS27_HIGH_SA register field. */
#define CORE_MAC_ADDRESS27_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS27_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS27_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS27_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS27_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS27_HIGH_SA register field. */
#define CORE_MAC_ADDRESS27_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS27_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS27_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS27_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS27_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 27th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_HIGH_AE register field. */
#define CORE_MAC_ADDRESS27_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_HIGH_AE register field. */
#define CORE_MAC_ADDRESS27_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS27_HIGH_AE register field. */
#define CORE_MAC_ADDRESS27_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS27_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS27_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS27_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS27_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS27_HIGH_AE register field. */
#define CORE_MAC_ADDRESS27_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS27_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS27_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS27_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS27_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS27_HIGH.
 */
struct CORE_MAC_ADDRESS27_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS27_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS27_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS27_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS27_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS27_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS27_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS27_HIGH. */
typedef struct CORE_MAC_ADDRESS27_HIGH_s CORE_MAC_ADDRESS27_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS27_HIGH register. */
#define CORE_MAC_ADDRESS27_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS27_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS27_HIGH_OFST  0x3d8

/*
 * Register : MAC_Address27_Low
 *
 * The MAC Address27 Low register holds the lower 32 bits of the 27th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS27_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address27 [31:0].
 *
 * This field contains the lower 32 bits of 27th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS27_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS27_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS27_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS27_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS27_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS27_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS27_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS27_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS27_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS27_LOW.
 */
struct CORE_MAC_ADDRESS27_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS27_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS27_LOW. */
typedef struct CORE_MAC_ADDRESS27_LOW_s CORE_MAC_ADDRESS27_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS27_LOW register. */
#define CORE_MAC_ADDRESS27_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS27_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS27_LOW_OFST  0x3dc

/*
 * Register : MAC_Address28_High
 *
 * The MAC Address28 High register holds the upper 16 bits of the 28th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address28 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address28
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address28_Low register are written, so MAC Address28 High register must be
 * written prior to MAC Address28 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address28 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS28_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS28_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS28_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS28_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS28_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address28 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 28th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS28_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS28_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS28_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS28_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS28_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS28_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS28_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address28 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS28_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS28_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS28_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS28_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS28_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS28_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS28_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address28 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS28_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS28_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS28_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS28_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS28_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS28_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS28_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address28[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address28[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_HIGH_SA register field. */
#define CORE_MAC_ADDRESS28_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_HIGH_SA register field. */
#define CORE_MAC_ADDRESS28_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS28_HIGH_SA register field. */
#define CORE_MAC_ADDRESS28_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS28_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS28_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS28_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS28_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS28_HIGH_SA register field. */
#define CORE_MAC_ADDRESS28_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS28_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS28_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS28_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS28_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 28th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_HIGH_AE register field. */
#define CORE_MAC_ADDRESS28_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_HIGH_AE register field. */
#define CORE_MAC_ADDRESS28_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS28_HIGH_AE register field. */
#define CORE_MAC_ADDRESS28_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS28_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS28_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS28_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS28_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS28_HIGH_AE register field. */
#define CORE_MAC_ADDRESS28_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS28_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS28_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS28_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS28_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS28_HIGH.
 */
struct CORE_MAC_ADDRESS28_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS28_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS28_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS28_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS28_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS28_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS28_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS28_HIGH. */
typedef struct CORE_MAC_ADDRESS28_HIGH_s CORE_MAC_ADDRESS28_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS28_HIGH register. */
#define CORE_MAC_ADDRESS28_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS28_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS28_HIGH_OFST  0x3e0

/*
 * Register : MAC_Address28_Low
 *
 * The MAC Address28 Low register holds the lower 32 bits of the 28th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS28_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address28 [31:0].
 *
 * This field contains the lower 32 bits of 28th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS28_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS28_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS28_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS28_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS28_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS28_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS28_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS28_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS28_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS28_LOW.
 */
struct CORE_MAC_ADDRESS28_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS28_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS28_LOW. */
typedef struct CORE_MAC_ADDRESS28_LOW_s CORE_MAC_ADDRESS28_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS28_LOW register. */
#define CORE_MAC_ADDRESS28_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS28_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS28_LOW_OFST  0x3e4

/*
 * Register : MAC_Address29_High
 *
 * The MAC Address29 High register holds the upper 16 bits of the 29th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address29 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address29
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address29_Low register are written, so MAC Address29 High register must be
 * written prior to MAC Address29 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address29 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS29_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS29_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS29_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS29_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS29_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address29 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 29th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS29_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS29_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS29_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS29_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS29_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS29_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS29_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address29 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS29_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS29_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS29_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS29_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS29_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS29_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS29_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address29 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS29_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS29_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS29_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS29_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS29_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS29_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS29_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address29[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address29[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_HIGH_SA register field. */
#define CORE_MAC_ADDRESS29_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_HIGH_SA register field. */
#define CORE_MAC_ADDRESS29_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS29_HIGH_SA register field. */
#define CORE_MAC_ADDRESS29_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS29_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS29_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS29_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS29_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS29_HIGH_SA register field. */
#define CORE_MAC_ADDRESS29_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS29_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS29_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS29_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS29_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 29th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_HIGH_AE register field. */
#define CORE_MAC_ADDRESS29_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_HIGH_AE register field. */
#define CORE_MAC_ADDRESS29_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS29_HIGH_AE register field. */
#define CORE_MAC_ADDRESS29_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS29_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS29_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS29_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS29_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS29_HIGH_AE register field. */
#define CORE_MAC_ADDRESS29_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS29_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS29_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS29_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS29_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS29_HIGH.
 */
struct CORE_MAC_ADDRESS29_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS29_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS29_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS29_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS29_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS29_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS29_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS29_HIGH. */
typedef struct CORE_MAC_ADDRESS29_HIGH_s CORE_MAC_ADDRESS29_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS29_HIGH register. */
#define CORE_MAC_ADDRESS29_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS29_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS29_HIGH_OFST  0x3e8

/*
 * Register : MAC_Address29_Low
 *
 * The MAC Address29 Low register holds the lower 32 bits of the 29th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS29_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address29 [31:0].
 *
 * This field contains the lower 32 bits of 29th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS29_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS29_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS29_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS29_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS29_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS29_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS29_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS29_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS29_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS29_LOW.
 */
struct CORE_MAC_ADDRESS29_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS29_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS29_LOW. */
typedef struct CORE_MAC_ADDRESS29_LOW_s CORE_MAC_ADDRESS29_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS29_LOW register. */
#define CORE_MAC_ADDRESS29_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS29_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS29_LOW_OFST  0x3ec

/*
 * Register : MAC_Address30_High
 *
 * The MAC Address30 High register holds the upper 16 bits of the 30th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address30 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address30
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address30_Low register are written, so MAC Address30 High register must be
 * written prior to MAC Address30 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address30 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS30_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS30_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS30_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS30_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS30_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address30 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 30th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS30_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS30_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS30_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS30_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS30_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS30_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS30_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address30 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS30_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS30_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS30_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS30_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS30_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS30_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS30_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address30 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS30_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS30_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS30_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS30_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS30_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS30_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS30_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address30[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address30[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_HIGH_SA register field. */
#define CORE_MAC_ADDRESS30_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_HIGH_SA register field. */
#define CORE_MAC_ADDRESS30_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS30_HIGH_SA register field. */
#define CORE_MAC_ADDRESS30_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS30_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS30_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS30_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS30_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS30_HIGH_SA register field. */
#define CORE_MAC_ADDRESS30_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS30_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS30_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS30_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS30_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 30th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_HIGH_AE register field. */
#define CORE_MAC_ADDRESS30_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_HIGH_AE register field. */
#define CORE_MAC_ADDRESS30_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS30_HIGH_AE register field. */
#define CORE_MAC_ADDRESS30_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS30_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS30_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS30_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS30_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS30_HIGH_AE register field. */
#define CORE_MAC_ADDRESS30_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS30_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS30_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS30_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS30_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS30_HIGH.
 */
struct CORE_MAC_ADDRESS30_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS30_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS30_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS30_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS30_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS30_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS30_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS30_HIGH. */
typedef struct CORE_MAC_ADDRESS30_HIGH_s CORE_MAC_ADDRESS30_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS30_HIGH register. */
#define CORE_MAC_ADDRESS30_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS30_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS30_HIGH_OFST  0x3f0

/*
 * Register : MAC_Address30_Low
 *
 * The MAC Address30 Low register holds the lower 32 bits of the 30th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS30_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address30 [31:0].
 *
 * This field contains the lower 32 bits of 30th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS30_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS30_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS30_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS30_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS30_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS30_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS30_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS30_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS30_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS30_LOW.
 */
struct CORE_MAC_ADDRESS30_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS30_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS30_LOW. */
typedef struct CORE_MAC_ADDRESS30_LOW_s CORE_MAC_ADDRESS30_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS30_LOW register. */
#define CORE_MAC_ADDRESS30_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS30_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS30_LOW_OFST  0x3f4

/*
 * Register : MAC_Address31_High
 *
 * The MAC Address31 High register holds the upper 16 bits of the 31th 6-byte MAC
 * address of the station. The first DA byte that is received on the (X)GMII
 * interface corresponds to the LS byte (Bits [7:0]) of the MAC Address31 Low
 * register. For example, if 0x112233445566 is received (0x11 in lane 0 of the
 * first column) on the (X)GMII as the destination address, then the MAC_Address31
 * register [47:0] is compared with 0x665544332211.
 *
 * If the MAC address registers are configured to be double-synchronized to the
 * (X)GMII clock domain, then the synchronization is triggered only when
 * Bits[31:24] (in little-endian mode) or Bits[7:0] (in big-endian mode) of the
 * MAC_Address31_Low register are written, so MAC Address31 High register must be
 * written prior to MAC Address31 Low register. For proper synchronization updates,
 * the consecutive writes to MAC Address31 Low register should be performed after
 * at least four clock cycles of the slowest clock between the source and the
 * destination clock domains.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset  | Description
 * :--------|:-------|:-------|:--------------------------------------------------------
 *  [15:0]  | RW     | 0xffff | CORE_MAC_ADDRESS31_HIGH_ADDRHI
 *  [18:16] | RW     | 0x0    | CORE_MAC_ADDRESS31_HIGH_DCS
 *  [23:19] | R      | 0x0    | CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y
 *  [29:24] | RW     | 0x0    | CORE_MAC_ADDRESS31_HIGH_MBC
 *  [30]    | RW     | 0x0    | CORE_MAC_ADDRESS31_HIGH_SA
 *  [31]    | RW     | 0x0    | CORE_MAC_ADDRESS31_HIGH_AE
 *
 */
/*
 * Field : ADDRHI
 *
 * MAC Address31 [47:32].
 *
 * This field contains the upper 16 bits[47:32] of the 31th 6-byte MAC address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_MSB	  15
/* The width in bits of the CORE_MAC_ADDRESS31_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_WIDTH	  16
/* The mask used to set the CORE_MAC_ADDRESS31_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_ADDRESS31_HIGH_ADDRHI register field value. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_ADDRESS31_HIGH_ADDRHI register field. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_RESET	  0xffff
/* Extracts the CORE_MAC_ADDRESS31_HIGH_ADDRHI field value from a register. */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_ADDRESS31_HIGH_ADDRHI register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS31_HIGH_ADDRHI_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : DCS
 *
 * DMA Channel Select.
 *
 * If the DDS bit of MAC_Extended_Configuration register is not set:
 *
 * This field contains the binary representation of the DMA Channel number to which
 * an Rx packet whose DA matches the MAC Address0 content is routed.
 *
 * If the DDS bit of MAC_Extended_Configuration register is set:
 *
 * The XDCS field of MAC_DChSel_IndReg register contains the one-hot representation
 * of one or more DMA Channel numbers to which an Rx packet whose DA matches the
 * MAC Address31 content is routed.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_MSB	       18
/* The width in bits of the CORE_MAC_ADDRESS31_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_WIDTH      3
/* The mask used to set the CORE_MAC_ADDRESS31_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_SET_MSK    0x00070000
/* The mask used to clear the CORE_MAC_ADDRESS31_HIGH_DCS register field value. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MAC_ADDRESS31_HIGH_DCS register field. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS31_HIGH_DCS field value from a register. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_ADDRESS31_HIGH_DCS register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS31_HIGH_DCS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_23_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register
 * field. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_MSB	 23
/* The width in bits of the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_WIDTH	 5
/* The mask used to set the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_SET_MSK	 0x00f80000
/* The mask used to clear the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register field value. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_CLR_MSK	 0xff07ffff
/* The reset value of the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register field. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_RESET	 0x0
/* Extracts the CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y field value from a register. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_GET(value) (((value)&0x00f80000) >> 19)
/* Produces a CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y register field value suitable for setting the
 * register. */
#define CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y_SET(value) (((value) << 19) & 0x00f80000)

/*
 * Field : MBC
 *
 * Mask Byte Control.
 *
 * These bits are mask control bits for comparing each of the MAC Address bytes.
 * When set high, the MAC does not compare the corresponding byte of received DA or
 * SA with the contents of MAC Address31 registers. Each bit controls the masking
 * of the bytes as follows:
 *
 * * Bit 29: MAD Address High [15:8]
 *
 * * Bit 28: MAD Address High [7:0]
 *
 * * Bit 27: MAD Address Low[31:24]
 *
 * * ...
 *
 * * Bit 24: MAD Address Low[7:0]
 *
 * You can filter a group of addresses (known as group address filtering) by
 * masking one or more bytes of the address.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_MSB	       29
/* The width in bits of the CORE_MAC_ADDRESS31_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_WIDTH      6
/* The mask used to set the CORE_MAC_ADDRESS31_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_SET_MSK    0x3f000000
/* The mask used to clear the CORE_MAC_ADDRESS31_HIGH_MBC register field value. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_CLR_MSK    0xc0ffffff
/* The reset value of the CORE_MAC_ADDRESS31_HIGH_MBC register field. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS31_HIGH_MBC field value from a register. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_GET(value) (((value)&0x3f000000) >> 24)
/* Produces a CORE_MAC_ADDRESS31_HIGH_MBC register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS31_HIGH_MBC_SET(value) (((value) << 24) & 0x3f000000)

/*
 * Field : SA
 *
 * Source Address.
 *
 * When this bit is set, the MAC Address31[47:0] is used to compare with the SA
 * fields of the received packet. When this bit is reset, the MAC Address31[47:0]
 * is used to compare with the DA fields of the received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_HIGH_SA register field. */
#define CORE_MAC_ADDRESS31_HIGH_SA_LSB	      30
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_HIGH_SA register field. */
#define CORE_MAC_ADDRESS31_HIGH_SA_MSB	      30
/* The width in bits of the CORE_MAC_ADDRESS31_HIGH_SA register field. */
#define CORE_MAC_ADDRESS31_HIGH_SA_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS31_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS31_HIGH_SA_SET_MSK    0x40000000
/* The mask used to clear the CORE_MAC_ADDRESS31_HIGH_SA register field value. */
#define CORE_MAC_ADDRESS31_HIGH_SA_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MAC_ADDRESS31_HIGH_SA register field. */
#define CORE_MAC_ADDRESS31_HIGH_SA_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS31_HIGH_SA field value from a register. */
#define CORE_MAC_ADDRESS31_HIGH_SA_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_ADDRESS31_HIGH_SA register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS31_HIGH_SA_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : AE
 *
 * Address Enable.
 *
 * When this bit is set, the address filter module uses the 31th MAC address for
 * perfect filtering. When this bit is reset, the address filter module ignores the
 * address for filtering.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_HIGH_AE register field. */
#define CORE_MAC_ADDRESS31_HIGH_AE_LSB	      31
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_HIGH_AE register field. */
#define CORE_MAC_ADDRESS31_HIGH_AE_MSB	      31
/* The width in bits of the CORE_MAC_ADDRESS31_HIGH_AE register field. */
#define CORE_MAC_ADDRESS31_HIGH_AE_WIDTH      1
/* The mask used to set the CORE_MAC_ADDRESS31_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS31_HIGH_AE_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_ADDRESS31_HIGH_AE register field value. */
#define CORE_MAC_ADDRESS31_HIGH_AE_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_ADDRESS31_HIGH_AE register field. */
#define CORE_MAC_ADDRESS31_HIGH_AE_RESET      0x0
/* Extracts the CORE_MAC_ADDRESS31_HIGH_AE field value from a register. */
#define CORE_MAC_ADDRESS31_HIGH_AE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_ADDRESS31_HIGH_AE register field value suitable for setting the register. */
#define CORE_MAC_ADDRESS31_HIGH_AE_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS31_HIGH.
 */
struct CORE_MAC_ADDRESS31_HIGH_s {
	volatile uint32_t ADDRHI : 16;		   /* CORE_MAC_ADDRESS31_HIGH_ADDRHI */
	volatile uint32_t DCS : 3;		   /* CORE_MAC_ADDRESS31_HIGH_DCS */
	const volatile uint32_t Reserved_23_y : 5; /* CORE_MAC_ADDRESS31_HIGH_RESERVED_23_Y */
	volatile uint32_t MBC : 6;		   /* CORE_MAC_ADDRESS31_HIGH_MBC */
	volatile uint32_t SA : 1;		   /* CORE_MAC_ADDRESS31_HIGH_SA */
	volatile uint32_t AE : 1;		   /* CORE_MAC_ADDRESS31_HIGH_AE */
};

/* The typedef declaration for register CORE_MAC_ADDRESS31_HIGH. */
typedef struct CORE_MAC_ADDRESS31_HIGH_s CORE_MAC_ADDRESS31_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS31_HIGH register. */
#define CORE_MAC_ADDRESS31_HIGH_RESET 0x0000ffff
/* The byte offset of the CORE_MAC_ADDRESS31_HIGH register from the beginning of the component. */
#define CORE_MAC_ADDRESS31_HIGH_OFST  0x3f8

/*
 * Register : MAC_Address31_Low
 *
 * The MAC Address31 Low register holds the lower 32 bits of the 31th 6-byte MAC
 * address of the station.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:------------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ADDRESS31_LOW_ADDRLO
 *
 */
/*
 * Field : ADDRLO
 *
 * MAC Address31 [31:0].
 *
 * This field contains the lower 32 bits of 31th 6-byte MAC address. The MAC uses
 * this field for filtering the received packets and inserting
 *
 * the MAC address in the Transmit Flow Control (Pause) Packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ADDRESS31_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ADDRESS31_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_MSB	 31
/* The width in bits of the CORE_MAC_ADDRESS31_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_WIDTH	 32
/* The mask used to set the CORE_MAC_ADDRESS31_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_ADDRESS31_LOW_ADDRLO register field value. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_ADDRESS31_LOW_ADDRLO register field. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_RESET	 0xffffffff
/* Extracts the CORE_MAC_ADDRESS31_LOW_ADDRLO field value from a register. */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ADDRESS31_LOW_ADDRLO register field value suitable for setting the register.
 */
#define CORE_MAC_ADDRESS31_LOW_ADDRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ADDRESS31_LOW.
 */
struct CORE_MAC_ADDRESS31_LOW_s {
	volatile uint32_t ADDRLO : 32; /* CORE_MAC_ADDRESS31_LOW_ADDRLO */
};

/* The typedef declaration for register CORE_MAC_ADDRESS31_LOW. */
typedef struct CORE_MAC_ADDRESS31_LOW_s CORE_MAC_ADDRESS31_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ADDRESS31_LOW register. */
#define CORE_MAC_ADDRESS31_LOW_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ADDRESS31_LOW register from the beginning of the component. */
#define CORE_MAC_ADDRESS31_LOW_OFST  0x3fc

/*
 * Register : MAC_Indir_Access_Ctrl
 *
 * This register provides the Indirect Access control and status for
 * MAC_<MSEL>_IndReg(#AOFF) registers.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_OB
 *  [1]     | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_COM
 *  [4:2]   | R      | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2
 *  [5]     | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_AUTO
 *  [7:6]   | R      | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6
 *  [15:8]  | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_AOFF
 *  [23:16] | R      | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X
 *  [25:24] | R      | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24
 *  [29:26] | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_MSEL
 *  [30]    | R      | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30
 *  [31]    | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R
 *
 */
/*
 * Field : OB
 *
 * Operation Busy
 *
 * This bit is set along with a read or write command for initiating the indirect
 * access to MAC_<MSEL>_IndReg(#AOFF) registers.
 *
 * This bit is reset when the read or write command to MAC_<MSEL>_IndReg(#AOFF)
 * register is complete. The next indirect register access can be initiated only
 * after this bit is reset.
 *
 * During a write operation, the bit is reset only after the data has been written
 * into MAC_<MSEL>_IndReg(#AOFF) register. During a read operation, the data should
 * be read from MAC_Indir_Access_Data register only after this bit is reset.
 *
 * To initiate an indirect access, this bit should be set at last.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_OB register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_OB register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_MSB	 0
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_OB register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_WIDTH	 1
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_OB register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_SET_MSK	 0x00000001
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_OB register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_CLR_MSK	 0xfffffffe
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_OB register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_RESET	 0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_OB field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_OB register field value suitable for setting the register.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_OB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : COM
 *
 * Command type
 *
 * This bit indicates if the current register access is a read or a write. When
 * set, it indicates a read operation. When reset, it indicates a write operation.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:----------------
 *  CORE_MAC_INDIR_ACCESS_CTRL_COM_E_WRITE | 0x0   | Write operation
 *  CORE_MAC_INDIR_ACCESS_CTRL_COM_E_READ  | 0x1   | Read operation
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MAC_INDIR_ACCESS_CTRL_COM
 *
 * Write operation
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_E_WRITE 0x0
/*
 * Enumerated value for register field CORE_MAC_INDIR_ACCESS_CTRL_COM
 *
 * Read operation
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_E_READ  0x1

/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_COM register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_COM register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_MSB	  1
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_COM register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_WIDTH	  1
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_COM register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_COM register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_COM register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_RESET	  0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_COM field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_COM register field value suitable for setting the register.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_COM_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_4_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_LSB	   2
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_MSB	   4
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_WIDTH	   3
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_SET_MSK	   0x0000001c
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_CLR_MSK	   0xffffffe3
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_RESET	   0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_GET(value) (((value)&0x0000001c) >> 2)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2_SET(value) (((value) << 2) & 0x0000001c)

/*
 * Field : AUTO
 *
 * Auto increment
 *
 * * When Auto increment is set, AOFF is incremented by 1 and care should be taken
 *   by software not to cause a wrap condition.
 *
 * * Byte wise read/write is not supported when auto increment is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_LSB	   5
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_MSB	   5
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_WIDTH	   1
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_SET_MSK	   0x00000020
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_CLR_MSK	   0xffffffdf
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_RESET	   0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_AUTO field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_AUTO register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AUTO_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_MSB	   7
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_WIDTH	   2
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_SET_MSK	   0x000000c0
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_CLR_MSK	   0xffffff3f
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_RESET	   0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : AOFF
 *
 * Address Offset
 *
 * This field is used in indirect access of MAC_<MSEL>_IndReg(#AOFF) registers.
 * This field must be set along with initiation of read/write to
 * MAC_<MSEL>_IndReg(#AOFF) registers and should not be changed until the OB is
 * reset.
 *
 * Note: Supported maximum value of AOFF are specific to MSEL. Based on maximum
 * value remaining bits are not implemented and are reserved.
 *
 * AOFF Values:
 *
 * * 0x0    : IndReg0 (Indirect register 0)
 *
 * * ...
 *
 * * 0xFFFF : IndReg65535
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_LSB	   8
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_MSB	   15
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_WIDTH	   8
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_SET_MSK	   0x0000ff00
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_CLR_MSK	   0xffff00ff
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_RESET	   0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_AOFF field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_AOFF register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_AOFF_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_23_x
 *
 * Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_MSB	    23
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_WIDTH	    8
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_SET_MSK    0x00ff0000
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_CLR_MSK    0xff00ffff
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_RESET	    0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : Reserved_25_24
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24
 * register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_LSB	     24
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_MSB	     25
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_WIDTH	     2
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_SET_MSK    0x03000000
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_CLR_MSK    0xfcffffff
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_RESET	     0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_GET(value) (((value)&0x03000000) >> 24)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 register field value suitable for setting
 * the register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24_SET(value) (((value) << 24) & 0x03000000)

/*
 * Field : MSEL
 *
 * Mode Select
 *
 * This field is used in indirect access of MAC_<MSEL>_IndReg(#AOFF) registers.
 * This field must be set along with initiation of read/write to
 * MAC_<MSEL>_IndReg(#AOFF) registers and should not be changed until the OB is
 * reset.
 *
 * Values:
 *
 * * 0x0: DChSel (DMA_Channel_Select)
 *
 * * 0x1: PCCtrl (Policing_Counter_Control)
 *
 * * 0x2: PCntr (Policing_Counter)
 *
 * * 0x3: DPCSel (DA_Policing_Pounter_Select)
 *
 * * 0x4: VPCSel (VLAN_Policing_Counter_Select)
 *
 * * 0x5: LPCSel (L3L4_Policing_Counter_Select)
 *
 * * 0x6: FPCSel (Additional_Event_Policing_Counter_Select)
 *
 * * 0x7: PCStatus (Policing_Counter_Status for DA, VLAN, L3L4 and
 *   Additional_Event)
 *
 * * 0x8: EXT_DAH (External DA Hashtable)
 *
 * * 0x9: EXT_ROVTL (External Rx Outer VLAN Lookup)
 *
 * * 0xA: EXT_RIVTL (External Rx Inner VLAN Lookup)
 *
 * * 0xB - 0xF: Reserved for future use.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_LSB	   26
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_MSB	   29
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_WIDTH	   4
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_SET_MSK	   0x3c000000
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_CLR_MSK	   0xc3ffffff
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_RESET	   0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_MSEL field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_GET(value) (((value)&0x3c000000) >> 26)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_MSEL register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_MSEL_SET(value) (((value) << 26) & 0x3c000000)

/*
 * Field : Reserved_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_LSB	  30
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register
 * field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_MSB	  30
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_WIDTH	  1
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_SET_MSK	  0x40000000
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_CLR_MSK	  0xbfffffff
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_RESET	  0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : SNPS_R
 *
 * Synopsys Reserved
 *
 * This bit must be set to 0. This field is reserved for Synopsys Internal use, and
 * must always be set to 0 unless instructed by Synopsys.
 *
 * Setting any bit to 1 might cause unexpected behavior in the IP.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_MSB	     31
/* The width in bits of the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_WIDTH	     1
/* The mask used to set the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field value. */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field. */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_RESET	     0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R field value from a register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_INDIR_ACCESS_CTRL.
 */
struct CORE_MAC_INDIR_ACCESS_CTRL_s {
	volatile uint32_t OB : 1;		    /* CORE_MAC_INDIR_ACCESS_CTRL_OB */
	volatile uint32_t COM : 1;		    /* CORE_MAC_INDIR_ACCESS_CTRL_COM */
	const volatile uint32_t Reserved_4_2 : 3;   /* CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_4_2 */
	volatile uint32_t AUTO : 1;		    /* CORE_MAC_INDIR_ACCESS_CTRL_AUTO */
	const volatile uint32_t Reserved_7_6 : 2;   /* CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_7_6 */
	volatile uint32_t AOFF : 8;		    /* CORE_MAC_INDIR_ACCESS_CTRL_AOFF */
	const volatile uint32_t Reserved_23_x : 8;  /* CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_23_X */
	const volatile uint32_t Reserved_25_24 : 2; /* CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_25_24 */
	volatile uint32_t MSEL : 4;		    /* CORE_MAC_INDIR_ACCESS_CTRL_MSEL */
	const volatile uint32_t Reserved_30 : 1;    /* CORE_MAC_INDIR_ACCESS_CTRL_RESERVED_30 */
	volatile uint32_t SNPS_R : 1;		    /* CORE_MAC_INDIR_ACCESS_CTRL_SNPS_R */
};

/* The typedef declaration for register CORE_MAC_INDIR_ACCESS_CTRL. */
typedef struct CORE_MAC_INDIR_ACCESS_CTRL_s CORE_MAC_INDIR_ACCESS_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_INDIR_ACCESS_CTRL register. */
#define CORE_MAC_INDIR_ACCESS_CTRL_RESET 0x00000000
/* The byte offset of the CORE_MAC_INDIR_ACCESS_CTRL register from the beginning of the component.
 */
#define CORE_MAC_INDIR_ACCESS_CTRL_OFST	 0x700

/*
 * Register : MAC_Indir_Access_Data
 *
 * This register holds the read/write data for Indirect Access of
 * MAC_<MSEL_IndReg(#AOFF) registers.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_INDIR_ACCESS_DATA_DATA
 *
 */
/*
 * Field : DATA
 *
 * This field contains data to read/write for Indirect address access associated
 * with MAC_Indir_Access_Ctrl register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_INDIR_ACCESS_DATA_DATA register field.
 */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_INDIR_ACCESS_DATA_DATA register field. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_MSB	   31
/* The width in bits of the CORE_MAC_INDIR_ACCESS_DATA_DATA register field. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_WIDTH	   32
/* The mask used to set the CORE_MAC_INDIR_ACCESS_DATA_DATA register field value. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_MAC_INDIR_ACCESS_DATA_DATA register field value. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_CLR_MSK	   0x00000000
/* The reset value of the CORE_MAC_INDIR_ACCESS_DATA_DATA register field. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_RESET	   0x0
/* Extracts the CORE_MAC_INDIR_ACCESS_DATA_DATA field value from a register. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_INDIR_ACCESS_DATA_DATA register field value suitable for setting the
 * register. */
#define CORE_MAC_INDIR_ACCESS_DATA_DATA_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_INDIR_ACCESS_DATA.
 */
struct CORE_MAC_INDIR_ACCESS_DATA_s {
	volatile uint32_t DATA : 32; /* CORE_MAC_INDIR_ACCESS_DATA_DATA */
};

/* The typedef declaration for register CORE_MAC_INDIR_ACCESS_DATA. */
typedef struct CORE_MAC_INDIR_ACCESS_DATA_s CORE_MAC_INDIR_ACCESS_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_INDIR_ACCESS_DATA register. */
#define CORE_MAC_INDIR_ACCESS_DATA_RESET 0x00000000
/* The byte offset of the CORE_MAC_INDIR_ACCESS_DATA register from the beginning of the component.
 */
#define CORE_MAC_INDIR_ACCESS_DATA_OFST	 0x704

/*
 * Register : MMC_Control
 *
 * The MMC Control register establishes the operating mode of the management
 * counters.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MMC_CONTROL_CNTRST
 *  [1]     | RW     | 0x0   | CORE_MMC_CONTROL_CNTSTOPRO
 *  [2]     | RW     | 0x0   | CORE_MMC_CONTROL_RSTONRD
 *  [3]     | RW     | 0x0   | CORE_MMC_CONTROL_MCF
 *  [5:4]   | RW     | 0x2   | CORE_MMC_CONTROL_MCT
 *  [6]     | R      | 0x0   | CORE_MMC_CONTROL_RESERVED_6
 *  [7]     | RW     | 0x0   | CORE_MMC_CONTROL_CNTPRST
 *  [15:8]  | R      | 0x0   | CORE_MMC_CONTROL_RESERVED_15_8
 *  [18:16] | R      | 0x0   | CORE_MMC_CONTROL_RESERVED_PRMMCSEL
 *  [31:19] | R      | 0x0   | CORE_MMC_CONTROL_RESERVED_31_19
 *
 */
/*
 * Field : CNTRST
 *
 * Counters Reset
 *
 * When this bit is set, all counters are reset. This bit is cleared automatically
 * after 1 clock cycle.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_CNTRST register field. */
#define CORE_MMC_CONTROL_CNTRST_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_CNTRST register field. */
#define CORE_MMC_CONTROL_CNTRST_MSB	   0
/* The width in bits of the CORE_MMC_CONTROL_CNTRST register field. */
#define CORE_MMC_CONTROL_CNTRST_WIDTH	   1
/* The mask used to set the CORE_MMC_CONTROL_CNTRST register field value. */
#define CORE_MMC_CONTROL_CNTRST_SET_MSK	   0x00000001
/* The mask used to clear the CORE_MMC_CONTROL_CNTRST register field value. */
#define CORE_MMC_CONTROL_CNTRST_CLR_MSK	   0xfffffffe
/* The reset value of the CORE_MMC_CONTROL_CNTRST register field. */
#define CORE_MMC_CONTROL_CNTRST_RESET	   0x0
/* Extracts the CORE_MMC_CONTROL_CNTRST field value from a register. */
#define CORE_MMC_CONTROL_CNTRST_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_CONTROL_CNTRST register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_CNTRST_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : CNTSTOPRO
 *
 * Counter Stop Rollover
 *
 * When this bit is set, no MMC counter rolls over to zero after reaching the
 * maximum count value.
 *
 * The counters are cleared when the least significant byte lane (bits[7:0]) is
 * read after reaching the maximum count value. When the MMC module is enabled for
 * the 64-bit counter mode, the lower and upper counters are cleared only when the
 * least significant byte lane (bits[7:0]) of the upper counter is read after
 * reaching the maximum count value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_CNTSTOPRO register field. */
#define CORE_MMC_CONTROL_CNTSTOPRO_LSB	      1
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_CNTSTOPRO register field. */
#define CORE_MMC_CONTROL_CNTSTOPRO_MSB	      1
/* The width in bits of the CORE_MMC_CONTROL_CNTSTOPRO register field. */
#define CORE_MMC_CONTROL_CNTSTOPRO_WIDTH      1
/* The mask used to set the CORE_MMC_CONTROL_CNTSTOPRO register field value. */
#define CORE_MMC_CONTROL_CNTSTOPRO_SET_MSK    0x00000002
/* The mask used to clear the CORE_MMC_CONTROL_CNTSTOPRO register field value. */
#define CORE_MMC_CONTROL_CNTSTOPRO_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MMC_CONTROL_CNTSTOPRO register field. */
#define CORE_MMC_CONTROL_CNTSTOPRO_RESET      0x0
/* Extracts the CORE_MMC_CONTROL_CNTSTOPRO field value from a register. */
#define CORE_MMC_CONTROL_CNTSTOPRO_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_CONTROL_CNTSTOPRO register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_CNTSTOPRO_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RSTONRD
 *
 * Reset on Read
 *
 * When this bit is set, the MMC counters are reset to zero after a read. The
 * counters are cleared when the least significant byte lane (bits[7:0]) is read.
 * When the MMC module is enabled for the 64-bit counter mode, the lower and upper
 * counters are cleared only when the least significant byte lane (bits[7:0]) of
 * the corresponding counter is read.
 *
 * Note:  When 64-bit counter mode is selected and RSTONRD is set, read the lower
 * counter first followed by the corresponding upper counter. This is to ensure
 * that only the lower 32-bit counter is updated after the first read operation and
 * the software gets the original higher 32-bit counter and gets a consistent
 * value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_RSTONRD register field. */
#define CORE_MMC_CONTROL_RSTONRD_LSB	    2
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_RSTONRD register field. */
#define CORE_MMC_CONTROL_RSTONRD_MSB	    2
/* The width in bits of the CORE_MMC_CONTROL_RSTONRD register field. */
#define CORE_MMC_CONTROL_RSTONRD_WIDTH	    1
/* The mask used to set the CORE_MMC_CONTROL_RSTONRD register field value. */
#define CORE_MMC_CONTROL_RSTONRD_SET_MSK    0x00000004
/* The mask used to clear the CORE_MMC_CONTROL_RSTONRD register field value. */
#define CORE_MMC_CONTROL_RSTONRD_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MMC_CONTROL_RSTONRD register field. */
#define CORE_MMC_CONTROL_RSTONRD_RESET	    0x0
/* Extracts the CORE_MMC_CONTROL_RSTONRD field value from a register. */
#define CORE_MMC_CONTROL_RSTONRD_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_CONTROL_RSTONRD register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_RSTONRD_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : MCF
 *
 * MMC Counter Freeze
 *
 * When set, this bit freezes the MMC counters to their current value. No MMC
 * counter is updated for subsequent packet transmission or reception until this
 * bit is reset to 0. If any MMC counter is read with the Reset on Read bit set,
 * that counter is also cleared when this bit is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_MCF register field. */
#define CORE_MMC_CONTROL_MCF_LSB	3
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_MCF register field. */
#define CORE_MMC_CONTROL_MCF_MSB	3
/* The width in bits of the CORE_MMC_CONTROL_MCF register field. */
#define CORE_MMC_CONTROL_MCF_WIDTH	1
/* The mask used to set the CORE_MMC_CONTROL_MCF register field value. */
#define CORE_MMC_CONTROL_MCF_SET_MSK	0x00000008
/* The mask used to clear the CORE_MMC_CONTROL_MCF register field value. */
#define CORE_MMC_CONTROL_MCF_CLR_MSK	0xfffffff7
/* The reset value of the CORE_MMC_CONTROL_MCF register field. */
#define CORE_MMC_CONTROL_MCF_RESET	0x0
/* Extracts the CORE_MMC_CONTROL_MCF field value from a register. */
#define CORE_MMC_CONTROL_MCF_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_CONTROL_MCF register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_MCF_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : MCT
 *
 * MMC Counter Threshold
 *
 * Threshold value for the counter which, when crossed, causes the interrupt to be
 * scheduled
 *
 * * 2'b00: Reserved
 *
 * * 2'b01: One-quarter the maximum value - X
 *
 * * 2'b10: One-half of the maximum value - X
 *
 * * 2'b11: Three-quarters of the maximum value - X
 *
 * Here,
 *
 * * X = 16 for all the Packet counters and
 *
 * * X = 2048 for all the Octet/Byte counters
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_MCT register field. */
#define CORE_MMC_CONTROL_MCT_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_MCT register field. */
#define CORE_MMC_CONTROL_MCT_MSB	5
/* The width in bits of the CORE_MMC_CONTROL_MCT register field. */
#define CORE_MMC_CONTROL_MCT_WIDTH	2
/* The mask used to set the CORE_MMC_CONTROL_MCT register field value. */
#define CORE_MMC_CONTROL_MCT_SET_MSK	0x00000030
/* The mask used to clear the CORE_MMC_CONTROL_MCT register field value. */
#define CORE_MMC_CONTROL_MCT_CLR_MSK	0xffffffcf
/* The reset value of the CORE_MMC_CONTROL_MCT register field. */
#define CORE_MMC_CONTROL_MCT_RESET	0x2
/* Extracts the CORE_MMC_CONTROL_MCT field value from a register. */
#define CORE_MMC_CONTROL_MCT_GET(value) (((value)&0x00000030) >> 4)
/* Produces a CORE_MMC_CONTROL_MCT register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_MCT_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : Reserved_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_RESERVED_6 register field. */
#define CORE_MMC_CONTROL_RESERVED_6_LSB	       6
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_RESERVED_6 register field. */
#define CORE_MMC_CONTROL_RESERVED_6_MSB	       6
/* The width in bits of the CORE_MMC_CONTROL_RESERVED_6 register field. */
#define CORE_MMC_CONTROL_RESERVED_6_WIDTH      1
/* The mask used to set the CORE_MMC_CONTROL_RESERVED_6 register field value. */
#define CORE_MMC_CONTROL_RESERVED_6_SET_MSK    0x00000040
/* The mask used to clear the CORE_MMC_CONTROL_RESERVED_6 register field value. */
#define CORE_MMC_CONTROL_RESERVED_6_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MMC_CONTROL_RESERVED_6 register field. */
#define CORE_MMC_CONTROL_RESERVED_6_RESET      0x0
/* Extracts the CORE_MMC_CONTROL_RESERVED_6 field value from a register. */
#define CORE_MMC_CONTROL_RESERVED_6_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_CONTROL_RESERVED_6 register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_RESERVED_6_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : CNTPRST
 *
 * Counters Preset
 *
 * When this bit is set, all counters are initialized or preset to a value
 * depending on Bits [5:4]. This bit is cleared after 1 clock cycle. This bit,
 * along with Bits [5:4], is useful for debugging and testing the assertion of
 * interrupts because of MMC counter becoming one-quarter-full/half-full/three-
 * quarter-full.
 *
 * If this bit is set along with CNTRST bit, CNTRST bit has precedence.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_CNTPRST register field. */
#define CORE_MMC_CONTROL_CNTPRST_LSB	    7
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_CNTPRST register field. */
#define CORE_MMC_CONTROL_CNTPRST_MSB	    7
/* The width in bits of the CORE_MMC_CONTROL_CNTPRST register field. */
#define CORE_MMC_CONTROL_CNTPRST_WIDTH	    1
/* The mask used to set the CORE_MMC_CONTROL_CNTPRST register field value. */
#define CORE_MMC_CONTROL_CNTPRST_SET_MSK    0x00000080
/* The mask used to clear the CORE_MMC_CONTROL_CNTPRST register field value. */
#define CORE_MMC_CONTROL_CNTPRST_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MMC_CONTROL_CNTPRST register field. */
#define CORE_MMC_CONTROL_CNTPRST_RESET	    0x0
/* Extracts the CORE_MMC_CONTROL_CNTPRST field value from a register. */
#define CORE_MMC_CONTROL_CNTPRST_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_CONTROL_CNTPRST register field value suitable for setting the register. */
#define CORE_MMC_CONTROL_CNTPRST_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_RESERVED_15_8 register field. */
#define CORE_MMC_CONTROL_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_RESERVED_15_8 register field. */
#define CORE_MMC_CONTROL_RESERVED_15_8_MSB	  15
/* The width in bits of the CORE_MMC_CONTROL_RESERVED_15_8 register field. */
#define CORE_MMC_CONTROL_RESERVED_15_8_WIDTH	  8
/* The mask used to set the CORE_MMC_CONTROL_RESERVED_15_8 register field value. */
#define CORE_MMC_CONTROL_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the CORE_MMC_CONTROL_RESERVED_15_8 register field value. */
#define CORE_MMC_CONTROL_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the CORE_MMC_CONTROL_RESERVED_15_8 register field. */
#define CORE_MMC_CONTROL_RESERVED_15_8_RESET	  0x0
/* Extracts the CORE_MMC_CONTROL_RESERVED_15_8 field value from a register. */
#define CORE_MMC_CONTROL_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MMC_CONTROL_RESERVED_15_8 register field value suitable for setting the register.
 */
#define CORE_MMC_CONTROL_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_PRMMCSEL
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_RESERVED_PRMMCSEL register
 * field. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_RESERVED_PRMMCSEL register field.
 */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_MSB	      18
/* The width in bits of the CORE_MMC_CONTROL_RESERVED_PRMMCSEL register field. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_WIDTH      3
/* The mask used to set the CORE_MMC_CONTROL_RESERVED_PRMMCSEL register field value. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_SET_MSK    0x00070000
/* The mask used to clear the CORE_MMC_CONTROL_RESERVED_PRMMCSEL register field value. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_CLR_MSK    0xfff8ffff
/* The reset value of the CORE_MMC_CONTROL_RESERVED_PRMMCSEL register field. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_RESET      0x0
/* Extracts the CORE_MMC_CONTROL_RESERVED_PRMMCSEL field value from a register. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MMC_CONTROL_RESERVED_PRMMCSEL register field value suitable for setting the
 * register. */
#define CORE_MMC_CONTROL_RESERVED_PRMMCSEL_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_31_19
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_CONTROL_RESERVED_31_19 register field.
 */
#define CORE_MMC_CONTROL_RESERVED_31_19_LSB	   19
/* The Most Significant Bit (MSB) position of the CORE_MMC_CONTROL_RESERVED_31_19 register field. */
#define CORE_MMC_CONTROL_RESERVED_31_19_MSB	   31
/* The width in bits of the CORE_MMC_CONTROL_RESERVED_31_19 register field. */
#define CORE_MMC_CONTROL_RESERVED_31_19_WIDTH	   13
/* The mask used to set the CORE_MMC_CONTROL_RESERVED_31_19 register field value. */
#define CORE_MMC_CONTROL_RESERVED_31_19_SET_MSK	   0xfff80000
/* The mask used to clear the CORE_MMC_CONTROL_RESERVED_31_19 register field value. */
#define CORE_MMC_CONTROL_RESERVED_31_19_CLR_MSK	   0x0007ffff
/* The reset value of the CORE_MMC_CONTROL_RESERVED_31_19 register field. */
#define CORE_MMC_CONTROL_RESERVED_31_19_RESET	   0x0
/* Extracts the CORE_MMC_CONTROL_RESERVED_31_19 field value from a register. */
#define CORE_MMC_CONTROL_RESERVED_31_19_GET(value) (((value)&0xfff80000) >> 19)
/* Produces a CORE_MMC_CONTROL_RESERVED_31_19 register field value suitable for setting the
 * register. */
#define CORE_MMC_CONTROL_RESERVED_31_19_SET(value) (((value) << 19) & 0xfff80000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_CONTROL.
 */
struct CORE_MMC_CONTROL_s {
	volatile uint32_t CNTRST : 1;		       /* CORE_MMC_CONTROL_CNTRST */
	volatile uint32_t CNTSTOPRO : 1;	       /* CORE_MMC_CONTROL_CNTSTOPRO */
	volatile uint32_t RSTONRD : 1;		       /* CORE_MMC_CONTROL_RSTONRD */
	volatile uint32_t MCF : 1;		       /* CORE_MMC_CONTROL_MCF */
	volatile uint32_t MCT : 2;		       /* CORE_MMC_CONTROL_MCT */
	const volatile uint32_t Reserved_6 : 1;	       /* CORE_MMC_CONTROL_RESERVED_6 */
	volatile uint32_t CNTPRST : 1;		       /* CORE_MMC_CONTROL_CNTPRST */
	const volatile uint32_t Reserved_15_8 : 8;     /* CORE_MMC_CONTROL_RESERVED_15_8 */
	const volatile uint32_t Reserved_PRMMCSEL : 3; /* CORE_MMC_CONTROL_RESERVED_PRMMCSEL */
	const volatile uint32_t Reserved_31_19 : 13;   /* CORE_MMC_CONTROL_RESERVED_31_19 */
};

/* The typedef declaration for register CORE_MMC_CONTROL. */
typedef struct CORE_MMC_CONTROL_s CORE_MMC_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_CONTROL register. */
#define CORE_MMC_CONTROL_RESET 0x00000020
/* The byte offset of the CORE_MMC_CONTROL register from the beginning of the component. */
#define CORE_MMC_CONTROL_OFST  0x800

/*
 * Register : MMC_Rx_Interrupt
 *
 * The MMC Receive Interrupt Status register maintains the interrupts generated
 * when receive statistic counters reach the threshold programmed in the MMC
 * control register. When the MMC counter that caused the interrupt is read, the
 * corresponding interrupt status bit is cleared. The least significant byte lane
 * (bits[7:0]) of the counter must be read to clear the interrupt status bit. When
 * the MMC module is enabled for 64-bit counter mode, the least significant byte
 * lane (bits[7:0]) of the upper counter must be read to clear the interrupt status
 * bit.
 *
 * Register Layout
 *
 *  Bits | Access | Reset | Description
 * :-----|:-------|:------|:-----------------------------------------------------------
 *  [0]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXGBPKTIS
 *  [1]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXGBOCTIS
 *  [2]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXGOCTIS
 *  [3]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXBCGPIS
 *  [4]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXMCGPIS
 *  [5]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXCRCERPIS
 *  [6]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXRUNTPIS
 *  [7]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXJABERPIS
 *  [8]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS
 *  [9]  | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS
 *  [10] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS
 *  [11] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS
 *  [12] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS
 *  [13] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS
 *  [14] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS
 *  [15] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS
 *  [16] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXUCGPIS
 *  [17] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXLENERPIS
 *  [18] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXORANGEPIS
 *  [19] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXPAUSPIS
 *  [20] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXFOVPIS
 *  [21] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXVLANGBPIS
 *  [22] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXWDOGPIS
 *  [23] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXDISPCGBIS
 *  [24] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXDISOCGBIS
 *  [25] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXLPIUSCIS
 *  [26] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXLPITRCIS
 *  [27] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXALEPIS
 *  [28] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_SGPPIS
 *  [29] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_SGFPIS
 *  [30] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RESERVED_30
 *  [31] | R      | 0x0   | CORE_MMC_RX_INTERRUPT_RXPRMMCIS
 *
 */
/*
 * Field : RXGBPKTIS
 *
 * Rx Good Bad Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_Packet_Count_Good_Bad_High and
 * Rx_Packet_Count_Good_Bad_Low counter or 32-bit Rx_Packet_Count_Good_Bad_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_MSB	   0
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_SET_MSK	   0x00000001
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_CLR_MSK	   0xfffffffe
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXGBPKTIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_RX_INTERRUPT_RXGBPKTIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXGBPKTIS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RXGBOCTIS
 *
 * Rx Good Bad Octet Counter Interrupt Status
 *
 * The bit is set when the Rx_Octet_Count_Good_Bad_High and
 * Rx_Octet_Count_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_LSB	   1
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_MSB	   1
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_SET_MSK	   0x00000002
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_CLR_MSK	   0xfffffffd
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXGBOCTIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_RX_INTERRUPT_RXGBOCTIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXGBOCTIS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RXGOCTIS
 *
 * Rx Good Octet Counter Interrupt Status
 *
 * The bit is set when the Rx_Octet_Count_Good_High and Rx_Octet_Count_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXGOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_LSB	  2
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXGOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_MSB	  2
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXGOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXGOCTIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_SET_MSK	  0x00000004
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXGOCTIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_CLR_MSK	  0xfffffffb
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXGOCTIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXGOCTIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_RX_INTERRUPT_RXGOCTIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_RXGOCTIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : RXBCGPIS
 *
 * Rx Good Broadcast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_Broadcast_Packets_Good_High and
 * Rx_Broadcast_Packets_Good_Low counter or 32-bit Rx_Broadcast_Packets_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXBCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_LSB	  3
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXBCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_MSB	  3
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXBCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXBCGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_SET_MSK	  0x00000008
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXBCGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_CLR_MSK	  0xfffffff7
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXBCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXBCGPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_RX_INTERRUPT_RXBCGPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_RXBCGPIS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : RXMCGPIS
 *
 * Rx Good Multicast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_Multicast_Packets_Good_High and
 * Rx_Multicast_Packets_Good_Low counter or 32-bit Rx_Multicast_Packets_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXMCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_LSB	  4
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXMCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_MSB	  4
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXMCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXMCGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_SET_MSK	  0x00000010
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXMCGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_CLR_MSK	  0xffffffef
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXMCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXMCGPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MMC_RX_INTERRUPT_RXMCGPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_RXMCGPIS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : RXCRCERPIS
 *
 * Rx CRC Error Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_CRC_Error_Packets_High and
 * Rx_CRC_Error_Packets_Low counter or 32-bit Rx_CRC_Error_Packets_Low reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_LSB	    5
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_MSB	    5
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_SET_MSK    0x00000020
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXCRCERPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MMC_RX_INTERRUPT_RXCRCERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXCRCERPIS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : RXRUNTPIS
 *
 * Rx Runt Error Packet Counter Interrupt Status
 *
 * This bit is set when the Rx_Runt_Error_Packets counter reaches the threshold
 * value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_MSB	   6
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_SET_MSK	   0x00000040
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_CLR_MSK	   0xffffffbf
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXRUNTPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_RX_INTERRUPT_RXRUNTPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXRUNTPIS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : RXJABERPIS
 *
 * Rx Jabber Error Packet Counter Interrupt Status
 *
 * The bit is set when the Rx_Jabber_Error_Packets counter reaches the threshold
 * value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXJABERPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_LSB	    7
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXJABERPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_MSB	    7
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXJABERPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXJABERPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_SET_MSK    0x00000080
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXJABERPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXJABERPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXJABERPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_RX_INTERRUPT_RXJABERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXJABERPIS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : RXUSIZEGPIS
 *
 * Rx Good Undersize Packet Counter Interrupt Status
 *
 * The bit is set when the Rx_Undersize_Packets_Good counter reaches the threshold
 * value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_LSB	     8
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_MSB	     8
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_SET_MSK    0x00000100
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : RXOSIZEGPIS
 *
 * Rx Good Oversize Packet Counter Interrupt Status
 *
 * The bit is set when the Rx_Oversize_Packets_Good counter reaches the threshold
 * value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_LSB	     9
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_MSB	     9
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_SET_MSK    0x00000200
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : RX64OCTGBPIS
 *
 * Rx Good Bad 64 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_64Octets_Packets_Good_Bad_High and
 * Rx_64Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_64Octets_Packets_Good_Bad_Low counter reaches the threshold value programmed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_LSB	      10
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_MSB	      10
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_WIDTH      1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_SET_MSK    0x00000400
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_RESET      0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : RX65T127OCTGBPIS
 *
 * Rx Good Bad 65-to-127 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_65To127Octets_Packets_Good_Bad_High and
 * Rx_65To127Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_65To127Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_LSB	  11
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_MSB	  11
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_SET_MSK	  0x00000800
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_CLR_MSK	  0xfffff7ff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : RX128T255OCTGBPIS
 *
 * Rx Good Bad 128-to-255 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_128To255Octets_Packets_Good_Bad_High and
 * Rx_128To255Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_128To255Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_LSB	   12
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_MSB	   12
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_SET_MSK	   0x00001000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_CLR_MSK	   0xffffefff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : RX256T511OCTGBPIS
 *
 * Rx Good Bad 256-to-511 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_256To511Octets_Packets_Good_Bad_High and
 * Rx_256To511Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_256To511Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_LSB	   13
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_MSB	   13
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_SET_MSK	   0x00002000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_CLR_MSK	   0xffffdfff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : RX512T1023OCTGBPIS
 *
 * Rx Good Bad 512-to-1023 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_512To1023Octets_Packets_Good_Bad_High and
 * Rx_512To1023Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_512To1023Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_LSB	    14
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_MSB	    14
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_SET_MSK    0x00004000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_CLR_MSK    0xffffbfff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : RX1024TMAXOCTGBPIS
 *
 * Rx Good Bad 1024-to-Max Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_1024ToMaxOctets_Packets_Good_Bad_High and
 * Rx_1024ToMaxOctets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_1024ToMaxOctets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_LSB	    15
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register
 * field. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_MSB	    15
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_SET_MSK    0x00008000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : RXUCGPIS
 *
 * Rx Good Unicast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_Unicast_Packets_Good_High and
 * Rx_Unicast_Packets_Good_Low counter or 32-bit Rx_Unicast_Packets_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXUCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_LSB	  16
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXUCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_MSB	  16
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXUCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXUCGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_SET_MSK	  0x00010000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXUCGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_CLR_MSK	  0xfffeffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXUCGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXUCGPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MMC_RX_INTERRUPT_RXUCGPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_RXUCGPIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : RXLENERPIS
 *
 * Rx Length Error Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_Length_Error_Packets_High and
 * Rx_Length_Error_Packets_Low counter or 32-bit Rx_Length_Error_Packets_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXLENERPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_LSB	    17
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXLENERPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_MSB	    17
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXLENERPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXLENERPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_SET_MSK    0x00020000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXLENERPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXLENERPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXLENERPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MMC_RX_INTERRUPT_RXLENERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXLENERPIS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : RXORANGEPIS
 *
 * Rx Out-of-Range Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_OutofRange_Packets_High and
 * Rx_OutofRange_Packets_Low counter or 32-bit Rx_OutofRange_Packets_Low counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_LSB	     18
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_MSB	     18
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_SET_MSK    0x00040000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXORANGEPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MMC_RX_INTERRUPT_RXORANGEPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXORANGEPIS_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : RXPAUSPIS
 *
 * Rx Pause Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_Pause_Packets_High and Rx_Pause_Packets_Low
 * counter or 32-bit Rx_Pause_Packets_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_LSB	   19
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_MSB	   19
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_SET_MSK	   0x00080000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_CLR_MSK	   0xfff7ffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXPAUSPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MMC_RX_INTERRUPT_RXPAUSPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXPAUSPIS_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : RXFOVPIS
 *
 * Rx Queue Overflow Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_FIFOOverflow_Packets_High and
 * Rx_FIFOOverflow_Packets_Low counter or 32-bit Rx_FIFOOverflow_Packets_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXFOVPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_LSB	  20
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXFOVPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_MSB	  20
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXFOVPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXFOVPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_SET_MSK	  0x00100000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXFOVPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_CLR_MSK	  0xffefffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXFOVPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXFOVPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MMC_RX_INTERRUPT_RXFOVPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_RXFOVPIS_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : RXVLANGBPIS
 *
 * Rx Good Bad VLAN Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Rx_VLAN_Packets_Good_Bad_High and
 * Rx_VLAN_Packets_Good_Bad_Low counter or 32-bit Rx_VLAN_Packets_Good_Bad_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_LSB	     21
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_MSB	     21
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_SET_MSK    0x00200000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXVLANGBPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MMC_RX_INTERRUPT_RXVLANGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXVLANGBPIS_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : RXWDOGPIS
 *
 * Rx Watchdog Error Packet Counter Interrupt Status
 *
 * The bit is set when the Rx_Watchdog_Error_Packets counter reaches the threshold
 * value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_LSB	   22
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_MSB	   22
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_SET_MSK	   0x00400000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_CLR_MSK	   0xffbfffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXWDOGPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MMC_RX_INTERRUPT_RXWDOGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXWDOGPIS_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : RXDISPCGBIS
 *
 * Rx Good Bad Discarded Packet Counter Interrupt Status
 *
 * This bit is set when the 64-bit Rx_Discard_Packets_Good_Bad_High and
 * Rx_Discard_Packets_Good_Bad_Low counter or 32-bit
 * Rx_Discard_Packets_Good_Bad_Low counter reaches the threshold value programmed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_LSB	     23
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_MSB	     23
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_SET_MSK    0x00800000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXDISPCGBIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MMC_RX_INTERRUPT_RXDISPCGBIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXDISPCGBIS_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : RXDISOCGBIS
 *
 * Rx Good Bad Discarded Octet Counter Interrupt Status
 *
 * This bit is set when the Rx_Discard_Octets_Good_Bad_High and
 * Rx_Discard_Octets_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_LSB	     24
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_MSB	     24
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_SET_MSK    0x01000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXDISOCGBIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MMC_RX_INTERRUPT_RXDISOCGBIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXDISOCGBIS_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : RXLPIUSCIS
 *
 * Rx LPI microsecond Counter Interrupt Status
 *
 * This bit is set when the Rx_LPI_USEC_Cntr reaches the threshold value programed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_LSB	    25
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_MSB	    25
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_SET_MSK    0x02000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXLPIUSCIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MMC_RX_INTERRUPT_RXLPIUSCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXLPIUSCIS_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : RXLPITRCIS
 *
 * Rx LPI Transition Counter Interrupt Status
 *
 * This bit is set when the Rx_LPI_Tran_Cntr reaches the threshold value programed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_LSB	    26
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_MSB	    26
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_WIDTH	    1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_SET_MSK    0x04000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_RESET	    0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXLPITRCIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MMC_RX_INTERRUPT_RXLPITRCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXLPITRCIS_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : RXALEPIS
 *
 * Rx Alignment Error Packet Counter Interrupt Status
 *
 * This bit is set when the Rx_Alignment_Error_Packets counter reaches the
 * threshold value programed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXALEPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_LSB	  27
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXALEPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_MSB	  27
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXALEPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXALEPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_SET_MSK	  0x08000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXALEPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_CLR_MSK	  0xf7ffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXALEPIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_RESET	  0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXALEPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MMC_RX_INTERRUPT_RXALEPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_RXALEPIS_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : SGPPIS
 *
 * SGF Pass Packet Counter Interrupt Status
 *
 * The bit is set when the SGF Pass Packet Counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_SGPPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_LSB	28
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_SGPPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_MSB	28
/* The width in bits of the CORE_MMC_RX_INTERRUPT_SGPPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_WIDTH	1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_SGPPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_SET_MSK	0x10000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_SGPPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_CLR_MSK	0xefffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_SGPPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_RESET	0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_SGPPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MMC_RX_INTERRUPT_SGPPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_SGPPIS_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : SGFPIS
 *
 * SGF Fail Packet Counter Interrupt Status
 *
 * The bit is set when the and when the SGF Fail Packet Counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_SGFPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_LSB	29
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_SGFPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_MSB	29
/* The width in bits of the CORE_MMC_RX_INTERRUPT_SGFPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_WIDTH	1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_SGFPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_SET_MSK	0x20000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_SGFPIS register field value. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_CLR_MSK	0xdfffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_SGFPIS register field. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_RESET	0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_SGFPIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MMC_RX_INTERRUPT_SGFPIS register field value suitable for setting the register.
 */
#define CORE_MMC_RX_INTERRUPT_SGFPIS_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : Reserved_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RESERVED_30 register field.
 */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_LSB	     30
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RESERVED_30 register field.
 */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_MSB	     30
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RESERVED_30 register field. */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_WIDTH	     1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RESERVED_30 register field value. */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_SET_MSK    0x40000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RESERVED_30 register field value. */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_CLR_MSK    0xbfffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RESERVED_30 register field. */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_RESET	     0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RESERVED_30 field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MMC_RX_INTERRUPT_RESERVED_30 register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RESERVED_30_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : RXPRMMCIS
 *
 * Rx Priority MMC Counter Interrupt Status
 *
 * The bit is set when the any of the Rx Per Priority MMC counter (0x09D0 to
 * 0x09FC) reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field.
 */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_MSB	   31
/* The width in bits of the CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_WIDTH	   1
/* The mask used to set the CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field value. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_RESET	   0x0
/* Extracts the CORE_MMC_RX_INTERRUPT_RXPRMMCIS field value from a register. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MMC_RX_INTERRUPT_RXPRMMCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_INTERRUPT_RXPRMMCIS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_RX_INTERRUPT.
 */
struct CORE_MMC_RX_INTERRUPT_s {
	const volatile uint32_t RXGBPKTIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXGBPKTIS */
	const volatile uint32_t RXGBOCTIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXGBOCTIS */
	const volatile uint32_t RXGOCTIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXGOCTIS */
	const volatile uint32_t RXBCGPIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXBCGPIS */
	const volatile uint32_t RXMCGPIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXMCGPIS */
	const volatile uint32_t RXCRCERPIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXCRCERPIS */
	const volatile uint32_t RXRUNTPIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXRUNTPIS */
	const volatile uint32_t RXJABERPIS : 1;	       /* CORE_MMC_RX_INTERRUPT_RXJABERPIS */
	const volatile uint32_t RXUSIZEGPIS : 1;       /* CORE_MMC_RX_INTERRUPT_RXUSIZEGPIS */
	const volatile uint32_t RXOSIZEGPIS : 1;       /* CORE_MMC_RX_INTERRUPT_RXOSIZEGPIS */
	const volatile uint32_t RX64OCTGBPIS : 1;      /* CORE_MMC_RX_INTERRUPT_RX64OCTGBPIS */
	const volatile uint32_t RX65T127OCTGBPIS : 1;  /* CORE_MMC_RX_INTERRUPT_RX65T127OCTGBPIS */
	const volatile uint32_t RX128T255OCTGBPIS : 1; /* CORE_MMC_RX_INTERRUPT_RX128T255OCTGBPIS */
	const volatile uint32_t RX256T511OCTGBPIS : 1; /* CORE_MMC_RX_INTERRUPT_RX256T511OCTGBPIS */
	const volatile uint32_t
		RX512T1023OCTGBPIS : 1; /* CORE_MMC_RX_INTERRUPT_RX512T1023OCTGBPIS */
	const volatile uint32_t
		RX1024TMAXOCTGBPIS : 1;		 /* CORE_MMC_RX_INTERRUPT_RX1024TMAXOCTGBPIS */
	const volatile uint32_t RXUCGPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXUCGPIS */
	const volatile uint32_t RXLENERPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXLENERPIS */
	const volatile uint32_t RXORANGEPIS : 1; /* CORE_MMC_RX_INTERRUPT_RXORANGEPIS */
	const volatile uint32_t RXPAUSPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXPAUSPIS */
	const volatile uint32_t RXFOVPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXFOVPIS */
	const volatile uint32_t RXVLANGBPIS : 1; /* CORE_MMC_RX_INTERRUPT_RXVLANGBPIS */
	const volatile uint32_t RXWDOGPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXWDOGPIS */
	const volatile uint32_t RXDISPCGBIS : 1; /* CORE_MMC_RX_INTERRUPT_RXDISPCGBIS */
	const volatile uint32_t RXDISOCGBIS : 1; /* CORE_MMC_RX_INTERRUPT_RXDISOCGBIS */
	const volatile uint32_t RXLPIUSCIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXLPIUSCIS */
	const volatile uint32_t RXLPITRCIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXLPITRCIS */
	const volatile uint32_t RXALEPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXALEPIS */
	const volatile uint32_t SGPPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_SGPPIS */
	const volatile uint32_t SGFPIS : 1;	 /* CORE_MMC_RX_INTERRUPT_SGFPIS */
	const volatile uint32_t Reserved_30 : 1; /* CORE_MMC_RX_INTERRUPT_RESERVED_30 */
	const volatile uint32_t RXPRMMCIS : 1;	 /* CORE_MMC_RX_INTERRUPT_RXPRMMCIS */
};

/* The typedef declaration for register CORE_MMC_RX_INTERRUPT. */
typedef struct CORE_MMC_RX_INTERRUPT_s CORE_MMC_RX_INTERRUPT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_RX_INTERRUPT register. */
#define CORE_MMC_RX_INTERRUPT_RESET 0x00000000
/* The byte offset of the CORE_MMC_RX_INTERRUPT register from the beginning of the component. */
#define CORE_MMC_RX_INTERRUPT_OFST  0x804

/*
 * Register : MMC_Tx_Interrupt
 *
 * The MMC Transmit Interrupt Status register maintains the interrupts generated
 * when the transmit statistic counters reach the threshold value programmed in MMC
 * control register (for example, the counter's MSB is set). This register is 32
 * bits wide. When the MMC counter that caused the interrupt is read, the
 * corresponding interrupt status bit is cleared. The least significant byte lane
 * (bits[7:0]) of the corresponding counter must be read to clear the interrupt
 * status bit. When the MMC module is enabled for 64-bit counter mode, the least
 * significant byte lane (bits[7:0]) of the upper counter must be read to clear the
 * interrupt status bit.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXGBOCTIS
 *  [1]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXGBPKTIS
 *  [2]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXBCGPIS
 *  [3]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXMCGPIS
 *  [4]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS
 *  [5]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS
 *  [6]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS
 *  [7]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS
 *  [8]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS
 *  [9]     | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS
 *  [10]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXUCGBPIS
 *  [11]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXMCGBPIS
 *  [12]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXBCGBPIS
 *  [13]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS
 *  [14]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXGOCTIS
 *  [15]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXGPKTIS
 *  [16]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXPAUSPIS
 *  [17]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXVLANGPIS
 *  [18]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXLPIUSCIS
 *  [19]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXLPITRCIS
 *  [20]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXSCOLGPIS
 *  [21]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXMCOLGPIS
 *  [22]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXDEFPIS
 *  [23]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXLATCOLPIS
 *  [24]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXEXCOLPIS
 *  [25]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXCARERPIS
 *  [26]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXEXDEFPIS
 *  [30:27] | R      | 0x0   | CORE_MMC_TX_INTERRUPT_RESERVED_30_27
 *  [31]    | R      | 0x0   | CORE_MMC_TX_INTERRUPT_TXPRMMCIS
 *
 */
/*
 * Field : TXGBOCTIS
 *
 * Tx Good Bad Octet Counter Interrupt Status
 *
 * The bit is set when the Tx_Octet_Count_Good_Bad_High and
 * Tx_Octet_Count_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_MSB	   0
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_SET_MSK	   0x00000001
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_CLR_MSK	   0xfffffffe
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXGBOCTIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_TX_INTERRUPT_TXGBOCTIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXGBOCTIS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TXGBPKTIS
 *
 * Tx Good Bad Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Packet_Count_Good_Bad_High and
 * Tx_Packet_Count_Good_Bad_Low counter or 32-bit Tx_Packet_Count_Good_Bad_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_LSB	   1
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_MSB	   1
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_SET_MSK	   0x00000002
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_CLR_MSK	   0xfffffffd
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXGBPKTIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_TX_INTERRUPT_TXGBPKTIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXGBPKTIS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TXBCGPIS
 *
 * Tx Good Broadcast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Broadcast_Packets_Good_High and
 * Tx_Broadcast_Packets_Good_Low counter or 32-bit Tx_Broadcast_Packets_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXBCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_LSB	  2
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXBCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_MSB	  2
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXBCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXBCGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_SET_MSK	  0x00000004
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXBCGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_CLR_MSK	  0xfffffffb
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXBCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_RESET	  0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXBCGPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_TX_INTERRUPT_TXBCGPIS register field value suitable for setting the register.
 */
#define CORE_MMC_TX_INTERRUPT_TXBCGPIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : TXMCGPIS
 *
 * Tx Good Multicast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Multicast_Packets_Good_High and
 * Tx_Multicast_Packets_Good_Low counter or 32-bit Tx_Multicast_Packets_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXMCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_LSB	  3
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXMCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_MSB	  3
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXMCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXMCGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_SET_MSK	  0x00000008
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXMCGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_CLR_MSK	  0xfffffff7
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXMCGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_RESET	  0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXMCGPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_TX_INTERRUPT_TXMCGPIS register field value suitable for setting the register.
 */
#define CORE_MMC_TX_INTERRUPT_TXMCGPIS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : TX64OCTGBPIS
 *
 * Tx Good Bad 64 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_64Octets_Packets_Good_Bad_High and
 * Tx_64Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_64Octets_Packets_Good_Bad_Low counter reaches the threshold value programmed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_LSB	      4
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_MSB	      4
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_WIDTH      1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_SET_MSK    0x00000010
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_CLR_MSK    0xffffffef
/* The reset value of the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_RESET      0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : TX65T127OCTGBPIS
 *
 * Tx Good Bad 65-to-127 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_65To127Octets_Packets_Good_Bad_High and
 * Tx_65To127Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_65To127Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_LSB	  5
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_MSB	  5
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_SET_MSK	  0x00000020
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_CLR_MSK	  0xffffffdf
/* The reset value of the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_RESET	  0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : TX128T255OCTGBPIS
 *
 * Tx Good Bad 128-to-255 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_128To255Octets_Packets_Good_Bad_High and
 * Tx_128To255Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_128To255Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_MSB	   6
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_SET_MSK	   0x00000040
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_CLR_MSK	   0xffffffbf
/* The reset value of the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : TX256T511OCTGBPIS
 *
 * Tx Good Bad 256-to-511 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_256To511Octets_Packets_Good_Bad_High and
 * Tx_256To511Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_256To511Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_MSB	   7
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_SET_MSK	   0x00000080
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_CLR_MSK	   0xffffff7f
/* The reset value of the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : TX512T1023OCTGBPIS
 *
 * Tx Good Bad 512-to-1023 Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_512To1023Octets_Packets_Good_Bad_High and
 * Tx_512To1023Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_512To1023Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_MSB	    8
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_SET_MSK    0x00000100
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : TX1024TMAXOCTGBPIS
 *
 * Tx Good Bad 1024-to-Max Octet Size Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_1024ToMaxOctets_Packets_Good_Bad_High and
 * Tx_1024ToMaxOctets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_1024ToMaxOctets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_LSB	    9
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_MSB	    9
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_SET_MSK    0x00000200
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : TXUCGBPIS
 *
 * Tx Good Bad Unicast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Unicast_Packets_Good_Bad_High and
 * Tx_Unicast_Packets_Good_Bad_Low counter or 32-bit
 * Tx_Unicast_Packets_Good_Bad_Low counter reaches the threshold value programmed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_LSB	   10
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_MSB	   10
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_SET_MSK	   0x00000400
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_CLR_MSK	   0xfffffbff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXUCGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MMC_TX_INTERRUPT_TXUCGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXUCGBPIS_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : TXMCGBPIS
 *
 * Tx Good Bad Multicast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Multicast_Packets_Good_Bad_High and
 * Tx_Multicast_Packets_Good_Bad_Low counter or 32-bit
 * Tx_Multicast_Packets_Good_Bad_Low counter reaches the threshold value programmed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_LSB	   11
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_MSB	   11
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_SET_MSK	   0x00000800
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_CLR_MSK	   0xfffff7ff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXMCGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MMC_TX_INTERRUPT_TXMCGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXMCGBPIS_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : TXBCGBPIS
 *
 * Tx Good Bad Broadcast Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Broadcast_Packets_Good_Bad_High and
 * Tx_Broadcast_Packets_Good_Bad_Low counter or 32-bit
 * Tx_Broadcast_Packets_Good_Bad_Low counter reaches the threshold value programmed
 * in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_LSB	   12
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_MSB	   12
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_SET_MSK	   0x00001000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_CLR_MSK	   0xffffefff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXBCGBPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MMC_TX_INTERRUPT_TXBCGBPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXBCGBPIS_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : TXUFLOWERPIS
 *
 * Tx Underflow Error Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Underflow_Error_Packets_High and
 * Tx_Underflow_Error_Packets_Low counter or 32-bit Tx_Underflow_Error_Packets_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register
 * field. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_LSB	      13
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_MSB	      13
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_WIDTH      1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_SET_MSK    0x00002000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_RESET      0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : TXGOCTIS
 *
 * Tx Good Octet Counter Interrupt Status
 *
 * The bit is set when the Tx_Octet_Count_Good_High and Tx_Octet_Count_Good_Low
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXGOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_LSB	  14
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXGOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_MSB	  14
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXGOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_WIDTH	  1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXGOCTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_SET_MSK	  0x00004000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXGOCTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_CLR_MSK	  0xffffbfff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXGOCTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_RESET	  0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXGOCTIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MMC_TX_INTERRUPT_TXGOCTIS register field value suitable for setting the register.
 */
#define CORE_MMC_TX_INTERRUPT_TXGOCTIS_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : TXGPKTIS
 *
 * Tx Good Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Packet_Count_Good_High and
 * Tx_Packet_Count_Good_Low counter or 32-bit Tx_Packet_Count_Good_Low counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXGPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_LSB	  15
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXGPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_MSB	  15
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXGPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_WIDTH	  1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXGPKTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_SET_MSK	  0x00008000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXGPKTIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_CLR_MSK	  0xffff7fff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXGPKTIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_RESET	  0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXGPKTIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MMC_TX_INTERRUPT_TXGPKTIS register field value suitable for setting the register.
 */
#define CORE_MMC_TX_INTERRUPT_TXGPKTIS_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : TXPAUSPIS
 *
 * Tx Pause Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_Pause_Packets_High and Tx_Pause_Packets_Low
 * counter or 32-bit Tx_Pause_Packets_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_LSB	   16
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_MSB	   16
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_SET_MSK	   0x00010000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_CLR_MSK	   0xfffeffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXPAUSPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MMC_TX_INTERRUPT_TXPAUSPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXPAUSPIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : TXVLANGPIS
 *
 * Tx Good VLAN Packet Counter Interrupt Status
 *
 * The bit is set when the 64-bit Tx_VLAN_Packets_Good_High and
 * Tx_VLAN_Packets_Good_Low counter or 32-bit Tx_VLAN_Packets_Good_Low counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_LSB	    17
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_MSB	    17
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_SET_MSK    0x00020000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXVLANGPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MMC_TX_INTERRUPT_TXVLANGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXVLANGPIS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : TXLPIUSCIS
 *
 * Tx LPI microsecond Counter Interrupt Status
 *
 * This bit is set when the Tx_LPI_USEC_Cntr counter reaches the threshold value
 * programmed in the MMC counter register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_LSB	    18
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_MSB	    18
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_SET_MSK    0x00040000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXLPIUSCIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MMC_TX_INTERRUPT_TXLPIUSCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXLPIUSCIS_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : TXLPITRCIS
 *
 * Tx LPI Transition Counter Interrupt Status
 *
 * This bit is set when the Tx_LPI_Tran_Cntr counter reaches the threshold value
 * programmed in the MMC counter register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_LSB	    19
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_MSB	    19
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_SET_MSK    0x00080000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXLPITRCIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MMC_TX_INTERRUPT_TXLPITRCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXLPITRCIS_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : TXSCOLGPIS
 *
 * MMC Transmit Single Collision Good Packet Counter Interrupt Status
 *
 * This bit is set when the txsinglecol_g counter reaches half of the maximum value
 * or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_E_INACTIVE | 0x0   | MMC Transmit Single Collision Good Packet
 * :                                                              |       | Counter Interrupt Status
 * not detected CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_E_ACTIVE   | 0x1   | MMC Transmit Single Collision
 * Good Packet :                                                              |       | Counter
 * Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXSCOLGPIS
 *
 * MMC Transmit Single Collision Good Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXSCOLGPIS
 *
 * MMC Transmit Single Collision Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_LSB	    20
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_MSB	    20
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_SET_MSK    0x00100000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_CLR_MSK    0xffefffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXSCOLGPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MMC_TX_INTERRUPT_TXSCOLGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXSCOLGPIS_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : TXMCOLGPIS
 *
 * MMC Transmit Multiple Collision Good Packet Counter Interrupt Status
 *
 * This bit is set when the txmulticol_g counter reaches half of the maximum value
 * or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_E_INACTIVE | 0x0   | MMC Transmit Multiple Collision Good
 * Packet :                                                              |       | Counter Interrupt
 * Status not detected CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_E_ACTIVE   | 0x1   | MMC Transmit Multiple
 * Collision Good Packet :                                                              |       |
 * Counter Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXMCOLGPIS
 *
 * MMC Transmit Multiple Collision Good Packet Counter Interrupt Status not
 * detected
 */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXMCOLGPIS
 *
 * MMC Transmit Multiple Collision Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_LSB	    21
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_MSB	    21
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_SET_MSK    0x00200000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXMCOLGPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MMC_TX_INTERRUPT_TXMCOLGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXMCOLGPIS_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : TXDEFPIS
 *
 * MMC Transmit Deferred Packet Counter Interrupt Status
 *
 * This bit is set when the txdeferred counter reaches half of the maximum value or
 * the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                        | Value | Description
 * :------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXDEFPIS_E_INACTIVE | 0x0   | MMC Transmit Deferred Packet Counter
 * Interrupt :                                                            |       | Status not
 * detected CORE_MMC_TX_INTERRUPT_TXDEFPIS_E_ACTIVE   | 0x1   | MMC Transmit Deferred Packet Counter
 * Interrupt :                                                            |       | Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXDEFPIS
 *
 * MMC Transmit Deferred Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXDEFPIS
 *
 * MMC Transmit Deferred Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXDEFPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_LSB	  22
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXDEFPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_MSB	  22
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXDEFPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXDEFPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_SET_MSK	  0x00400000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXDEFPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_CLR_MSK	  0xffbfffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXDEFPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_RESET	  0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXDEFPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MMC_TX_INTERRUPT_TXDEFPIS register field value suitable for setting the register.
 */
#define CORE_MMC_TX_INTERRUPT_TXDEFPIS_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : TXLATCOLPIS
 *
 * MMC Transmit Late Collision Packet Counter Interrupt Status
 *
 * This bit is set when the txlatecol counter reaches half of the maximum value or
 * the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                           | Value | Description
 * :---------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_E_INACTIVE | 0x0   | MMC Transmit Late Collision Packet
 * Counter :                                                               |       | Interrupt
 * Status not detected CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_E_ACTIVE   | 0x1   | MMC Transmit Late
 * Collision Packet Counter :                                                               | |
 * Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXLATCOLPIS
 *
 * MMC Transmit Late Collision Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXLATCOLPIS
 *
 * MMC Transmit Late Collision Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_LSB	     23
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_MSB	     23
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_WIDTH	     1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_SET_MSK    0x00800000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_RESET	     0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXLATCOLPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MMC_TX_INTERRUPT_TXLATCOLPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXLATCOLPIS_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : TXEXCOLPIS
 *
 * MMC Transmit Excessive Collision Packet Counter Interrupt Status
 *
 * This bit is set when the txexesscol counter reaches half of the maximum value or
 * the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_E_INACTIVE | 0x0   | MMC Transmit Excessive Collision Packet
 * Counter :                                                              |       | Interrupt Status
 * not detected CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_E_ACTIVE   | 0x1   | MMC Transmit Excessive
 * Collision Packet Counter :                                                              |       |
 * Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXEXCOLPIS
 *
 * MMC Transmit Excessive Collision Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXEXCOLPIS
 *
 * MMC Transmit Excessive Collision Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_LSB	    24
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_MSB	    24
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_SET_MSK    0x01000000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXEXCOLPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MMC_TX_INTERRUPT_TXEXCOLPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXEXCOLPIS_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : TXCARERPIS
 *
 * MMC Transmit Carrier Error Packet Counter Interrupt Status
 *
 * This bit is set when the txcarriererror counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXCARERPIS_E_INACTIVE | 0x0   | MMC Transmit Carrier Error Packet Counter
 * :                                                              |       | Interrupt Status not
 * detected CORE_MMC_TX_INTERRUPT_TXCARERPIS_E_ACTIVE   | 0x1   | MMC Transmit Carrier Error Packet
 * Counter :                                                              |       | Interrupt Status
 * detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXCARERPIS
 *
 * MMC Transmit Carrier Error Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXCARERPIS
 *
 * MMC Transmit Carrier Error Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXCARERPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_LSB	    25
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXCARERPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_MSB	    25
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXCARERPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXCARERPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_SET_MSK    0x02000000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXCARERPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXCARERPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXCARERPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MMC_TX_INTERRUPT_TXCARERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXCARERPIS_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : TXEXDEFPIS
 *
 * MMC Transmit Excessive Deferral Packet Counter Interrupt Status
 *
 * This bit is set when the txexcessdef counter reaches half of the maximum value
 * or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_E_INACTIVE | 0x0   | MMC Transmit Excessive Deferral Packet
 * Counter :                                                              |       | Interrupt Status
 * not detected CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_E_ACTIVE   | 0x1   | MMC Transmit Excessive
 * Deferral Packet Counter :                                                              |       |
 * Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXEXDEFPIS
 *
 * MMC Transmit Excessive Deferral Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_TX_INTERRUPT_TXEXDEFPIS
 *
 * MMC Transmit Excessive Deferral Packet Counter Interrupt Status detected
 */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_LSB	    26
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_MSB	    26
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_SET_MSK    0x04000000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_RESET	    0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXEXDEFPIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MMC_TX_INTERRUPT_TXEXDEFPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXEXDEFPIS_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : Reserved_30_27
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register
 * field. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_LSB	27
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register
 * field. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_MSB	30
/* The width in bits of the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register field. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_WIDTH	4
/* The mask used to set the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register field value. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_SET_MSK	0x78000000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register field value. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_CLR_MSK	0x87ffffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register field. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_RESET	0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_RESERVED_30_27 field value from a register. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_GET(value) (((value)&0x78000000) >> 27)
/* Produces a CORE_MMC_TX_INTERRUPT_RESERVED_30_27 register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_RESERVED_30_27_SET(value) (((value) << 27) & 0x78000000)

/*
 * Field : TXPRMMCIS
 *
 * Tx Priority MMC Counter Interrupt Status
 *
 * The bit is set when the any of the Tx Per Priority MMC counter (0x08D0 to
 * 0x08FC) reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field.
 */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_MSB	   31
/* The width in bits of the CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_WIDTH	   1
/* The mask used to set the CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field value. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_RESET	   0x0
/* Extracts the CORE_MMC_TX_INTERRUPT_TXPRMMCIS field value from a register. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MMC_TX_INTERRUPT_TXPRMMCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_INTERRUPT_TXPRMMCIS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_TX_INTERRUPT.
 */
struct CORE_MMC_TX_INTERRUPT_s {
	const volatile uint32_t TXGBOCTIS : 1;	       /* CORE_MMC_TX_INTERRUPT_TXGBOCTIS */
	const volatile uint32_t TXGBPKTIS : 1;	       /* CORE_MMC_TX_INTERRUPT_TXGBPKTIS */
	const volatile uint32_t TXBCGPIS : 1;	       /* CORE_MMC_TX_INTERRUPT_TXBCGPIS */
	const volatile uint32_t TXMCGPIS : 1;	       /* CORE_MMC_TX_INTERRUPT_TXMCGPIS */
	const volatile uint32_t TX64OCTGBPIS : 1;      /* CORE_MMC_TX_INTERRUPT_TX64OCTGBPIS */
	const volatile uint32_t TX65T127OCTGBPIS : 1;  /* CORE_MMC_TX_INTERRUPT_TX65T127OCTGBPIS */
	const volatile uint32_t TX128T255OCTGBPIS : 1; /* CORE_MMC_TX_INTERRUPT_TX128T255OCTGBPIS */
	const volatile uint32_t TX256T511OCTGBPIS : 1; /* CORE_MMC_TX_INTERRUPT_TX256T511OCTGBPIS */
	const volatile uint32_t
		TX512T1023OCTGBPIS : 1; /* CORE_MMC_TX_INTERRUPT_TX512T1023OCTGBPIS */
	const volatile uint32_t
		TX1024TMAXOCTGBPIS : 1;		    /* CORE_MMC_TX_INTERRUPT_TX1024TMAXOCTGBPIS */
	const volatile uint32_t TXUCGBPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXUCGBPIS */
	const volatile uint32_t TXMCGBPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXMCGBPIS */
	const volatile uint32_t TXBCGBPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXBCGBPIS */
	const volatile uint32_t TXUFLOWERPIS : 1;   /* CORE_MMC_TX_INTERRUPT_TXUFLOWERPIS */
	const volatile uint32_t TXGOCTIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXGOCTIS */
	const volatile uint32_t TXGPKTIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXGPKTIS */
	const volatile uint32_t TXPAUSPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXPAUSPIS */
	const volatile uint32_t TXVLANGPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXVLANGPIS */
	const volatile uint32_t TXLPIUSCIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXLPIUSCIS */
	const volatile uint32_t TXLPITRCIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXLPITRCIS */
	const volatile uint32_t TXSCOLGPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXSCOLGPIS */
	const volatile uint32_t TXMCOLGPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXMCOLGPIS */
	const volatile uint32_t TXDEFPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXDEFPIS */
	const volatile uint32_t TXLATCOLPIS : 1;    /* CORE_MMC_TX_INTERRUPT_TXLATCOLPIS */
	const volatile uint32_t TXEXCOLPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXEXCOLPIS */
	const volatile uint32_t TXCARERPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXCARERPIS */
	const volatile uint32_t TXEXDEFPIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXEXDEFPIS */
	const volatile uint32_t Reserved_30_27 : 4; /* CORE_MMC_TX_INTERRUPT_RESERVED_30_27 */
	const volatile uint32_t TXPRMMCIS : 1;	    /* CORE_MMC_TX_INTERRUPT_TXPRMMCIS */
};

/* The typedef declaration for register CORE_MMC_TX_INTERRUPT. */
typedef struct CORE_MMC_TX_INTERRUPT_s CORE_MMC_TX_INTERRUPT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_TX_INTERRUPT register. */
#define CORE_MMC_TX_INTERRUPT_RESET 0x00000000
/* The byte offset of the CORE_MMC_TX_INTERRUPT register from the beginning of the component. */
#define CORE_MMC_TX_INTERRUPT_OFST  0x808

/*
 * Register : MMC_Receive_Interrupt_Enable
 *
 * The MMC Receive Interrupt Enable register maintains the enables for the
 * interrupts generated when receive statistic counters reach the threshold value
 * programmed in the MMC Control register. This register is 32 bits wide.
 *
 * Register Layout
 *
 *  Bits | Access | Reset | Description
 * :-----|:-------|:------|:-----------------------------------------------------------------------
 *  [0]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE
 *  [1]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE
 *  [2]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE
 *  [3]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE
 *  [4]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE
 *  [5]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE
 *  [6]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE
 *  [7]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE
 *  [8]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE
 *  [9]  | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE
 *  [10] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE
 *  [11] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE
 *  [12] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE
 *  [13] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE
 *  [14] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE
 *  [15] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE
 *  [16] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE
 *  [17] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE
 *  [18] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE
 *  [19] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE
 *  [20] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE
 *  [21] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE
 *  [22] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE
 *  [23] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE
 *  [24] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE
 *  [25] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE
 *  [26] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE
 *  [27] | RW     | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE
 *  [28] | R      | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE
 *  [29] | R      | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE
 *  [30] | R      | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30
 *  [31] | R      | 0x0   | CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE
 *
 */
/*
 * Field : RXGBPKTIE
 *
 * Rx Good Bad Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_Packet_Count_Good_Bad_High and Rx_Packet_Count_Good_Bad_Low counter or 32-bit
 * Rx_Packet_Count_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_MSB	       0
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_SET_MSK    0x00000001
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RXGBOCTIE
 *
 * Rx Good Bad Octet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Octet_Count_Good_Bad_High and
 * Rx_Octet_Count_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_LSB	       1
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_MSB	       1
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_SET_MSK    0x00000002
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RXGOCTIE
 *
 * Rx Good Octet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Octet_Count_Good_High and
 * Rx_Octet_Count_Good_Lo counter reaches the threshold value programmed in the MMC
 * control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_LSB	      2
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_MSB	      2
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_SET_MSK    0x00000004
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : RXBCGPIE
 *
 * Rx Good Broadcast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_Broadcast_Packets_Good_High and Rx_Broadcast_Packets_Good_Low counter or
 * 32-bit Rx_Broadcast_Packets_Good_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_LSB	      3
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_MSB	      3
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_SET_MSK    0x00000008
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : RXMCGPIE
 *
 * Rx Good Multicast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_Multicast_Packets_Good_High and Rx_Multicast_Packets_Good_Low counter or
 * 32-bit Rx_Multicast_Packets_Good_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_LSB	      4
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_MSB	      4
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_SET_MSK    0x00000010
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_CLR_MSK    0xffffffef
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : RXCRCERPIE
 *
 * Rx CRC Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit Rx_CRC_Error_Packets_High
 * and Rx_CRC_Error_Packets_Low counter or 32-bit Rx_CRC_Error_Packets_Low counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_MSB	5
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_SET_MSK	0x00000020
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : RXRUNTPIE
 *
 * Rx Runt Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Runt_Error_Packets counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_LSB	       6
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_MSB	       6
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_SET_MSK    0x00000040
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : RXJABERPIE
 *
 * Rx Jabber Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Jabber_Error_Packets counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_LSB	7
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_MSB	7
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_SET_MSK	0x00000080
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_CLR_MSK	0xffffff7f
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : RXUSIZEGPIE
 *
 * Rx Good Undersize Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Undersize_Packets_Good
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_LSB	 8
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_MSB	 8
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_SET_MSK	 0x00000100
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_CLR_MSK	 0xfffffeff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : RXOSIZEGPIE
 *
 * Rx Good Oversize Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Oversize_Packets_Good counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_LSB	 9
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_MSB	 9
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_SET_MSK	 0x00000200
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_CLR_MSK	 0xfffffdff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : RX64OCTGBPIE
 *
 * Rx Good Bad 64 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_64Octets_Packets_Good_Bad_High and Rx_64Octets_Packets_Good_Bad_Low counter
 * or 32-bit Rx_64Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_LSB	  10
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_MSB	  10
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_WIDTH	  1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_SET_MSK	  0x00000400
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE register field value.
 */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_CLR_MSK	  0xfffffbff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_RESET	  0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : RX65T127OCTGBPIE
 *
 * Rx Good Bad 65-to-127 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_65To127Octets_Packets_Good_Bad_High and Rx_65To127Octets_Packets_Good_Bad_Low
 * counter or 32-bit Rx_65To127Octets_Packets_Good_Bad_Low counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_MSB	      11
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE register field value.
 */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_SET_MSK    0x00000800
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : RX128T255OCTGBPIE
 *
 * Rx Good Bad 128-to-255 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_128To255Octets_Packets_Good_Bad_High and
 * Rx_128To255Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_128To255Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_LSB	       12
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_MSB	       12
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_SET_MSK    0x00001000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_CLR_MSK    0xffffefff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE_SET(value)                             \
	(((value) << 12) & 0x00001000)

/*
 * Field : RX256T511OCTGBPIE
 *
 * Rx Good Bad 256-to-511 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_256To511Octets_Packets_Good_Bad_High and
 * Rx_256To511Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_256To511Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_LSB	       13
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_MSB	       13
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_SET_MSK    0x00002000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE_SET(value)                             \
	(((value) << 13) & 0x00002000)

/*
 * Field : RX512T1023OCTGBPIE
 *
 * Rx Good Bad 512-to-1023 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_512To1023Octets_Packets_Good_Bad_High and
 * Rx_512To1023Octets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_512To1023Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_LSB	14
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_MSB	14
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_SET_MSK	0x00004000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_CLR_MSK	0xffffbfff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE_SET(value)                            \
	(((value) << 14) & 0x00004000)

/*
 * Field : RX1024TMAXOCTGBPIE
 *
 * Rx Good Bad 1024-to-Max Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_1024ToMaxOctets_Packets_Good_Bad_High and
 * Rx_1024ToMaxOctets_Packets_Good_Bad_Low counter or 32-bit
 * Rx_1024ToMaxOctets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_LSB	15
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_MSB	15
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_SET_MSK	0x00008000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_CLR_MSK	0xffff7fff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE_SET(value)                            \
	(((value) << 15) & 0x00008000)

/*
 * Field : RXUCGPIE
 *
 * Rx Good Unicast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_Unicast_Packets_Good_High and Rx_Unicast_Packets_Good_Low counter or 32-bit
 * Rx_Unicast_Packets_Good_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_LSB	      16
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_MSB	      16
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_SET_MSK    0x00010000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : RXLENERPIE
 *
 * Rx Length Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_Length_Error_Packets_High and Rx_Length_Error_Packets_Low counter or 32-bit
 * Rx_Length_Error_Packets_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_LSB	17
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_MSB	17
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_SET_MSK	0x00020000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_CLR_MSK	0xfffdffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : RXORANGEPIE
 *
 * Rx Out-of-Range Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_OutofRange_Packets_High and Rx_OutofRange_Packets_Low counter or 32-bit
 * Rx_OutofRange_Packets_Low counter reaches the threshold value programmed in the
 * MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_LSB	 18
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_MSB	 18
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_SET_MSK	 0x00040000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_CLR_MSK	 0xfffbffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : RXPAUSPIE
 *
 * Rx Pause Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit Rx_Pause_Packets_High and
 * Rx_Pause_Packets_Low counter or 32-bit Rx_Pause_Packets_Low counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_LSB	       19
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_MSB	       19
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_SET_MSK    0x00080000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_CLR_MSK    0xfff7ffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : RXFOVPIE
 *
 * Rx Queue Overflow Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_FIFOOverflow_Packets_High and Rx_FIFOOverflow_Packets_Low counter or 32-bit
 * Rx_FIFOOverflow_Packets_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_LSB	      20
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_MSB	      20
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_SET_MSK    0x00100000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_CLR_MSK    0xffefffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : RXVLANGBPIE
 *
 * Rx Good Bad VLAN Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_VLAN_Packets_Good_Bad_High and Rx_VLAN_Packets_Good_Bad_Low counter or 32-bit
 * Rx_VLAN_Packets_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_LSB	 21
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_MSB	 21
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_SET_MSK	 0x00200000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_CLR_MSK	 0xffdfffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : RXWDOGPIE
 *
 * Rx Watchdog Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Watchdog_Error_Packets
 * counter reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_LSB	       22
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_MSB	       22
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_SET_MSK    0x00400000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : RXDISPCGBIE
 *
 * Rx Discard Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Rx_Discard_Packets_Good_Bad_High and Rx_Discard_Packets_Good_Bad_Low counter or
 * 32-bit Rx_Discard_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_LSB	 23
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_MSB	 23
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_SET_MSK	 0x00800000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_CLR_MSK	 0xff7fffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : RXDISOCGBIE
 *
 * Rx Discard Octet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_Discard_Octets_Good_Bad_High
 * and Rx_Discard_Octets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_LSB	 24
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_MSB	 24
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_SET_MSK	 0x01000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_CLR_MSK	 0xfeffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : RXLPIUSCIE
 *
 * Rx LPI microsecond Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Rx_LPI_USEC_Cntr reaches the
 * threshold value programed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_LSB	25
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_MSB	25
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_SET_MSK	0x02000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_CLR_MSK	0xfdffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : RXLPITRCIE
 *
 * Rx LPI Transition Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when Rx_LPI_Tran_Cntr reaches the
 * threshold value programed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_LSB	26
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_MSB	26
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_SET_MSK	0x04000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_CLR_MSK	0xfbffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : RXALEPIE
 *
 * Rx Alignment Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when Rx_Alignment_Error_Packets counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_LSB	      27
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_MSB	      27
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_WIDTH      1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_SET_MSK    0x08000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_RESET      0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : Reserved_SGPPIE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_LSB	     28
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_MSB	     28
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_WIDTH	     1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE register field value.
 */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_SET_MSK    0x10000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_CLR_MSK    0xefffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_RESET	     0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : Reserved_SGFPIE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_LSB	     29
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_MSB	     29
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_WIDTH	     1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE register field value.
 */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_SET_MSK    0x20000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_CLR_MSK    0xdfffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_RESET	     0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : Reserved_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_LSB	 30
/* The Most Significant Bit (MSB) position of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30
 * register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_MSB	 30
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_WIDTH	 1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_SET_MSK	 0x40000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 register field value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_CLR_MSK	 0xbfffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_RESET	 0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_GET(value) (((value)&0x40000000) >> 30)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30_SET(value) (((value) << 30) & 0x40000000)

/*
 * Field : Reserved_RXPRMMCIE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_LSB	31
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_MSB	31
/* The width in bits of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_WIDTH	1
/* The mask used to set the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_SET_MSK	0x80000000
/* The mask used to clear the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field
 * value. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_RESET	0x0
/* Extracts the CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE field value from a register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE register field value suitable for
 * setting the register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE_SET(value)                            \
	(((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_RECEIVE_INTERRUPT_ENABLE.
 */
struct CORE_MMC_RECEIVE_INTERRUPT_ENABLE_s {
	volatile uint32_t RXGBPKTIE : 1;    /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBPKTIE */
	volatile uint32_t RXGBOCTIE : 1;    /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGBOCTIE */
	volatile uint32_t RXGOCTIE : 1;	    /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXGOCTIE */
	volatile uint32_t RXBCGPIE : 1;	    /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXBCGPIE */
	volatile uint32_t RXMCGPIE : 1;	    /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXMCGPIE */
	volatile uint32_t RXCRCERPIE : 1;   /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXCRCERPIE */
	volatile uint32_t RXRUNTPIE : 1;    /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXRUNTPIE */
	volatile uint32_t RXJABERPIE : 1;   /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXJABERPIE */
	volatile uint32_t RXUSIZEGPIE : 1;  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUSIZEGPIE */
	volatile uint32_t RXOSIZEGPIE : 1;  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXOSIZEGPIE */
	volatile uint32_t RX64OCTGBPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX64OCTGBPIE */
	volatile uint32_t
		RX65T127OCTGBPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX65T127OCTGBPIE */
	volatile uint32_t
		RX128T255OCTGBPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX128T255OCTGBPIE */
	volatile uint32_t
		RX256T511OCTGBPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX256T511OCTGBPIE */
	volatile uint32_t
		RX512T1023OCTGBPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX512T1023OCTGBPIE */
	volatile uint32_t
		RX1024TMAXOCTGBPIE : 1;	  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RX1024TMAXOCTGBPIE */
	volatile uint32_t RXUCGPIE : 1;	  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXUCGPIE */
	volatile uint32_t RXLENERPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLENERPIE */
	volatile uint32_t RXORANGEPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXORANGEPIE */
	volatile uint32_t RXPAUSPIE : 1;   /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXPAUSPIE */
	volatile uint32_t RXFOVPIE : 1;	   /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXFOVPIE */
	volatile uint32_t RXVLANGBPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXVLANGBPIE */
	volatile uint32_t RXWDOGPIE : 1;   /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXWDOGPIE */
	volatile uint32_t RXDISPCGBIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISPCGBIE */
	volatile uint32_t RXDISOCGBIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXDISOCGBIE */
	volatile uint32_t RXLPIUSCIE : 1;  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPIUSCIE */
	volatile uint32_t RXLPITRCIE : 1;  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXLPITRCIE */
	volatile uint32_t RXALEPIE : 1;	   /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RXALEPIE */
	const volatile uint32_t
		Reserved_SGPPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGPPIE */
	const volatile uint32_t
		Reserved_SGFPIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_SGFPIE */
	const volatile uint32_t Reserved_30 : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_30 */
	const volatile uint32_t
		Reserved_RXPRMMCIE : 1; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESERVED_RXPRMMCIE */
};

/* The typedef declaration for register CORE_MMC_RECEIVE_INTERRUPT_ENABLE. */
typedef struct CORE_MMC_RECEIVE_INTERRUPT_ENABLE_s CORE_MMC_RECEIVE_INTERRUPT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE register. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_RESET 0x00000000
/* The byte offset of the CORE_MMC_RECEIVE_INTERRUPT_ENABLE register from the beginning of the
 * component. */
#define CORE_MMC_RECEIVE_INTERRUPT_ENABLE_OFST	0x80c

/*
 * Register : MMC_Transmit_Interrupt_Enable
 *
 * The MMC Transmit Interrupt Enable register maintains the enables for the
 * interrupts generated when transmit statistic counters reach the threshold value
 * programmed in the MMC Control register. This register is 32 bits wide.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE
 *  [1]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE
 *  [2]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE
 *  [3]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE
 *  [4]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE
 *  [5]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE
 *  [6]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE
 *  [7]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE
 *  [8]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE
 *  [9]     | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE
 *  [10]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE
 *  [11]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE
 *  [12]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE
 *  [13]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE
 *  [14]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE
 *  [15]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE
 *  [16]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE
 *  [17]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE
 *  [18]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE
 *  [19]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE
 *  [20]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE
 *  [21]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE
 *  [22]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE
 *  [23]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE
 *  [24]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE
 *  [25]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE
 *  [26]    | RW     | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE
 *  [30:27] | R      | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27
 *  [31]    | R      | 0x0   | CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE
 *
 */
/*
 * Field : TXGBOCTIE
 *
 * Tx Good Bad Octet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Tx_Octet_Count_Good_Bad_High and
 * Tx_Octet_Count_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_MSB	0
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_SET_MSK	0x00000001
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TXGBPKTIE
 *
 * Tx Good Bad Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Packet_Count_Good_Bad_High and Tx_Packet_Count_Good_Bad_Low counter or 32-bit
 * Tx_Packet_Count_Good_Bad_Low counter reaches the threshold value programmed in
 * the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_MSB	1
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_SET_MSK	0x00000002
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TXBCGPIE
 *
 * Tx Good Broadcast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Broadcast_Packets_Good_High and Tx_Broadcast_Packets_Good_Low counter or
 * 32-bit Tx_Broadcast_Packets_Good_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_MSB	       2
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_WIDTH      1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_SET_MSK    0x00000004
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_RESET      0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : TXMCGPIE
 *
 * Tx Good Multicast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Multicast_Packets_Good_High and Tx_Multicast_Packets_Good_Low counter or
 * 32-bit Tx_Multicast_Packets_Good_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_MSB	       3
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_WIDTH      1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_SET_MSK    0x00000008
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_RESET      0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : TX64OCTGBPIE
 *
 * Tx Good Bad 64 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_64Octets_Packets_Good_Bad_High and Tx_64Octets_Packets_Good_Bad_Low counter
 * or 32-bit Tx_64Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_LSB	   4
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_MSB	   4
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_WIDTH	   1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_SET_MSK	   0x00000010
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE register field value.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_CLR_MSK	   0xffffffef
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_RESET	   0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : TX65T127OCTGBPIE
 *
 * Tx Good Bad 65-to-127 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_65To127Octets_Packets_Good_Bad_High and Tx_65To127Octets_Packets_Good_Bad_Low
 * counter or 32-bit Tx_65To127Octets_Packets_Good_Bad_Low counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_LSB	       5
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_MSB	       5
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_WIDTH      1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_SET_MSK    0x00000020
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_RESET      0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : TX128T255OCTGBPIE
 *
 * Tx Good Bad 128-to-255 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_128To255Octets_Packets_Good_Bad_High and
 * Tx_128To255Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_128To255Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_LSB	6
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_MSB	6
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_SET_MSK	0x00000040
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_CLR_MSK	0xffffffbf
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE_SET(value)                            \
	(((value) << 6) & 0x00000040)

/*
 * Field : TX256T511OCTGBPIE
 *
 * Tx Good Bad 256-to-511 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_256To511Octets_Packets_Good_Bad_High and
 * Tx_256To511Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_256To511Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_LSB	7
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_MSB	7
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_SET_MSK	0x00000080
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_CLR_MSK	0xffffff7f
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE_SET(value)                            \
	(((value) << 7) & 0x00000080)

/*
 * Field : TX512T1023OCTGBPIE
 *
 * Tx Good Bad 512-to-1023 Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_512To1023Octets_Packets_Good_Bad_High and
 * Tx_512To1023Octets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_512To1023Octets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_LSB	 8
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_MSB	 8
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_SET_MSK	 0x00000100
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_CLR_MSK	 0xfffffeff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE field value from a register.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE register field value suitable
 * for setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE_SET(value)                           \
	(((value) << 8) & 0x00000100)

/*
 * Field : TX1024TMAXOCTGBPIE
 *
 * Tx Good Bad 1024-to-Max Octet Size Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_1024ToMaxOctets_Packets_Good_Bad_High and
 * Tx_1024ToMaxOctets_Packets_Good_Bad_Low counter or 32-bit
 * Tx_1024ToMaxOctets_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_LSB	 9
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_MSB	 9
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_SET_MSK	 0x00000200
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_CLR_MSK	 0xfffffdff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE field value from a register.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE register field value suitable
 * for setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE_SET(value)                           \
	(((value) << 9) & 0x00000200)

/*
 * Field : TXUCGBPIE
 *
 * Tx Good Bad Unicast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Unicast_Packets_Good_Bad_High and Tx_Unicast_Packets_Good_Bad_Low counter or
 * 32-bit Tx_Unicast_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_LSB	10
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_MSB	10
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_SET_MSK	0x00000400
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_CLR_MSK	0xfffffbff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : TXMCGBPIE
 *
 * Tx Good Bad Multicast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Multicast_Packets_Good_Bad_High and Tx_Multicast_Packets_Good_Bad_Low counter
 * or 32-bit Tx_Multicast_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_LSB	11
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_MSB	11
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_SET_MSK	0x00000800
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_CLR_MSK	0xfffff7ff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : TXBCGBPIE
 *
 * Tx Good Bad Broadcast Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Broadcast_Packets_Good_Bad_High and Tx_Broadcast_Packets_Good_Bad_Low counter
 * or 32-bit Tx_Broadcast_Packets_Good_Bad_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_LSB	12
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_MSB	12
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_SET_MSK	0x00001000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_CLR_MSK	0xffffefff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : TXUFLOWERPIE
 *
 * Tx Underflow Error Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit
 * Tx_Underflow_Error_Packets_High and Tx_Underflow_Error_Packets_Low counter or
 * 32-bit Tx_Underflow_Error_Packets_Low counter reaches the threshold value
 * programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_LSB	   13
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_MSB	   13
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_WIDTH	   1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_SET_MSK	   0x00002000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE register field value.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_CLR_MSK	   0xffffdfff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_RESET	   0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : TXGOCTIE
 *
 * Tx Good Octet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the Tx_Octet_Count_Good_High and
 * Tx_Octet_Count_Good_Low counter reaches the threshold value programmed in the
 * MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_LSB	       14
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_MSB	       14
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_WIDTH      1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_SET_MSK    0x00004000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_CLR_MSK    0xffffbfff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_RESET      0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : TXGPKTIE
 *
 * Tx Good Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit Tx_Packet_Count_Good_High
 * and Tx_Packet_Count_Good_Low counter or 32-bit Tx_Packet_Count_Good_Low counter
 * reaches the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_LSB	       15
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_MSB	       15
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_WIDTH      1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_SET_MSK    0x00008000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_RESET      0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : TXPAUSPIE
 *
 * Tx Pause Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit Tx_Pause_Packets_High and
 * Tx_Pause_Packets_Low counter or 32-bit Tx_Pause_Packets_Low counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_LSB	16
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_MSB	16
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_WIDTH	1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_SET_MSK	0x00010000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_CLR_MSK	0xfffeffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_RESET	0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : TXVLANGPIE
 *
 * Tx Good VLAN Packet Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when the 64-bit Tx_VLAN_Packets_Good_High
 * and Tx_VLAN_Packets_Good_Low counter or 32-bit Tx_VLAN_Packets_Good_Low reaches
 * the threshold value programmed in the MMC control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_LSB	 17
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_MSB	 17
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_SET_MSK	 0x00020000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_CLR_MSK	 0xfffdffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : TXLPIUSCIE
 *
 * Tx LPI microsecond Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when Tx_LPI_USEC_Cntr counter reaches the
 * threshold value programmed in the MMC counter register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_LSB	 18
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_MSB	 18
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_SET_MSK	 0x00040000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_CLR_MSK	 0xfffbffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : TXLPITRCIE
 *
 * Tx LPI Transition Counter Interrupt Enable
 *
 * Setting this bit enables the interrupt when Tx_LPI_Tran_Cntr counter reaches the
 * threshold value programmed in the MMC counter register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_LSB	 19
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_MSB	 19
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_SET_MSK	 0x00080000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_CLR_MSK	 0xfff7ffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : TXSCOLGPIE
 *
 * MMC Transmit Single Collision Good Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txsinglecol_g counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_E_DISABLE | 0x0   | MMC Transmit Single Collision
 * Good Packet :                                                                          |       |
 * Counter Interrupt Enable is disabled CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_E_ENABLE  |
 * 0x1   | MMC Transmit Single Collision Good Packet : |       | Counter Interrupt Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE
 *
 * MMC Transmit Single Collision Good Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE
 *
 * MMC Transmit Single Collision Good Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_LSB	 20
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_MSB	 20
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_SET_MSK	 0x00100000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_CLR_MSK	 0xffefffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : TXMCOLGPIE
 *
 * MMC Transmit Multiple Collision Good Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txmulticol_g counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_E_DISABLE | 0x0   | MMC Transmit Multiple
 * Collision Good Packet : |       | Counter Interrupt Enable is disabled
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_E_ENABLE  | 0x1   | MMC Transmit Multiple
 * Collision Good Packet : |       | Counter Interrupt Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE
 *
 * MMC Transmit Multiple Collision Good Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE
 *
 * MMC Transmit Multiple Collision Good Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_LSB	 21
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_MSB	 21
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_SET_MSK	 0x00200000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_CLR_MSK	 0xffdfffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : TXDEFPIE
 *
 * MMC Transmit Deferred Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txdeferred counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                    | Value | Description
 * :------------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_E_DISABLE | 0x0   | MMC Transmit Deferred Packet
 * Counter Interrupt :                                                                        | |
 * Enable is disabled CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_E_ENABLE  | 0x1   | MMC Transmit
 * Deferred Packet Counter Interrupt : |       | Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE
 *
 * MMC Transmit Deferred Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE
 *
 * MMC Transmit Deferred Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_LSB	       22
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_MSB	       22
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_WIDTH      1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_SET_MSK    0x00400000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_RESET      0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE register field value suitable for setting
 * the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : TXLATCOLPIE
 *
 * MMC Transmit Late Collision Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txlatecol counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                       | Value | Description
 * :---------------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_E_DISABLE | 0x0   | MMC Transmit Late Collision
 * Packet Counter :                                                                           | |
 * Interrupt Enable is disabled CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_E_ENABLE  | 0x1   |
 * MMC Transmit Late Collision Packet Counter : |       | Interrupt Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE
 *
 * MMC Transmit Late Collision Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE
 *
 * MMC Transmit Late Collision Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_E_ENABLE	 0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_LSB	  23
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_MSB	  23
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_WIDTH	  1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_SET_MSK	  0x00800000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE register field value.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_CLR_MSK	  0xff7fffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_RESET	  0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : TXEXCOLPIE
 *
 * MMC Transmit Excessive Collision Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txexcesscol counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_E_DISABLE | 0x0   | MMC Transmit Excessive
 * Collision Packet Counter : |       | Interrupt Enable is disabled
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_E_ENABLE  | 0x1   | MMC Transmit Excessive
 * Collision Packet Counter : |       | Interrupt Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE
 *
 * MMC Transmit Excessive Collision Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE
 *
 * MMC Transmit Excessive Collision Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_LSB	 24
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_MSB	 24
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_SET_MSK	 0x01000000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_CLR_MSK	 0xfeffffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : TXCARERPIE
 *
 * MMC Transmit Carrier Error Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txcarriererror counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_E_DISABLE | 0x0   | MMC Transmit Carrier Error
 * Packet Counter :                                                                          | |
 * Interrupt Enable is disabled CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_E_ENABLE  | 0x1   |
 * MMC Transmit Carrier Error Packet Counter : |       | Interrupt Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE
 *
 * MMC Transmit Carrier Error Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE
 *
 * MMC Transmit Carrier Error Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_LSB	 25
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_MSB	 25
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_SET_MSK	 0x02000000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_CLR_MSK	 0xfdffffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : TXEXDEFPIE
 *
 * MMC Transmit Excessive Deferral Packet Counter Interrupt Enable
 *
 * Setting this bit masks the interrupt when the txexcessdef counter reaches the
 * threshold value programmed in the MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_E_DISABLE | 0x0   | MMC Transmit Excessive
 * Deferral Packet Counter : |       | Interrupt Enable is disabled
 *  CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_E_ENABLE  | 0x1   | MMC Transmit Excessive
 * Deferral Packet Counter : |       | Interrupt Enable is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE
 *
 * MMC Transmit Excessive Deferral Packet Counter Interrupt Enable is disabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE
 *
 * MMC Transmit Excessive Deferral Packet Counter Interrupt Enable is enabled
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_LSB	 26
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_MSB	 26
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_WIDTH	 1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_SET_MSK	 0x04000000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE register field value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_CLR_MSK	 0xfbffffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_RESET	 0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : Reserved_30_27
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_LSB	     27
/* The Most Significant Bit (MSB) position of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27
 * register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_MSB	     30
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_WIDTH	     4
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 register field value.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_SET_MSK    0x78000000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_CLR_MSK    0x87ffffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_RESET	     0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 field value from a register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_GET(value) (((value)&0x78000000) >> 27)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 register field value suitable for
 * setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27_SET(value) (((value) << 27) & 0x78000000)

/*
 * Field : Reserved_TXPRMMCIE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_LSB     31
/* The Most Significant Bit (MSB) position of the
 * CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_MSB     31
/* The width in bits of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_WIDTH   1
/* The mask used to set the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_SET_MSK 0x80000000
/* The mask used to clear the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field
 * value. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_CLR_MSK 0x7fffffff
/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_RESET   0x0
/* Extracts the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE field value from a register.
 */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_GET(value)                           \
	(((value)&0x80000000) >> 31)
/* Produces a CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE register field value suitable
 * for setting the register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE_SET(value)                           \
	(((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_TRANSMIT_INTERRUPT_ENABLE.
 */
struct CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_s {
	volatile uint32_t TXGBOCTIE : 1;    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBOCTIE */
	volatile uint32_t TXGBPKTIE : 1;    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGBPKTIE */
	volatile uint32_t TXBCGPIE : 1;	    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGPIE */
	volatile uint32_t TXMCGPIE : 1;	    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGPIE */
	volatile uint32_t TX64OCTGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX64OCTGBPIE */
	volatile uint32_t
		TX65T127OCTGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX65T127OCTGBPIE */
	volatile uint32_t
		TX128T255OCTGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX128T255OCTGBPIE */
	volatile uint32_t
		TX256T511OCTGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX256T511OCTGBPIE */
	volatile uint32_t
		TX512T1023OCTGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX512T1023OCTGBPIE */
	volatile uint32_t
		TX1024TMAXOCTGBPIE : 1;	 /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TX1024TMAXOCTGBPIE */
	volatile uint32_t TXUCGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUCGBPIE */
	volatile uint32_t TXMCGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCGBPIE */
	volatile uint32_t TXBCGBPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXBCGBPIE */
	volatile uint32_t TXUFLOWERPIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXUFLOWERPIE */
	volatile uint32_t TXGOCTIE : 1;	    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGOCTIE */
	volatile uint32_t TXGPKTIE : 1;	    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXGPKTIE */
	volatile uint32_t TXPAUSPIE : 1;    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXPAUSPIE */
	volatile uint32_t TXVLANGPIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXVLANGPIE */
	volatile uint32_t TXLPIUSCIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPIUSCIE */
	volatile uint32_t TXLPITRCIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLPITRCIE */
	volatile uint32_t TXSCOLGPIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXSCOLGPIE */
	volatile uint32_t TXMCOLGPIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXMCOLGPIE */
	volatile uint32_t TXDEFPIE : 1;	    /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXDEFPIE */
	volatile uint32_t TXLATCOLPIE : 1;  /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXLATCOLPIE */
	volatile uint32_t TXEXCOLPIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXCOLPIE */
	volatile uint32_t TXCARERPIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXCARERPIE */
	volatile uint32_t TXEXDEFPIE : 1;   /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_TXEXDEFPIE */
	const volatile uint32_t
		Reserved_30_27 : 4; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_30_27 */
	const volatile uint32_t
		Reserved_TXPRMMCIE : 1; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESERVED_TXPRMMCIE */
};

/* The typedef declaration for register CORE_MMC_TRANSMIT_INTERRUPT_ENABLE. */
typedef struct CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_s CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE register. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_RESET 0x00000000
/* The byte offset of the CORE_MMC_TRANSMIT_INTERRUPT_ENABLE register from the beginning of the
 * component. */
#define CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_OFST	 0x810

/*
 * Register : Tx_Octet_Count_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted octet count, excluding
 * preamble, in good and bad packets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO
 *
 */
/*
 * Field : TXOCTGBLO
 *
 * Tx Good Bad Octet Count Low
 *
 * This field indicates the lower 32 bits of transmitted octet count, where octet
 * count is the number of bytes transmitted, excluding preamble, in good and bad
 * packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO
 * register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO
 * register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_MSB	      31
/* The width in bits of the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_WIDTH      32
/* The mask used to set the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_RESET      0x0
/* Extracts the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO field value from a register. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO register field value suitable for setting
 * the register. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_OCTET_COUNT_GOOD_BAD_LOW.
 */
struct CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_s {
	const volatile uint32_t TXOCTGBLO : 32; /* CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_TXOCTGBLO */
};

/* The typedef declaration for register CORE_TX_OCTET_COUNT_GOOD_BAD_LOW. */
typedef struct CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_s CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW register. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_OCTET_COUNT_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_OFST  0x814

/*
 * Register : Tx_Octet_Count_Good_Bad_High
 *
 * This register provides upper 32 bits of transmitted octet count, excluding
 * preamble, in good and bad packets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI
 *
 */
/*
 * Field : TXOCTGBHI
 *
 * Tx Good Bad Octet Count High
 *
 * This field indicates upper 32 bits of transmitted octet count, where octet count
 * is the number of bytes transmitted, excluding preamble, in good and bad packets
 * (optional).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI
 * register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI
 * register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_MSB	       31
/* The width in bits of the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_WIDTH      32
/* The mask used to set the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI register field. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_RESET      0x0
/* Extracts the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI field value from a register. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI register field value suitable for setting
 * the register. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH.
 */
struct CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_s {
	const volatile uint32_t TXOCTGBHI : 32; /* CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_TXOCTGBHI */
};

/* The typedef declaration for register CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH. */
typedef struct CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_s CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH register. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_RESET 0x00000000
/* The byte offset of the CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH register from the beginning of the
 * component. */
#define CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_OFST	0x818

/*
 * Register : Tx_Packet_Count_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted good and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO
 *
 */
/*
 * Field : TXPKTGBLO
 *
 * Tx Good Bad Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO
 * register field. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO
 * register field. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_MSB	       31
/* The width in bits of the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO register field. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_WIDTH      32
/* The mask used to set the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO register field value. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO register field value. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO register field. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_RESET      0x0
/* Extracts the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO field value from a register. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO register field value suitable for setting
 * the register. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_PACKET_COUNT_GOOD_BAD_LOW.
 */
struct CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_s {
	const volatile uint32_t TXPKTGBLO : 32; /* CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_TXPKTGBLO */
};

/* The typedef declaration for register CORE_TX_PACKET_COUNT_GOOD_BAD_LOW. */
typedef struct CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_s CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW register. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_PACKET_COUNT_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_OFST	0x81c

/*
 * Register : Tx_Broadcast_Packets_Good_Low
 *
 * This register provides lower 32 bits of transmitted good broadcast packets
 * count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO
 *
 */
/*
 * Field : TXBCASTGLO
 *
 * Tx Good Broadcast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * broadcast packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO
 * register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO
 * register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_MSB	 31
/* The width in bits of the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_WIDTH	 32
/* The mask used to set the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO register field value. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO register field value. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_RESET	 0x0
/* Extracts the CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO field value from a register. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO register field value suitable for
 * setting the register. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_BROADCAST_PACKETS_GOOD_LOW.
 */
struct CORE_TX_BROADCAST_PACKETS_GOOD_LOW_s {
	const volatile uint32_t TXBCASTGLO : 32; /* CORE_TX_BROADCAST_PACKETS_GOOD_LOW_TXBCASTGLO */
};

/* The typedef declaration for register CORE_TX_BROADCAST_PACKETS_GOOD_LOW. */
typedef struct CORE_TX_BROADCAST_PACKETS_GOOD_LOW_s CORE_TX_BROADCAST_PACKETS_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_BROADCAST_PACKETS_GOOD_LOW register. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_BROADCAST_PACKETS_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_LOW_OFST	 0x824

/*
 * Register : Tx_Multicast_Packets_Good_Low
 *
 * This register provides lower 32 bits of transmitted good multicast packets
 * count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO
 *
 */
/*
 * Field : TXMCASTGLO
 *
 * Tx Good Multicast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * multicast packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO
 * register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO
 * register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_MSB	 31
/* The width in bits of the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_WIDTH	 32
/* The mask used to set the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO register field value. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO register field value. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_RESET	 0x0
/* Extracts the CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO field value from a register. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO register field value suitable for
 * setting the register. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_MULTICAST_PACKETS_GOOD_LOW.
 */
struct CORE_TX_MULTICAST_PACKETS_GOOD_LOW_s {
	const volatile uint32_t TXMCASTGLO : 32; /* CORE_TX_MULTICAST_PACKETS_GOOD_LOW_TXMCASTGLO */
};

/* The typedef declaration for register CORE_TX_MULTICAST_PACKETS_GOOD_LOW. */
typedef struct CORE_TX_MULTICAST_PACKETS_GOOD_LOW_s CORE_TX_MULTICAST_PACKETS_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_MULTICAST_PACKETS_GOOD_LOW register. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_MULTICAST_PACKETS_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_LOW_OFST	 0x82c

/*
 * Register : Tx_64Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted 64 octet size good and bad
 * packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO
 *
 */
/*
 * Field : TX64OCTGBLO
 *
 * Tx Good Bad 64 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad packets transmitted that are of size 64 bytes, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO
 * register field. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO
 * register field. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_MSB	     31
/* The width in bits of the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO register field. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_WIDTH	     32
/* The mask used to set the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO register field value.
 */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO register field
 * value. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO register field. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_RESET	     0x0
/* Extracts the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO field value from a register. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO register field value suitable for
 * setting the register. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		TX64OCTGBLO : 32; /* CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_TX64OCTGBLO */
};

/* The typedef declaration for register CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_s CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x834

/*
 * Register : Tx_65To127Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted 65-to-127 octet size good
 * and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO
 *
 */
/*
 * Field : TX65_127OCTGBLO
 *
 * Tx Good Bad 65-to-127 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 65-to-127-byte good and bad packets transmitted, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register field. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_LSB	   0
/* The Most Significant Bit (MSB) position of the
 * CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register field. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_MSB	   31
/* The width in bits of the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register
 * field. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_WIDTH   32
/* The mask used to set the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register
 * field value. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register
 * field value. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register field.
 */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_RESET   0x0
/* Extracts the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO field value from a
 * register. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_GET(value)                      \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO_SET(value)                      \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t TX65_127OCTGBLO : 32; /* CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_TX65_127OCTGBLO
						       */
};

/* The typedef declaration for register CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of
 * the component. */
#define CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_OFST	 0x83c

/*
 * Register : Tx_128To255Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted 128-to-255 octet size good
 * and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO
 *
 */
/*
 * Field : TX128_255OCTGBLO
 *
 * Tx Good Bad 128-to-255 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 128-to-255-byte good and bad packets transmitted, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register field. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register field. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_MSB     31
/* The width in bits of the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register
 * field. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_WIDTH   32
/* The mask used to set the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register
 * field value. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register
 * field value. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register
 * field. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_RESET   0x0
/* Extracts the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO field value from a
 * register. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_GET(value)                    \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO_SET(value)                    \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t TX128_255OCTGBLO : 32; /* CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_TX128_255OCTGBLO
							*/
};

/* The typedef declaration for register CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of
 * the component. */
#define CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x844

/*
 * Register : Tx_256To511Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted 256-to-511 octet size good
 * and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO
 *
 */
/*
 * Field : TX256_511OCTGBLO
 *
 * Tx Good Bad 256-to-511 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 256-to-511-byte good and bad packets transmitted, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register field. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register field. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_MSB     31
/* The width in bits of the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register
 * field. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_WIDTH   32
/* The mask used to set the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register
 * field value. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register
 * field value. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register
 * field. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_RESET   0x0
/* Extracts the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO field value from a
 * register. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_GET(value)                    \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO_SET(value)                    \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t TX256_511OCTGBLO : 32; /* CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_TX256_511OCTGBLO
							*/
};

/* The typedef declaration for register CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of
 * the component. */
#define CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x84c

/*
 * Register : Tx_512To1023Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted 512-to-1023 octet size good
 * and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO
 *
 */
/*
 * Field : TX512_1023OCTGBLO
 *
 * Tx Good Bad 512-to-1023 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 512-to-1023-byte good and bad packets transmitted, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO register field. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO register field. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_MSB     31
/* The width in bits of the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO register
 * field. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_WIDTH   32
/* The mask used to set the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO register
 * field value. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO
 * register field value. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO register
 * field. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_RESET   0x0
/* Extracts the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO field value from a
 * register. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_GET(value)                  \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO_SET(value)                  \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t TX512_1023OCTGBLO : 32; /* CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_TX512_1023OCTGBLO
							 */
};

/* The typedef declaration for register CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning
 * of the component. */
#define CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x854

/*
 * Register : Tx_1024ToMaxOctets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted 1024-tomaxsize octet size
 * good and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO
 *
 */
/*
 * Field : TX1024_MAXOCTGBLO
 *
 * Tx Good Bad 1024-tomaxsize Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of 1024
 * -tomaxsize-byte (inclusive) good and bad packets transmitted, excluding
 * preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO register field. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO register field. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_MSB     31
/* The width in bits of the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO register
 * field. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_WIDTH   32
/* The mask used to set the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO register
 * field value. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO
 * register field value. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO register
 * field. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_RESET   0x0
/* Extracts the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO field value from a
 * register. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_GET(value)                  \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO register field value
 * suitable for setting the register. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO_SET(value)                  \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t TX1024_MAXOCTGBLO : 32; /* CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_TX1024_MAXOCTGBLO
							 */
};

/* The typedef declaration for register CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW register from the beginning
 * of the component. */
#define CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x85c

/*
 * Register : Tx_Unicast_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted good bad unicast packets
 * count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO
 *
 */
/*
 * Field : TXUCASTGBLO
 *
 * Tx Good Bad Unicast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad unicast packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO
 * register field. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO
 * register field. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_MSB	    31
/* The width in bits of the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO register field. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_WIDTH	    32
/* The mask used to set the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO register field value.
 */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO register field value.
 */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO register field. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_RESET	    0x0
/* Extracts the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO field value from a register. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO register field value suitable for
 * setting the register. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		TXUCASTGBLO : 32; /* CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_TXUCASTGBLO */
};

/* The typedef declaration for register CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_s CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_OFST  0x864

/*
 * Register : Tx_Multicast_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted good bad multicast packets
 * count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO
 *
 */
/*
 * Field : TXMCASTGBLO
 *
 * Tx Good Bad Multicast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad multicast packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO
 * register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_MSB	      31
/* The width in bits of the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_WIDTH      32
/* The mask used to set the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO register field value.
 */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO register field
 * value. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO register field. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_RESET      0x0
/* Extracts the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO field value from a register. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO register field value suitable for
 * setting the register. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		TXMCASTGBLO : 32; /* CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_TXMCASTGBLO */
};

/* The typedef declaration for register CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_s CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_OFST  0x86c

/*
 * Register : Tx_Broadcast_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of transmitted good bad broadcast packets
 * count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO
 *
 */
/*
 * Field : TXBCASTGBLO
 *
 * Tx Good Bad Broadcast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad broadcast packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO
 * register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_MSB	      31
/* The width in bits of the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_WIDTH      32
/* The mask used to set the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO register field value.
 */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO register field
 * value. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO register field. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_RESET      0x0
/* Extracts the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO field value from a register. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO register field value suitable for
 * setting the register. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		TXBCASTGBLO : 32; /* CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_TXBCASTGBLO */
};

/* The typedef declaration for register CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_s CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW register. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_OFST  0x874

/*
 * Register : Tx_Underflow_Error_Packets_Low
 *
 * This register provides lower 32 bits of transmitted packets aborted due to
 * packet underflow error count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO
 *
 */
/*
 * Field : TXUNDRFLWLO
 *
 * Tx Underflow Error Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * packets aborted due to packet underflow error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO
 * register field. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO
 * register field. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_MSB	   31
/* The width in bits of the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO register field. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_WIDTH	   32
/* The mask used to set the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO register field value. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO register field value.
 */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_CLR_MSK	   0x00000000
/* The reset value of the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO register field. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_RESET	   0x0
/* Extracts the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO field value from a register. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO register field value suitable for
 * setting the register. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW.
 */
struct CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_s {
	const volatile uint32_t
		TXUNDRFLWLO : 32; /* CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_TXUNDRFLWLO */
};

/* The typedef declaration for register CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW. */
typedef struct CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_s CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW register. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_OFST  0x87c

/*
 * Register : Tx_Octet_Count_Good_Low
 *
 * This register provides lower 32 bits of transmitted good octets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO
 *
 */
/*
 * Field : TXOCTGLO
 *
 * Tx Good Octet Count Low
 *
 * This field indicates lower 32 bits of the transmitted octet count, where the
 * octet count is the number of bytes transmitted, excluding preamble, in good
 * packets only.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register
 * field. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register
 * field. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_MSB	 31
/* The width in bits of the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register field. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_WIDTH	 32
/* The mask used to set the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register field. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_RESET	 0x0
/* Extracts the CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO field value from a register. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO register field value suitable for setting the
 * register. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_OCTET_COUNT_GOOD_LOW.
 */
struct CORE_TX_OCTET_COUNT_GOOD_LOW_s {
	const volatile uint32_t TXOCTGLO : 32; /* CORE_TX_OCTET_COUNT_GOOD_LOW_TXOCTGLO */
};

/* The typedef declaration for register CORE_TX_OCTET_COUNT_GOOD_LOW. */
typedef struct CORE_TX_OCTET_COUNT_GOOD_LOW_s CORE_TX_OCTET_COUNT_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_LOW register. */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_OCTET_COUNT_GOOD_LOW register from the beginning of the component.
 */
#define CORE_TX_OCTET_COUNT_GOOD_LOW_OFST  0x884

/*
 * Register : Tx_Octet_Count_Good_High
 *
 * This register provides upper 32 bits of transmitted good octets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI
 *
 */
/*
 * Field : TXOCTGHI
 *
 * Tx Good Octet Count High
 *
 * This field indicates upper 32 bits of the transmitted octet count, where the
 * octet count is the number of bytes transmitted, excluding preamble, in good
 * packets only (optional).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register
 * field. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register
 * field. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_MSB	  31
/* The width in bits of the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register field. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_WIDTH	  32
/* The mask used to set the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register field value. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_CLR_MSK	  0x00000000
/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register field. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_RESET	  0x0
/* Extracts the CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI field value from a register. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI register field value suitable for setting the
 * register. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_OCTET_COUNT_GOOD_HIGH.
 */
struct CORE_TX_OCTET_COUNT_GOOD_HIGH_s {
	const volatile uint32_t TXOCTGHI : 32; /* CORE_TX_OCTET_COUNT_GOOD_HIGH_TXOCTGHI */
};

/* The typedef declaration for register CORE_TX_OCTET_COUNT_GOOD_HIGH. */
typedef struct CORE_TX_OCTET_COUNT_GOOD_HIGH_s CORE_TX_OCTET_COUNT_GOOD_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_OCTET_COUNT_GOOD_HIGH register. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_RESET 0x00000000
/* The byte offset of the CORE_TX_OCTET_COUNT_GOOD_HIGH register from the beginning of the
 * component. */
#define CORE_TX_OCTET_COUNT_GOOD_HIGH_OFST  0x888

/*
 * Register : Tx_Packet_Count_Good_Low
 *
 * This register provides lower 32 bits of transmitted good packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO
 *
 */
/*
 * Field : TXPKTGLO
 *
 * Tx Good Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register
 * field. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register
 * field. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_MSB	  31
/* The width in bits of the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register field. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_WIDTH	  32
/* The mask used to set the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register field value. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register field value. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_CLR_MSK	  0x00000000
/* The reset value of the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register field. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_RESET	  0x0
/* Extracts the CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO field value from a register. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO register field value suitable for setting the
 * register. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_PACKET_COUNT_GOOD_LOW.
 */
struct CORE_TX_PACKET_COUNT_GOOD_LOW_s {
	const volatile uint32_t TXPKTGLO : 32; /* CORE_TX_PACKET_COUNT_GOOD_LOW_TXPKTGLO */
};

/* The typedef declaration for register CORE_TX_PACKET_COUNT_GOOD_LOW. */
typedef struct CORE_TX_PACKET_COUNT_GOOD_LOW_s CORE_TX_PACKET_COUNT_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_PACKET_COUNT_GOOD_LOW register. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_PACKET_COUNT_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_TX_PACKET_COUNT_GOOD_LOW_OFST  0x88c

/*
 * Register : Tx_Pause_Packets_Low
 *
 * This register provides lower 32 bits of transmitted Pause packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO
 *
 */
/*
 * Field : TXPAUSEGLO
 *
 * Tx Pause Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * PAUSE packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register
 * field. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register
 * field. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_MSB	31
/* The width in bits of the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register field. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_WIDTH	32
/* The mask used to set the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register field value. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register field value. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_CLR_MSK	0x00000000
/* The reset value of the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register field. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_RESET	0x0
/* Extracts the CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO field value from a register. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO register field value suitable for setting the
 * register. */
#define CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_PAUSE_PACKETS_LOW.
 */
struct CORE_TX_PAUSE_PACKETS_LOW_s {
	const volatile uint32_t TXPAUSEGLO : 32; /* CORE_TX_PAUSE_PACKETS_LOW_TXPAUSEGLO */
};

/* The typedef declaration for register CORE_TX_PAUSE_PACKETS_LOW. */
typedef struct CORE_TX_PAUSE_PACKETS_LOW_s CORE_TX_PAUSE_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_PAUSE_PACKETS_LOW register. */
#define CORE_TX_PAUSE_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_PAUSE_PACKETS_LOW register from the beginning of the component. */
#define CORE_TX_PAUSE_PACKETS_LOW_OFST	0x894

/*
 * Register : Tx_VLAN_Packets_Good_Low
 *
 * This register provides lower 32 bits of transmitted good VLAN packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO
 *
 */
/*
 * Field : TXVLANGLO
 *
 * Tx Good VLAN Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * VLAN packets transmitted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register
 * field. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register
 * field. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_MSB	   31
/* The width in bits of the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register field. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_WIDTH	   32
/* The mask used to set the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register field value. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register field value. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_CLR_MSK	   0x00000000
/* The reset value of the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register field. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_RESET	   0x0
/* Extracts the CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO field value from a register. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO register field value suitable for setting the
 * register. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_VLAN_PACKETS_GOOD_LOW.
 */
struct CORE_TX_VLAN_PACKETS_GOOD_LOW_s {
	const volatile uint32_t TXVLANGLO : 32; /* CORE_TX_VLAN_PACKETS_GOOD_LOW_TXVLANGLO */
};

/* The typedef declaration for register CORE_TX_VLAN_PACKETS_GOOD_LOW. */
typedef struct CORE_TX_VLAN_PACKETS_GOOD_LOW_s CORE_TX_VLAN_PACKETS_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_VLAN_PACKETS_GOOD_LOW register. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_TX_VLAN_PACKETS_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_TX_VLAN_PACKETS_GOOD_LOW_OFST  0x89c

/*
 * Register : Tx_LPI_USEC_Cntr
 *
 * This register provides duration in microsecond for which MAC was in Tx LPI.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_LPI_USEC_CNTR_TXLPIUSC
 *
 */
/*
 * Field : TXLPIUSC
 *
 * Tx LPI microsecond Count
 *
 * This field indicates the number of microseconds DWC_xgmac is in Tx LPI state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_MSB	  31
/* The width in bits of the CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_WIDTH	  32
/* The mask used to set the CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field value. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field value. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_CLR_MSK	  0x00000000
/* The reset value of the CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_RESET	  0x0
/* Extracts the CORE_TX_LPI_USEC_CNTR_TXLPIUSC field value from a register. */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_LPI_USEC_CNTR_TXLPIUSC register field value suitable for setting the register.
 */
#define CORE_TX_LPI_USEC_CNTR_TXLPIUSC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_LPI_USEC_CNTR.
 */
struct CORE_TX_LPI_USEC_CNTR_s {
	const volatile uint32_t TXLPIUSC : 32; /* CORE_TX_LPI_USEC_CNTR_TXLPIUSC */
};

/* The typedef declaration for register CORE_TX_LPI_USEC_CNTR. */
typedef struct CORE_TX_LPI_USEC_CNTR_s CORE_TX_LPI_USEC_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_LPI_USEC_CNTR register. */
#define CORE_TX_LPI_USEC_CNTR_RESET 0x00000000
/* The byte offset of the CORE_TX_LPI_USEC_CNTR register from the beginning of the component. */
#define CORE_TX_LPI_USEC_CNTR_OFST  0x8a4

/*
 * Register : Tx_LPI_Tran_Cntr
 *
 * This register provides number of times MAC transitioned to Tx LPI state.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_LPI_TRAN_CNTR_TXLPITRC
 *
 */
/*
 * Field : TXLPITRC
 *
 * Tx LPI Transition Count
 *
 * This field indicates the number of times DWC_xgmac entered to Tx LPI state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_MSB	  31
/* The width in bits of the CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_WIDTH	  32
/* The mask used to set the CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field value. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field value. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_CLR_MSK	  0x00000000
/* The reset value of the CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_RESET	  0x0
/* Extracts the CORE_TX_LPI_TRAN_CNTR_TXLPITRC field value from a register. */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_LPI_TRAN_CNTR_TXLPITRC register field value suitable for setting the register.
 */
#define CORE_TX_LPI_TRAN_CNTR_TXLPITRC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_LPI_TRAN_CNTR.
 */
struct CORE_TX_LPI_TRAN_CNTR_s {
	const volatile uint32_t TXLPITRC : 32; /* CORE_TX_LPI_TRAN_CNTR_TXLPITRC */
};

/* The typedef declaration for register CORE_TX_LPI_TRAN_CNTR. */
typedef struct CORE_TX_LPI_TRAN_CNTR_s CORE_TX_LPI_TRAN_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_LPI_TRAN_CNTR register. */
#define CORE_TX_LPI_TRAN_CNTR_RESET 0x00000000
/* The byte offset of the CORE_TX_LPI_TRAN_CNTR register from the beginning of the component. */
#define CORE_TX_LPI_TRAN_CNTR_OFST  0x8a8

/*
 * Register : Rx_Packet_Count_Good_Bad_Low
 *
 * This register provides lower 32 bits of received good and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO
 *
 */
/*
 * Field : RXPKTGBLO
 *
 * Rx Good Bad Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad packets received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO
 * register field. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO
 * register field. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_MSB	       31
/* The width in bits of the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO register field. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_WIDTH      32
/* The mask used to set the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO register field value. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO register field value. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO register field. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_RESET      0x0
/* Extracts the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO field value from a register. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO register field value suitable for setting
 * the register. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_PACKET_COUNT_GOOD_BAD_LOW.
 */
struct CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_s {
	const volatile uint32_t RXPKTGBLO : 32; /* CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RXPKTGBLO */
};

/* The typedef declaration for register CORE_RX_PACKET_COUNT_GOOD_BAD_LOW. */
typedef struct CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_s CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW register. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_PACKET_COUNT_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_OFST	0x900

/*
 * Register : Rx_Octet_Count_Good_Bad_Low
 *
 * This register provides lower 32 bits of received octet count, excluding
 * preamble, in good and bad packets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO
 *
 */
/*
 * Field : RXOCTGBLO
 *
 * Rx Good Bad Octet Count Low
 *
 * This field indicates the lower 32 bits of received octet count, where octet
 * count is the number of bytes received, excluding preamble, in good and bad
 * packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO
 * register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO
 * register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_MSB	      31
/* The width in bits of the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_WIDTH      32
/* The mask used to set the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_RESET      0x0
/* Extracts the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO field value from a register. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO register field value suitable for setting
 * the register. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_OCTET_COUNT_GOOD_BAD_LOW.
 */
struct CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_s {
	const volatile uint32_t RXOCTGBLO : 32; /* CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RXOCTGBLO */
};

/* The typedef declaration for register CORE_RX_OCTET_COUNT_GOOD_BAD_LOW. */
typedef struct CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_s CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW register. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_OCTET_COUNT_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_OFST  0x908

/*
 * Register : Rx_Octet_Count_Good_Bad_High
 *
 * This register provides upper 32 bits of received octet count, excluding
 * preamble, in good and bad packets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI
 *
 */
/*
 * Field : RXOCTGBHI
 *
 * Rx Good Bad Octet Count High
 *
 * This field indicates upper 32 bits of received octet count, where octet count is
 * the number of bytes received, excluding preamble, in good and bad packets
 * (optional).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI
 * register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI
 * register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_MSB	       31
/* The width in bits of the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_WIDTH      32
/* The mask used to set the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI register field. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_RESET      0x0
/* Extracts the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI field value from a register. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI register field value suitable for setting
 * the register. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH.
 */
struct CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_s {
	const volatile uint32_t RXOCTGBHI : 32; /* CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RXOCTGBHI */
};

/* The typedef declaration for register CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH. */
typedef struct CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_s CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH register. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_RESET 0x00000000
/* The byte offset of the CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH register from the beginning of the
 * component. */
#define CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_OFST	0x90c

/*
 * Register : Rx_Octet_Count_Good_Low
 *
 * This register provides lower 32 bits of received good octets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO
 *
 */
/*
 * Field : RXOCTGLO
 *
 * Rx Good Octet Count Low
 *
 * This field indicates lower 32 bits of the received octet count, where the octet
 * count is the number of bytes received, excluding preamble, in good packets only.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register
 * field. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register
 * field. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_MSB	 31
/* The width in bits of the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register field. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_WIDTH	 32
/* The mask used to set the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register field. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_RESET	 0x0
/* Extracts the CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO field value from a register. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO register field value suitable for setting the
 * register. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_OCTET_COUNT_GOOD_LOW.
 */
struct CORE_RX_OCTET_COUNT_GOOD_LOW_s {
	const volatile uint32_t RXOCTGLO : 32; /* CORE_RX_OCTET_COUNT_GOOD_LOW_RXOCTGLO */
};

/* The typedef declaration for register CORE_RX_OCTET_COUNT_GOOD_LOW. */
typedef struct CORE_RX_OCTET_COUNT_GOOD_LOW_s CORE_RX_OCTET_COUNT_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_LOW register. */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_OCTET_COUNT_GOOD_LOW register from the beginning of the component.
 */
#define CORE_RX_OCTET_COUNT_GOOD_LOW_OFST  0x910

/*
 * Register : Rx_Octet_Count_Good_High
 *
 * This register provides upper 32 bits of received good octets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI
 *
 */
/*
 * Field : RXOCTGHI
 *
 * Rx Good Octet Count High
 *
 * This field indicates upper 32 bits of the received octet count, where the octet
 * count is the number of bytes received, excluding preamble, in good packets only
 * (optional).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register
 * field. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register
 * field. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_MSB	  31
/* The width in bits of the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register field. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_WIDTH	  32
/* The mask used to set the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register field value. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_CLR_MSK	  0x00000000
/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register field. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_RESET	  0x0
/* Extracts the CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI field value from a register. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI register field value suitable for setting the
 * register. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_OCTET_COUNT_GOOD_HIGH.
 */
struct CORE_RX_OCTET_COUNT_GOOD_HIGH_s {
	const volatile uint32_t RXOCTGHI : 32; /* CORE_RX_OCTET_COUNT_GOOD_HIGH_RXOCTGHI */
};

/* The typedef declaration for register CORE_RX_OCTET_COUNT_GOOD_HIGH. */
typedef struct CORE_RX_OCTET_COUNT_GOOD_HIGH_s CORE_RX_OCTET_COUNT_GOOD_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_OCTET_COUNT_GOOD_HIGH register. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_RESET 0x00000000
/* The byte offset of the CORE_RX_OCTET_COUNT_GOOD_HIGH register from the beginning of the
 * component. */
#define CORE_RX_OCTET_COUNT_GOOD_HIGH_OFST  0x914

/*
 * Register : Rx_Broadcast_Packets_Good_Low
 *
 * This register provides lower 32 bits of received good broadcast packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO
 *
 */
/*
 * Field : RXBCASTGLO
 *
 * Rx Good Broadcast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * broadcast packets received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO
 * register field. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO
 * register field. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_MSB	 31
/* The width in bits of the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO register field. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_WIDTH	 32
/* The mask used to set the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO register field value. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO register field value. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO register field. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_RESET	 0x0
/* Extracts the CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO field value from a register. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO register field value suitable for
 * setting the register. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_BROADCAST_PACKETS_GOOD_LOW.
 */
struct CORE_RX_BROADCAST_PACKETS_GOOD_LOW_s {
	const volatile uint32_t RXBCASTGLO : 32; /* CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RXBCASTGLO */
};

/* The typedef declaration for register CORE_RX_BROADCAST_PACKETS_GOOD_LOW. */
typedef struct CORE_RX_BROADCAST_PACKETS_GOOD_LOW_s CORE_RX_BROADCAST_PACKETS_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_BROADCAST_PACKETS_GOOD_LOW register. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_BROADCAST_PACKETS_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_RX_BROADCAST_PACKETS_GOOD_LOW_OFST	 0x918

/*
 * Register : Rx_Multicast_Packets_Good_Low
 *
 * This register provides lower 32 bits of received good multicast packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO
 *
 */
/*
 * Field : RXMCASTGLO
 *
 * Rx Good Multicast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * multicast packets received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO
 * register field. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO
 * register field. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_MSB	 31
/* The width in bits of the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO register field. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_WIDTH	 32
/* The mask used to set the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO register field value. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO register field value. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO register field. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_RESET	 0x0
/* Extracts the CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO field value from a register. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO register field value suitable for
 * setting the register. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_MULTICAST_PACKETS_GOOD_LOW.
 */
struct CORE_RX_MULTICAST_PACKETS_GOOD_LOW_s {
	const volatile uint32_t RXMCASTGLO : 32; /* CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RXMCASTGLO */
};

/* The typedef declaration for register CORE_RX_MULTICAST_PACKETS_GOOD_LOW. */
typedef struct CORE_RX_MULTICAST_PACKETS_GOOD_LOW_s CORE_RX_MULTICAST_PACKETS_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_MULTICAST_PACKETS_GOOD_LOW register. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_MULTICAST_PACKETS_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_RX_MULTICAST_PACKETS_GOOD_LOW_OFST	 0x920

/*
 * Register : Rx_CRC_Error_Packets_Low
 *
 * This register provides lower 32 bits of received packets with CRC error count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO
 *
 */
/*
 * Field : RXCRCERLO
 *
 * Rx CRC Error Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * packets received with a CRC error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register
 * field. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register
 * field. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_MSB	   31
/* The width in bits of the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register field. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_WIDTH	   32
/* The mask used to set the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register field value. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register field value. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_CLR_MSK	   0x00000000
/* The reset value of the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register field. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_RESET	   0x0
/* Extracts the CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO field value from a register. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO register field value suitable for setting the
 * register. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_CRC_ERROR_PACKETS_LOW.
 */
struct CORE_RX_CRC_ERROR_PACKETS_LOW_s {
	const volatile uint32_t RXCRCERLO : 32; /* CORE_RX_CRC_ERROR_PACKETS_LOW_RXCRCERLO */
};

/* The typedef declaration for register CORE_RX_CRC_ERROR_PACKETS_LOW. */
typedef struct CORE_RX_CRC_ERROR_PACKETS_LOW_s CORE_RX_CRC_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_CRC_ERROR_PACKETS_LOW register. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_CRC_ERROR_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RX_CRC_ERROR_PACKETS_LOW_OFST  0x928

/*
 * Register : Rx_Runt_Error_Packets
 *
 * This register provides received packets with Runt error count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER
 *
 */
/*
 * Field : RXRUNTER
 *
 * Rx Runt Error Packet Count
 *
 * This field indicates number of shorter-than-64-byte packets received with a CRC
 * error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register
 * field. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register
 * field. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_MSB	       31
/* The width in bits of the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register field. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_WIDTH      32
/* The mask used to set the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register field value. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register field value. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register field. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_RESET      0x0
/* Extracts the CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER field value from a register. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER register field value suitable for setting the
 * register. */
#define CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_RUNT_ERROR_PACKETS.
 */
struct CORE_RX_RUNT_ERROR_PACKETS_s {
	const volatile uint32_t RXRUNTER : 32; /* CORE_RX_RUNT_ERROR_PACKETS_RXRUNTER */
};

/* The typedef declaration for register CORE_RX_RUNT_ERROR_PACKETS. */
typedef struct CORE_RX_RUNT_ERROR_PACKETS_s CORE_RX_RUNT_ERROR_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_RUNT_ERROR_PACKETS register. */
#define CORE_RX_RUNT_ERROR_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_RX_RUNT_ERROR_PACKETS register from the beginning of the component.
 */
#define CORE_RX_RUNT_ERROR_PACKETS_OFST	 0x930

/*
 * Register : Rx_Jabber_Error_Packets
 *
 * This register provides received packets with Jabber error count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_JABBER_ERROR_PACKETS_RXJABERER
 *
 */
/*
 * Field : RXJABERER
 *
 * Rx Jabber Error Packet Count
 *
 * This field indicates number of giant (including CRC) packets received with a CRC
 * error. The giant packet status is generated as per the programming described in
 * MAC_Rx_Configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register
 * field. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register
 * field. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_MSB	  31
/* The width in bits of the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register field. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_WIDTH	  32
/* The mask used to set the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register field value. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register field value. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_CLR_MSK	  0x00000000
/* The reset value of the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register field. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_RESET	  0x0
/* Extracts the CORE_RX_JABBER_ERROR_PACKETS_RXJABERER field value from a register. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_JABBER_ERROR_PACKETS_RXJABERER register field value suitable for setting the
 * register. */
#define CORE_RX_JABBER_ERROR_PACKETS_RXJABERER_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_JABBER_ERROR_PACKETS.
 */
struct CORE_RX_JABBER_ERROR_PACKETS_s {
	const volatile uint32_t RXJABERER : 32; /* CORE_RX_JABBER_ERROR_PACKETS_RXJABERER */
};

/* The typedef declaration for register CORE_RX_JABBER_ERROR_PACKETS. */
typedef struct CORE_RX_JABBER_ERROR_PACKETS_s CORE_RX_JABBER_ERROR_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_JABBER_ERROR_PACKETS register. */
#define CORE_RX_JABBER_ERROR_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_RX_JABBER_ERROR_PACKETS register from the beginning of the component.
 */
#define CORE_RX_JABBER_ERROR_PACKETS_OFST  0x934

/*
 * Register : Rx_Undersize_Packets_Good
 *
 * This register provides count of received good undersize packets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG
 *
 */
/*
 * Field : RXUSIZEG
 *
 * Rx Good Undersize Packet Count
 *
 * This field indicates number of shorter-than-64-byte packets received without any
 * errors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register
 * field. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register
 * field. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_MSB	   31
/* The width in bits of the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register field. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_WIDTH	   32
/* The mask used to set the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register field value. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register field value. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_CLR_MSK	   0x00000000
/* The reset value of the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register field. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_RESET	   0x0
/* Extracts the CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG field value from a register. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG register field value suitable for setting the
 * register. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_UNDERSIZE_PACKETS_GOOD.
 */
struct CORE_RX_UNDERSIZE_PACKETS_GOOD_s {
	const volatile uint32_t RXUSIZEG : 32; /* CORE_RX_UNDERSIZE_PACKETS_GOOD_RXUSIZEG */
};

/* The typedef declaration for register CORE_RX_UNDERSIZE_PACKETS_GOOD. */
typedef struct CORE_RX_UNDERSIZE_PACKETS_GOOD_s CORE_RX_UNDERSIZE_PACKETS_GOOD_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_UNDERSIZE_PACKETS_GOOD register. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_RESET 0x00000000
/* The byte offset of the CORE_RX_UNDERSIZE_PACKETS_GOOD register from the beginning of the
 * component. */
#define CORE_RX_UNDERSIZE_PACKETS_GOOD_OFST  0x938

/*
 * Register : Rx_Oversize_Packets_Good
 *
 * This register provides count of received good oversize packets.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG
 *
 */
/*
 * Field : RXOSIZEG
 *
 * Rx Good Oversize Packet Count
 *
 * This field indicates number of greater than the maxsize packets received without
 * errors. In other words, the number of good giant packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register
 * field. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register
 * field. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_MSB	  31
/* The width in bits of the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register field. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_WIDTH	  32
/* The mask used to set the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register field value. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register field value. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_CLR_MSK	  0x00000000
/* The reset value of the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register field. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_RESET	  0x0
/* Extracts the CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG field value from a register. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG register field value suitable for setting the
 * register. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_OVERSIZE_PACKETS_GOOD.
 */
struct CORE_RX_OVERSIZE_PACKETS_GOOD_s {
	const volatile uint32_t RXOSIZEG : 32; /* CORE_RX_OVERSIZE_PACKETS_GOOD_RXOSIZEG */
};

/* The typedef declaration for register CORE_RX_OVERSIZE_PACKETS_GOOD. */
typedef struct CORE_RX_OVERSIZE_PACKETS_GOOD_s CORE_RX_OVERSIZE_PACKETS_GOOD_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_OVERSIZE_PACKETS_GOOD register. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_RESET 0x00000000
/* The byte offset of the CORE_RX_OVERSIZE_PACKETS_GOOD register from the beginning of the
 * component. */
#define CORE_RX_OVERSIZE_PACKETS_GOOD_OFST  0x93c

/*
 * Register : Rx_64Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received 64 octet size good and bad
 * packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO
 *
 */
/*
 * Field : RX64OCTGBLO
 *
 * Rx Good Bad 64 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad packets received that are of size 64 bytes, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO
 * register field. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO
 * register field. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_MSB	     31
/* The width in bits of the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO register field. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_WIDTH	     32
/* The mask used to set the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO register field value.
 */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO register field
 * value. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO register field. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_RESET	     0x0
/* Extracts the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO field value from a register. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO register field value suitable for
 * setting the register. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		RX64OCTGBLO : 32; /* CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RX64OCTGBLO */
};

/* The typedef declaration for register CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_s CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x940

/*
 * Register : Rx_65To127Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received 65-to-127 octet size good and
 * bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO
 *
 */
/*
 * Field : RX65_127OCTGBLO
 *
 * Rx Good Bad 65-to-127 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 65-to-127-byte good and bad packets received, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register field. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_LSB	   0
/* The Most Significant Bit (MSB) position of the
 * CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register field. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_MSB	   31
/* The width in bits of the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register
 * field. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_WIDTH   32
/* The mask used to set the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register
 * field value. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register
 * field value. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register field.
 */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_RESET   0x0
/* Extracts the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO field value from a
 * register. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_GET(value)                      \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO_SET(value)                      \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t RX65_127OCTGBLO : 32; /* CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RX65_127OCTGBLO
						       */
};

/* The typedef declaration for register CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of
 * the component. */
#define CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_OFST	 0x948

/*
 * Register : Rx_128To255Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received 128-to-255 octet size good and
 * bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO
 *
 */
/*
 * Field : RX128_255OCTGBLO
 *
 * Rx Good Bad 128-to-255 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 128-to-255-byte good and bad packets received, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register field. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register field. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_MSB     31
/* The width in bits of the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register
 * field. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_WIDTH   32
/* The mask used to set the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register
 * field value. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register
 * field value. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register
 * field. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_RESET   0x0
/* Extracts the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO field value from a
 * register. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_GET(value)                    \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO_SET(value)                    \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t RX128_255OCTGBLO : 32; /* CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RX128_255OCTGBLO
							*/
};

/* The typedef declaration for register CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of
 * the component. */
#define CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x950

/*
 * Register : Rx_256To511Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received 256-to-511 octet size good and
 * bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO
 *
 */
/*
 * Field : RX256_511OCTGBLO
 *
 * Rx Good Bad 256-to-511 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 256-to-511-byte good and bad packets received, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register field. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register field. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_MSB     31
/* The width in bits of the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register
 * field. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_WIDTH   32
/* The mask used to set the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register
 * field value. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register
 * field value. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register
 * field. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_RESET   0x0
/* Extracts the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO field value from a
 * register. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_GET(value)                    \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO_SET(value)                    \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t RX256_511OCTGBLO : 32; /* CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RX256_511OCTGBLO
							*/
};

/* The typedef declaration for register CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning of
 * the component. */
#define CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x958

/*
 * Register : Rx_512To1023Octets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received 512-to-1023 octet size good and
 * bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO
 *
 */
/*
 * Field : RX512_1023OCTGBLO
 *
 * Rx Good Bad 512-to-1023 Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * 512-to-1023-byte good and bad packets received, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO register field. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO register field. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_MSB     31
/* The width in bits of the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO register
 * field. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_WIDTH   32
/* The mask used to set the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO register
 * field value. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO
 * register field value. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO register
 * field. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_RESET   0x0
/* Extracts the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO field value from a
 * register. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_GET(value)                  \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO register field value
 * suitable for setting the register. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO_SET(value)                  \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t RX512_1023OCTGBLO : 32; /* CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RX512_1023OCTGBLO
							 */
};

/* The typedef declaration for register CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW register from the beginning
 * of the component. */
#define CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x960

/*
 * Register : Rx_1024ToMaxOctets_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received 1024-tomaxsize octet size good
 * and bad packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO
 *
 */
/*
 * Field : RX1024_MAXOCTGBLO
 *
 * Rx Good Bad 1024-tomaxsize Octet Size Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of 1024
 * -tomaxsize-byte (inclusive) good and bad packets received, excluding preamble.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO register field. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO register field. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_MSB     31
/* The width in bits of the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO register
 * field. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_WIDTH   32
/* The mask used to set the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO register
 * field value. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO
 * register field value. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO register
 * field. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_RESET   0x0
/* Extracts the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO field value from a
 * register. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_GET(value)                  \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO register field value
 * suitable for setting the register. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO_SET(value)                  \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t RX1024_MAXOCTGBLO : 32; /* CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RX1024_MAXOCTGBLO
							 */
};

/* The typedef declaration for register CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_s
	CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW register from the beginning
 * of the component. */
#define CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_OFST  0x968

/*
 * Register : Rx_Unicast_Packets_Good_Low
 *
 * This register provides lower 32 bits of received good unicast packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO
 *
 */
/*
 * Field : RXUCASTGLO
 *
 * Rx Good Unicast Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * unicast packets received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO
 * register field. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO
 * register field. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_MSB	       31
/* The width in bits of the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO register field. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_WIDTH      32
/* The mask used to set the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO register field value. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO register field value. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO register field. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_RESET      0x0
/* Extracts the CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO field value from a register. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO register field value suitable for setting
 * the register. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_UNICAST_PACKETS_GOOD_LOW.
 */
struct CORE_RX_UNICAST_PACKETS_GOOD_LOW_s {
	const volatile uint32_t RXUCASTGLO : 32; /* CORE_RX_UNICAST_PACKETS_GOOD_LOW_RXUCASTGLO */
};

/* The typedef declaration for register CORE_RX_UNICAST_PACKETS_GOOD_LOW. */
typedef struct CORE_RX_UNICAST_PACKETS_GOOD_LOW_s CORE_RX_UNICAST_PACKETS_GOOD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_UNICAST_PACKETS_GOOD_LOW register. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_UNICAST_PACKETS_GOOD_LOW register from the beginning of the
 * component. */
#define CORE_RX_UNICAST_PACKETS_GOOD_LOW_OFST  0x970

/*
 * Register : Rx_Length_Error_Packets_Low
 *
 * This register provides lower 32 bits of received packets with Length error
 * count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO
 *
 */
/*
 * Field : RXLENERRLO
 *
 * Rx Length Error Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * packets received with a Length error (Length field not equal to packet size),
 * for all packets with valid Length field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO
 * register field. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO
 * register field. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_MSB	       31
/* The width in bits of the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO register field. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_WIDTH      32
/* The mask used to set the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO register field value. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO register field value. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO register field. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_RESET      0x0
/* Extracts the CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO field value from a register. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO register field value suitable for setting
 * the register. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_LENGTH_ERROR_PACKETS_LOW.
 */
struct CORE_RX_LENGTH_ERROR_PACKETS_LOW_s {
	const volatile uint32_t RXLENERRLO : 32; /* CORE_RX_LENGTH_ERROR_PACKETS_LOW_RXLENERRLO */
};

/* The typedef declaration for register CORE_RX_LENGTH_ERROR_PACKETS_LOW. */
typedef struct CORE_RX_LENGTH_ERROR_PACKETS_LOW_s CORE_RX_LENGTH_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_LENGTH_ERROR_PACKETS_LOW register. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_LENGTH_ERROR_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RX_LENGTH_ERROR_PACKETS_LOW_OFST  0x978

/*
 * Register : Rx_OutofRange_Packets_Low
 *
 * This register provides lower 32 bits of received packets with out of range
 * length field count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO
 *
 */
/*
 * Field : RXORANGELO
 *
 * Rx Out of Range Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * packets received with Length field not equal to the valid packet size (>1500).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO
 * register field. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO register
 * field. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_MSB	     31
/* The width in bits of the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO register field. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_WIDTH	     32
/* The mask used to set the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO register field value. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO register field value. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO register field. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_RESET	     0x0
/* Extracts the CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO field value from a register. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO register field value suitable for setting
 * the register. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_OUTOFRANGE_PACKETS_LOW.
 */
struct CORE_RX_OUTOFRANGE_PACKETS_LOW_s {
	const volatile uint32_t RXORANGELO : 32; /* CORE_RX_OUTOFRANGE_PACKETS_LOW_RXORANGELO */
};

/* The typedef declaration for register CORE_RX_OUTOFRANGE_PACKETS_LOW. */
typedef struct CORE_RX_OUTOFRANGE_PACKETS_LOW_s CORE_RX_OUTOFRANGE_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_OUTOFRANGE_PACKETS_LOW register. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_OUTOFRANGE_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RX_OUTOFRANGE_PACKETS_LOW_OFST  0x980

/*
 * Register : Rx_Pause_Packets_Low
 *
 * This register provides lower 32 bits of received Pause packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO
 *
 */
/*
 * Field : RXPAUSELO
 *
 * Rx Pause Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and valid PAUSE packets received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register
 * field. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register
 * field. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_MSB	       31
/* The width in bits of the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register field. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_WIDTH      32
/* The mask used to set the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register field value. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register field value. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register field. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_RESET      0x0
/* Extracts the CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO field value from a register. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO register field value suitable for setting the
 * register. */
#define CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_PAUSE_PACKETS_LOW.
 */
struct CORE_RX_PAUSE_PACKETS_LOW_s {
	const volatile uint32_t RXPAUSELO : 32; /* CORE_RX_PAUSE_PACKETS_LOW_RXPAUSELO */
};

/* The typedef declaration for register CORE_RX_PAUSE_PACKETS_LOW. */
typedef struct CORE_RX_PAUSE_PACKETS_LOW_s CORE_RX_PAUSE_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_PAUSE_PACKETS_LOW register. */
#define CORE_RX_PAUSE_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_PAUSE_PACKETS_LOW register from the beginning of the component. */
#define CORE_RX_PAUSE_PACKETS_LOW_OFST	0x988

/*
 * Register : Rx_FIFOOverflow_Packets_Low
 *
 * This register provides lower 32 bits of received packets count that had Rx Queue
 * overflow.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO
 *
 */
/*
 * Field : RXFOVFLO
 *
 * Rx FIFO Overflow Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of
 * receive packets dropped due to FIFO overflow.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO
 * register field. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO register
 * field. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_MSB	     31
/* The width in bits of the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO register field. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_WIDTH	     32
/* The mask used to set the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO register field value. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO register field value. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO register field. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_RESET	     0x0
/* Extracts the CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO field value from a register. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO register field value suitable for setting
 * the register. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_FIFOOVERFLOW_PACKETS_LOW.
 */
struct CORE_RX_FIFOOVERFLOW_PACKETS_LOW_s {
	const volatile uint32_t RXFOVFLO : 32; /* CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RXFOVFLO */
};

/* The typedef declaration for register CORE_RX_FIFOOVERFLOW_PACKETS_LOW. */
typedef struct CORE_RX_FIFOOVERFLOW_PACKETS_LOW_s CORE_RX_FIFOOVERFLOW_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_FIFOOVERFLOW_PACKETS_LOW register. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_FIFOOVERFLOW_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RX_FIFOOVERFLOW_PACKETS_LOW_OFST  0x990

/*
 * Register : Rx_VLAN_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received good bad VLAN packets count.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO
 *
 */
/*
 * Field : RXVLANGBLO
 *
 * Rx Good Bad VLAN Packet Count Low
 *
 * This field indicates lower 32 bits of the counter that counts the number of good
 * and bad VLAN packets received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO
 * register field. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO
 * register field. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_MSB	31
/* The width in bits of the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO register field. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_WIDTH	32
/* The mask used to set the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO register field value. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO register field value. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_CLR_MSK	0x00000000
/* The reset value of the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO register field. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_RESET	0x0
/* Extracts the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO field value from a register. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO register field value suitable for setting
 * the register. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t RXVLANGBLO : 32; /* CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RXVLANGBLO */
};

/* The typedef declaration for register CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_s CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_OFST	0x998

/*
 * Register : Rx_Watchdog_Error_Packets
 *
 * This register provides packets count that were received with watchdog error.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR
 *
 */
/*
 * Field : RXWDOGERR
 *
 * Rx Watchdog Error Packet Count
 *
 * This field indicates number of packets received with a watchdog time-out error
 * (packets of length greater than the watchdog time-out limit as described in
 * MAC_WD_JB_Timeout).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register
 * field. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register
 * field. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_MSB	    31
/* The width in bits of the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register field. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_WIDTH	    32
/* The mask used to set the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register field value. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register field value. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register field. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_RESET	    0x0
/* Extracts the CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR field value from a register. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR register field value suitable for setting the
 * register. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_WATCHDOG_ERROR_PACKETS.
 */
struct CORE_RX_WATCHDOG_ERROR_PACKETS_s {
	const volatile uint32_t RXWDOGERR : 32; /* CORE_RX_WATCHDOG_ERROR_PACKETS_RXWDOGERR */
};

/* The typedef declaration for register CORE_RX_WATCHDOG_ERROR_PACKETS. */
typedef struct CORE_RX_WATCHDOG_ERROR_PACKETS_s CORE_RX_WATCHDOG_ERROR_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_WATCHDOG_ERROR_PACKETS register. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_RX_WATCHDOG_ERROR_PACKETS register from the beginning of the
 * component. */
#define CORE_RX_WATCHDOG_ERROR_PACKETS_OFST  0x9a0

/*
 * Register : Rx_LPI_USEC_Cntr
 *
 * This register provides duration in microsecond for which MAC was in Rx LPI.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_LPI_USEC_CNTR_RXLPIUSC
 *
 */
/*
 * Field : RXLPIUSC
 *
 * Rx LPI microsecond Count
 *
 * This field indicates the number of microseconds DWC_xgmac is in Rx LPI state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_MSB	  31
/* The width in bits of the CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_WIDTH	  32
/* The mask used to set the CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field value. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field value. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_CLR_MSK	  0x00000000
/* The reset value of the CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_RESET	  0x0
/* Extracts the CORE_RX_LPI_USEC_CNTR_RXLPIUSC field value from a register. */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_LPI_USEC_CNTR_RXLPIUSC register field value suitable for setting the register.
 */
#define CORE_RX_LPI_USEC_CNTR_RXLPIUSC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_LPI_USEC_CNTR.
 */
struct CORE_RX_LPI_USEC_CNTR_s {
	const volatile uint32_t RXLPIUSC : 32; /* CORE_RX_LPI_USEC_CNTR_RXLPIUSC */
};

/* The typedef declaration for register CORE_RX_LPI_USEC_CNTR. */
typedef struct CORE_RX_LPI_USEC_CNTR_s CORE_RX_LPI_USEC_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_LPI_USEC_CNTR register. */
#define CORE_RX_LPI_USEC_CNTR_RESET 0x00000000
/* The byte offset of the CORE_RX_LPI_USEC_CNTR register from the beginning of the component. */
#define CORE_RX_LPI_USEC_CNTR_OFST  0x9a4

/*
 * Register : Rx_LPI_Tran_Cntr
 *
 * This register provides number of times MAC transitioned to Rx LPI state.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_LPI_TRAN_CNTR_RXLPITRC
 *
 */
/*
 * Field : RXLPITRC
 *
 * Rx LPI Transition Count
 *
 * This field indicates the number of times DWC_xgmac entered the Rx LPI state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_MSB	  31
/* The width in bits of the CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_WIDTH	  32
/* The mask used to set the CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field value. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field value. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_CLR_MSK	  0x00000000
/* The reset value of the CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_RESET	  0x0
/* Extracts the CORE_RX_LPI_TRAN_CNTR_RXLPITRC field value from a register. */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_LPI_TRAN_CNTR_RXLPITRC register field value suitable for setting the register.
 */
#define CORE_RX_LPI_TRAN_CNTR_RXLPITRC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_LPI_TRAN_CNTR.
 */
struct CORE_RX_LPI_TRAN_CNTR_s {
	const volatile uint32_t RXLPITRC : 32; /* CORE_RX_LPI_TRAN_CNTR_RXLPITRC */
};

/* The typedef declaration for register CORE_RX_LPI_TRAN_CNTR. */
typedef struct CORE_RX_LPI_TRAN_CNTR_s CORE_RX_LPI_TRAN_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_LPI_TRAN_CNTR register. */
#define CORE_RX_LPI_TRAN_CNTR_RESET 0x00000000
/* The byte offset of the CORE_RX_LPI_TRAN_CNTR register from the beginning of the component. */
#define CORE_RX_LPI_TRAN_CNTR_OFST  0x9a8

/*
 * Register : Rx_Discard_Packets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received good bad packets count that
 * were discarded due to filter fail.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO
 *
 */
/*
 * Field : RXDPCNTGBLO
 *
 * Rx Good Bad Discard Packet Count Low
 *
 * This field indicates the number of packets received and discarded due to Filter
 * Fail. This represents the lower 32 bits of the counter. When a packet is dropped
 * due to filtering and not counted in the normal RMON counters, this counter is
 * incremented. This counter is incremented irrespective of whether it is a good or
 * bad packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO
 * register field. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO
 * register field. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_MSB	    31
/* The width in bits of the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO register field. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_WIDTH	    32
/* The mask used to set the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO register field value.
 */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO register field value.
 */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO register field. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_RESET	    0x0
/* Extracts the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO field value from a register. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO register field value suitable for
 * setting the register. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW.
 */
struct CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		RXDPCNTGBLO : 32; /* CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RXDPCNTGBLO */
};

/* The typedef declaration for register CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_s CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW register. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_OFST  0x9ac

/*
 * Register : Rx_Discard_Octets_Good_Bad_Low
 *
 * This register provides lower 32 bits of received good bad octets count that were
 * discarded due to filter fail.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO
 *
 */
/*
 * Field : RXDOCNTGBLO
 *
 * Rx Good Bad Discard Octet Count Low
 *
 * This field indicates the number of octets received and discarded due to Filter
 * Fail. This represents the lower 32 bits of the counter. When a packet is dropped
 * due to filtering and not counted in the normal RMON counters, this octet counter
 * is incremented by packet size. This counter is incremented irrespective of
 * whether it is a good or bad packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO
 * register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO
 * register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_MSB	   31
/* The width in bits of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_WIDTH	   32
/* The mask used to set the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO register field value. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO register field value.
 */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_CLR_MSK	   0x00000000
/* The reset value of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_RESET	   0x0
/* Extracts the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO field value from a register. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO register field value suitable for
 * setting the register. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW.
 */
struct CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_s {
	const volatile uint32_t
		RXDOCNTGBLO : 32; /* CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RXDOCNTGBLO */
};

/* The typedef declaration for register CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW. */
typedef struct CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_s CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW register. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_RESET 0x00000000
/* The byte offset of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW register from the beginning of the
 * component. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_OFST  0x9b4

/*
 * Register : Rx_Discard_Octets_Good_Bad_High
 *
 * This register provides upper 32 bits of received good bad octets count that were
 * discarded due to filter fail.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI
 *
 */
/*
 * Field : RXDOCNTGBHI
 *
 * Rx Good Bad Discard Octet Count High
 *
 * This field indicates the number of octets received and discarded due to Filter
 * Fail. This represents the upper 32 bits of the counter. Any packet dropped due
 * to filtering and not counted in the normal RMON counters then this octet counter
 * is incremented by packet size. This counter is incremented irrespective of
 * whether it is a good or bad packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI
 * register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI
 * register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_MSB	    31
/* The width in bits of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_WIDTH	    32
/* The mask used to set the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI register field value.
 */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI register field value.
 */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI register field. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_RESET	    0x0
/* Extracts the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI field value from a register. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI register field value suitable for
 * setting the register. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH.
 */
struct CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_s {
	const volatile uint32_t
		RXDOCNTGBHI : 32; /* CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RXDOCNTGBHI */
};

/* The typedef declaration for register CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH. */
typedef struct CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_s CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH register. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_RESET 0x00000000
/* The byte offset of the CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH register from the beginning of the
 * component. */
#define CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_OFST  0x9b8

/*
 * Register : Rx_Alignment_Error_Packets
 *
 * This register provides the number of packets received by DWC_xgmac with
 * alignment (dribble) error. It is valid only in 10/100 mode.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR
 *
 */
/*
 * Field : RXALIGNERR
 *
 * Rx Alignment Error Packet Count
 *
 * This field indicates the number of packets received with alignment (dribble)
 * error. It is valid only in 10/100 mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR
 * register field. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR
 * register field. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_MSB	      31
/* The width in bits of the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR register field. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_WIDTH      32
/* The mask used to set the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR register field value. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR register field value. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_CLR_MSK    0x00000000
/* The reset value of the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR register field. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_RESET      0x0
/* Extracts the CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR field value from a register. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR register field value suitable for setting
 * the register. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RX_ALIGNMENT_ERROR_PACKETS.
 */
struct CORE_RX_ALIGNMENT_ERROR_PACKETS_s {
	const volatile uint32_t RXALIGNERR : 32; /* CORE_RX_ALIGNMENT_ERROR_PACKETS_RXALIGNERR */
};

/* The typedef declaration for register CORE_RX_ALIGNMENT_ERROR_PACKETS. */
typedef struct CORE_RX_ALIGNMENT_ERROR_PACKETS_s CORE_RX_ALIGNMENT_ERROR_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RX_ALIGNMENT_ERROR_PACKETS register. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_RX_ALIGNMENT_ERROR_PACKETS register from the beginning of the
 * component. */
#define CORE_RX_ALIGNMENT_ERROR_PACKETS_OFST  0x9bc

/*
 * Register : MMC_FPE_Tx_Interrupt
 *
 * This register maintains the interrupts generated from all FPE related Transmit
 * statistics counters. The MMC FPE Transmit Interrupt register maintains the
 * interrupts generated when the transmit statistic counters reach the threshold
 * value programmed in MMC control register (for example, the counter's MSB is
 * set). This register is 32 bits wide. An interrupt bit is cleared when the
 * respective MMC counter that caused the interrupt is read. The least significant
 * byte lane (bits[7:0]) of the corresponding counter must be read to clear the
 * interrupt status bit.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MMC_FPE_TX_INTERRUPT_FCIS
 *  [1]    | R      | 0x0   | CORE_MMC_FPE_TX_INTERRUPT_HRCIS
 *  [31:2] | R      | 0x0   | CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2
 *
 */
/*
 * Field : FCIS
 *
 * MMC Tx FPE Fragment Counter Interrupt status
 *
 * This bit is set when the Tx_FPE_Fragment_Cntr counter reaches the threshold
 * value programmed in MMC control register.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                        | Value | Description
 * :------------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MMC_FPE_TX_INTERRUPT_FCIS_E_INACTIVE | 0x0   | MMC Tx FPE Fragment Counter Interrupt status
 * not :                                                            |       | detected
 *  CORE_MMC_FPE_TX_INTERRUPT_FCIS_E_ACTIVE   | 0x1   | MMC Tx FPE Fragment Counter Interrupt status
 * :                                                            |       | detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_FCIS
 *
 * MMC Tx FPE Fragment Counter Interrupt status not detected
 */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_FCIS
 *
 * MMC Tx FPE Fragment Counter Interrupt status detected
 */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_TX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_TX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_MSB	  0
/* The width in bits of the CORE_MMC_FPE_TX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_WIDTH	  1
/* The mask used to set the CORE_MMC_FPE_TX_INTERRUPT_FCIS register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_SET_MSK	  0x00000001
/* The mask used to clear the CORE_MMC_FPE_TX_INTERRUPT_FCIS register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_CLR_MSK	  0xfffffffe
/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_RESET	  0x0
/* Extracts the CORE_MMC_FPE_TX_INTERRUPT_FCIS field value from a register. */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_FPE_TX_INTERRUPT_FCIS register field value suitable for setting the register.
 */
#define CORE_MMC_FPE_TX_INTERRUPT_FCIS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : HRCIS
 *
 * MMC Tx Hold Request Counter Interrupt Status
 *
 * This bit is set when the Tx_Hold_Req_Cntr counter reaches the threshold value
 * programmed in MMC control register.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                         | Value | Description
 * :-------------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MMC_FPE_TX_INTERRUPT_HRCIS_E_INACTIVE | 0x0   | MMC Tx Hold Request Counter Interrupt
 * Status not :                                                             |       | detected
 *  CORE_MMC_FPE_TX_INTERRUPT_HRCIS_E_ACTIVE   | 0x1   | MMC Tx Hold Request Counter Interrupt
 * Status :                                                             |       | detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_HRCIS
 *
 * MMC Tx Hold Request Counter Interrupt Status not detected
 */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_HRCIS
 *
 * MMC Tx Hold Request Counter Interrupt Status detected
 */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field.
 */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_LSB	   1
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_MSB	   1
/* The width in bits of the CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_WIDTH	   1
/* The mask used to set the CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_SET_MSK	   0x00000002
/* The mask used to clear the CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_CLR_MSK	   0xfffffffd
/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_RESET	   0x0
/* Extracts the CORE_MMC_FPE_TX_INTERRUPT_HRCIS field value from a register. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_FPE_TX_INTERRUPT_HRCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_TX_INTERRUPT_HRCIS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_31_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register
 * field. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_LSB	   2
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register
 * field. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_MSB	   31
/* The width in bits of the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_WIDTH	   30
/* The mask used to set the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_SET_MSK	   0xfffffffc
/* The mask used to clear the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_CLR_MSK	   0x00000003
/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_RESET	   0x0
/* Extracts the CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 field value from a register. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_GET(value) (((value)&0xfffffffc) >> 2)
/* Produces a CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2_SET(value) (((value) << 2) & 0xfffffffc)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_FPE_TX_INTERRUPT.
 */
struct CORE_MMC_FPE_TX_INTERRUPT_s {
	const volatile uint32_t FCIS : 1;	    /* CORE_MMC_FPE_TX_INTERRUPT_FCIS */
	const volatile uint32_t HRCIS : 1;	    /* CORE_MMC_FPE_TX_INTERRUPT_HRCIS */
	const volatile uint32_t Reserved_31_2 : 30; /* CORE_MMC_FPE_TX_INTERRUPT_RESERVED_31_2 */
};

/* The typedef declaration for register CORE_MMC_FPE_TX_INTERRUPT. */
typedef struct CORE_MMC_FPE_TX_INTERRUPT_s CORE_MMC_FPE_TX_INTERRUPT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT register. */
#define CORE_MMC_FPE_TX_INTERRUPT_RESET 0x00000000
/* The byte offset of the CORE_MMC_FPE_TX_INTERRUPT register from the beginning of the component. */
#define CORE_MMC_FPE_TX_INTERRUPT_OFST	0xa00

/*
 * Register : MMC_FPE_Tx_Interrupt_Mask
 *
 * This register maintains the masks for interrupts generated from all FPE related
 * Transmit statistics counters. The MMC Receive Interrupt Mask register maintains
 * the masks for the interrupts generated when FPE related receive statistic
 * counters reach the threshold value programmed in MMC control register. This
 * register is 32 bit wide.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [0]    | RW     | 0x0   | CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM
 *  [1]    | RW     | 0x0   | CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM
 *  [31:2] | R      | 0x0   | CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2
 *
 */
/*
 * Field : FCIM
 *
 * MMC Transmit Fragment Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the Tx_FPE_Fragment_Cntr counter
 * reaches the threshold value programmed in MMC control register.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                            | Value | Description
 * :----------------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_E_DISABLE | 0x0   | MMC Transmit Fragment Counter Interrupt
 * Mask is :                                                                |       | disabled
 *  CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_E_ENABLE  | 0x1   | MMC Transmit Fragment Counter Interrupt
 * Mask is :                                                                |       | enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM
 *
 * MMC Transmit Fragment Counter Interrupt Mask is disabled
 */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM
 *
 * MMC Transmit Fragment Counter Interrupt Mask is enabled
 */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register
 * field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register
 * field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_MSB	       0
/* The width in bits of the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_WIDTH      1
/* The mask used to set the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_SET_MSK    0x00000001
/* The mask used to clear the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_RESET      0x0
/* Extracts the CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM field value from a register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : HRCIM
 *
 * MMC Transmit Hold Request Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the Tx_Hold_Req_Cntr counter the
 * threshold value programmed in MMC control register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_E_DISABLE | 0x0   | MMC Transmit Hold Request Counter
 * Interrupt Mask :                                                                 |       | is
 * disabled CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_E_ENABLE  | 0x1   | MMC Transmit Hold Request
 * Counter Interrupt Mask :                                                                 | | is
 * enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM
 *
 * MMC Transmit Hold Request Counter Interrupt Mask is disabled
 */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM
 *
 * MMC Transmit Hold Request Counter Interrupt Mask is enabled
 */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register
 * field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register
 * field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_MSB	1
/* The width in bits of the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_WIDTH	1
/* The mask used to set the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_SET_MSK	0x00000002
/* The mask used to clear the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_RESET	0x0
/* Extracts the CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM field value from a register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_31_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2
 * register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_LSB	2
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2
 * register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_MSB	31
/* The width in bits of the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_WIDTH	30
/* The mask used to set the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_SET_MSK	0xfffffffc
/* The mask used to clear the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 register field value. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_CLR_MSK	0x00000003
/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 register field. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_RESET	0x0
/* Extracts the CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 field value from a register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_GET(value) (((value)&0xfffffffc) >> 2)
/* Produces a CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 register field value suitable for setting
 * the register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2_SET(value) (((value) << 2) & 0xfffffffc)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_FPE_TX_INTERRUPT_MASK.
 */
struct CORE_MMC_FPE_TX_INTERRUPT_MASK_s {
	volatile uint32_t FCIM : 1;  /* CORE_MMC_FPE_TX_INTERRUPT_MASK_FCIM */
	volatile uint32_t HRCIM : 1; /* CORE_MMC_FPE_TX_INTERRUPT_MASK_HRCIM */
	const volatile uint32_t
		Reserved_31_2 : 30; /* CORE_MMC_FPE_TX_INTERRUPT_MASK_RESERVED_31_2 */
};

/* The typedef declaration for register CORE_MMC_FPE_TX_INTERRUPT_MASK. */
typedef struct CORE_MMC_FPE_TX_INTERRUPT_MASK_s CORE_MMC_FPE_TX_INTERRUPT_MASK_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_FPE_TX_INTERRUPT_MASK register. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_RESET 0x00000000
/* The byte offset of the CORE_MMC_FPE_TX_INTERRUPT_MASK register from the beginning of the
 * component. */
#define CORE_MMC_FPE_TX_INTERRUPT_MASK_OFST  0xa04

/*
 * Register : MMC_Tx_FPE_Fragment_Cntr
 *
 * This register provides the number of additional mPackets transmitted due to
 * preemption.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC
 *
 */
/*
 * Field : TXFFC
 *
 * Tx FPE Fragment counter
 *
 * This field indicates the number of additional mPackets transmitted due to
 * preemption
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register
 * field. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register
 * field. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_MSB	       31
/* The width in bits of the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register field. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_WIDTH      32
/* The mask used to set the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register field value. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register field value. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_CLR_MSK    0x00000000
/* The reset value of the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register field. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_RESET      0x0
/* Extracts the CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC field value from a register. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_TX_FPE_FRAGMENT_CNTR.
 */
struct CORE_MMC_TX_FPE_FRAGMENT_CNTR_s {
	const volatile uint32_t TXFFC : 32; /* CORE_MMC_TX_FPE_FRAGMENT_CNTR_TXFFC */
};

/* The typedef declaration for register CORE_MMC_TX_FPE_FRAGMENT_CNTR. */
typedef struct CORE_MMC_TX_FPE_FRAGMENT_CNTR_s CORE_MMC_TX_FPE_FRAGMENT_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_TX_FPE_FRAGMENT_CNTR register. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_RESET 0x00000000
/* The byte offset of the CORE_MMC_TX_FPE_FRAGMENT_CNTR register from the beginning of the
 * component. */
#define CORE_MMC_TX_FPE_FRAGMENT_CNTR_OFST  0xa08

/*
 * Register : MMC_Tx_Hold_Req_Cntr
 *
 * This register provides the count of number of times a hold request is given to
 * MAC
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC
 *
 */
/*
 * Field : TXHRC
 *
 * Tx Hold Request Counter
 *
 * This field indicates count of number of a hold request is given to MAC.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field.
 */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_MSB	   31
/* The width in bits of the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_WIDTH	   32
/* The mask used to set the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field value. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field value. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_CLR_MSK	   0x00000000
/* The reset value of the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_RESET	   0x0
/* Extracts the CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC field value from a register. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC register field value suitable for setting the
 * register. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_TX_HOLD_REQ_CNTR.
 */
struct CORE_MMC_TX_HOLD_REQ_CNTR_s {
	const volatile uint32_t TXHRC : 32; /* CORE_MMC_TX_HOLD_REQ_CNTR_TXHRC */
};

/* The typedef declaration for register CORE_MMC_TX_HOLD_REQ_CNTR. */
typedef struct CORE_MMC_TX_HOLD_REQ_CNTR_s CORE_MMC_TX_HOLD_REQ_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_TX_HOLD_REQ_CNTR register. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_RESET 0x00000000
/* The byte offset of the CORE_MMC_TX_HOLD_REQ_CNTR register from the beginning of the component. */
#define CORE_MMC_TX_HOLD_REQ_CNTR_OFST	0xa0c

/*
 * Register : MMC_FPE_Rx_Interrupt
 *
 * This register maintains the interrupts generated from all FPE related Receive
 * statistics counters. The MMC FPE Receive Interrupt register maintains the
 * interrupts generated when receive statistic counters reach the threshold value
 * programmed in MMC control register (for example, the counter's MSB is set). The
 * MMC FPE Receive Interrupt register is a 32 bit register. An interrupt bit is
 * cleared when the respective MMC counter that caused the interrupt is read. The
 * least significant byte lane (Bits[7:0]) of the respective counter must be read
 * to clear the interrupt bit.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [0]    | R      | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_PAECIS
 *  [1]    | R      | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_PSECIS
 *  [2]    | R      | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_PAOCIS
 *  [3]    | R      | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_FCIS
 *  [31:4] | R      | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4
 *
 */
/*
 * Field : PAECIS
 *
 * MMC Rx Packet Assembly Error Counter Interrupt Status
 *
 * This bit is set when the Rx_Packet_Assemble_Err_Cntr counter reaches the
 * threshold value programmed in MMC control register.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_PAECIS_E_INACTIVE | 0x0   | MMC Rx Packet Assembly Error Counter
 * Interrupt :                                                              |       | Status not
 * detected CORE_MMC_FPE_RX_INTERRUPT_PAECIS_E_ACTIVE   | 0x1   | MMC Rx Packet Assembly Error
 * Counter Interrupt :                                                              |       | Status
 * detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_PAECIS
 *
 * MMC Rx Packet Assembly Error Counter Interrupt Status not detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_PAECIS
 *
 * MMC Rx Packet Assembly Error Counter Interrupt Status detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_MSB	    0
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_WIDTH	    1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_SET_MSK    0x00000001
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_RESET	    0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_PAECIS field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_PAECIS register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAECIS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PSECIS
 *
 * MMC Rx Packet SMD Error Counter Interrupt Status
 *
 * This bit is set when the Rx_Packet_SMD_Err_Cntr counter reaches the threshold
 * value programmed in MMC control register.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_PSECIS_E_INACTIVE | 0x0   | MMC Rx Packet SMD Error Counter Interrupt
 * Status :                                                              |       | not detected
 *  CORE_MMC_FPE_RX_INTERRUPT_PSECIS_E_ACTIVE   | 0x1   | MMC Rx Packet SMD Error Counter Interrupt
 * Status :                                                              |       | detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_PSECIS
 *
 * MMC Rx Packet SMD Error Counter Interrupt Status not detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_PSECIS
 *
 * MMC Rx Packet SMD Error Counter Interrupt Status detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_LSB	    1
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_MSB	    1
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_WIDTH	    1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_SET_MSK    0x00000002
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_RESET	    0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_PSECIS field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_PSECIS register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_PSECIS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PAOCIS
 *
 * MMC Rx Packet Assembly OK Counter Interrupt Status
 *
 * This bit is set when the Rx_Packet_Assemble_Ok_Cntr counter reach the threshold
 * value programmed in MMC control register.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                          | Value | Description
 * :--------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_E_INACTIVE | 0x0   | MMC Rx Packet Assembly OK Counter
 * Interrupt :                                                              |       | Status not
 * detected CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_E_ACTIVE   | 0x1   | MMC Rx Packet Assembly OK Counter
 * Interrupt :                                                              |       | Status
 * detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_PAOCIS
 *
 * MMC Rx Packet Assembly OK Counter Interrupt Status not detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_PAOCIS
 *
 * MMC Rx Packet Assembly OK Counter Interrupt Status detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_LSB	    2
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_MSB	    2
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_WIDTH	    1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_RESET	    0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_PAOCIS field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_PAOCIS register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_PAOCIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : FCIS
 *
 * MMC Rx FPE Fragment Counter Interrupt Status
 *
 * This bit is set when the Rx_FPE_Fragment_Cntr counter reach the threshold value
 * programmed in MMC control register.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                        | Value | Description
 * :------------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_FCIS_E_INACTIVE | 0x0   | MMC Rx FPE Fragment Counter Interrupt Status
 * not :                                                            |       | detected
 *  CORE_MMC_FPE_RX_INTERRUPT_FCIS_E_ACTIVE   | 0x1   | MMC Rx FPE Fragment Counter Interrupt Status
 * :                                                            |       | detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_FCIS
 *
 * MMC Rx FPE Fragment Counter Interrupt Status not detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_FCIS
 *
 * MMC Rx FPE Fragment Counter Interrupt Status detected
 */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_LSB	  3
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_MSB	  3
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_WIDTH	  1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_FCIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_SET_MSK	  0x00000008
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_FCIS register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_CLR_MSK	  0xfffffff7
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_FCIS register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_RESET	  0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_FCIS field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_FCIS register field value suitable for setting the register.
 */
#define CORE_MMC_FPE_RX_INTERRUPT_FCIS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_31_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_LSB	   4
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_MSB	   31
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_WIDTH	   28
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_SET_MSK	   0xfffffff0
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_CLR_MSK	   0x0000000f
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_RESET	   0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_GET(value) (((value)&0xfffffff0) >> 4)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4_SET(value) (((value) << 4) & 0xfffffff0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_FPE_RX_INTERRUPT.
 */
struct CORE_MMC_FPE_RX_INTERRUPT_s {
	const volatile uint32_t PAECIS : 1;	    /* CORE_MMC_FPE_RX_INTERRUPT_PAECIS */
	const volatile uint32_t PSECIS : 1;	    /* CORE_MMC_FPE_RX_INTERRUPT_PSECIS */
	const volatile uint32_t PAOCIS : 1;	    /* CORE_MMC_FPE_RX_INTERRUPT_PAOCIS */
	const volatile uint32_t FCIS : 1;	    /* CORE_MMC_FPE_RX_INTERRUPT_FCIS */
	const volatile uint32_t Reserved_31_4 : 28; /* CORE_MMC_FPE_RX_INTERRUPT_RESERVED_31_4 */
};

/* The typedef declaration for register CORE_MMC_FPE_RX_INTERRUPT. */
typedef struct CORE_MMC_FPE_RX_INTERRUPT_s CORE_MMC_FPE_RX_INTERRUPT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT register. */
#define CORE_MMC_FPE_RX_INTERRUPT_RESET 0x00000000
/* The byte offset of the CORE_MMC_FPE_RX_INTERRUPT register from the beginning of the component. */
#define CORE_MMC_FPE_RX_INTERRUPT_OFST	0xa20

/*
 * Register : MMC_FPE_Rx_Interrupt_Mask
 *
 * This register maintains the masks for interrupts generated from all FPE related
 * Receive statistics counters. The MMC Receive Interrupt Mask register maintains
 * the masks for the interrupts generated when FPE related receive statistic
 * counters reach the threshold value programmed in MMC control register. This
 * register is 32 bit wide.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [0]    | RW     | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM
 *  [1]    | RW     | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM
 *  [2]    | RW     | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM
 *  [3]    | RW     | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM
 *  [31:4] | R      | 0x0   | CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4
 *
 */
/*
 * Field : PAECIM
 *
 * MMC Rx Packet Assembly Error Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the Rx_Packet_Assemble_Err_Cntr
 * counter reaches the threshold value programmed in MMC control register.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_E_DISABLE | 0x0   | MMC Rx Packet Assembly Error Counter
 * Interrupt :                                                                  |       | Mask is
 * disabled CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_E_ENABLE  | 0x1   | MMC Rx Packet Assembly Error
 * Counter Interrupt :                                                                  |       |
 * Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM
 *
 * MMC Rx Packet Assembly Error Counter Interrupt Mask is disabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM
 *
 * MMC Rx Packet Assembly Error Counter Interrupt Mask is enabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_MSB	 0
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_WIDTH	 1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_SET_MSK	 0x00000001
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_CLR_MSK	 0xfffffffe
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_RESET	 0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : PSECIM
 *
 * MMC Rx Packet SMD Error Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the Rx_Packet_SMD_Err_Cntr counter
 * reaches the threshold value programmed in MMC control register.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_E_DISABLE | 0x0   | MMC Rx Packet SMD Error Counter
 * Interrupt Mask :                                                                  |       | is
 * disabled CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_E_ENABLE  | 0x1   | MMC Rx Packet SMD Error
 * Counter Interrupt Mask :                                                                  | | is
 * enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM
 *
 * MMC Rx Packet SMD Error Counter Interrupt Mask is disabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM
 *
 * MMC Rx Packet SMD Error Counter Interrupt Mask is enabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_LSB	 1
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_MSB	 1
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_WIDTH	 1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_SET_MSK	 0x00000002
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_CLR_MSK	 0xfffffffd
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_RESET	 0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : PAOCIM
 *
 * MMC Rx Packet Assembly OK Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the Rx_Packet_Assemble_Ok_Cntr counter
 * reaches the threshold value programmed in MMC control register.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-------------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_E_DISABLE | 0x0   | MMC Rx Packet Assembly OK Counter
 * Interrupt Mask :                                                                  |       | is
 * disabled CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_E_ENABLE  | 0x1   | MMC Rx Packet Assembly OK
 * Counter Interrupt Mask :                                                                  | | is
 * enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM
 *
 * MMC Rx Packet Assembly OK Counter Interrupt Mask is disabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM
 *
 * MMC Rx Packet Assembly OK Counter Interrupt Mask is enabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_MSB	 2
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_WIDTH	 1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_SET_MSK	 0x00000004
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_CLR_MSK	 0xfffffffb
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_RESET	 0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : FCIM
 *
 * MMC Rx FPE Fragment Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the Tx_FPE_Fragment_Cntr counter
 * reaches the threshold value programmed in MMC control register.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                            | Value | Description
 * :----------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_E_DISABLE | 0x0   | MMC Rx FPE Fragment Counter Interrupt
 * Mask is :                                                                |       | disabled
 *  CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_E_ENABLE  | 0x1   | MMC Rx FPE Fragment Counter Interrupt
 * Mask is :                                                                |       | enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM
 *
 * MMC Rx FPE Fragment Counter Interrupt Mask is disabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM
 *
 * MMC Rx FPE Fragment Counter Interrupt Mask is enabled
 */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_LSB	       3
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register
 * field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_MSB	       3
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_WIDTH      1
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_SET_MSK    0x00000008
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_RESET      0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM register field value suitable for setting the
 * register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_31_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4
 * register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_LSB	4
/* The Most Significant Bit (MSB) position of the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4
 * register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_MSB	31
/* The width in bits of the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_WIDTH	28
/* The mask used to set the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_SET_MSK	0xfffffff0
/* The mask used to clear the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 register field value. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_CLR_MSK	0x0000000f
/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 register field. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_RESET	0x0
/* Extracts the CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 field value from a register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_GET(value) (((value)&0xfffffff0) >> 4)
/* Produces a CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 register field value suitable for setting
 * the register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4_SET(value) (((value) << 4) & 0xfffffff0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_FPE_RX_INTERRUPT_MASK.
 */
struct CORE_MMC_FPE_RX_INTERRUPT_MASK_s {
	volatile uint32_t PAECIM : 1; /* CORE_MMC_FPE_RX_INTERRUPT_MASK_PAECIM */
	volatile uint32_t PSECIM : 1; /* CORE_MMC_FPE_RX_INTERRUPT_MASK_PSECIM */
	volatile uint32_t PAOCIM : 1; /* CORE_MMC_FPE_RX_INTERRUPT_MASK_PAOCIM */
	volatile uint32_t FCIM : 1;   /* CORE_MMC_FPE_RX_INTERRUPT_MASK_FCIM */
	const volatile uint32_t
		Reserved_31_4 : 28; /* CORE_MMC_FPE_RX_INTERRUPT_MASK_RESERVED_31_4 */
};

/* The typedef declaration for register CORE_MMC_FPE_RX_INTERRUPT_MASK. */
typedef struct CORE_MMC_FPE_RX_INTERRUPT_MASK_s CORE_MMC_FPE_RX_INTERRUPT_MASK_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_FPE_RX_INTERRUPT_MASK register. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_RESET 0x00000000
/* The byte offset of the CORE_MMC_FPE_RX_INTERRUPT_MASK register from the beginning of the
 * component. */
#define CORE_MMC_FPE_RX_INTERRUPT_MASK_OFST  0xa24

/*
 * Register : MMC_Rx_Packet_Assembly_Err_Cntr
 *
 * This register provides the number of MAC frames with reassembly errors on the
 * Receiver, due to mismatch in the Fragment Count value.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC
 *
 */
/*
 * Field : PAEC
 *
 * Rx Packet Assembly Error Counter
 *
 * This field indicates the number of MAC frames with reassembly errors on the
 * Receiver, due to mismatch in the Fragment Count value.
 *
 * Exists when any one of the Rx/Tx MMC counters are enabled during FPE Enabled
 * configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC
 * register field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC register
 * field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_MSB	     31
/* The width in bits of the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC register field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_WIDTH	     32
/* The mask used to set the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC register field value. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC register field value. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_CLR_MSK    0x00000000
/* The reset value of the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC register field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_RESET	     0x0
/* Extracts the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC field value from a register. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC register field value suitable for setting
 * the register. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR.
 */
struct CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_s {
	const volatile uint32_t PAEC : 32; /* CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_PAEC */
};

/* The typedef declaration for register CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR. */
typedef struct CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_s CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR register. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_RESET 0x00000000
/* The byte offset of the CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR register from the beginning of the
 * component. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_OFST  0xa28

/*
 * Register : MMC_Rx_Packet_SMD_Err_Cntr
 *
 * This register provides the number of received MAC frames rejected due to unknown
 * SMD value and MAC frame fragments rejected due to arriving with an SMD-C when
 * there was no preceding preempted frame.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC
 *
 */
/*
 * Field : PSEC
 *
 * Rx Packet SMD Error Counter
 *
 * This field indicates the number of MAC frames rejected due to unknown SMD value
 * and MAC frame fragments rejected due to arriving with an SMD-C when there was no
 * preceding preempted frame.
 *
 * Exists when at least one of the Rx/Tx MMC counters are enabled during FPE
 * Enabled configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register
 * field. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register
 * field. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_MSB	31
/* The width in bits of the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register field. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_WIDTH	32
/* The mask used to set the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register field value. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register field value. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_CLR_MSK	0x00000000
/* The reset value of the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register field. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_RESET	0x0
/* Extracts the CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC field value from a register. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_RX_PACKET_SMD_ERR_CNTR.
 */
struct CORE_MMC_RX_PACKET_SMD_ERR_CNTR_s {
	const volatile uint32_t PSEC : 32; /* CORE_MMC_RX_PACKET_SMD_ERR_CNTR_PSEC */
};

/* The typedef declaration for register CORE_MMC_RX_PACKET_SMD_ERR_CNTR. */
typedef struct CORE_MMC_RX_PACKET_SMD_ERR_CNTR_s CORE_MMC_RX_PACKET_SMD_ERR_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_RX_PACKET_SMD_ERR_CNTR register. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_RESET 0x00000000
/* The byte offset of the CORE_MMC_RX_PACKET_SMD_ERR_CNTR register from the beginning of the
 * component. */
#define CORE_MMC_RX_PACKET_SMD_ERR_CNTR_OFST  0xa2c

/*
 * Register : MMC_Rx_Packet_Assembly_OK_Cntr
 *
 * This register provides the number of MAC frames that were successfully
 * reassembled and delivered to MAC.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC
 *
 */
/*
 * Field : PAOC
 *
 * Rx Packet Assembly OK Counter
 *
 * This field indicates the number of MAC frames that were successfully reassembled
 * and delivered to MAC.
 *
 * Exists when at least one of the Rx/Tx MMC counters are enabled during FPE
 * Enabled configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register
 * field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register
 * field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_MSB	    31
/* The width in bits of the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_WIDTH	    32
/* The mask used to set the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register field value. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register field value. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_CLR_MSK    0x00000000
/* The reset value of the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register field. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_RESET	    0x0
/* Extracts the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC field value from a register. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR.
 */
struct CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_s {
	const volatile uint32_t PAOC : 32; /* CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_PAOC */
};

/* The typedef declaration for register CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR. */
typedef struct CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_s CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR register. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_RESET 0x00000000
/* The byte offset of the CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR register from the beginning of the
 * component. */
#define CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_OFST  0xa30

/*
 * Register : MMC_Rx_FPE_Fragment_Cntr
 *
 * This register provides the number of additional mPackets received due to
 * preemption.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC
 *
 */
/*
 * Field : FFC
 *
 * Rx FPE Fragment Counter
 *
 * This field indicates the number of additional mPackets received due to
 * preemption
 *
 * Exists when at least one of the Rx/Tx MMC counters are enabled during FPE
 * Enabled configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field.
 */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field.
 */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_MSB	     31
/* The width in bits of the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_WIDTH	     32
/* The mask used to set the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field value. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field value. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_CLR_MSK    0x00000000
/* The reset value of the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_RESET	     0x0
/* Extracts the CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC field value from a register. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC register field value suitable for setting the
 * register. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_RX_FPE_FRAGMENT_CNTR.
 */
struct CORE_MMC_RX_FPE_FRAGMENT_CNTR_s {
	const volatile uint32_t FFC : 32; /* CORE_MMC_RX_FPE_FRAGMENT_CNTR_FFC */
};

/* The typedef declaration for register CORE_MMC_RX_FPE_FRAGMENT_CNTR. */
typedef struct CORE_MMC_RX_FPE_FRAGMENT_CNTR_s CORE_MMC_RX_FPE_FRAGMENT_CNTR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_RX_FPE_FRAGMENT_CNTR register. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_RESET 0x00000000
/* The byte offset of the CORE_MMC_RX_FPE_FRAGMENT_CNTR register from the beginning of the
 * component. */
#define CORE_MMC_RX_FPE_FRAGMENT_CNTR_OFST  0xa34

/*
 * Register : Tx_Single_Collision_Good_Packets
 *
 * This register provides the number of successfully transmitted packets by
 * DWC_xgmac after a single collision in the half-duplex mode.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG
 *
 */
/*
 * Field : TXSNGLCOLG
 *
 * Tx Single Collision Good Packets
 *
 * This field indicates the number of successfully transmitted packets after a
 * single collision in the half-duplex mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG
 * register field. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG
 * register field. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_MSB	    31
/* The width in bits of the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG register field. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_WIDTH	    32
/* The mask used to set the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG register field value.
 */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG register field value.
 */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG register field. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_RESET	    0x0
/* Extracts the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG field value from a register. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG register field value suitable for
 * setting the register. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_SINGLE_COLLISION_GOOD_PACKETS.
 */
struct CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_s {
	const volatile uint32_t
		TXSNGLCOLG : 32; /* CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG */
};

/* The typedef declaration for register CORE_TX_SINGLE_COLLISION_GOOD_PACKETS. */
typedef struct CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_s CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS register. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_TX_SINGLE_COLLISION_GOOD_PACKETS register from the beginning of the
 * component. */
#define CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_OFST  0xa40

/*
 * Register : Tx_Multiple_Collision_Good_Packets
 *
 * This register provides the number of successfully transmitted packets by
 * DWC_xgmac after multiple collisions in the half-duplex mode.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG
 *
 */
/*
 * Field : TXMULTCOLG
 *
 * Tx Multiple Collision Good Packets
 *
 * This field indicates the number of successfully transmitted packets after
 * multiple collisions in the half-duplex mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG register field. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG
 * register field. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_MSB	      31
/* The width in bits of the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG register field. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_WIDTH      32
/* The mask used to set the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG register field value.
 */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG register field
 * value. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG register field. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_RESET      0x0
/* Extracts the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG field value from a register. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG register field value suitable for
 * setting the register. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS.
 */
struct CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_s {
	const volatile uint32_t
		TXMULTCOLG : 32; /* CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG */
};

/* The typedef declaration for register CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS. */
typedef struct CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_s CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS register. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS register from the beginning of the
 * component. */
#define CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_OFST  0xa44

/*
 * Register : Tx_Deferred_Packets
 *
 * This register provides the number of successfully transmitted by DWC_xgmac after
 * a deferral in the half-duplex mode.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_DEFERRED_PACKETS_TXDEFRD
 *
 */
/*
 * Field : TXDEFRD
 *
 * Tx Deferred Packets
 *
 * This field indicates the number of successfully transmitted after a deferral in
 * the half-duplex mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_DEFERRED_PACKETS_TXDEFRD register field.
 */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_TX_DEFERRED_PACKETS_TXDEFRD register field.
 */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_MSB	    31
/* The width in bits of the CORE_TX_DEFERRED_PACKETS_TXDEFRD register field. */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_WIDTH	    32
/* The mask used to set the CORE_TX_DEFERRED_PACKETS_TXDEFRD register field value. */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_DEFERRED_PACKETS_TXDEFRD register field value. */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_DEFERRED_PACKETS_TXDEFRD register field. */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_RESET	    0x0
/* Extracts the CORE_TX_DEFERRED_PACKETS_TXDEFRD field value from a register. */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_DEFERRED_PACKETS_TXDEFRD register field value suitable for setting the
 * register. */
#define CORE_TX_DEFERRED_PACKETS_TXDEFRD_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_DEFERRED_PACKETS.
 */
struct CORE_TX_DEFERRED_PACKETS_s {
	const volatile uint32_t TXDEFRD : 32; /* CORE_TX_DEFERRED_PACKETS_TXDEFRD */
};

/* The typedef declaration for register CORE_TX_DEFERRED_PACKETS. */
typedef struct CORE_TX_DEFERRED_PACKETS_s CORE_TX_DEFERRED_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_DEFERRED_PACKETS register. */
#define CORE_TX_DEFERRED_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_TX_DEFERRED_PACKETS register from the beginning of the component. */
#define CORE_TX_DEFERRED_PACKETS_OFST  0xa48

/*
 * Register : Tx_Late_Collision_Packets
 *
 * This register provides the number of packets aborted by DWC_xgmac because of
 * late collision error.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL
 *
 */
/*
 * Field : TXLATECOL
 *
 * Tx Late Collision Packets
 *
 * This field indicates the number of packets aborted because of late collision
 * error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register
 * field. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register
 * field. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_MSB	    31
/* The width in bits of the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register field. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_WIDTH	    32
/* The mask used to set the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register field value. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register field value. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register field. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_RESET	    0x0
/* Extracts the CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL field value from a register. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL register field value suitable for setting the
 * register. */
#define CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_LATE_COLLISION_PACKETS.
 */
struct CORE_TX_LATE_COLLISION_PACKETS_s {
	const volatile uint32_t TXLATECOL : 32; /* CORE_TX_LATE_COLLISION_PACKETS_TXLATECOL */
};

/* The typedef declaration for register CORE_TX_LATE_COLLISION_PACKETS. */
typedef struct CORE_TX_LATE_COLLISION_PACKETS_s CORE_TX_LATE_COLLISION_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_LATE_COLLISION_PACKETS register. */
#define CORE_TX_LATE_COLLISION_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_TX_LATE_COLLISION_PACKETS register from the beginning of the
 * component. */
#define CORE_TX_LATE_COLLISION_PACKETS_OFST  0xa4c

/*
 * Register : Tx_Excessive_Collision_Packets
 *
 * This register provides the number of packets aborted by DWC_xgmac because of
 * excessive (16) collision errors.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL
 *
 */
/*
 * Field : TXEXSCOL
 *
 * Tx Excessive Collision Packets
 *
 * This field indicates the number of packets aborted because of excessive (16)
 * collision errors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL
 * register field. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL
 * register field. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_MSB	31
/* The width in bits of the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL register field. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_WIDTH	32
/* The mask used to set the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL register field value. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_SET_MSK	0xffffffff
/* The mask used to clear the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL register field value. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_CLR_MSK	0x00000000
/* The reset value of the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL register field. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_RESET	0x0
/* Extracts the CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL field value from a register. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL register field value suitable for setting
 * the register. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_EXCESSIVE_COLLISION_PACKETS.
 */
struct CORE_TX_EXCESSIVE_COLLISION_PACKETS_s {
	const volatile uint32_t TXEXSCOL : 32; /* CORE_TX_EXCESSIVE_COLLISION_PACKETS_TXEXSCOL */
};

/* The typedef declaration for register CORE_TX_EXCESSIVE_COLLISION_PACKETS. */
typedef struct CORE_TX_EXCESSIVE_COLLISION_PACKETS_s CORE_TX_EXCESSIVE_COLLISION_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_EXCESSIVE_COLLISION_PACKETS register. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_TX_EXCESSIVE_COLLISION_PACKETS register from the beginning of the
 * component. */
#define CORE_TX_EXCESSIVE_COLLISION_PACKETS_OFST  0xa50

/*
 * Register : Tx_Carrier_Error_Packets
 *
 * This register provides the number of packets aborted by DWC_xgmac because of
 * carrier sense error (no carrier or loss of carrier).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_CARRIER_ERROR_PACKETS_TXCARR
 *
 */
/*
 * Field : TXCARR
 *
 * Tx Carrier Error Packets
 *
 * This field indicates the number of packets aborted because of carrier sense
 * error (no carrier or loss of carrier).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register
 * field. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register
 * field. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_MSB	31
/* The width in bits of the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register field. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_WIDTH	32
/* The mask used to set the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register field value. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_SET_MSK	0xffffffff
/* The mask used to clear the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register field value. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_CLR_MSK	0x00000000
/* The reset value of the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register field. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_RESET	0x0
/* Extracts the CORE_TX_CARRIER_ERROR_PACKETS_TXCARR field value from a register. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_CARRIER_ERROR_PACKETS_TXCARR register field value suitable for setting the
 * register. */
#define CORE_TX_CARRIER_ERROR_PACKETS_TXCARR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_CARRIER_ERROR_PACKETS.
 */
struct CORE_TX_CARRIER_ERROR_PACKETS_s {
	const volatile uint32_t TXCARR : 32; /* CORE_TX_CARRIER_ERROR_PACKETS_TXCARR */
};

/* The typedef declaration for register CORE_TX_CARRIER_ERROR_PACKETS. */
typedef struct CORE_TX_CARRIER_ERROR_PACKETS_s CORE_TX_CARRIER_ERROR_PACKETS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_CARRIER_ERROR_PACKETS register. */
#define CORE_TX_CARRIER_ERROR_PACKETS_RESET 0x00000000
/* The byte offset of the CORE_TX_CARRIER_ERROR_PACKETS register from the beginning of the
 * component. */
#define CORE_TX_CARRIER_ERROR_PACKETS_OFST  0xa54

/*
 * Register : Tx_Excessive_Deferral_Error
 *
 * This register provides the number of packets aborted by DWC_xgmac because of
 * excessive deferral error (deferred for more than two max-size packet times).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF
 *
 */
/*
 * Field : TXEXSDEF
 *
 * Tx Excessive Deferral Error
 *
 * This field indicates the number of packets aborted because of excessive deferral
 * error (deferred for more than two max-sized packet times).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF
 * register field. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF register
 * field. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_MSB	     31
/* The width in bits of the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF register field. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_WIDTH	     32
/* The mask used to set the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF register field value. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_SET_MSK    0xffffffff
/* The mask used to clear the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF register field value. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_CLR_MSK    0x00000000
/* The reset value of the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF register field. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_RESET	     0x0
/* Extracts the CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF field value from a register. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF register field value suitable for setting
 * the register. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_TX_EXCESSIVE_DEFERRAL_ERROR.
 */
struct CORE_TX_EXCESSIVE_DEFERRAL_ERROR_s {
	const volatile uint32_t TXEXSDEF : 32; /* CORE_TX_EXCESSIVE_DEFERRAL_ERROR_TXEXSDEF */
};

/* The typedef declaration for register CORE_TX_EXCESSIVE_DEFERRAL_ERROR. */
typedef struct CORE_TX_EXCESSIVE_DEFERRAL_ERROR_s CORE_TX_EXCESSIVE_DEFERRAL_ERROR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_TX_EXCESSIVE_DEFERRAL_ERROR register. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_RESET 0x00000000
/* The byte offset of the CORE_TX_EXCESSIVE_DEFERRAL_ERROR register from the beginning of the
 * component. */
#define CORE_TX_EXCESSIVE_DEFERRAL_ERROR_OFST  0xa58

/*
 * Register : MMC_IPC_Rx_Interrupt_Mask
 *
 * This register maintains the mask for the interrupt generated from the receive
 * IPC statistic counters.
 *
 * The MMC Receive Checksum Off load Interrupt Mask register maintains the masks
 * for the interrupts generated when the receive IPC (Checksum Off load) statistic
 * counters reach half their maximum value, and when they reach their maximum
 * values. This register is 32 bits wide.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM
 *  [1]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM
 *  [2]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM
 *  [3]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM
 *  [4]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM
 *  [5]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM
 *  [6]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM
 *  [7]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM
 *  [8]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM
 *  [9]     | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM
 *  [10]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM
 *  [11]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM
 *  [12]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM
 *  [13]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM
 *  [15:14] | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14
 *  [16]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM
 *  [17]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM
 *  [18]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM
 *  [19]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM
 *  [20]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM
 *  [21]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM
 *  [22]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM
 *  [23]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM
 *  [24]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM
 *  [25]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM
 *  [26]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM
 *  [27]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM
 *  [28]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM
 *  [29]    | RW     | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM
 *  [31:30] | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30
 *
 */
/*
 * Field : RXIPV4GPIM
 *
 * MMC Receive IPV4 Good Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_Good_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_E_DISABLE | 0x0   | MMC Receive IPV4 Good Packet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_E_ENABLE  | 0x1   | MMC Receive IPV4 Good
 * Packet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM
 *
 * MMC Receive IPV4 Good Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM
 *
 * MMC Receive IPV4 Good Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_MSB	     0
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_SET_MSK    0x00000001
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RXIPV4HERPIM
 *
 * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_Header_Error_Packets
 * counter reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                    | Value | Description
 * :------------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_E_DISABLE | 0x0   | MMC Receive IPV4 Header Error
 * Packet Counter :                                                                        |       |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV4 Header Error Packet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM
 *
 * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM
 *
 * MMC Receive IPV4 Header Error Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_LSB	       1
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_MSB	       1
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_SET_MSK    0x00000002
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RXIPV4NOPAYPIM
 *
 * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_No_Payload_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_E_DISABLE | 0x0   | MMC Receive IPV4 No Payload
 * Packet Counter :                                                                          | |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV4 No Payload Packet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM
 *
 * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM
 *
 * MMC Receive IPV4 No Payload Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_MSB	 2
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_SET_MSK	 0x00000004
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_CLR_MSK	 0xfffffffb
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : RXIPV4FRAGPIM
 *
 * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_Fragmented_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                     | Value | Description
 * :-------------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_E_DISABLE | 0x0   | MMC Receive IPV4 Fragmented
 * Packet Counter :                                                                         | |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV4 Fragmented Packet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM
 *
 * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM
 *
 * MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_LSB	3
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_MSB	3
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_SET_MSK	0x00000008
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_CLR_MSK	0xfffffff7
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : RXIPV4UDSBLPIM
 *
 * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the
 * RxIPv4_UDP_Checksum_Disabled_Packets counter reaches half of the maximum value
 * or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_E_DISABLE | 0x0   | MMC Receive IPV4 UDP Checksum
 * Disabled Packet :                                                                          | |
 * Counter Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_E_ENABLE  | 0x1
 * | MMC Receive IPV4 UDP Checksum Disabled Packet : |       | Counter Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM
 *
 * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM
 *
 * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_LSB	 4
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_MSB	 4
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_SET_MSK	 0x00000010
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_CLR_MSK	 0xffffffef
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : RXIPV6GPIM
 *
 * MMC Receive IPV6 Good Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv6_Good_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_E_DISABLE | 0x0   | MMC Receive IPV6 Good Packet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_E_ENABLE  | 0x1   | MMC Receive IPV6 Good
 * Packet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM
 *
 * MMC Receive IPV6 Good Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM
 *
 * MMC Receive IPV6 Good Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_LSB	     5
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_MSB	     5
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_SET_MSK    0x00000020
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : RXIPV6HERPIM
 *
 * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv6_Header_Error_Packets
 * counter reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                    | Value | Description
 * :------------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_E_DISABLE | 0x0   | MMC Receive IPV6 Header Error
 * Packet Counter :                                                                        |       |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV6 Header Error Packet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM
 *
 * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM
 *
 * MMC Receive IPV6 Header Error Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_LSB	       6
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_MSB	       6
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_SET_MSK    0x00000040
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : RXIPV6NOPAYPIM
 *
 * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv6_No_Payload_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_E_DISABLE | 0x0   | MMC Receive IPV6 No Payload
 * Packet Counter :                                                                          | |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV6 No Payload Packet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM
 *
 * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM
 *
 * MMC Receive IPV6 No Payload Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_LSB	 7
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_MSB	 7
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_SET_MSK	 0x00000080
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_CLR_MSK	 0xffffff7f
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : RXUDPGPIM
 *
 * MMC Receive UDP Good Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxUDP_Good_Packets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                 | Value | Description
 * :---------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_E_DISABLE | 0x0   | MMC Receive UDP Good Packet Counter
 * Interrupt :                                                                     |       | Mask is
 * disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_E_ENABLE  | 0x1   | MMC Receive UDP Good Packet
 * Counter Interrupt :                                                                     |       |
 * Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM
 *
 * MMC Receive UDP Good Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM
 *
 * MMC Receive UDP Good Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_MSB	    8
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_SET_MSK    0x00000100
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : RXUDPERPIM
 *
 * MMC Receive UDP Error Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxUDP_Error_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_E_DISABLE | 0x0   | MMC Receive UDP Error Packet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_E_ENABLE  | 0x1   | MMC Receive UDP Error
 * Packet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM
 *
 * MMC Receive UDP Error Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM
 *
 * MMC Receive UDP Error Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_LSB	     9
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_MSB	     9
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_SET_MSK    0x00000200
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_CLR_MSK    0xfffffdff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : RXTCPGPIM
 *
 * MMC Receive TCP Good Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxTCP_Good_Packets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                 | Value | Description
 * :---------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_E_DISABLE | 0x0   | MMC Receive TCP Good Packet Counter
 * Interrupt :                                                                     |       | Mask is
 * disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_E_ENABLE  | 0x1   | MMC Receive TCP Good Packet
 * Counter Interrupt :                                                                     |       |
 * Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM
 *
 * MMC Receive TCP Good Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM
 *
 * MMC Receive TCP Good Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_LSB	    10
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_MSB	    10
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_SET_MSK    0x00000400
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : RXTCPERPIM
 *
 * MMC Receive TCP Error Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxTCP_Error_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_E_DISABLE | 0x0   | MMC Receive TCP Error Packet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_E_ENABLE  | 0x1   | MMC Receive TCP Error
 * Packet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM
 *
 * MMC Receive TCP Error Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM
 *
 * MMC Receive TCP Error Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_LSB	     11
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_MSB	     11
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_SET_MSK    0x00000800
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : RXICMPGPIM
 *
 * MMC Receive ICMP Good Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxICMP_Good_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_E_DISABLE | 0x0   | MMC Receive ICMP Good Packet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_E_ENABLE  | 0x1   | MMC Receive ICMP Good
 * Packet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM
 *
 * MMC Receive ICMP Good Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM
 *
 * MMC Receive ICMP Good Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_LSB	     12
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_MSB	     12
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_SET_MSK    0x00001000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_CLR_MSK    0xffffefff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : RXICMPERPIM
 *
 * MMC Receive ICMP Error Packet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxICMP_Error_Packets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                   | Value | Description
 * :-----------------------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_E_DISABLE | 0x0   | MMC Receive ICMP Error Packet
 * Counter Interrupt :                                                                       | |
 * Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_E_ENABLE  | 0x1   | MMC Receive ICMP
 * Error Packet Counter Interrupt : |       | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM
 *
 * MMC Receive ICMP Error Packet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM
 *
 * MMC Receive ICMP Error Packet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_LSB	      13
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_MSB	      13
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_SET_MSK    0x00002000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_CLR_MSK    0xffffdfff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_LSB	 14
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_MSB	 15
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_WIDTH	 2
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_SET_MSK	 0x0000c000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_CLR_MSK	 0xffff3fff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : RXIPV4GOIM
 *
 * MMC Receive IPV4 Good Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_Good_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_E_DISABLE | 0x0   | MMC Receive IPV4 Good Octet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_E_ENABLE  | 0x1   | MMC Receive IPV4 Good
 * Octet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM
 *
 * MMC Receive IPV4 Good Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM
 *
 * MMC Receive IPV4 Good Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_LSB	     16
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_MSB	     16
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_SET_MSK    0x00010000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_CLR_MSK    0xfffeffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : RXIPV4HEROIM
 *
 * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_Header_Error_Octets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                    | Value | Description
 * :------------------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_E_DISABLE | 0x0   | MMC Receive IPV4 Header Error
 * Octet Counter :                                                                        |       |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV4 Header Error Octet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM
 *
 * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM
 *
 * MMC Receive IPV4 Header Error Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_LSB	       17
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_MSB	       17
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_SET_MSK    0x00020000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_CLR_MSK    0xfffdffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : RXIPV4NOPAYOIM
 *
 * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_No_Payload_Octets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_E_DISABLE | 0x0   | MMC Receive IPV4 No Payload
 * Octet Counter :                                                                          | |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV4 No Payload Octet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM
 *
 * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM
 *
 * MMC Receive IPV4 No Payload Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_LSB	 18
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_MSB	 18
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_SET_MSK	 0x00040000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_CLR_MSK	 0xfffbffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : RXIPV4FRAGOIM
 *
 * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_Fragmented_Octets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                     | Value | Description
 * :-------------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_E_DISABLE | 0x0   | MMC Receive IPV4 Fragmented
 * Octet Counter :                                                                         |       |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV4 Fragmented Octet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM
 *
 * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM
 *
 * MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_LSB	19
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_MSB	19
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_SET_MSK	0x00080000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_CLR_MSK	0xfff7ffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : RXIPV4UDSBLOIM
 *
 * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv4_UDP_Checksum_Disable_Octets
 * counter reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_E_DISABLE | 0x0   | MMC Receive IPV4 UDP Checksum
 * Disabled Octet :                                                                          | |
 * Counter Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_E_ENABLE  | 0x1
 * | MMC Receive IPV4 UDP Checksum Disabled Octet : |       | Counter Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM
 *
 * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM
 *
 * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_LSB	 20
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_MSB	 20
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_SET_MSK	 0x00100000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_CLR_MSK	 0xffefffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : RXIPV6GOIM
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv6_Good_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_E_DISABLE | 0x0   | MMC Receive IPV6 Good Octet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_E_ENABLE  | 0x1   | MMC Receive IPV6 Good
 * Octet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_LSB	     21
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_MSB	     21
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_SET_MSK    0x00200000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_CLR_MSK    0xffdfffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : RXIPV6HEROIM
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv6_Header_Error_Octets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                    | Value | Description
 * :------------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_E_DISABLE | 0x0   | MMC Receive IPV6 Good Octet
 * Counter Interrupt :                                                                        | |
 * Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_E_ENABLE  | 0x1   | MMC Receive IPV6
 * Good Octet Counter Interrupt : |       | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_LSB	       22
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_MSB	       22
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_SET_MSK    0x00400000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_CLR_MSK    0xffbfffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : RXIPV6NOPAYOIM
 *
 * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxIPv6_No_Payload_Octets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                      | Value | Description
 * :--------------------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_E_DISABLE | 0x0   | MMC Receive IPV6 Header Error
 * Octet Counter :                                                                          | |
 * Interrupt Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_E_ENABLE  | 0x1   | MMC
 * Receive IPV6 Header Error Octet Counter : |       | Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM
 *
 * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM
 *
 * MMC Receive IPV6 Header Error Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_LSB	 23
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_MSB	 23
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_SET_MSK	 0x00800000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_CLR_MSK	 0xff7fffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : RXUDPGOIM
 *
 * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxUDP_Good_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                 | Value | Description
 * :---------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_E_DISABLE | 0x0   | MMC Receive IPV6 No Payload Octet
 * Counter :                                                                     |       | Interrupt
 * Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_E_ENABLE  | 0x1   | MMC Receive IPV6 No
 * Payload Octet Counter :                                                                     | |
 * Interrupt Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM
 *
 * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM
 *
 * MMC Receive IPV6 No Payload Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_LSB	    24
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_MSB	    24
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_SET_MSK    0x01000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : RXUDPEROIM
 *
 * MMC Receive UDP Good Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxUDP_Error_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_E_DISABLE | 0x0   | MMC Receive UDP Good Octet Counter
 * Interrupt :                                                                      |       | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_E_ENABLE  | 0x1   | MMC Receive UDP Good
 * Octet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM
 *
 * MMC Receive UDP Good Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM
 *
 * MMC Receive UDP Good Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_LSB	     25
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_MSB	     25
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_SET_MSK    0x02000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_CLR_MSK    0xfdffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : RXTCPGOIM
 *
 * MMC Receive TCP Good Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxTCP_Good_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                 | Value | Description
 * :---------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_E_DISABLE | 0x0   | MMC Receive TCP Good Octet Counter
 * Interrupt :                                                                     |       | Mask is
 * disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_E_ENABLE  | 0x1   | MMC Receive TCP Good Octet
 * Counter Interrupt :                                                                     |       |
 * Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM
 *
 * MMC Receive TCP Good Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM
 *
 * MMC Receive TCP Good Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_LSB	    26
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_MSB	    26
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_SET_MSK    0x04000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : RXTCPEROIM
 *
 * MMC Receive TCP Error Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxTCP_Error_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_E_DISABLE | 0x0   | MMC Receive TCP Error Octet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_E_ENABLE  | 0x1   | MMC Receive TCP Error
 * Octet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM
 *
 * MMC Receive TCP Error Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM
 *
 * MMC Receive TCP Error Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_LSB	     27
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_MSB	     27
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_SET_MSK    0x08000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_CLR_MSK    0xf7ffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : RXICMPGOIM
 *
 * MMC Receive ICMP Good Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxICMP_Good_Octets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_E_DISABLE | 0x0   | MMC Receive ICMP Good Octet
 * Counter Interrupt :                                                                      | | Mask
 * is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_E_ENABLE  | 0x1   | MMC Receive ICMP Good
 * Octet Counter Interrupt :                                                                      |
 * | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM
 *
 * MMC Receive ICMP Good Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM
 *
 * MMC Receive ICMP Good Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_LSB	     28
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_MSB	     28
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_WIDTH	     1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_SET_MSK    0x10000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_CLR_MSK    0xefffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_RESET	     0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : RXICMPEROIM
 *
 * MMC Receive ICMP Error Octet Counter Interrupt Mask
 *
 * Setting this bit masks the interrupt when the RxICMP_Error_Octets counter
 * reaches half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                   | Value | Description
 * :-----------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_E_DISABLE | 0x0   | MMC Receive ICMP Error Octet
 * Counter Interrupt :                                                                       | |
 * Mask is disabled CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_E_ENABLE  | 0x1   | MMC Receive ICMP
 * Error Octet Counter Interrupt : |       | Mask is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM
 *
 * MMC Receive ICMP Error Octet Counter Interrupt Mask is disabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_E_DISABLE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM
 *
 * MMC Receive ICMP Error Octet Counter Interrupt Mask is enabled
 */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_LSB	      29
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_MSB	      29
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_SET_MSK    0x20000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_CLR_MSK    0xdfffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM register field value suitable for setting
 * the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : Reserved_31_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_LSB	 30
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30
 * register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_MSB	 31
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_WIDTH	 2
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_SET_MSK	 0xc0000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_CLR_MSK	 0x3fffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 register field value suitable for
 * setting the register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_IPC_RX_INTERRUPT_MASK.
 */
struct CORE_MMC_IPC_RX_INTERRUPT_MASK_s {
	volatile uint32_t RXIPV4GPIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GPIM */
	volatile uint32_t RXIPV4HERPIM : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HERPIM */
	volatile uint32_t RXIPV4NOPAYPIM : 1; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYPIM */
	volatile uint32_t RXIPV4FRAGPIM : 1;  /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGPIM */
	volatile uint32_t RXIPV4UDSBLPIM : 1; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLPIM */
	volatile uint32_t RXIPV6GPIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GPIM */
	volatile uint32_t RXIPV6HERPIM : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HERPIM */
	volatile uint32_t RXIPV6NOPAYPIM : 1; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYPIM */
	volatile uint32_t RXUDPGPIM : 1;      /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGPIM */
	volatile uint32_t RXUDPERPIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPERPIM */
	volatile uint32_t RXTCPGPIM : 1;      /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGPIM */
	volatile uint32_t RXTCPERPIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPERPIM */
	volatile uint32_t RXICMPGPIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGPIM */
	volatile uint32_t RXICMPERPIM : 1;    /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPERPIM */
	const volatile uint32_t
		Reserved_15_14 : 2;	      /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_15_14 */
	volatile uint32_t RXIPV4GOIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4GOIM */
	volatile uint32_t RXIPV4HEROIM : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4HEROIM */
	volatile uint32_t RXIPV4NOPAYOIM : 1; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4NOPAYOIM */
	volatile uint32_t RXIPV4FRAGOIM : 1;  /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4FRAGOIM */
	volatile uint32_t RXIPV4UDSBLOIM : 1; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV4UDSBLOIM */
	volatile uint32_t RXIPV6GOIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6GOIM */
	volatile uint32_t RXIPV6HEROIM : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6HEROIM */
	volatile uint32_t RXIPV6NOPAYOIM : 1; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXIPV6NOPAYOIM */
	volatile uint32_t RXUDPGOIM : 1;      /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPGOIM */
	volatile uint32_t RXUDPEROIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXUDPEROIM */
	volatile uint32_t RXTCPGOIM : 1;      /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPGOIM */
	volatile uint32_t RXTCPEROIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXTCPEROIM */
	volatile uint32_t RXICMPGOIM : 1;     /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPGOIM */
	volatile uint32_t RXICMPEROIM : 1;    /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RXICMPEROIM */
	const volatile uint32_t
		Reserved_31_30 : 2; /* CORE_MMC_IPC_RX_INTERRUPT_MASK_RESERVED_31_30 */
};

/* The typedef declaration for register CORE_MMC_IPC_RX_INTERRUPT_MASK. */
typedef struct CORE_MMC_IPC_RX_INTERRUPT_MASK_s CORE_MMC_IPC_RX_INTERRUPT_MASK_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_MASK register. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_RESET 0x00000000
/* The byte offset of the CORE_MMC_IPC_RX_INTERRUPT_MASK register from the beginning of the
 * component. */
#define CORE_MMC_IPC_RX_INTERRUPT_MASK_OFST  0xa5c

/*
 * Register : MMC_IPC_Rx_Interrupt
 *
 * This register maintains the interrupt that the receive IPC statistic counters
 * generate.
 *
 * The MMC Receive Checksum Offload Interrupt register maintains the interrupts
 * generated when receive IPC statistic counters reach half their maximum values
 * (0x8000_0000_0000_0000 for 64 bit counter and 0x8000_0000 for 32 bit counter),
 * and when they cross their maximum values (0xFFFF_FFFF_FFFF_FFFF for 64 bit
 * counter and 0xFFFF_FFFF for 32 bit counter). When Counter Stop Rollover is set,
 * the interrupts are set but the counter remains at all-ones.
 *
 * The MMC Receive Checksum Offload Interrupt register is 32 bit wide. When the MMC
 * IPC counter that caused the interrupt is read, its corresponding interrupt bit
 * is cleared. The counter's least-significant byte lane (Bits[7:0]) must be read
 * to clear the interrupt bit.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS
 *  [1]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS
 *  [2]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS
 *  [3]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS
 *  [4]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS
 *  [5]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS
 *  [6]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS
 *  [7]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS
 *  [8]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS
 *  [9]     | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS
 *  [10]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS
 *  [11]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS
 *  [12]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS
 *  [13]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS
 *  [15:14] | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14
 *  [16]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS
 *  [17]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS
 *  [18]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS
 *  [19]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS
 *  [20]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS
 *  [21]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS
 *  [22]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS
 *  [23]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS
 *  [24]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS
 *  [25]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS
 *  [26]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS
 *  [27]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS
 *  [28]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS
 *  [29]    | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS
 *  [31:30] | R      | 0x0   | CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30
 *
 */
/*
 * Field : RXIPV4GPIS
 *
 * MMC Receive IPV4 Good Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_Good_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_E_INACTIVE | 0x0   | MMC Receive IPV4 Good Packet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_E_ACTIVE   | 0x1   | MMC Receive IPV4 Good Packet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS
 *
 * MMC Receive IPV4 Good Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS
 *
 * MMC Receive IPV4 Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_MSB	0
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_SET_MSK	0x00000001
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_CLR_MSK	0xfffffffe
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RXIPV4HERPIS
 *
 * MMC Receive IPV4 Header Error Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_Header_Error_Packets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                | Value | Description
 * :--------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_E_INACTIVE | 0x0   | MMC Receive IPV4 Header Error Packet
 * Counter :                                                                    |       | Interrupt
 * Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_E_ACTIVE   | 0x1   | MMC Receive IPV4
 * Header Error Packet Counter : |       | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS
 *
 * MMC Receive IPV4 Header Error Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS
 *
 * MMC Receive IPV4 Header Error Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_LSB	  1
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_MSB	  1
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_SET_MSK	  0x00000002
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_CLR_MSK	  0xfffffffd
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_RESET	  0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RXIPV4NOPAYPIS
 *
 * MMC Receive IPV4 No Payload Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_No_Payload_Packets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_E_INACTIVE | 0x0   | MMC Receive IPV4 No Payload Packet
 * Counter :                                                                      |       |
 * Interrupt Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_E_ACTIVE   | 0x1   | MMC
 * Receive IPV4 No Payload Packet Counter : |       | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS
 *
 * MMC Receive IPV4 No Payload Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS
 *
 * MMC Receive IPV4 No Payload Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_LSB	    2
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_MSB	    2
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_SET_MSK    0x00000004
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : RXIPV4FRAGPIS
 *
 * MMC Receive IPV4 Fragmented Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_Fragmented_Packets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                 | Value | Description
 * :---------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_E_INACTIVE | 0x0   | MMC Receive IPV4 Fragmented Packet
 * Counter :                                                                     |       | Interrupt
 * Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_E_ACTIVE   | 0x1   | MMC Receive IPV4
 * Fragmented Packet Counter :                                                                     |
 * | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS
 *
 * MMC Receive IPV4 Fragmented Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS
 *
 * MMC Receive IPV4 Fragmented Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_LSB	   3
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_MSB	   3
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_WIDTH	   1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_SET_MSK	   0x00000008
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_CLR_MSK	   0xfffffff7
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_RESET	   0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : RXIPV4UDSBLPIS
 *
 * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_UDP_Checksum_Disabled_Packets counter reaches
 * half of the maximum value or the maximum value.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_E_INACTIVE | 0x0   | MMC Receive IPV4 UDP Checksum
 * Disabled Packet :                                                                      |       |
 * Counter Interrupt Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_E_ACTIVE   | 0x1
 * | MMC Receive IPV4 UDP Checksum Disabled Packet : |       | Counter Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS
 *
 * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Status not
 * detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS
 *
 * MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_LSB	    4
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_MSB	    4
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_SET_MSK    0x00000010
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_CLR_MSK    0xffffffef
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : RXIPV6GPIS
 *
 * MMC Receive IPV6 Good Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv6_Good_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_E_INACTIVE | 0x0   | MMC Receive IPV6 Good Packet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_E_ACTIVE   | 0x1   | MMC Receive IPV6 Good Packet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS
 *
 * MMC Receive IPV6 Good Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS
 *
 * MMC Receive IPV6 Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_MSB	5
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_SET_MSK	0x00000020
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : RXIPV6HERPIS
 *
 * MMC Receive IPV6 Header Error Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv6_Header_Error_Packets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                | Value | Description
 * :--------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_E_INACTIVE | 0x0   | MMC Receive IPV6 Header Error Packet
 * Counter :                                                                    |       | Interrupt
 * Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_E_ACTIVE   | 0x1   | MMC Receive IPV6
 * Header Error Packet Counter : |       | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS
 *
 * MMC Receive IPV6 Header Error Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS
 *
 * MMC Receive IPV6 Header Error Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_LSB	  6
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_MSB	  6
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_WIDTH	  1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_SET_MSK	  0x00000040
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_CLR_MSK	  0xffffffbf
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_RESET	  0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : RXIPV6NOPAYPIS
 *
 * MMC Receive IPV6 No Payload Packet Counter Interrupt Status
 *
 * This bit is set when the RxIPv6_No_Payload_Packets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:-------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_E_INACTIVE | 0x0   | MMC Receive IPV6 No Payload Packet
 * Counter :                                                                      |       |
 * Interrupt Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_E_ACTIVE   | 0x1   | MMC
 * Receive IPV6 No Payload Packet Counter : |       | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS
 *
 * MMC Receive IPV6 No Payload Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS
 *
 * MMC Receive IPV6 No Payload Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_LSB	    7
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_MSB	    7
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_SET_MSK    0x00000080
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : RXUDPGPIS
 *
 * MC Receive UDP Good Packet Counter Interrupt Status
 *
 * This bit is set when the RxUDP_Good_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_E_INACTIVE | 0x0   | MMC Receive UDP Good Packet Counter
 * Interrupt :                                                                 |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_E_ACTIVE   | 0x1   | MMC Receive UDP Good Packet
 * Counter Interrupt :                                                                 |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS
 *
 * MMC Receive UDP Good Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS
 *
 * MMC Receive UDP Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_LSB	       8
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_MSB	       8
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_SET_MSK    0x00000100
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : RXUDPERPIS
 *
 * MMC Receive UDP Error Packet Counter Interrupt Status
 *
 * This bit is set when the RxUDP_Error_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_E_INACTIVE | 0x0   | MMC Receive UDP Error Packet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_E_ACTIVE   | 0x1   | MMC Receive UDP Error Packet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS
 *
 * MMC Receive UDP Error Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS
 *
 * MMC Receive UDP Error Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_LSB	9
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_MSB	9
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_SET_MSK	0x00000200
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_CLR_MSK	0xfffffdff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : RXTCPGPIS
 *
 * MMC Receive TCP Good Packet Counter Interrupt Status
 *
 * This bit is set when the RxTCP_Good_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_E_INACTIVE | 0x0   | MMC Receive TCP Good Packet Counter
 * Interrupt :                                                                 |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_E_ACTIVE   | 0x1   | MMC Receive TCP Good Packet
 * Counter Interrupt :                                                                 |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS
 *
 * MMC Receive TCP Good Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS
 *
 * MMC Receive TCP Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_LSB	       10
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_MSB	       10
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_SET_MSK    0x00000400
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_CLR_MSK    0xfffffbff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : RXTCPERPIS
 *
 * MMC Receive TCP Error Packet Counter Interrupt Status
 *
 * This bit is set when the RxTCP_Error_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_E_INACTIVE | 0x0   | MMC Receive TCP Error Packet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_E_ACTIVE   | 0x1   | MMC Receive TCP Error Packet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS
 *
 * MMC Receive TCP Error Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS
 *
 * MMC Receive TCP Error Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_LSB	11
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_MSB	11
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_SET_MSK	0x00000800
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_CLR_MSK	0xfffff7ff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : RXICMPGPIS
 *
 * MMC Receive ICMP Good Packet Counter Interrupt Status
 *
 * This bit is set when the RxICMP_Good_Packets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_E_INACTIVE | 0x0   | MMC Receive ICMP Good Packet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_E_ACTIVE   | 0x1   | MMC Receive ICMP Good Packet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS
 *
 * MMC Receive ICMP Good Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS
 *
 * MMC Receive ICMP Good Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_LSB	12
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_MSB	12
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_SET_MSK	0x00001000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_CLR_MSK	0xffffefff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : RXICMPERPIS
 *
 * MMC Receive ICMP Error Packet Counter Interrupt Status
 *
 * This bit is set when the RxICMP_Error_Packets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                               | Value | Description
 * :-------------------------------------------------------------------|:------|:------------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_E_INACTIVE | 0x0   | MMC Receive ICMP Error Packet Counter
 * Interrupt :                                                                   |       | Status
 * not detected CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_E_ACTIVE   | 0x1   | MMC Receive ICMP Error
 * Packet Counter Interrupt :                                                                   | |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS
 *
 * MMC Receive ICMP Error Packet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS
 *
 * MMC Receive ICMP Error Packet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_E_ACTIVE	 0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_LSB	 13
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_MSB	 13
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_SET_MSK	 0x00002000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_CLR_MSK	 0xffffdfff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_LSB	    14
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_MSB	    15
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_WIDTH	    2
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_SET_MSK    0x0000c000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_CLR_MSK    0xffff3fff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : RXIPV4GOIS
 *
 * MMC Receive IPV4 Good Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_Good_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_E_INACTIVE | 0x0   | MMC Receive IPV4 Good Octet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_E_ACTIVE   | 0x1   | MMC Receive IPV4 Good Octet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS
 *
 * MMC Receive IPV4 Good Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS
 *
 * MMC Receive IPV4 Good Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_LSB	16
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_MSB	16
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_SET_MSK	0x00010000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_CLR_MSK	0xfffeffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : RXIPV4HEROIS
 *
 * MMC Receive IPV4 Header Error Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_Header_Error_Octets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                | Value | Description
 * :--------------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_E_INACTIVE | 0x0   | MMC Receive IPV4 Header Error Octet
 * Counter :                                                                    |       | Interrupt
 * Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_E_ACTIVE   | 0x1   | MMC Receive IPV4
 * Header Error Octet Counter :                                                                    |
 * | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS
 *
 * MMC Receive IPV4 Header Error Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS
 *
 * MMC Receive IPV4 Header Error Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_LSB	  17
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_MSB	  17
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_WIDTH	  1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_SET_MSK	  0x00020000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_CLR_MSK	  0xfffdffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_RESET	  0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : RXIPV4NOPAYOIS
 *
 * MMC Receive IPV4 No Payload Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_No_Payload_Octets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_E_INACTIVE | 0x0   | MMC Receive IPV4 No Payload Octet
 * Counter :                                                                      |       |
 * Interrupt Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_E_ACTIVE   | 0x1   | MMC
 * Receive IPV4 No Payload Octet Counter : |       | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS
 *
 * MMC Receive IPV4 No Payload Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS
 *
 * MMC Receive IPV4 No Payload Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_LSB	    18
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_MSB	    18
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_SET_MSK    0x00040000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_CLR_MSK    0xfffbffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : RXIPV4FRAGOIS
 *
 * MMC Receive IPV4 Fragmented Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv4_Fragmented_Octets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                 | Value | Description
 * :---------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_E_INACTIVE | 0x0   | MMC Receive IPV4 Fragmented Octet
 * Counter :                                                                     |       | Interrupt
 * Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_E_ACTIVE   | 0x1   | MMC Receive IPV4
 * Fragmented Octet Counter :                                                                     |
 * | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS
 *
 * MMC Receive IPV4 Fragmented Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS
 *
 * MMC Receive IPV4 Fragmented Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_LSB	   19
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_MSB	   19
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_WIDTH	   1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_SET_MSK	   0x00080000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_CLR_MSK	   0xfff7ffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_RESET	   0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : RXIPV4UDSBLOIS
 *
 * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt
 *
 * Status
 *
 * This bit is set when the RxIPv4_UDP_Checksum_Disable_Octets counter reaches half
 * of the maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_E_INACTIVE | 0x0   | MMC Receive IPV4 UDP Checksum
 * Disabled Octet :                                                                      |       |
 * Counter Interrupt Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_E_ACTIVE   | 0x1
 * | MMC Receive IPV4 UDP Checksum Disabled Octet : |       | Counter Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS
 *
 * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Status not
 * detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS
 *
 * MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_LSB	    20
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_MSB	    20
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_SET_MSK    0x00100000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_CLR_MSK    0xffefffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : RXIPV6GOIS
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv6_Good_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_E_INACTIVE | 0x0   | MMC Receive IPV6 Good Octet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_E_ACTIVE   | 0x1   | MMC Receive IPV6 Good Octet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS
 *
 * MMC Receive IPV6 Good Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_LSB	21
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_MSB	21
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_SET_MSK	0x00200000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_CLR_MSK	0xffdfffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_GET(value) (((value)&0x00200000) >> 21)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : RXIPV6HEROIS
 *
 * MMC Receive IPV6 Header Error Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv6_Header_Error_Octets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                | Value | Description
 * :--------------------------------------------------------------------|:------|:--------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_E_INACTIVE | 0x0   | MMC Receive IPV6 Header Error Octet
 * Counter :                                                                    |       | Interrupt
 * Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_E_ACTIVE   | 0x1   | MMC Receive IPV6
 * Header Error Octet Counter :                                                                    |
 * | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS
 *
 * MMC Receive IPV6 Header Error Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS
 *
 * MMC Receive IPV6 Header Error Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_E_ACTIVE	  0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_LSB	  22
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_MSB	  22
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_WIDTH	  1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_SET_MSK	  0x00400000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_CLR_MSK	  0xffbfffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_RESET	  0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_GET(value) (((value)&0x00400000) >> 22)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : RXIPV6NOPAYOIS
 *
 * MMC Receive IPV6 No Payload Octet Counter Interrupt Status
 *
 * This bit is set when the RxIPv6_No_Payload_Octets counter reaches half of the
 * maximum value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                  | Value | Description
 * :----------------------------------------------------------------------|:------|:------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_E_INACTIVE | 0x0   | MMC Receive IPV6 No Payload Octet
 * Counter :                                                                      |       |
 * Interrupt Status not detected CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_E_ACTIVE   | 0x1   | MMC
 * Receive IPV6 No Payload Octet Counter : |       | Interrupt Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS
 *
 * MMC Receive IPV6 No Payload Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS
 *
 * MMC Receive IPV6 No Payload Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_LSB	    23
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_MSB	    23
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_WIDTH	    1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_SET_MSK    0x00800000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : RXUDPGOIS
 *
 * MMC Receive UDP Good Octet Counter Interrupt Status
 *
 * This bit is set when the RxUDP_Good_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_E_INACTIVE | 0x0   | MMC Receive UDP Good Octet Counter
 * Interrupt :                                                                 |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_E_ACTIVE   | 0x1   | MMC Receive UDP Good Octet
 * Counter Interrupt :                                                                 |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS
 *
 * MMC Receive UDP Good Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS
 *
 * MMC Receive UDP Good Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_MSB	       24
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_SET_MSK    0x01000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : RXUDPEROIS
 *
 * MMC Receive UDP Error Octet Counter Interrupt Status
 *
 * This bit is set when the RxUDP_Error_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_E_INACTIVE | 0x0   | MMC Receive UDP Error Octet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_E_ACTIVE   | 0x1   | MMC Receive UDP Error Octet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS
 *
 * MMC Receive UDP Error Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS
 *
 * MMC Receive UDP Error Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_LSB	25
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_MSB	25
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_SET_MSK	0x02000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_CLR_MSK	0xfdffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_GET(value) (((value)&0x02000000) >> 25)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS_SET(value) (((value) << 25) & 0x02000000)

/*
 * Field : RXTCPGOIS
 *
 * MMC Receive TCP Good Octet Counter Interrupt Status
 *
 * This bit is set when the RxTCP_Good_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                             | Value | Description
 * :-----------------------------------------------------------------|:------|:---------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_E_INACTIVE | 0x0   | MMC Receive TCP Good Octet Counter
 * Interrupt :                                                                 |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_E_ACTIVE   | 0x1   | MMC Receive TCP Good Octet
 * Counter Interrupt :                                                                 |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS
 *
 * MMC Receive TCP Good Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS
 *
 * MMC Receive TCP Good Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_LSB	       26
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_MSB	       26
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_WIDTH      1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_SET_MSK    0x04000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_CLR_MSK    0xfbffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_RESET      0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_GET(value) (((value)&0x04000000) >> 26)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS_SET(value) (((value) << 26) & 0x04000000)

/*
 * Field : RXTCPEROIS
 *
 * MMC Receive TCP Error Octet Counter Interrupt Status
 *
 * This bit is set when the RxTCP_Error_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_E_INACTIVE | 0x0   | MMC Receive TCP Error Octet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_E_ACTIVE   | 0x1   | MMC Receive TCP Error Octet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS
 *
 * MMC Receive TCP Error Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS
 *
 * MMC Receive TCP Error Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_LSB	27
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_MSB	27
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_SET_MSK	0x08000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_CLR_MSK	0xf7ffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_GET(value) (((value)&0x08000000) >> 27)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS_SET(value) (((value) << 27) & 0x08000000)

/*
 * Field : RXICMPGOIS
 *
 * MMC Receive ICMP Good Octet Counter Interrupt Status
 *
 * This bit is set when the RxICMP_Good_Octets reaches half of the maximum value or
 * the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                              | Value | Description
 * :------------------------------------------------------------------|:------|:----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_E_INACTIVE | 0x0   | MMC Receive ICMP Good Octet Counter
 * Interrupt :                                                                  |       | Status not
 * detected CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_E_ACTIVE   | 0x1   | MMC Receive ICMP Good Octet
 * Counter Interrupt :                                                                  |       |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS
 *
 * MMC Receive ICMP Good Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS
 *
 * MMC Receive ICMP Good Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_E_ACTIVE	0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_LSB	28
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_MSB	28
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_WIDTH	1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_SET_MSK	0x10000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_CLR_MSK	0xefffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_RESET	0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : RXICMPEROIS
 *
 * MMC Receive ICMP Error Octet Counter Interrupt Status
 *
 * This bit is set when the RxICMP_Error_Octets counter reaches half of the maximum
 * value or the maximum value.
 *
 * Access restriction applies. Clears on read. Self-set to 1 on internal event.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                               | Value | Description
 * :-------------------------------------------------------------------|:------|:-----------------------------------------------
 *  CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_E_INACTIVE | 0x0   | MMC Receive ICMP Error Octet Counter
 * Interrupt :                                                                   |       | Status
 * not detected CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_E_ACTIVE   | 0x1   | MMC Receive ICMP Error
 * Octet Counter Interrupt :                                                                   | |
 * Status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS
 *
 * MMC Receive ICMP Error Octet Counter Interrupt Status not detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS
 *
 * MMC Receive ICMP Error Octet Counter Interrupt Status detected
 */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_E_ACTIVE	 0x1

/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_LSB	 29
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_MSB	 29
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_WIDTH	 1
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_SET_MSK	 0x20000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_CLR_MSK	 0xdfffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_RESET	 0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_GET(value) (((value)&0x20000000) >> 29)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS_SET(value) (((value) << 29) & 0x20000000)

/*
 * Field : Reserved_31_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_LSB	    30
/* The Most Significant Bit (MSB) position of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register
 * field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_MSB	    31
/* The width in bits of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_WIDTH	    2
/* The mask used to set the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_SET_MSK    0xc0000000
/* The mask used to clear the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register field value. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_CLR_MSK    0x3fffffff
/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register field. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_RESET	    0x0
/* Extracts the CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 field value from a register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 register field value suitable for setting the
 * register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MMC_IPC_RX_INTERRUPT.
 */
struct CORE_MMC_IPC_RX_INTERRUPT_s {
	const volatile uint32_t RXIPV4GPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GPIS */
	const volatile uint32_t RXIPV4HERPIS : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HERPIS */
	const volatile uint32_t RXIPV4NOPAYPIS : 1; /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYPIS */
	const volatile uint32_t RXIPV4FRAGPIS : 1;  /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGPIS */
	const volatile uint32_t RXIPV4UDSBLPIS : 1; /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLPIS */
	const volatile uint32_t RXIPV6GPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GPIS */
	const volatile uint32_t RXIPV6HERPIS : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HERPIS */
	const volatile uint32_t RXIPV6NOPAYPIS : 1; /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYPIS */
	const volatile uint32_t RXUDPGPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXUDPGPIS */
	const volatile uint32_t RXUDPERPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXUDPERPIS */
	const volatile uint32_t RXTCPGPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXTCPGPIS */
	const volatile uint32_t RXTCPERPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXTCPERPIS */
	const volatile uint32_t RXICMPGPIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXICMPGPIS */
	const volatile uint32_t RXICMPERPIS : 1;    /* CORE_MMC_IPC_RX_INTERRUPT_RXICMPERPIS */
	const volatile uint32_t Reserved_15_14 : 2; /* CORE_MMC_IPC_RX_INTERRUPT_RESERVED_15_14 */
	const volatile uint32_t RXIPV4GOIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4GOIS */
	const volatile uint32_t RXIPV4HEROIS : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4HEROIS */
	const volatile uint32_t RXIPV4NOPAYOIS : 1; /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4NOPAYOIS */
	const volatile uint32_t RXIPV4FRAGOIS : 1;  /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4FRAGOIS */
	const volatile uint32_t RXIPV4UDSBLOIS : 1; /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV4UDSBLOIS */
	const volatile uint32_t RXIPV6GOIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV6GOIS */
	const volatile uint32_t RXIPV6HEROIS : 1;   /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV6HEROIS */
	const volatile uint32_t RXIPV6NOPAYOIS : 1; /* CORE_MMC_IPC_RX_INTERRUPT_RXIPV6NOPAYOIS */
	const volatile uint32_t RXUDPGOIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXUDPGOIS */
	const volatile uint32_t RXUDPEROIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXUDPEROIS */
	const volatile uint32_t RXTCPGOIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXTCPGOIS */
	const volatile uint32_t RXTCPEROIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXTCPEROIS */
	const volatile uint32_t RXICMPGOIS : 1;	    /* CORE_MMC_IPC_RX_INTERRUPT_RXICMPGOIS */
	const volatile uint32_t RXICMPEROIS : 1;    /* CORE_MMC_IPC_RX_INTERRUPT_RXICMPEROIS */
	const volatile uint32_t Reserved_31_30 : 2; /* CORE_MMC_IPC_RX_INTERRUPT_RESERVED_31_30 */
};

/* The typedef declaration for register CORE_MMC_IPC_RX_INTERRUPT. */
typedef struct CORE_MMC_IPC_RX_INTERRUPT_s CORE_MMC_IPC_RX_INTERRUPT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MMC_IPC_RX_INTERRUPT register. */
#define CORE_MMC_IPC_RX_INTERRUPT_RESET 0x00000000
/* The byte offset of the CORE_MMC_IPC_RX_INTERRUPT register from the beginning of the component. */
#define CORE_MMC_IPC_RX_INTERRUPT_OFST	0xa60

/*
 * Register : RxIPv4_Good_Packets_Low
 *
 * This register provides lower 32 bits of good IPv4 datagrams received by
 * DWC_xgmac with the TCP, UDP, or ICMP payload.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO
 *
 */
/*
 * Field : RXIPV4GDPKTLO
 *
 * RxIPv4 Good Packets
 *
 * This field indicates lower 32 bits of good IPv4 datagrams received with the TCP,
 * UDP, or ICMP payload.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO
 * register field. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO
 * register field. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_MSB	      31
/* The width in bits of the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO register field. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO register field value. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO register field value. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO register field. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_RESET      0x0
/* Extracts the CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO field value from a register. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO register field value suitable for setting
 * the register. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_GOOD_PACKETS_LOW.
 */
struct CORE_RXIPV4_GOOD_PACKETS_LOW_s {
	const volatile uint32_t RXIPV4GDPKTLO : 32; /* CORE_RXIPV4_GOOD_PACKETS_LOW_RXIPV4GDPKTLO */
};

/* The typedef declaration for register CORE_RXIPV4_GOOD_PACKETS_LOW. */
typedef struct CORE_RXIPV4_GOOD_PACKETS_LOW_s CORE_RXIPV4_GOOD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_GOOD_PACKETS_LOW register. */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_GOOD_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXIPV4_GOOD_PACKETS_LOW_OFST  0xa64

/*
 * Register : RxIPv4_Header_Error_Packets_Low
 *
 * RxIPv4 Header Error Packets
 *
 * This register provides lower 32 bits of IPv4 datagrams received by DWC_xgmac
 * with header (checksum, length, or version mismatch) errors.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO
 *
 */
/*
 * Field : RXIPV4HDRERRPKTLO
 *
 * RxIPv4 Header Error Packets
 *
 * This field indicates lower 32 bits of IPv4 datagrams received with header
 * (checksum, length, or version mismatch) errors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_MSB     31
/* The width in bits of the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field.
 */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_WIDTH   32
/* The mask used to set the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field
 * value. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field
 * value. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_RESET   0x0
/* Extracts the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO field value from a register.
 */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_GET(value)                          \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO register field value suitable
 * for setting the register. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO_SET(value)                          \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW.
 */
struct CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_s {
	const volatile uint32_t
		RXIPV4HDRERRPKTLO : 32; /* CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RXIPV4HDRERRPKTLO */
};

/* The typedef declaration for register CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW. */
typedef struct CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_s CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW register. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_OFST  0xa6c

/*
 * Register : RxIPv4_No_Payload_Packets_Low
 *
 * This register provides lower 32 bits of IPv4 datagram packets received by
 * DWC_xgmac that did not have a TCP, UDP, or ICMP payload.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO
 *
 */
/*
 * Field : RXIPV4NOPAYPKTLO
 *
 * RxIPv4 Payload Packets
 *
 * This field indicates lower 32 bits of IPv4 datagram packets received that did
 * not have a TCP, UDP, or ICMP payload.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_LSB	       0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_MSB	       31
/* The width in bits of the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field
 * value. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field
 * value. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_RESET      0x0
/* Extracts the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO field value from a register. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO register field value suitable for
 * setting the register. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW.
 */
struct CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_s {
	const volatile uint32_t
		RXIPV4NOPAYPKTLO : 32; /* CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RXIPV4NOPAYPKTLO */
};

/* The typedef declaration for register CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW. */
typedef struct CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_s CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW register. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_OFST	 0xa74

/*
 * Register : RxIPv4_Fragmented_Packets_Low
 *
 * This register provides lower 32 bits of good IPv4 datagrams received by
 * DWC_xgmac with fragmentation.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO
 *
 */
/*
 * Field : RXIPV4FRAGPKTLO
 *
 * RxIPv4 Fragmented Packets
 *
 * This field indicates lower 32 bits of good IPv4 datagrams received with
 * fragmentation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO register field. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO
 * register field. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_MSB	      31
/* The width in bits of the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO register field. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO register field value.
 */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO register field
 * value. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO register field. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_RESET      0x0
/* Extracts the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO field value from a register. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO register field value suitable for
 * setting the register. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_FRAGMENTED_PACKETS_LOW.
 */
struct CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_s {
	const volatile uint32_t
		RXIPV4FRAGPKTLO : 32; /* CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RXIPV4FRAGPKTLO */
};

/* The typedef declaration for register CORE_RXIPV4_FRAGMENTED_PACKETS_LOW. */
typedef struct CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_s CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW register. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_FRAGMENTED_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_OFST	 0xa7c

/*
 * Register : RxIPv4_UDP_Checksum_Disabled_Packets_Low
 *
 * This register provides lower 32 bits of good IPv4 datagrams received by
 * DWC_xgmac that had a UDP payload with checksum disabled.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO
 *
 */
/*
 * Field : RXIPV4UDSBLPKTLO
 *
 * RxIPv4 UDP Checksum Disabled Packets
 *
 * This field indicates lower 32 bits of good IPv4 datagrams received that had a
 * UDP payload with checksum disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO register field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO register field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_MSB     31
/* The width in bits of the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO register
 * field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_WIDTH   32
/* The mask used to set the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO register
 * field value. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO
 * register field value. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO register
 * field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_RESET   0x0
/* Extracts the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO field value from a
 * register. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_GET(value)                  \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO register field value
 * suitable for setting the register. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO_SET(value)                  \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW.
 */
struct CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_s {
	const volatile uint32_t RXIPV4UDSBLPKTLO : 32; /* CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RXIPV4UDSBLPKTLO
							*/
};

/* The typedef declaration for register CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW. */
typedef struct CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_s
	CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW register. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW register from the beginning
 * of the component. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_OFST  0xa84

/*
 * Register : RxIPv6_Good_Packets_Low
 *
 * This register provides lower 32 bits of good IPv6 datagrams received by
 * DWC_xgmac with the TCP, UDP, or ICMP payload.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO
 *
 */
/*
 * Field : RXIPV6GDPKTLO
 *
 * RxIPv6 Good Packets
 *
 * This field indicates lower 32 bits of good IPv6 datagrams received with the TCP,
 * UDP, or ICMP payload.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO
 * register field. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO
 * register field. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_MSB	      31
/* The width in bits of the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO register field. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO register field value. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO register field value. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO register field. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_RESET      0x0
/* Extracts the CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO field value from a register. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO register field value suitable for setting
 * the register. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV6_GOOD_PACKETS_LOW.
 */
struct CORE_RXIPV6_GOOD_PACKETS_LOW_s {
	const volatile uint32_t RXIPV6GDPKTLO : 32; /* CORE_RXIPV6_GOOD_PACKETS_LOW_RXIPV6GDPKTLO */
};

/* The typedef declaration for register CORE_RXIPV6_GOOD_PACKETS_LOW. */
typedef struct CORE_RXIPV6_GOOD_PACKETS_LOW_s CORE_RXIPV6_GOOD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV6_GOOD_PACKETS_LOW register. */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV6_GOOD_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXIPV6_GOOD_PACKETS_LOW_OFST  0xa8c

/*
 * Register : RxIPv6_Header_Error_Packets_Low
 *
 * This register provides lower 32 bits of IPv6 datagrams received by DWC_xgmac
 * with header (length or version mismatch) errors.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO
 *
 */
/*
 * Field : RXIPV6HDRERRPKTLO
 *
 * RxIPv6 Header Error Packets
 *
 * This field indicates lower 32 bits of IPv6 datagrams received with header
 * (length or version mismatch) errors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_MSB     31
/* The width in bits of the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field.
 */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_WIDTH   32
/* The mask used to set the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field
 * value. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field
 * value. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_RESET   0x0
/* Extracts the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO field value from a register.
 */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_GET(value)                          \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO register field value suitable
 * for setting the register. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO_SET(value)                          \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW.
 */
struct CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_s {
	const volatile uint32_t
		RXIPV6HDRERRPKTLO : 32; /* CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RXIPV6HDRERRPKTLO */
};

/* The typedef declaration for register CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW. */
typedef struct CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_s CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW register. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_OFST  0xa94

/*
 * Register : RxIPv6_No_Payload_Packets_Low
 *
 * This register provides lower 32 bits of IPv6 datagram packets received by
 * DWC_xgmac that did not have a TCP, UDP, or ICMP payload. This includes all IPv6
 * datagrams with fragmentation or security extension headers.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO
 *
 */
/*
 * Field : RXIPV6NOPAYPKTLO
 *
 * RxIPv6 Payload Packets
 *
 * This field indicates lower 32 bits of IPv6 datagram packets received that did
 * not have a TCP, UDP, or ICMP payload. This includes all IPv6 datagrams with
 * fragmentation or security extension headers.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_LSB	       0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_MSB	       31
/* The width in bits of the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field
 * value. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field
 * value. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_RESET      0x0
/* Extracts the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO field value from a register. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO register field value suitable for
 * setting the register. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW.
 */
struct CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_s {
	const volatile uint32_t
		RXIPV6NOPAYPKTLO : 32; /* CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RXIPV6NOPAYPKTLO */
};

/* The typedef declaration for register CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW. */
typedef struct CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_s CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW register. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_OFST	 0xa9c

/*
 * Register : RxUDP_Good_Packets_Low
 *
 * This register provides lower 32 bits of good IP datagrams received by DWC_xgmac
 * with a good UDP payload. This counter is not updated when the
 * RxIPv4_UDP_Checksum_Disabled_Packets counter is incremented.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO
 *
 */
/*
 * Field : RXUDPGDPKTLO
 *
 * RxUDP Good Packets
 *
 * This field indicates lower 32 bits of good IP datagrams received with a good UDP
 * payload. This counter is not updated when the
 * RxIPv4_UDP_Checksum_Disabled_Packets counter is incremented.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register
 * field. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register
 * field. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_MSB	    31
/* The width in bits of the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register field. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_WIDTH	    32
/* The mask used to set the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register field value. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register field value. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register field. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_RESET	    0x0
/* Extracts the CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO field value from a register. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO register field value suitable for setting the
 * register. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXUDP_GOOD_PACKETS_LOW.
 */
struct CORE_RXUDP_GOOD_PACKETS_LOW_s {
	const volatile uint32_t RXUDPGDPKTLO : 32; /* CORE_RXUDP_GOOD_PACKETS_LOW_RXUDPGDPKTLO */
};

/* The typedef declaration for register CORE_RXUDP_GOOD_PACKETS_LOW. */
typedef struct CORE_RXUDP_GOOD_PACKETS_LOW_s CORE_RXUDP_GOOD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXUDP_GOOD_PACKETS_LOW register. */
#define CORE_RXUDP_GOOD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXUDP_GOOD_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXUDP_GOOD_PACKETS_LOW_OFST  0xaa4

/*
 * Register : RxUDP_Error_Packets_Low
 *
 * This register provides lower 32 bits of good IP datagrams received by DWC_xgmac
 * whose UDP payload has a checksum error.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO
 *
 */
/*
 * Field : RXUDPERRPKTLO
 *
 * RxUDP Error Packets
 *
 * This field indicates lower 32 bits of good IP datagrams received whose UDP
 * payload has a checksum error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO
 * register field. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO
 * register field. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_MSB	      31
/* The width in bits of the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO register field. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_WIDTH      32
/* The mask used to set the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO register field value. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO register field value. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO register field. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_RESET      0x0
/* Extracts the CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO field value from a register. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO register field value suitable for setting
 * the register. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXUDP_ERROR_PACKETS_LOW.
 */
struct CORE_RXUDP_ERROR_PACKETS_LOW_s {
	const volatile uint32_t RXUDPERRPKTLO : 32; /* CORE_RXUDP_ERROR_PACKETS_LOW_RXUDPERRPKTLO */
};

/* The typedef declaration for register CORE_RXUDP_ERROR_PACKETS_LOW. */
typedef struct CORE_RXUDP_ERROR_PACKETS_LOW_s CORE_RXUDP_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXUDP_ERROR_PACKETS_LOW register. */
#define CORE_RXUDP_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXUDP_ERROR_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXUDP_ERROR_PACKETS_LOW_OFST  0xaac

/*
 * Register : RxTCP_Good_Packets_Low
 *
 * This register provides lower 32 bits of good IP datagrams received by DWC_xgmac
 * with a good TCP payload.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO
 *
 */
/*
 * Field : RXTCPGDPKTLO
 *
 * RxTCP Good Packets
 *
 * This field indicates lower 32 bits of good IP datagrams received with a good TCP
 * payload.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register
 * field. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register
 * field. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_MSB	    31
/* The width in bits of the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register field. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_WIDTH	    32
/* The mask used to set the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register field value. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register field value. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register field. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_RESET	    0x0
/* Extracts the CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO field value from a register. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO register field value suitable for setting the
 * register. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXTCP_GOOD_PACKETS_LOW.
 */
struct CORE_RXTCP_GOOD_PACKETS_LOW_s {
	const volatile uint32_t RXTCPGDPKTLO : 32; /* CORE_RXTCP_GOOD_PACKETS_LOW_RXTCPGDPKTLO */
};

/* The typedef declaration for register CORE_RXTCP_GOOD_PACKETS_LOW. */
typedef struct CORE_RXTCP_GOOD_PACKETS_LOW_s CORE_RXTCP_GOOD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXTCP_GOOD_PACKETS_LOW register. */
#define CORE_RXTCP_GOOD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXTCP_GOOD_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXTCP_GOOD_PACKETS_LOW_OFST  0xab4

/*
 * Register : RxTCP_Error_Packets_Low
 *
 * This register provides lower 32 bits of good IP datagrams received by DWC_xgmac
 * whose TCP payload has a checksum error.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO
 *
 */
/*
 * Field : RXTCPERRPKTLO
 *
 * RxTCP Error Packets
 *
 * This field indicates lower 32 bits of good IP datagrams received whose TCP
 * payload has a checksum error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO
 * register field. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO
 * register field. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_MSB	      31
/* The width in bits of the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO register field. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_WIDTH      32
/* The mask used to set the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO register field value. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO register field value. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO register field. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_RESET      0x0
/* Extracts the CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO field value from a register. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO register field value suitable for setting
 * the register. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXTCP_ERROR_PACKETS_LOW.
 */
struct CORE_RXTCP_ERROR_PACKETS_LOW_s {
	const volatile uint32_t RXTCPERRPKTLO : 32; /* CORE_RXTCP_ERROR_PACKETS_LOW_RXTCPERRPKTLO */
};

/* The typedef declaration for register CORE_RXTCP_ERROR_PACKETS_LOW. */
typedef struct CORE_RXTCP_ERROR_PACKETS_LOW_s CORE_RXTCP_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXTCP_ERROR_PACKETS_LOW register. */
#define CORE_RXTCP_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXTCP_ERROR_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXTCP_ERROR_PACKETS_LOW_OFST  0xabc

/*
 * Register : RxICMP_Good_Packets_Low
 *
 * This register provides lower 32 bits of good IP datagrams received by DWC_xgmac
 * with a good ICMP payload.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO
 *
 */
/*
 * Field : RXICMPGDPKTLO
 *
 * RxICMP Good Packets
 *
 * This field indicates lower 32 bits of good IP datagrams received with a good
 * ICMP payload.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO
 * register field. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO
 * register field. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_MSB	      31
/* The width in bits of the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO register field. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_WIDTH      32
/* The mask used to set the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO register field value. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO register field value. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO register field. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_RESET      0x0
/* Extracts the CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO field value from a register. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO register field value suitable for setting
 * the register. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXICMP_GOOD_PACKETS_LOW.
 */
struct CORE_RXICMP_GOOD_PACKETS_LOW_s {
	const volatile uint32_t RXICMPGDPKTLO : 32; /* CORE_RXICMP_GOOD_PACKETS_LOW_RXICMPGDPKTLO */
};

/* The typedef declaration for register CORE_RXICMP_GOOD_PACKETS_LOW. */
typedef struct CORE_RXICMP_GOOD_PACKETS_LOW_s CORE_RXICMP_GOOD_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXICMP_GOOD_PACKETS_LOW register. */
#define CORE_RXICMP_GOOD_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXICMP_GOOD_PACKETS_LOW register from the beginning of the component.
 */
#define CORE_RXICMP_GOOD_PACKETS_LOW_OFST  0xac4

/*
 * Register : RxICMP_Error_Packets_Low
 *
 * This register provides lower 32 bits of good IP datagrams received by DWC_xgmac
 * whose ICMP payload has a checksum error.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO
 *
 */
/*
 * Field : RXICMPERRPKTLO
 *
 * RxICMP Error Packets
 *
 * This field indicates lower 32 bits of good IP datagrams received whose ICMP
 * payload has a checksum error.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO
 * register field. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO
 * register field. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_MSB	31
/* The width in bits of the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO register field. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_WIDTH	32
/* The mask used to set the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO register field value. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_SET_MSK	0xffffffff
/* The mask used to clear the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO register field value. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_CLR_MSK	0x00000000
/* The reset value of the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO register field. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_RESET	0x0
/* Extracts the CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO field value from a register. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO register field value suitable for setting
 * the register. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXICMP_ERROR_PACKETS_LOW.
 */
struct CORE_RXICMP_ERROR_PACKETS_LOW_s {
	const volatile uint32_t
		RXICMPERRPKTLO : 32; /* CORE_RXICMP_ERROR_PACKETS_LOW_RXICMPERRPKTLO */
};

/* The typedef declaration for register CORE_RXICMP_ERROR_PACKETS_LOW. */
typedef struct CORE_RXICMP_ERROR_PACKETS_LOW_s CORE_RXICMP_ERROR_PACKETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXICMP_ERROR_PACKETS_LOW register. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXICMP_ERROR_PACKETS_LOW register from the beginning of the
 * component. */
#define CORE_RXICMP_ERROR_PACKETS_LOW_OFST  0xacc

/*
 * Register : RxIPv4_Good_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in good IPv4
 * datagrams encapsulating TCP, UDP, or ICMP data. (Ethernet header, FCS, pad, or
 * IP pad bytes are not included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO
 *
 */
/*
 * Field : RXIPV4GDOCTLO
 *
 * RxIPv4 Good Octets
 *
 * This field indicates lower 32 bits of bytes received in good IPv4 datagrams
 * encapsulating TCP, UDP, or ICMP data. (Ethernet header, FCS, pad, or IP pad
 * bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO
 * register field. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO register
 * field. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_MSB	     31
/* The width in bits of the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO register field. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_WIDTH	     32
/* The mask used to set the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO register field value. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO register field value. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO register field. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_RESET	     0x0
/* Extracts the CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO field value from a register. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO register field value suitable for setting
 * the register. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_GOOD_OCTETS_LOW.
 */
struct CORE_RXIPV4_GOOD_OCTETS_LOW_s {
	const volatile uint32_t RXIPV4GDOCTLO : 32; /* CORE_RXIPV4_GOOD_OCTETS_LOW_RXIPV4GDOCTLO */
};

/* The typedef declaration for register CORE_RXIPV4_GOOD_OCTETS_LOW. */
typedef struct CORE_RXIPV4_GOOD_OCTETS_LOW_s CORE_RXIPV4_GOOD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_GOOD_OCTETS_LOW register. */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_GOOD_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXIPV4_GOOD_OCTETS_LOW_OFST  0xad4

/*
 * Register : RxIPv4_Header_Error_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in IPv4
 * datagrams with header errors (checksum, length, version mismatch). The value in
 * the Length field of IPv4 header is used to update this counter. (Ethernet
 * header, FCS, pad, or IP pad bytes are not included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO
 *
 */
/*
 * Field : RXIPV4HDRERROCTLO
 *
 * RxIPv4 Header Error Octets
 *
 * This field indicates lower 32 bits of bytes received in IPv4 datagrams with
 * header errors (checksum, length, version mismatch). The value in the Length
 * field of IPv4 header is used to update this counter. (Ethernet header, FCS, pad,
 * or IP pad bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_LSB	 0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_MSB	 31
/* The width in bits of the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_WIDTH	 32
/* The mask used to set the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field
 * value. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field
 * value. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_RESET	 0x0
/* Extracts the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO field value from a register.
 */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO register field value suitable
 * for setting the register. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO_SET(value)                           \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW.
 */
struct CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_s {
	const volatile uint32_t
		RXIPV4HDRERROCTLO : 32; /* CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RXIPV4HDRERROCTLO */
};

/* The typedef declaration for register CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW. */
typedef struct CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_s CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW register. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_OFST  0xadc

/*
 * Register : RxIPv4_No_Payload_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in IPv4
 * datagrams that did not have a TCP, UDP, or ICMP payload. The value in the Length
 * field of IPv4 header is used to update this counter. (Ethernet header, FCS, pad,
 * or IP pad bytes are not included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO
 *
 */
/*
 * Field : RXIPV4NOPAYOCTLO
 *
 * RxIPv4 Payload Octets
 *
 * This field indicates lower 32 bits of bytes received in IPv4 datagrams that did
 * not have a TCP, UDP, or ICMP payload. The value in the Length field of IPv4
 * header is used to update this counter. (Ethernet header, FCS, pad, or IP pad
 * bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO
 * register field. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_MSB	      31
/* The width in bits of the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO register field value.
 */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO register field
 * value. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO register field. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_RESET      0x0
/* Extracts the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO field value from a register. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO register field value suitable for
 * setting the register. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW.
 */
struct CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_s {
	const volatile uint32_t
		RXIPV4NOPAYOCTLO : 32; /* CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RXIPV4NOPAYOCTLO */
};

/* The typedef declaration for register CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW. */
typedef struct CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_s CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW register. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_OFST	0xae4

/*
 * Register : RxIPv4_Fragmented_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in
 * fragmented IPv4 datagrams. The value in the Length field of IPv4 header is used
 * to update this counter. (Ethernet header, FCS, pad, or IP pad bytes are not
 * included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO
 *
 */
/*
 * Field : RXIPV4FRAGOCTLO
 *
 * RxIPv4 Fragmented Octets
 *
 * This field indicates lower 32 bits of bytes received in fragmented IPv4
 * datagrams. The value in the Length field of IPv4 header is used to update this
 * counter. (Ethernet header, FCS, pad, or IP pad bytes are not included in this
 * counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO
 * register field. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO
 * register field. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_MSB	     31
/* The width in bits of the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO register field. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_WIDTH	     32
/* The mask used to set the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO register field value.
 */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO register field
 * value. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO register field. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_RESET	     0x0
/* Extracts the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO field value from a register. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO register field value suitable for
 * setting the register. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_FRAGMENTED_OCTETS_LOW.
 */
struct CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_s {
	const volatile uint32_t
		RXIPV4FRAGOCTLO : 32; /* CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RXIPV4FRAGOCTLO */
};

/* The typedef declaration for register CORE_RXIPV4_FRAGMENTED_OCTETS_LOW. */
typedef struct CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_s CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW register. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_FRAGMENTED_OCTETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_OFST	0xaec

/*
 * Register : RxIPv4_UDP_Checksum_Disable_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a UDP
 * segment that had the UDP checksum disabled. This counter does not count IP
 * Header bytes. (Ethernet header, FCS, pad, or IP pad bytes are not included in
 * this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO
 *
 */
/*
 * Field : RXIPV4UDSBLOCTLO
 *
 * RxIPv4 UDP Checksum Disable Octets
 *
 * This field indicates lower 32 bits of bytes received in a UDP segment that had
 * the UDP checksum disabled. This counter does not count IP Header bytes.
 * (Ethernet header, FCS, pad, or IP pad bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_LSB     0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_MSB     31
/* The width in bits of the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register
 * field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_WIDTH   32
/* The mask used to set the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register
 * field value. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_SET_MSK 0xffffffff
/* The mask used to clear the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register
 * field value. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_CLR_MSK 0x00000000
/* The reset value of the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register
 * field. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_RESET   0x0
/* Extracts the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO field value from a
 * register. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_GET(value)                    \
	(((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO register field value
 * suitable for setting the register. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO_SET(value)                    \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW.
 */
struct CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_s {
	const volatile uint32_t RXIPV4UDSBLOCTLO : 32; /* CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RXIPV4UDSBLOCTLO
							*/
};

/* The typedef declaration for register CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW. */
typedef struct CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_s
	CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW register. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW register from the beginning of
 * the component. */
#define CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_OFST  0xaf4

/*
 * Register : RxIPv6_Good_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in good IPv6
 * datagrams encapsulating TCP, UDP, or ICMP data. (Ethernet header, FCS, pad, or
 * IP pad bytes are not included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO
 *
 */
/*
 * Field : RXIPV6GDOCTLO
 *
 * RxIPv6 Good Octets
 *
 * This field indicates lower 32 bits of bytes received in good IPv6 datagrams
 * encapsulating TCP, UDP, or ICMP data. (Ethernet header, FCS, pad, or IP pad
 * bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO
 * register field. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO register
 * field. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_MSB	     31
/* The width in bits of the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO register field. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_WIDTH	     32
/* The mask used to set the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO register field value. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO register field value. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO register field. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_RESET	     0x0
/* Extracts the CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO field value from a register. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO register field value suitable for setting
 * the register. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV6_GOOD_OCTETS_LOW.
 */
struct CORE_RXIPV6_GOOD_OCTETS_LOW_s {
	const volatile uint32_t RXIPV6GDOCTLO : 32; /* CORE_RXIPV6_GOOD_OCTETS_LOW_RXIPV6GDOCTLO */
};

/* The typedef declaration for register CORE_RXIPV6_GOOD_OCTETS_LOW. */
typedef struct CORE_RXIPV6_GOOD_OCTETS_LOW_s CORE_RXIPV6_GOOD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV6_GOOD_OCTETS_LOW register. */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV6_GOOD_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXIPV6_GOOD_OCTETS_LOW_OFST  0xafc

/*
 * Register : RxIPv6_Header_Error_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in IPv6
 * datagrams with header errors (length, version mismatch). The value in the Length
 * field of IPv6 header is used to update this counter. (Ethernet header, FCS, pad,
 * or IP pad bytes are not included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO
 *
 */
/*
 * Field : RXIPV6HDRERROCTLO
 *
 * RxIPv6 Header Error Octets
 *
 * This field indicates lower 32 bits of bytes received in IPv6 datagrams with
 * header errors (length, version mismatch). The value in the Length field of IPv6
 * header is used to update this counter. (Ethernet header, FCS, pad, or IP pad
 * bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_LSB	 0
/* The Most Significant Bit (MSB) position of the
 * CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_MSB	 31
/* The width in bits of the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_WIDTH	 32
/* The mask used to set the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field
 * value. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field
 * value. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_CLR_MSK	 0x00000000
/* The reset value of the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_RESET	 0x0
/* Extracts the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO field value from a register.
 */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO register field value suitable
 * for setting the register. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO_SET(value)                           \
	(((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW.
 */
struct CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_s {
	const volatile uint32_t
		RXIPV6HDRERROCTLO : 32; /* CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RXIPV6HDRERROCTLO */
};

/* The typedef declaration for register CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW. */
typedef struct CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_s CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW register. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_OFST  0xb04

/*
 * Register : RxIPv6_No_Payload_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in IPv6
 * datagrams that did not have a TCP, UDP, or ICMP payload. The value in the Length
 * field of IPv6 header is used to update this counter. (Ethernet header, FCS, pad,
 * or IP pad bytes are not included in this counter.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO
 *
 */
/*
 * Field : RXIPV6NOPAYOCTLO
 *
 * RxIPv6 Payload Octets
 *
 * This field indicates lower 32 bits of bytes received in IPv6 datagrams that did
 * not have a TCP, UDP, or ICMP payload. The value in the Length field of IPv6
 * header is used to update this counter. (Ethernet header, FCS, pad, or IP pad
 * bytes are not included in this counter.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO
 * register field. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_MSB	      31
/* The width in bits of the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_WIDTH      32
/* The mask used to set the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO register field value.
 */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO register field
 * value. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO register field. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_RESET      0x0
/* Extracts the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO field value from a register. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO register field value suitable for
 * setting the register. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW.
 */
struct CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_s {
	const volatile uint32_t
		RXIPV6NOPAYOCTLO : 32; /* CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RXIPV6NOPAYOCTLO */
};

/* The typedef declaration for register CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW. */
typedef struct CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_s CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW register. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW register from the beginning of the
 * component. */
#define CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_OFST	0xb0c

/*
 * Register : RxUDP_Good_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a good
 * UDP segment. This counter does not count IP header bytes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO
 *
 */
/*
 * Field : RXUDPGDOCTLO
 *
 * RxUDP Good Octets
 *
 * This field indicates lower 32 bits of bytes received in a good UDP segment. This
 * counter does not count IP header bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register
 * field. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register
 * field. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_MSB	   31
/* The width in bits of the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register field. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_WIDTH	   32
/* The mask used to set the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register field value. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register field value. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_CLR_MSK	   0x00000000
/* The reset value of the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register field. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_RESET	   0x0
/* Extracts the CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO field value from a register. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO register field value suitable for setting the
 * register. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXUDP_GOOD_OCTETS_LOW.
 */
struct CORE_RXUDP_GOOD_OCTETS_LOW_s {
	const volatile uint32_t RXUDPGDOCTLO : 32; /* CORE_RXUDP_GOOD_OCTETS_LOW_RXUDPGDOCTLO */
};

/* The typedef declaration for register CORE_RXUDP_GOOD_OCTETS_LOW. */
typedef struct CORE_RXUDP_GOOD_OCTETS_LOW_s CORE_RXUDP_GOOD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXUDP_GOOD_OCTETS_LOW register. */
#define CORE_RXUDP_GOOD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXUDP_GOOD_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXUDP_GOOD_OCTETS_LOW_OFST	 0xb14

/*
 * Register : RxUDP_Error_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a UDP
 * segment that had checksum errors. This counter does not count IP header bytes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO
 *
 */
/*
 * Field : RXUDPERROCTLO
 *
 * RxUDP Error Octets
 *
 * This field indicates lower 32 bits of bytes received in a UDP segment that had
 * checksum errors. This counter does not count IP header bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO
 * register field. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO register
 * field. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_MSB	     31
/* The width in bits of the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO register field. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_WIDTH	     32
/* The mask used to set the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO register field value. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO register field value. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO register field. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_RESET	     0x0
/* Extracts the CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO field value from a register. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO register field value suitable for setting
 * the register. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXUDP_ERROR_OCTETS_LOW.
 */
struct CORE_RXUDP_ERROR_OCTETS_LOW_s {
	const volatile uint32_t RXUDPERROCTLO : 32; /* CORE_RXUDP_ERROR_OCTETS_LOW_RXUDPERROCTLO */
};

/* The typedef declaration for register CORE_RXUDP_ERROR_OCTETS_LOW. */
typedef struct CORE_RXUDP_ERROR_OCTETS_LOW_s CORE_RXUDP_ERROR_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXUDP_ERROR_OCTETS_LOW register. */
#define CORE_RXUDP_ERROR_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXUDP_ERROR_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXUDP_ERROR_OCTETS_LOW_OFST  0xb1c

/*
 * Register : RxTCP_Good_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a good
 * TCP segment. This counter does not count IP header bytes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO
 *
 */
/*
 * Field : RXTCPGDOCTLO
 *
 * RxTCP Good Octets
 *
 * This field indicates lower 32 bits of bytes received in a good TCP segment. This
 * counter does not count IP header bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register
 * field. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register
 * field. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_MSB	   31
/* The width in bits of the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register field. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_WIDTH	   32
/* The mask used to set the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register field value. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register field value. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_CLR_MSK	   0x00000000
/* The reset value of the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register field. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_RESET	   0x0
/* Extracts the CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO field value from a register. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO register field value suitable for setting the
 * register. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXTCP_GOOD_OCTETS_LOW.
 */
struct CORE_RXTCP_GOOD_OCTETS_LOW_s {
	const volatile uint32_t RXTCPGDOCTLO : 32; /* CORE_RXTCP_GOOD_OCTETS_LOW_RXTCPGDOCTLO */
};

/* The typedef declaration for register CORE_RXTCP_GOOD_OCTETS_LOW. */
typedef struct CORE_RXTCP_GOOD_OCTETS_LOW_s CORE_RXTCP_GOOD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXTCP_GOOD_OCTETS_LOW register. */
#define CORE_RXTCP_GOOD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXTCP_GOOD_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXTCP_GOOD_OCTETS_LOW_OFST	 0xb24

/*
 * Register : RxTCP_Error_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a TCP
 * segment that had checksum errors. This counter does not count IP header bytes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO
 *
 */
/*
 * Field : RXTCPERROCTLO
 *
 * RxTCP Error Octets
 *
 * This field indicates lower 32 bits of bytes received in a TCP segment that had
 * checksum errors. This counter does not count IP header bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO
 * register field. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO register
 * field. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_MSB	     31
/* The width in bits of the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO register field. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_WIDTH	     32
/* The mask used to set the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO register field value. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO register field value. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO register field. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_RESET	     0x0
/* Extracts the CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO field value from a register. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO register field value suitable for setting
 * the register. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXTCP_ERROR_OCTETS_LOW.
 */
struct CORE_RXTCP_ERROR_OCTETS_LOW_s {
	const volatile uint32_t RXTCPERROCTLO : 32; /* CORE_RXTCP_ERROR_OCTETS_LOW_RXTCPERROCTLO */
};

/* The typedef declaration for register CORE_RXTCP_ERROR_OCTETS_LOW. */
typedef struct CORE_RXTCP_ERROR_OCTETS_LOW_s CORE_RXTCP_ERROR_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXTCP_ERROR_OCTETS_LOW register. */
#define CORE_RXTCP_ERROR_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXTCP_ERROR_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXTCP_ERROR_OCTETS_LOW_OFST  0xb2c

/*
 * Register : RxICMP_Good_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a good
 * ICMP segment. This counter does not count IP header bytes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO
 *
 */
/*
 * Field : RXICMPGDOCTLO
 *
 * RxICMP Good Octets
 *
 * This field indicates lower 32 bits of bytes received in a good ICMP segment.
 * This counter does not count IP header bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO
 * register field. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO register
 * field. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_MSB	     31
/* The width in bits of the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO register field. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_WIDTH	     32
/* The mask used to set the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO register field value. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO register field value. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO register field. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_RESET	     0x0
/* Extracts the CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO field value from a register. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO register field value suitable for setting
 * the register. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXICMP_GOOD_OCTETS_LOW.
 */
struct CORE_RXICMP_GOOD_OCTETS_LOW_s {
	const volatile uint32_t RXICMPGDOCTLO : 32; /* CORE_RXICMP_GOOD_OCTETS_LOW_RXICMPGDOCTLO */
};

/* The typedef declaration for register CORE_RXICMP_GOOD_OCTETS_LOW. */
typedef struct CORE_RXICMP_GOOD_OCTETS_LOW_s CORE_RXICMP_GOOD_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXICMP_GOOD_OCTETS_LOW register. */
#define CORE_RXICMP_GOOD_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXICMP_GOOD_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXICMP_GOOD_OCTETS_LOW_OFST  0xb34

/*
 * Register : RxICMP_Error_Octets_Low
 *
 * This register provides lower 32 bits of bytes received by DWC_xgmac in a ICMP
 * segment that had checksum errors. This counter does not count IP header bytes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO
 *
 */
/*
 * Field : RXICMPERROCTLO
 *
 * RxICMP Error Octets
 *
 * This field indicates lower 32 bits of bytes received in a ICMP segment that had
 * checksum errors. This counter does not count IP header bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO
 * register field. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO
 * register field. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_MSB	       31
/* The width in bits of the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO register field. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_WIDTH      32
/* The mask used to set the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO register field value. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_SET_MSK    0xffffffff
/* The mask used to clear the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO register field value. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_CLR_MSK    0x00000000
/* The reset value of the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO register field. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_RESET      0x0
/* Extracts the CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO field value from a register. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO register field value suitable for setting
 * the register. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_RXICMP_ERROR_OCTETS_LOW.
 */
struct CORE_RXICMP_ERROR_OCTETS_LOW_s {
	const volatile uint32_t
		RXICMPERROCTLO : 32; /* CORE_RXICMP_ERROR_OCTETS_LOW_RXICMPERROCTLO */
};

/* The typedef declaration for register CORE_RXICMP_ERROR_OCTETS_LOW. */
typedef struct CORE_RXICMP_ERROR_OCTETS_LOW_s CORE_RXICMP_ERROR_OCTETS_LOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_RXICMP_ERROR_OCTETS_LOW register. */
#define CORE_RXICMP_ERROR_OCTETS_LOW_RESET 0x00000000
/* The byte offset of the CORE_RXICMP_ERROR_OCTETS_LOW register from the beginning of the component.
 */
#define CORE_RXICMP_ERROR_OCTETS_LOW_OFST  0xb3c

/*
 * Register : MAC_L3_L4_Address_Control
 *
 * This register has the indirect address and control for accessing the Layer 3 and
 * Layer 4 Filter registers.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_L3_L4_ADDRESS_CONTROL_XB
 *  [1]     | RW     | 0x0   | CORE_MAC_L3_L4_ADDRESS_CONTROL_TT
 *  [7:2]   | R      | 0x0   | CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2
 *  [15:8]  | RW     | 0x0   | CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR
 *  [31:16] | R      | 0x0   | CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16
 *
 */
/*
 * Field : XB
 *
 * Transfer Busy.
 *
 * When set, initiates a read or write transaction (as indicated by TT) is
 * initiated to the L3_L4 Filter register. When reset, indicates that read or write
 * transaction to L3-L4 Filter register is complete.
 *
 * You must read and confirm that this bit is 0 (previous transfer is completed)
 * before setting this bit again.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field.
 */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field.
 */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_MSB	     0
/* The width in bits of the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_WIDTH	     1
/* The mask used to set the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_RESET	     0x0
/* Extracts the CORE_MAC_L3_L4_ADDRESS_CONTROL_XB field value from a register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_L3_L4_ADDRESS_CONTROL_XB register field value suitable for setting the
 * register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_XB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TT
 *
 * Transfer Type.
 *
 * When set, a read transfer from the L3_L4 Filter register addressed by IDDR is
 * executed. The data read from the register is available in the MAC_L3_L4_Data
 * register.
 *
 * When reset, a write transfer to the L3_L4 Filter register addressed by IDDR is
 * executed. The data is transferred from the MAC_L3_L4_Data register and written
 * to the respective L3_L4 Filter register. You must write the MAC_L3_L4_Data
 * register before initiating the write transaction.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field.
 */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_LSB	     1
/* The Most Significant Bit (MSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field.
 */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_MSB	     1
/* The width in bits of the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_WIDTH	     1
/* The mask used to set the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_RESET	     0x0
/* Extracts the CORE_MAC_L3_L4_ADDRESS_CONTROL_TT field value from a register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_L3_L4_ADDRESS_CONTROL_TT register field value suitable for setting the
 * register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_TT_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_7_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2
 * register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2
 * register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_MSB	       7
/* The width in bits of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_WIDTH      6
/* The mask used to set the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_SET_MSK    0x000000fc
/* The mask used to clear the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_CLR_MSK    0xffffff03
/* The reset value of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_RESET      0x0
/* Extracts the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 field value from a register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_GET(value) (((value)&0x000000fc) >> 2)
/* Produces a CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 register field value suitable for setting
 * the register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2_SET(value) (((value) << 2) & 0x000000fc)

/*
 * Field : IDDR
 *
 * L3_L4 Filter Address.
 *
 * This field contains the indirect address to the L3_L4 Filter registers. The
 * IDDR[3:0] indicates the type of L3_L4 Filter register while bits[8:4] indicate
 * the Filter number (0 to 31).
 *
 * IDDR[3:0] Values:
 *
 * * 0x0: MAC_L3_L4_Control
 *
 * * 0x1: MAC_Layer4_Address
 *
 * * 0x2: MAC_Layer3_Addr0_Reg
 *
 * * 0x2: MAC_Layer3_Addr1_Reg
 *
 * * 0x2: MAC_Layer3_Addr2_Reg
 *
 * * 0x2: MAC_Layer3_Addr3_Reg
 *
 * * 0x6 to 0xF: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register
 * field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_LSB	       8
/* The Most Significant Bit (MSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register
 * field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_MSB	       15
/* The width in bits of the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_WIDTH      8
/* The mask used to set the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_SET_MSK    0x0000ff00
/* The mask used to clear the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_CLR_MSK    0xffff00ff
/* The reset value of the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_RESET      0x0
/* Extracts the CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR field value from a register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR register field value suitable for setting the
 * register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16
 * register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_LSB	 16
/* The Most Significant Bit (MSB) position of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16
 * register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_MSB	 31
/* The width in bits of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_WIDTH	 16
/* The mask used to set the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_SET_MSK	 0xffff0000
/* The mask used to clear the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 register field value. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_CLR_MSK	 0x0000ffff
/* The reset value of the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 register field. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_RESET	 0x0
/* Extracts the CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 field value from a register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 register field value suitable for
 * setting the register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_L3_L4_ADDRESS_CONTROL.
 */
struct CORE_MAC_L3_L4_ADDRESS_CONTROL_s {
	volatile uint32_t XB : 1;		  /* CORE_MAC_L3_L4_ADDRESS_CONTROL_XB */
	volatile uint32_t TT : 1;		  /* CORE_MAC_L3_L4_ADDRESS_CONTROL_TT */
	const volatile uint32_t Reserved_7_2 : 6; /* CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_7_2 */
	volatile uint32_t IDDR : 8;		  /* CORE_MAC_L3_L4_ADDRESS_CONTROL_IDDR */
	const volatile uint32_t
		Reserved_31_16 : 16; /* CORE_MAC_L3_L4_ADDRESS_CONTROL_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_L3_L4_ADDRESS_CONTROL. */
typedef struct CORE_MAC_L3_L4_ADDRESS_CONTROL_s CORE_MAC_L3_L4_ADDRESS_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_L3_L4_ADDRESS_CONTROL register. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_RESET 0x00000000
/* The byte offset of the CORE_MAC_L3_L4_ADDRESS_CONTROL register from the beginning of the
 * component. */
#define CORE_MAC_L3_L4_ADDRESS_CONTROL_OFST  0xc00

/*
 * Register : MAC_L3_L4_Data
 *
 * This register has the indirect data and control for accessing the Layer 3 and
 * Layer 4 Filter registers.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_L3_L4_DATA_IDATA
 *
 */
/*
 * Field : IDATA
 *
 * Indirect Data.
 *
 * The data written to or read from the L3_L4 Filter register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_L3_L4_DATA_IDATA register field. */
#define CORE_MAC_L3_L4_DATA_IDATA_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_L3_L4_DATA_IDATA register field. */
#define CORE_MAC_L3_L4_DATA_IDATA_MSB	     31
/* The width in bits of the CORE_MAC_L3_L4_DATA_IDATA register field. */
#define CORE_MAC_L3_L4_DATA_IDATA_WIDTH	     32
/* The mask used to set the CORE_MAC_L3_L4_DATA_IDATA register field value. */
#define CORE_MAC_L3_L4_DATA_IDATA_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_L3_L4_DATA_IDATA register field value. */
#define CORE_MAC_L3_L4_DATA_IDATA_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_L3_L4_DATA_IDATA register field. */
#define CORE_MAC_L3_L4_DATA_IDATA_RESET	     0x0
/* Extracts the CORE_MAC_L3_L4_DATA_IDATA field value from a register. */
#define CORE_MAC_L3_L4_DATA_IDATA_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_L3_L4_DATA_IDATA register field value suitable for setting the register. */
#define CORE_MAC_L3_L4_DATA_IDATA_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_L3_L4_DATA.
 */
struct CORE_MAC_L3_L4_DATA_s {
	volatile uint32_t IDATA : 32; /* CORE_MAC_L3_L4_DATA_IDATA */
};

/* The typedef declaration for register CORE_MAC_L3_L4_DATA. */
typedef struct CORE_MAC_L3_L4_DATA_s CORE_MAC_L3_L4_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_L3_L4_DATA register. */
#define CORE_MAC_L3_L4_DATA_RESET 0x00000000
/* The byte offset of the CORE_MAC_L3_L4_DATA register from the beginning of the component. */
#define CORE_MAC_L3_L4_DATA_OFST  0xc04

/*
 * Register : MAC_ARP_Address
 *
 * The ARP Address register contains the IPv4 Destination Address of the MAC. This
 * register is available only when the Enable IPv4 ARP Offload option is selected.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset      | Description
 * :-------|:-------|:-----------|:---------------------------------------------
 *  [31:0] | RW     | 0xffffffff | CORE_MAC_ARP_ADDRESS_ARPPA
 *
 */
/*
 * Field : ARPPA
 *
 * ARP Protocol Address.
 *
 * This field contains the IPv4 Destination Address of the MAC. This address is
 * used for perfect match with the Protocol Address of Target field in the received
 * ARP packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_ARP_ADDRESS_ARPPA register field. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_ARP_ADDRESS_ARPPA register field. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_MSB	      31
/* The width in bits of the CORE_MAC_ARP_ADDRESS_ARPPA register field. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_WIDTH      32
/* The mask used to set the CORE_MAC_ARP_ADDRESS_ARPPA register field value. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_ARP_ADDRESS_ARPPA register field value. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_ARP_ADDRESS_ARPPA register field. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_RESET      0xffffffff
/* Extracts the CORE_MAC_ARP_ADDRESS_ARPPA field value from a register. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_ARP_ADDRESS_ARPPA register field value suitable for setting the register. */
#define CORE_MAC_ARP_ADDRESS_ARPPA_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_ARP_ADDRESS.
 */
struct CORE_MAC_ARP_ADDRESS_s {
	volatile uint32_t ARPPA : 32; /* CORE_MAC_ARP_ADDRESS_ARPPA */
};

/* The typedef declaration for register CORE_MAC_ARP_ADDRESS. */
typedef struct CORE_MAC_ARP_ADDRESS_s CORE_MAC_ARP_ADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_ARP_ADDRESS register. */
#define CORE_MAC_ARP_ADDRESS_RESET 0xffffffff
/* The byte offset of the CORE_MAC_ARP_ADDRESS register from the beginning of the component. */
#define CORE_MAC_ARP_ADDRESS_OFST  0xc10

/*
 * Register : MAC_Timestamp_Control
 *
 * This register controls the operation of the System Time generator and processing
 * of PTP packets for timestamping in the Receiver.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSENA
 *  [1]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT
 *  [2]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSINIT
 *  [3]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSUPDT
 *  [4]     | R      | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG
 *  [5]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSADDREG
 *  [7:6]   | R      | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6
 *  [8]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSENALL
 *  [9]     | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR
 *  [10]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA
 *  [11]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSIPENA
 *  [12]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA
 *  [13]    | RW     | 0x1   | CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA
 *  [14]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA
 *  [15]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA
 *  [17:16] | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL
 *  [18]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR
 *  [19]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_CSC
 *  [20]    | R      | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI
 *  [23:21] | R      | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21
 *  [24]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM
 *  [27:25] | R      | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25
 *  [28]    | RW     | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN
 *  [31:29] | R      | 0x0   | CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29
 *
 */
/*
 * Field : TSENA
 *
 * Enable Timestamp.
 *
 * When this bit is set, the timestamp is added for Transmit and Receive packets.
 * When disabled, timestamp is not added for transmit and receive packets and the
 * Timestamp Generator is also suspended. You need to initialize the Timestamp
 * (system time) after enabling this mode.
 *
 * On the Receive side, the MAC processes the 1588 packets only if this bit is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSENA register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSENA register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_MSB	    0
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_WIDTH	    1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENA_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TSCFUPDT
 *
 * Fine or Coarse Timestamp Update.
 *
 * When this bit is set, the Fine method is used to update system timestamp. When
 * this bit is reset, Coarse method is used to update the system timestamp.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_LSB	       1
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_MSB	       1
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TSINIT
 *
 * Initialize Timestamp.
 *
 * When this bit is set, the system time is initialized (overwritten) with the
 * value specified in the MAC_System_Time_Seconds_Update and
 * MAC_System_Time_Nanoseconds_Update registers.
 *
 * This bit should be zero before it is updated. This bit is reset when the
 * initialization is complete. The Timestamp Higher Word register (if enabled
 * during controller configuration) can only be initialized.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_LSB	     2
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_MSB	     2
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_WIDTH	     1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_SET_MSK    0x00000004
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_RESET	     0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSINIT field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSINIT register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSINIT_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : TSUPDT
 *
 * Update Timestamp.
 *
 * When this bit is set, the system time is updated (added or subtracted) with the
 * value specified in MAC_System_Time_Seconds_Update and
 * MAC_System_Time_Nanoseconds_Update.
 *
 * This bit should be zero before updating it. This bit is reset when the update is
 * complete in hardware. The Timestamp Higher Word register (if enabled during
 * controller configuration) is not updated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_LSB	     3
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_MSB	     3
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_WIDTH	     1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_SET_MSK    0x00000008
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_CLR_MSK    0xfffffff7
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_RESET	     0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSUPDT field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSUPDT register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSUPDT_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_TSTRIG
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG
 * register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_LSB	      4
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG
 * register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_MSB	      4
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG register field value suitable for setting
 * the register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : TSADDREG
 *
 * Update Addend Register.
 *
 * When this bit is set, the content of the Timestamp Addend register is updated in
 * the PTP block for fine correction. This bit is cleared when the update is
 * complete. This bit should be zero before it is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_LSB	       5
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_MSB	       5
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_SET_MSK    0x00000020
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSADDREG field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSADDREG register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSADDREG_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_LSB	   6
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_MSB	   7
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_WIDTH	   2
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_SET_MSK	   0x000000c0
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_CLR_MSK	   0xffffff3f
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_RESET	   0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : TSENALL
 *
 * Enable Timestamp for All Packets.
 *
 * When this bit is set, the timestamp snapshot is enabled for all packets received
 * by the MAC.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSENALL register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_LSB	      8
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSENALL register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_MSB	      8
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSENALL register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSENALL register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSENALL register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSENALL register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSENALL field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSENALL register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENALL_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : TSCTRLSSR
 *
 * Timestamp Digital or Binary Rollover Control.
 *
 * When this bit is set, the Timestamp Low register rolls over after 0x3B9A_C9FF
 * value (that is, 1 nanosecond accuracy) and increments the timestamp (High)
 * seconds. When this bit is reset, the rollover value of sub-second register is
 * 0x7FFF_FFFF. The sub-second increment must be programmed correctly depending on
 * the PTP reference clock frequency and the value of this bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_LSB	9
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_MSB	9
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_SET_MSK	0x00000200
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_CLR_MSK	0xfffffdff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : TSVER2ENA
 *
 * Enable PTP Packet Processing for Version 2 Format.
 *
 * When this bit is set, the IEEE 1588 version 2 format is used to process the PTP
 * packets. When this bit is reset, the IEEE 1588 version 1 format is used to
 * process the PTP packets. The IEEE 1588 formats are described in "PTP Processing
 * and Control" section.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_LSB	10
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_MSB	10
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_SET_MSK	0x00000400
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_CLR_MSK	0xfffffbff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_GET(value) (((value)&0x00000400) >> 10)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : TSIPENA
 *
 * Enable Processing of PTP over Ethernet Packets.
 *
 * When this bit is set, the MAC receiver processes the PTP packets encapsulated
 * directly in the Ethernet packets. When this bit is reset, the MAC ignores the
 * PTP over Ethernet packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_LSB	      11
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register field.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_MSB	      11
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_SET_MSK    0x00000800
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_CLR_MSK    0xfffff7ff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSIPENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_GET(value) (((value)&0x00000800) >> 11)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSIPENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPENA_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : TSIPV6ENA
 *
 * Enable Processing of PTP Packets Sent over IPv6-UDP.
 *
 * When this bit is set, the MAC receiver processes the PTP packets encapsulated in
 * IPv6-UDP packets. When this bit is clear, the MAC ignores the PTP transported
 * over IPv6-UDP packets.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_LSB	12
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_MSB	12
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_SET_MSK	0x00001000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_CLR_MSK	0xffffefff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_GET(value) (((value)&0x00001000) >> 12)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : TSIPV4ENA
 *
 * Enable Processing of PTP Packets Sent over IPv4-UDP.
 *
 * When this bit is set, the MAC receiver processes the PTP packets encapsulated in
 * IPv4-UDP packets. When this bit is reset, the MAC ignores the PTP transported
 * over IPv4-UDP packets. This bit is set by default.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_LSB	13
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_MSB	13
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_SET_MSK	0x00002000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_CLR_MSK	0xffffdfff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_RESET	0x1
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_GET(value) (((value)&0x00002000) >> 13)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : TSEVNTENA
 *
 * Enable Timestamp Snapshot for Event Messages.
 *
 * When this bit is set, the timestamp snapshot is taken only for event messages
 * (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp).
 *
 * When this bit is reset, the snapshot is taken for all messages except Announce,
 * Management, and Signaling.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_LSB	14
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_MSB	14
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_SET_MSK	0x00004000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_CLR_MSK	0xffffbfff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_GET(value) (((value)&0x00004000) >> 14)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : TSMSTRENA
 *
 * Enable Snapshot for Messages Relevant to Master.
 *
 * When this bit is set, the snapshot is taken only for the messages that are
 * relevant to the master node. Otherwise, the snapshot is taken for the messages
 * relevant to the slave node.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_LSB	15
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_MSB	15
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_SET_MSK	0x00008000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_CLR_MSK	0xffff7fff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : SNAPTYPSEL
 *
 * Select PTP packets for Taking Snapshots.
 *
 * These bits, along with Bits 15 and 14, decide the set of PTP packet types for
 * which snapshot needs to be taken.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_LSB	 16
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_MSB	 17
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_WIDTH	 2
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_SET_MSK	 0x00030000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_CLR_MSK	 0xfffcffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_RESET	 0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_GET(value) (((value)&0x00030000) >> 16)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL_SET(value) (((value) << 16) & 0x00030000)

/*
 * Field : TSENMACADDR
 *
 * Enable MAC Address for PTP Packet Filtering.
 *
 * When this bit is set, the DA MAC address (that matches any MAC Address register)
 * is used to filter the PTP packets when PTP is directly sent over Ethernet.
 *
 * Note:  When this bit is set, the PTP Offload function qualifies received PTP
 * packet with unicast DA matching MAC Address 0 register (in addition to received
 * PTP packet with unicast DA matching PTP special multicast addresses) for PTP
 * response generation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_LSB	  18
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_MSB	  18
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_WIDTH	  1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_SET_MSK	  0x00040000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_CLR_MSK	  0xfffbffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_RESET	  0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_GET(value) (((value)&0x00040000) >> 18)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : CSC
 *
 * Enable checksum correction during OST for PTP over UDP/IPv4 packets
 *
 * When this bit is set, the last two bytes of PTP message sent over UDP/IPv4 is
 * updated to keep the UDP checksum correct, for changes made to origin timestamp
 * and/or correction field as part of one step timestamp operation. The application
 * should form the packet with these two dummy bytes.
 *
 * When reset, no updates are done to keep the UDP checksum correct. The
 * application should form the packet with UDP checksum set to 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_CSC register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_LSB	  19
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_CSC register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_MSB	  19
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_CSC register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_WIDTH	  1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_CSC register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_SET_MSK	  0x00080000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_CSC register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_CLR_MSK	  0xfff7ffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_CSC register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_RESET	  0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_CSC field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_GET(value) (((value)&0x00080000) >> 19)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_CSC register field value suitable for setting the register.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_CSC_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : Reserved_ESTI
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_LSB	    20
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_MSB	    20
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_WIDTH	    1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_SET_MSK    0x00100000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_CLR_MSK    0xffefffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_GET(value) (((value)&0x00100000) >> 20)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : Reserved_23_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21
 * register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_LSB	     21
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_MSB	     23
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_WIDTH	     3
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_SET_MSK    0x00e00000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_CLR_MSK    0xff1fffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_RESET	     0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_GET(value) (((value)&0x00e00000) >> 21)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 register field value suitable for setting
 * the register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21_SET(value) (((value) << 21) & 0x00e00000)

/*
 * Field : TXTSSTSM
 *
 * Transmit Timestamp Status Mode.
 *
 * * When this bit is set, the MAC overwrites the earlier transmit timestamp status
 *   even if it is not read by the software. The MAC indicates this by setting the
 *   TXTSSTSMIS bit of the MAC_TxTimestamp_Status_Nanoseconds register.
 *
 * * When this bit is reset, the MAC ignores the timestamp status of current packet
 *   if the timestamp status of previous packet is not read by the software. The
 *   MAC indicates this by setting the TXTSSTSHI bit of the
 *   MAC_TxTimestamp_Status_Seconds register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_LSB	       24
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_MSB	       24
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_SET_MSK    0x01000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : Reserved_27_25
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25
 * register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_LSB	     25
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_MSB	     27
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_WIDTH	     3
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_SET_MSK    0x0e000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_CLR_MSK    0xf1ffffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_RESET	     0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_GET(value) (((value)&0x0e000000) >> 25)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 register field value suitable for setting
 * the register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25_SET(value) (((value) << 25) & 0x0e000000)

/*
 * Field : AV8021ASMEN
 *
 * AV IEEE 802.1AS Mode Enable.
 *
 * When this bit is set, the MAC processes only untagged PTP over Ethernet packets
 * for providing PTP status and capturing timestamp snapshots, that is, IEEE
 * 802.1AS mode of operation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_LSB	  28
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_MSB	  28
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_WIDTH	  1
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_SET_MSK	  0x10000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_CLR_MSK	  0xefffffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_RESET	  0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_GET(value) (((value)&0x10000000) >> 28)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : Reserved_31_29
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29
 * register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_LSB	     29
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 register
 * field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_MSB	     31
/* The width in bits of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_WIDTH	     3
/* The mask used to set the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_SET_MSK    0xe0000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 register field value. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_CLR_MSK    0x1fffffff
/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 register field. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_RESET	     0x0
/* Extracts the CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 field value from a register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_GET(value) (((value)&0xe0000000) >> 29)
/* Produces a CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 register field value suitable for setting
 * the register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29_SET(value) (((value) << 29) & 0xe0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_CONTROL.
 */
struct CORE_MAC_TIMESTAMP_CONTROL_s {
	volatile uint32_t TSENA : 1;	/* CORE_MAC_TIMESTAMP_CONTROL_TSENA */
	volatile uint32_t TSCFUPDT : 1; /* CORE_MAC_TIMESTAMP_CONTROL_TSCFUPDT */
	volatile uint32_t TSINIT : 1;	/* CORE_MAC_TIMESTAMP_CONTROL_TSINIT */
	volatile uint32_t TSUPDT : 1;	/* CORE_MAC_TIMESTAMP_CONTROL_TSUPDT */
	const volatile uint32_t
		Reserved_TSTRIG : 1;		    /* CORE_MAC_TIMESTAMP_CONTROL_RESERVED_TSTRIG */
	volatile uint32_t TSADDREG : 1;		    /* CORE_MAC_TIMESTAMP_CONTROL_TSADDREG */
	const volatile uint32_t Reserved_7_6 : 2;   /* CORE_MAC_TIMESTAMP_CONTROL_RESERVED_7_6 */
	volatile uint32_t TSENALL : 1;		    /* CORE_MAC_TIMESTAMP_CONTROL_TSENALL */
	volatile uint32_t TSCTRLSSR : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSCTRLSSR */
	volatile uint32_t TSVER2ENA : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSVER2ENA */
	volatile uint32_t TSIPENA : 1;		    /* CORE_MAC_TIMESTAMP_CONTROL_TSIPENA */
	volatile uint32_t TSIPV6ENA : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSIPV6ENA */
	volatile uint32_t TSIPV4ENA : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSIPV4ENA */
	volatile uint32_t TSEVNTENA : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSEVNTENA */
	volatile uint32_t TSMSTRENA : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSMSTRENA */
	volatile uint32_t SNAPTYPSEL : 2;	    /* CORE_MAC_TIMESTAMP_CONTROL_SNAPTYPSEL */
	volatile uint32_t TSENMACADDR : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_TSENMACADDR */
	volatile uint32_t CSC : 1;		    /* CORE_MAC_TIMESTAMP_CONTROL_CSC */
	const volatile uint32_t Reserved_ESTI : 1;  /* CORE_MAC_TIMESTAMP_CONTROL_RESERVED_ESTI */
	const volatile uint32_t Reserved_23_21 : 3; /* CORE_MAC_TIMESTAMP_CONTROL_RESERVED_23_21 */
	volatile uint32_t TXTSSTSM : 1;		    /* CORE_MAC_TIMESTAMP_CONTROL_TXTSSTSM */
	const volatile uint32_t Reserved_27_25 : 3; /* CORE_MAC_TIMESTAMP_CONTROL_RESERVED_27_25 */
	volatile uint32_t AV8021ASMEN : 1;	    /* CORE_MAC_TIMESTAMP_CONTROL_AV8021ASMEN */
	const volatile uint32_t Reserved_31_29 : 3; /* CORE_MAC_TIMESTAMP_CONTROL_RESERVED_31_29 */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_CONTROL. */
typedef struct CORE_MAC_TIMESTAMP_CONTROL_s CORE_MAC_TIMESTAMP_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_CONTROL register. */
#define CORE_MAC_TIMESTAMP_CONTROL_RESET 0x00002000
/* The byte offset of the CORE_MAC_TIMESTAMP_CONTROL register from the beginning of the component.
 */
#define CORE_MAC_TIMESTAMP_CONTROL_OFST	 0xd00

/*
 * Register : MAC_Sub_Second_Increment
 *
 * The Sub-Second Increment register is present only when the IEEE 1588 timestamp
 * feature is selected without an external timestamp input. In Coarse Update mode
 * [Bit 1 in MAC_Timestamp_Control register], the value in this register is added
 * to the system time every clock cycle of clk_ptp_ref_i. In Fine Update mode, the
 * value in this register is added to the system time when the Accumulator gets an
 * overflow.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------
 *  [7:0]   | R      | 0x0   | CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0
 *  [15:8]  | RW     | 0x0   | CORE_MAC_SUB_SECOND_INCREMENT_SNSINC
 *  [23:16] | RW     | 0x0   | CORE_MAC_SUB_SECOND_INCREMENT_SSINC
 *  [31:24] | R      | 0x0   | CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24
 *
 */
/*
 * Field : Reserved_7_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0
 * register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0
 * register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_MSB	      7
/* The width in bits of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_WIDTH      8
/* The mask used to set the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_SET_MSK    0x000000ff
/* The mask used to clear the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_CLR_MSK    0xffffff00
/* The reset value of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_RESET      0x0
/* Extracts the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 field value from a register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 register field value suitable for setting
 * the register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : SNSINC
 *
 * Sub-nanosecond Increment Value.
 *
 * This field contains the sub-nanosecond increment value, represented in
 * nanoseconds multiplied by 28. This value is accumulated with the sub-nanoseconds
 * field of the sub-second register.
 *
 * For example, when TSCTRLSSR field in the MAC_Timestamp_Control register is set.
 * and if the required increment is 5.3ns, then SSINC should be 0x05 and SNSINC
 * should be 0x4C.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register
 * field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_LSB	8
/* The Most Significant Bit (MSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register
 * field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_MSB	15
/* The width in bits of the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_WIDTH	8
/* The mask used to set the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_SET_MSK	0x0000ff00
/* The mask used to clear the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_CLR_MSK	0xffff00ff
/* The reset value of the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_RESET	0x0
/* Extracts the CORE_MAC_SUB_SECOND_INCREMENT_SNSINC field value from a register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_SUB_SECOND_INCREMENT_SNSINC register field value suitable for setting the
 * register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SNSINC_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : SSINC
 *
 * Sub-second Increment Value.
 *
 * The value programmed in this field is accumulated with the contents of the sub-
 * second register. For example, when the PTP clock is 50 MHz (period is 20 ns),
 * you should program 20 (0x14) when the System Time- Nanoseconds register has an
 * accuracy of 1 ns [Bit 9 (TSCTRLSSR) is set in MAC_Timestamp_Control]. When
 * TSCTRLSSR is clear, the Nanoseconds register has a resolution of ~0.465 ns. In
 * this case, you should program a value of 43 (0x2B) which is derived by 20
 * ns/0.465.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_SSINC register
 * field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_SSINC register
 * field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_MSB	       23
/* The width in bits of the CORE_MAC_SUB_SECOND_INCREMENT_SSINC register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_WIDTH      8
/* The mask used to set the CORE_MAC_SUB_SECOND_INCREMENT_SSINC register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_SET_MSK    0x00ff0000
/* The mask used to clear the CORE_MAC_SUB_SECOND_INCREMENT_SSINC register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_CLR_MSK    0xff00ffff
/* The reset value of the CORE_MAC_SUB_SECOND_INCREMENT_SSINC register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_RESET      0x0
/* Extracts the CORE_MAC_SUB_SECOND_INCREMENT_SSINC field value from a register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a CORE_MAC_SUB_SECOND_INCREMENT_SSINC register field value suitable for setting the
 * register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_SSINC_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : Reserved_31_24
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24
 * register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_LSB	24
/* The Most Significant Bit (MSB) position of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24
 * register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_MSB	31
/* The width in bits of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_WIDTH	8
/* The mask used to set the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_SET_MSK	0xff000000
/* The mask used to clear the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 register field value. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_CLR_MSK	0x00ffffff
/* The reset value of the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 register field. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_RESET	0x0
/* Extracts the CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 field value from a register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_GET(value) (((value)&0xff000000) >> 24)
/* Produces a CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 register field value suitable for setting
 * the register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SUB_SECOND_INCREMENT.
 */
struct CORE_MAC_SUB_SECOND_INCREMENT_s {
	const volatile uint32_t Reserved_7_0 : 8; /* CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_7_0 */
	volatile uint32_t SNSINC : 8;		  /* CORE_MAC_SUB_SECOND_INCREMENT_SNSINC */
	volatile uint32_t SSINC : 8;		  /* CORE_MAC_SUB_SECOND_INCREMENT_SSINC */
	const volatile uint32_t
		Reserved_31_24 : 8; /* CORE_MAC_SUB_SECOND_INCREMENT_RESERVED_31_24 */
};

/* The typedef declaration for register CORE_MAC_SUB_SECOND_INCREMENT. */
typedef struct CORE_MAC_SUB_SECOND_INCREMENT_s CORE_MAC_SUB_SECOND_INCREMENT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SUB_SECOND_INCREMENT register. */
#define CORE_MAC_SUB_SECOND_INCREMENT_RESET 0x00000000
/* The byte offset of the CORE_MAC_SUB_SECOND_INCREMENT register from the beginning of the
 * component. */
#define CORE_MAC_SUB_SECOND_INCREMENT_OFST  0xd04

/*
 * Register : MAC_System_Time_Seconds
 *
 * The System Time-Seconds register, along with System Time-Nanoseconds register,
 * indicates the current value of the system time maintained by the MAC. Though it
 * is updated on a continuous basis, there is some delay from the actual time
 * because of clock domain transfer latencies (from clk_ptp_ref_i to CSR clock).
 *
 * This register is present only when the IEEE 1588 Timestamp feature is selected
 * without external timestamp input.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MAC_SYSTEM_TIME_SECONDS_TSS
 *
 */
/*
 * Field : TSS
 *
 * Timestamp Second.
 *
 * The value in this field indicates the current value in seconds of the System
 * Time maintained by the MAC.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field.
 */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field.
 */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_MSB	    31
/* The width in bits of the CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_WIDTH	    32
/* The mask used to set the CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field value. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field value. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_RESET	    0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_SECONDS_TSS field value from a register. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_SYSTEM_TIME_SECONDS_TSS register field value suitable for setting the
 * register. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_TSS_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SYSTEM_TIME_SECONDS.
 */
struct CORE_MAC_SYSTEM_TIME_SECONDS_s {
	const volatile uint32_t TSS : 32; /* CORE_MAC_SYSTEM_TIME_SECONDS_TSS */
};

/* The typedef declaration for register CORE_MAC_SYSTEM_TIME_SECONDS. */
typedef struct CORE_MAC_SYSTEM_TIME_SECONDS_s CORE_MAC_SYSTEM_TIME_SECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SYSTEM_TIME_SECONDS register. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_SYSTEM_TIME_SECONDS register from the beginning of the component.
 */
#define CORE_MAC_SYSTEM_TIME_SECONDS_OFST  0xd08

/*
 * Register : MAC_System_Time_Nanoseconds
 *
 * The System Time-Nanoseconds register, along with System Time-Seconds register,
 * indicates the current value of the system time maintained by the MAC.
 *
 * This register is present only when the IEEE 1588 Timestamp feature is selected
 * without external timestamp input.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [30:0] | R      | 0x0   | CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS
 *  [31]   | R      | 0x0   | CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31
 *
 */
/*
 * Field : TSSS
 *
 * Timestamp Sub Seconds.
 *
 * The value in this field has the sub-second representation of time, with an
 * accuracy of 0.46 ns. When Bit 9 is set in MAC_Timestamp_Control, each bit
 * represents 1 ns. The maximum value is 0x3B9A_C9FF after which it rolls-over to
 * zero.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register
 * field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register
 * field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_MSB	 30
/* The width in bits of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_WIDTH	 31
/* The mask used to set the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_SET_MSK	 0x7fffffff
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_CLR_MSK	 0x80000000
/* The reset value of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_RESET	 0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS field value from a register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_GET(value) (((value)&0x7fffffff) >> 0)
/* Produces a CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS register field value suitable for setting the
 * register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS_SET(value) (((value) << 0) & 0x7fffffff)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31
 * register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_LSB	31
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31
 * register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_MSB	31
/* The width in bits of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_WIDTH	1
/* The mask used to set the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_SET_MSK	0x80000000
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_RESET	0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 field value from a register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 register field value suitable for setting
 * the register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SYSTEM_TIME_NANOSECONDS.
 */
struct CORE_MAC_SYSTEM_TIME_NANOSECONDS_s {
	const volatile uint32_t TSSS : 31;	 /* CORE_MAC_SYSTEM_TIME_NANOSECONDS_TSSS */
	const volatile uint32_t Reserved_31 : 1; /* CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESERVED_31 */
};

/* The typedef declaration for register CORE_MAC_SYSTEM_TIME_NANOSECONDS. */
typedef struct CORE_MAC_SYSTEM_TIME_NANOSECONDS_s CORE_MAC_SYSTEM_TIME_NANOSECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SYSTEM_TIME_NANOSECONDS register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_SYSTEM_TIME_NANOSECONDS register from the beginning of the
 * component. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_OFST  0xd0c

/*
 * Register : MAC_System_Time_Seconds_Update
 *
 * The System Time-Seconds Update register, along with the System Time-Nanoseconds
 * Update register, initializes or updates the system time maintained by the MAC.
 * You must write both registers before setting the TSINIT or TSUPDT bits in
 * MAC_Timestamp_Control register.
 *
 * This register is present only when the IEEE 1588 Timestamp feature is selected
 * without external timestamp input.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS
 *
 */
/*
 * Field : TSS
 *
 * Timestamp Second.
 *
 * Timestamp Seconds The value in this field is the seconds part of the update.
 * When ADDSUB is reset, this field must be programmed with the seconds part of the
 * update value. When ADDSUB is set, this field must be programmed with the
 * complement of the seconds part of the update value. For example, if 2.000000001
 * seconds need to be subtracted from the system time, the TSS field in the
 * MAC_Timestamp_Seconds_Update register must be 0xFFFF_FFFE (that is, 2^32 - 2).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register
 * field. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register
 * field. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_MSB	   31
/* The width in bits of the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register field. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_WIDTH	   32
/* The mask used to set the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register field value. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register field value. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_CLR_MSK	   0x00000000
/* The reset value of the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register field. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_RESET	   0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS field value from a register. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS register field value suitable for setting the
 * register. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE.
 */
struct CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_s {
	volatile uint32_t TSS : 32; /* CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_TSS */
};

/* The typedef declaration for register CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE. */
typedef struct CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_s CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE register. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_RESET 0x00000000
/* The byte offset of the CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE register from the beginning of the
 * component. */
#define CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_OFST  0xd10

/*
 * Register : MAC_System_Time_Nanoseconds_Update
 *
 * This register is present only when the IEEE 1588 timestamp feature is selected
 * without external timestamp input.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [30:0] | RW     | 0x0   | CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS
 *  [31]   | RW     | 0x0   | CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB
 *
 */
/*
 * Field : TSSS
 *
 * Timestamp Sub Seconds.
 *
 * The value in this field is the sub-second part of the update.
 *
 * * When ADDSUB is reset, this field must be programmed with the sub-second part
 *   of the update value, with an accuracy based on the TSCTRLSSR bit of the MAC
 *   Timestamp Control register.
 *
 * * When ADDSUB is set, this field must be programmed with the complement of the
 *   sub-second part of the update value, as follows.
 *
 * * When TSCTRLSSR is set, the programmed value must be 10^9 - <sub-second value>.
 *   When TSCTRLSSR is reset, the programmed value should be 2^31 - <sub-
 *   second_value>.
 *
 * For example, when TSCTRLSSR bit is set and if 2.000000001 second needs to be
 * subtracted with the system time, the TSS field in the MAC Timestamp Seconds
 * update register must be 0xFFFF_FFFE (for instance, 2^32 - 2), ADDSUB bit in this
 * register must be set, and the TSSS field must be 0x3B9A_C9FF (for instance, 10^9
 * - 1).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS
 * register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS
 * register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_MSB	30
/* The width in bits of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_WIDTH	31
/* The mask used to set the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_SET_MSK	0x7fffffff
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_CLR_MSK	0x80000000
/* The reset value of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_RESET	0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS field value from a register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_GET(value) (((value)&0x7fffffff) >> 0)
/* Produces a CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS register field value suitable for setting
 * the register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS_SET(value) (((value) << 0) & 0x7fffffff)

/*
 * Field : ADDSUB
 *
 * Add or Subtract Time.
 *
 * When this bit is set, the time value is subtracted with the contents of the
 * update register. When this bit is reset, the time value is added with the
 * contents of the update register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB
 * register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_LSB	  31
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB
 * register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_MSB	  31
/* The width in bits of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_WIDTH	  1
/* The mask used to set the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB register field value. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_SET_MSK	  0x80000000
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB register field value.
 */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_CLR_MSK	  0x7fffffff
/* The reset value of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB register field. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_RESET	  0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB field value from a register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB register field value suitable for
 * setting the register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.
 */
struct CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_s {
	volatile uint32_t TSSS : 31;  /* CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_TSSS */
	volatile uint32_t ADDSUB : 1; /* CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB */
};

/* The typedef declaration for register CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE. */
typedef struct CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_s CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE register. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_RESET 0x00000000
/* The byte offset of the CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE register from the beginning of the
 * component. */
#define CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_OFST  0xd14

/*
 * Register : MAC_Timestamp_Addend
 *
 * The Timestamp Addend register is present only when the IEEE 1588 Timestamp
 * feature is selected without external timestamp input. This register value is
 * used only when the system time is configured for Fine Update mode (TSCFUPDT bit
 * in the MAC_Timestamp_Control register). The content of this register is added to
 * a 32-bit accumulator in every clock cycle (of clk_ptp_ref_i) and the system time
 * is updated when the accumulator overflows.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_TIMESTAMP_ADDEND_TSAR
 *
 */
/*
 * Field : TSAR
 *
 * Timestamp Addend Register.
 *
 * This field indicates the 32-bit time value to be added to the Accumulator
 * register to achieve time synchronization.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_ADDEND_TSAR register field. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_ADDEND_TSAR register field. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_MSB	  31
/* The width in bits of the CORE_MAC_TIMESTAMP_ADDEND_TSAR register field. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_WIDTH	  32
/* The mask used to set the CORE_MAC_TIMESTAMP_ADDEND_TSAR register field value. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_MAC_TIMESTAMP_ADDEND_TSAR register field value. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_CLR_MSK	  0x00000000
/* The reset value of the CORE_MAC_TIMESTAMP_ADDEND_TSAR register field. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_RESET	  0x0
/* Extracts the CORE_MAC_TIMESTAMP_ADDEND_TSAR field value from a register. */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_ADDEND_TSAR register field value suitable for setting the register.
 */
#define CORE_MAC_TIMESTAMP_ADDEND_TSAR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_ADDEND.
 */
struct CORE_MAC_TIMESTAMP_ADDEND_s {
	volatile uint32_t TSAR : 32; /* CORE_MAC_TIMESTAMP_ADDEND_TSAR */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_ADDEND. */
typedef struct CORE_MAC_TIMESTAMP_ADDEND_s CORE_MAC_TIMESTAMP_ADDEND_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_ADDEND register. */
#define CORE_MAC_TIMESTAMP_ADDEND_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_ADDEND register from the beginning of the component. */
#define CORE_MAC_TIMESTAMP_ADDEND_OFST	0xd18

/*
 * Register : MAC_System_Time_Higher_Word_Seconds
 *
 * The System Time - Higher Word Seconds register is present only when the IEEE
 * 1588 Timestamp feature is selected without an external timestamp input.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR
 *  [31:16] | R      | 0x0   | CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16
 *
 */
/*
 * Field : TSHWR
 *
 * Timestamp Higher Word Register.
 *
 * This field contains the most-significant 16-bits of timestamp seconds value.
 * This register is optional. You can add this register by selecting the Add IEEE
 * 1588 Higher Word Register option. This register is directly written to
 * initialize the value and it is incremented when there is an overflow from
 * 32-bits of the System Time - Seconds register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR
 * register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR
 * register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_MSB	  15
/* The width in bits of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_WIDTH	  16
/* The mask used to set the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR register field value. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_SET_MSK	  0x0000ffff
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR register field value.
 */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_CLR_MSK	  0xffff0000
/* The reset value of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_RESET	  0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR field value from a register. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR register field value suitable for
 * setting the register. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_LSB	16
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_MSB	31
/* The width in bits of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field.
 */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_WIDTH	16
/* The mask used to set the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field
 * value. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_SET_MSK 0xffff0000
/* The mask used to clear the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field
 * value. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_CLR_MSK 0x0000ffff
/* The reset value of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_RESET	0x0
/* Extracts the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 field value from a register.
 */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_GET(value)                         \
	(((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 register field value suitable
 * for setting the register. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16_SET(value)                         \
	(((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS.
 */
struct CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_s {
	volatile uint32_t TSHWR : 16; /* CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_TSHWR */
	const volatile uint32_t
		Reserved_31_16 : 16; /* CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS. */
typedef struct CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_s
	CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS register. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS register from the beginning of
 * the component. */
#define CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_OFST  0xd1c

/*
 * Register : MAC_Timestamp_Status
 *
 * The Timestamp Status register is present only when the IEEE 1588 Timestamp
 * feature is selected. All bits except Bits[29:25] gets cleared when the
 * application reads this register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [0]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSSOVF
 *  [1]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTARGT0
 *  [2]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG
 *  [3]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0
 *  [4]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTARGT1
 *  [5]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1
 *  [6]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTARGT2
 *  [7]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2
 *  [8]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTARGT3
 *  [9]     | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3
 *  [14:10] | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TTSNS
 *  [15]    | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_TXTSC
 *  [19:16] | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_ATSSTN
 *  [23:20] | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20
 *  [24]    | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_ATSSTM
 *  [29:25] | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_ATSNS
 *  [31:30] | R      | 0x0   | CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30
 *
 */
/*
 * Field : TSSOVF
 *
 * Timestamp Seconds Overflow.
 *
 * When this bit is set, it indicates that the seconds value of the timestamp (when
 * supporting version 2 format) has overflowed beyond 32'hFFFF_FFFF.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_MSB	    0
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_WIDTH	    1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSSOVF field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSSOVF register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSSOVF_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TSTARGT0
 *
 * Timestamp Target Time Reached.
 *
 * When set, this bit indicates that the value of system time is greater than or
 * equal to the value specified in the MAC_PPS0_Target_Time_Seconds and
 * MAC_PPS0_Target_Time_Nanoseconds registers.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_LSB	      1
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_MSB	      1
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_SET_MSK    0x00000002
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_CLR_MSK    0xfffffffd
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT0_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : AUXTSTRIG
 *
 * Auxiliary Timestamp Trigger Snapshot.
 *
 * This bit is set high when the auxiliary snapshot is written to the FIFO. This
 * bit is valid only if the Add IEEE 1588 Auxiliary Snapshot option is selected.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_LSB	       2
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_MSB	       2
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register field. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_SET_MSK    0x00000004
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_CLR_MSK    0xfffffffb
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register field. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : TSTRGTERR0
 *
 * Timestamp Target Time Error.
 *
 * This bit is set when the latest target time programmed in the
 * MAC_PPS0_Target_Time_Seconds and MAC_PPS0_Target_Time_Nanoseconds registers has
 * already elapsed. The bit is also set when the PPS command programmed cannot be
 * executed due to earlier programmed target time has already elapsed. This bit is
 * cleared when the application reads this bit.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_LSB	3
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_MSB	3
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_SET_MSK	0x00000008
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_CLR_MSK	0xfffffff7
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : TSTARGT1
 *
 * Timestamp Target Time Reached for Target Time PPS1.
 *
 * When set, this bit indicates that the value of system time is greater than or
 * equal to the value specified in the MAC_PPS1_Target_Time_Seconds and
 * MAC_PPS1_Target_Time_Nanoseconds registers.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_LSB	      4
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_MSB	      4
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT1_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : TSTRGTERR1
 *
 * Timestamp Target Time Error.
 *
 * This bit is set when the latest target time programmed in the
 * MAC_PPS1_Target_Time_Seconds and MAC_PPS1_Target_Time_Nanoseconds registers has
 * already elapsed. The bit is also set when the PPS command programmed cannot be
 * executed due to earlier programmed target time has already elapsed. This bit is
 * cleared when the application reads this bit.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_LSB	5
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_MSB	5
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_SET_MSK	0x00000020
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_CLR_MSK	0xffffffdf
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : TSTARGT2
 *
 * Timestamp Target Time Reached for Target Time PPS2.
 *
 * When set, this bit indicates that the value of system time is greater than or
 * equal to the value specified in the MAC_PPS2_Target_Time_Seconds and
 * MAC_PPS2_Target_Time_Nanoseconds registers.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_MSB	      6
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_SET_MSK    0x00000040
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT2_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : TSTRGTERR2
 *
 * Timestamp Target Time Error.
 *
 * This bit is set when the latest target time programmed in the
 * MAC_PPS2_Target_Time_Seconds and MAC_PPS2_Target_Time_Nanoseconds registers has
 * already elapsed. The bit is also set when the PPS command programmed cannot be
 * executed due to earlier programmed target time has already elapsed. This bit is
 * cleared when the application reads this bit.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_LSB	7
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_MSB	7
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_SET_MSK	0x00000080
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_CLR_MSK	0xffffff7f
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : TSTARGT3
 *
 * Timestamp Target Time Reached for Target Time PPS3.
 *
 * When this bit is set, it indicates that the value of system time is greater than
 * or equal to the value specified in the MAC_PPS3_Target_Time_Seconds and
 * MAC_PPS3_Target_Time_Nanoseconds registers.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_LSB	      8
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_MSB	      8
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_WIDTH      1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_SET_MSK    0x00000100
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_CLR_MSK    0xfffffeff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_GET(value) (((value)&0x00000100) >> 8)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTARGT3_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : TSTRGTERR3
 *
 * Timestamp Target Time Error.
 *
 * This bit is set when the latest target time programmed in the
 * MAC_PPS3_Target_Time_Seconds and MAC_PPS3_Target_Time_Nanoseconds registers has
 * already elapsed. The bit is also set when the PPS command programmed cannot be
 * executed due to earlier programmed target time has already elapsed. This bit is
 * cleared when the application reads this bit.
 *
 * Access restriction applies. Clears on read (or write of 1 when RCWE bit in
 * MAC_CSR_SW_Ctrl register is set). Self-set to 1 on internal event.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_LSB	9
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_MSB	9
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_WIDTH	1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_SET_MSK	0x00000200
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_CLR_MSK	0xfffffdff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_GET(value) (((value)&0x00000200) >> 9)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : TTSNS
 *
 * Number of Tx Timestamp Snapshots.
 *
 * This field indicates the number of Tx Timestamp Snapshots available in the FIFO.
 * A value equal to the selected depth of FIFO (2, 4, 8, or 16) indicates that the
 * Tx Timestamp Snapshot FIFO is full.
 *
 * The Tx Timestamp Snapshot FIFO is implemented as synchronous FIFO in the CSR
 * clock domain. This field is incremented along with the Tx Timestamp Snapshot
 * write command to the FIFO. This field is decremented along with the Tx Timestamp
 * Snapshot read command (issued when byte 3 or byte 0 of
 * MAC_TxTimestamp_Status_Seconds register is read in little or big endian mode
 * respectively) to the FIFO. If both write and read command is issued
 * simultaneously, this field is not changed.
 *
 * This field is valid only if the "Enable IEEE 1588 Timestamp Support" option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TTSNS register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_LSB	   10
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TTSNS register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_MSB	   14
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TTSNS register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_WIDTH	   5
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TTSNS register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_SET_MSK	   0x00007c00
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TTSNS register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_CLR_MSK	   0xffff83ff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TTSNS register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_RESET	   0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TTSNS field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_GET(value) (((value)&0x00007c00) >> 10)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TTSNS register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TTSNS_SET(value) (((value) << 10) & 0x00007c00)

/*
 * Field : TXTSC
 *
 * Tx Timestamp Captured.
 *
 * When set, this bit indicates that a timestamp of the current packet being
 * transmitted by the MAC is available in MAC_TxTimestamp_Status_Seconds and
 * MAC_TxTimestamp_Status_Nanoseconds registers. This bit is cleared on reading
 * (byte 3 or byte 0 in little or big endian mode respectively) the
 * MAC_TxTimestamp_Status_Seconds register.
 *
 * When Tx Timestamp Status FIFO depth selected is more than 1, this bit is set as
 * long as Tx Timestamp status FIFO has Tx Timestamp status entries. It is cleared
 * when Seconds field corresponding to last entry is read (byte 3 or byte 0 in
 * little or big endian mode respectively) from MAC_TxTimestamp_Status_Seconds
 * register.
 *
 * Access restriction applies.This bit is cleared on reading (byte 3 or byte 0 in
 * little or big endian mode respectively) the MAC_TxTimestamp_Status_Seconds
 * register (or write to corresponding byte of MAC_Tx_Timestamp_Status_Seconds
 * register when RCWE bit of MAC_CSR_SW_Ctrl register is set).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_TXTSC register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_LSB	   15
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_TXTSC register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_MSB	   15
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_TXTSC register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_WIDTH	   1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_TXTSC register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_SET_MSK	   0x00008000
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_TXTSC register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_CLR_MSK	   0xffff7fff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_TXTSC register field. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_RESET	   0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_TXTSC field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_TXTSC register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_TXTSC_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : ATSSTN
 *
 * Auxiliary Timestamp Snapshot Trigger Identifier.
 *
 * These bits identify the Auxiliary trigger inputs for which the timestamp
 * available in the Auxiliary Snapshot register is applicable. When more than one
 * bit is set at the same time, it means that corresponding auxiliary triggers are
 * sampled at the same clock. These bits are applicable only if the number of
 * Auxiliary snapshots is more than one. One bit is assigned for each trigger as
 * shown in the following list:
 *
 * * Bit 16: Auxiliary trigger 0
 *
 * * Bit 17: Auxiliary trigger 1
 *
 * * Bit 18: Auxiliary trigger 2
 *
 * * Bit 19: Auxiliary trigger 3
 *
 * The software can read this register to find the triggers that are set when the
 * timestamp is taken.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_LSB	    16
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_MSB	    19
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_WIDTH	    4
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_SET_MSK    0x000f0000
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_CLR_MSK    0xfff0ffff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_ATSSTN field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_ATSSTN register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTN_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : Reserved_23_20
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_LSB	    20
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_MSB	    23
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_WIDTH	    4
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_SET_MSK    0x00f00000
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_CLR_MSK    0xff0fffff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_GET(value) (((value)&0x00f00000) >> 20)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20_SET(value) (((value) << 20) & 0x00f00000)

/*
 * Field : ATSSTM
 *
 * Auxiliary Timestamp Snapshot Trigger Missed.
 *
 * This bit is set when the Auxiliary timestamp snapshot FIFO is full and external
 * trigger was set. This indicates that the latest snapshot is not stored in the
 * FIFO. This bit is valid only if the Add IEEE 1588 Auxiliary Snapshot option is
 * selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_LSB	    24
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_MSB	    24
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_WIDTH	    1
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_SET_MSK    0x01000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_CLR_MSK    0xfeffffff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_ATSSTM field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_GET(value) (((value)&0x01000000) >> 24)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_ATSSTM register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSSTM_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : ATSNS
 *
 * Number of Auxiliary Timestamp Snapshots.
 *
 * This field indicates the number of Snapshots available in the FIFO. A value
 * equal to the selected depth of FIFO (4, 8, or 16) indicates that the Auxiliary
 * Snapshot FIFO is full. These bits are cleared (to 00000) when the Auxiliary
 * snapshot FIFO clear bit is set. This bit is valid only if the Add IEEE 1588
 * Auxiliary Snapshot option is selected.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_ATSNS register field.
 */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_LSB	   25
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_ATSNS register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_MSB	   29
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_ATSNS register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_WIDTH	   5
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_ATSNS register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_SET_MSK	   0x3e000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_ATSNS register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_CLR_MSK	   0xc1ffffff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_ATSNS register field. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_RESET	   0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_ATSNS field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_GET(value) (((value)&0x3e000000) >> 25)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_ATSNS register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_ATSNS_SET(value) (((value) << 25) & 0x3e000000)

/*
 * Field : Reserved_31_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_LSB	    30
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register
 * field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_MSB	    31
/* The width in bits of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_WIDTH	    2
/* The mask used to set the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_SET_MSK    0xc0000000
/* The mask used to clear the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register field value. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_CLR_MSK    0x3fffffff
/* The reset value of the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register field. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_RESET	    0x0
/* Extracts the CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 field value from a register. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 register field value suitable for setting the
 * register. */
#define CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_STATUS.
 */
struct CORE_MAC_TIMESTAMP_STATUS_s {
	const volatile uint32_t TSSOVF : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSSOVF */
	const volatile uint32_t TSTARGT0 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTARGT0 */
	const volatile uint32_t AUXTSTRIG : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_AUXTSTRIG */
	const volatile uint32_t TSTRGTERR0 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR0 */
	const volatile uint32_t TSTARGT1 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTARGT1 */
	const volatile uint32_t TSTRGTERR1 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR1 */
	const volatile uint32_t TSTARGT2 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTARGT2 */
	const volatile uint32_t TSTRGTERR2 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR2 */
	const volatile uint32_t TSTARGT3 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTARGT3 */
	const volatile uint32_t TSTRGTERR3 : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TSTRGTERR3 */
	const volatile uint32_t TTSNS : 5;	    /* CORE_MAC_TIMESTAMP_STATUS_TTSNS */
	const volatile uint32_t TXTSC : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_TXTSC */
	const volatile uint32_t ATSSTN : 4;	    /* CORE_MAC_TIMESTAMP_STATUS_ATSSTN */
	const volatile uint32_t Reserved_23_20 : 4; /* CORE_MAC_TIMESTAMP_STATUS_RESERVED_23_20 */
	const volatile uint32_t ATSSTM : 1;	    /* CORE_MAC_TIMESTAMP_STATUS_ATSSTM */
	const volatile uint32_t ATSNS : 5;	    /* CORE_MAC_TIMESTAMP_STATUS_ATSNS */
	const volatile uint32_t Reserved_31_30 : 2; /* CORE_MAC_TIMESTAMP_STATUS_RESERVED_31_30 */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_STATUS. */
typedef struct CORE_MAC_TIMESTAMP_STATUS_s CORE_MAC_TIMESTAMP_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_STATUS register. */
#define CORE_MAC_TIMESTAMP_STATUS_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_STATUS register from the beginning of the component. */
#define CORE_MAC_TIMESTAMP_STATUS_OFST	0xd20

/*
 * Register : MAC_Tx_Timestamp_Status_Nanoseconds
 *
 * The MAC_TxTimestamp_Status_Nanoseconds register, along with
 * MAC_TxTimestamp_Status_Seconds, gives the 64-bit timestamp captured for the PTP
 * packet successfully transmitted by the MAC. This value is considered to be read
 * by the application when the last byte of MAC_Tx_Timestamp_Status_Seconds is
 * read. In the little-endian mode, this means bits[31:24] are read; in big-endian
 * mode, bits[7:0] are read.
 *
 * If the application does not read these registers and timestamp of another packet
 * is captured, then either the current timestamp is lost (overwritten) or the new
 * timestamp is lost (dropped), depending on the setting of the TXTSSTSM bit of the
 * MAC_Timestamp_Control register. The status bit TXTSC bit [15] in
 * MAC_Timestamp_Status register is set when the MAC transmitter captures the
 * timestamp.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [30:0] | R      | 0x0   | CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO
 *  [31]   | R      | 0x0   | CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS
 *
 */
/*
 * Field : TXTSSLO
 *
 * Transmit Timestamp Status Low.
 *
 * This field contains the 31 bits of the Nanoseconds field of the Transmit
 * packet's captured timestamp.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_MSB	    30
/* The width in bits of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_WIDTH	    31
/* The mask used to set the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO register field value.
 */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_SET_MSK    0x7fffffff
/* The mask used to clear the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO register field value.
 */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_CLR_MSK    0x80000000
/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_RESET	    0x0
/* Extracts the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO field value from a register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_GET(value) (((value)&0x7fffffff) >> 0)
/* Produces a CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO register field value suitable for
 * setting the register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO_SET(value) (((value) << 0) & 0x7fffffff)

/*
 * Field : TXTSSMIS
 *
 * Transmit Timestamp Status Missed.
 *
 * When this bit is set, it indicates one of the following:
 *
 * * The timestamp of the current packet is ignored if TXTSSTSM bit of the
 *   MAC_Timestamp_Control register is reset
 *
 * * The timestamp of the previous packet is overwritten with timestamp of the
 *   current packet if TXTSSTSM bit of the MAC_Timestamp_Control register is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_LSB	     31
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_MSB	     31
/* The width in bits of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_WIDTH	     1
/* The mask used to set the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS register field value.
 */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS register field
 * value. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_RESET	     0x0
/* Extracts the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS field value from a register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS register field value suitable for
 * setting the register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS.
 */
struct CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_s {
	const volatile uint32_t TXTSSLO : 31; /* CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSLO */
	const volatile uint32_t
		TXTSSMIS : 1; /* CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_TXTSSMIS */
};

/* The typedef declaration for register CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS. */
typedef struct CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_s
	CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS register from the beginning of
 * the component. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_OFST  0xd30

/*
 * Register : MAC_Tx_Timestamp_Status_Seconds
 *
 * The register contains the higher 32 bits of the timestamp (in seconds) captured
 * when a PTP packet is transmitted.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI
 *
 */
/*
 * Field : TXTSSTSHI
 *
 * Transmit Timestamp Status High.
 *
 * This field contains the lower 32 bits of the Seconds field of Transmit packet's
 * captured timestamp.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_MSB	  31
/* The width in bits of the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_WIDTH	  32
/* The mask used to set the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI register field value. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI register field value.
 */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_CLR_MSK	  0x00000000
/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_RESET	  0x0
/* Extracts the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI field value from a register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI register field value suitable for
 * setting the register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS.
 */
struct CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_s {
	const volatile uint32_t TXTSSTSHI : 32; /* CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_TXTSSTSHI */
};

/* The typedef declaration for register CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS. */
typedef struct CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_s CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS register from the beginning of the
 * component. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_OFST  0xd34

/*
 * Register : MAC_Tx_Timestamp_Status_PktID
 *
 * This register contains the PTP packet ID corresponding to the Tx Timestamp
 * Status in MAC_TxTimestamp_Status_Nanoseconds and MAC_TxTimestamp_Status_Seconds
 * registers. This register is available when IEEE 1588 Tx Timestamp Status FIFO
 * Depth is greater than 1.
 *
 * The correct reading sequence of these registers is as follows:
 *
 * * MAC_TxTimestamp_Status_PktID register
 *
 * * MAC_TxTimestamp_Status_Nanoseconds register
 *
 * * MAC_TxTimestamp_Status_Seconds register
 *
 * This is because, all the 3 registers are updated to a new value when the
 * application reads the last byte of the MAC_TxTimestamp_Status_Seconds register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------------------
 *  [9:0]   | R      | 0x0   | CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID
 *  [31:10] | R      | 0x0   | CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10
 *
 */
/*
 * Field : PKTID
 *
 * Packet ID.
 *
 * The field contains the packet ID corresponding to the Tx Timestamp status in
 * MAC_TxTimestamp_Status_Nanoseconds and MAC_TxTimestamp_Status_Seconds registers.
 *
 * Note: The value of 0 for Packet ID is reserved, it is used by DWC_xgmac for
 * indicating timestamp status of packets for which Packet ID was not provided by
 * Software or for PTP response packets generated by the hardware PTP Offload
 * engine.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register
 * field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register
 * field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_MSB	    9
/* The width in bits of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_WIDTH	    10
/* The mask used to set the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register field value. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_SET_MSK    0x000003ff
/* The mask used to clear the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register field value. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_CLR_MSK    0xfffffc00
/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_RESET	    0x0
/* Extracts the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID field value from a register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_GET(value) (((value)&0x000003ff) >> 0)
/* Produces a CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID register field value suitable for setting the
 * register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID_SET(value) (((value) << 0) & 0x000003ff)

/*
 * Field : Reserved_31_10
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_LSB	     10
/* The Most Significant Bit (MSB) position of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10
 * register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_MSB	     31
/* The width in bits of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_WIDTH	     22
/* The mask used to set the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 register field value.
 */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_SET_MSK    0xfffffc00
/* The mask used to clear the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 register field
 * value. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_CLR_MSK    0x000003ff
/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 register field. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_RESET	     0x0
/* Extracts the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 field value from a register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_GET(value) (((value)&0xfffffc00) >> 10)
/* Produces a CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 register field value suitable for
 * setting the register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10_SET(value) (((value) << 10) & 0xfffffc00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TX_TIMESTAMP_STATUS_PKTID.
 */
struct CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_s {
	const volatile uint32_t PKTID : 10; /* CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_PKTID */
	const volatile uint32_t
		Reserved_31_10 : 22; /* CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESERVED_31_10 */
};

/* The typedef declaration for register CORE_MAC_TX_TIMESTAMP_STATUS_PKTID. */
typedef struct CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_s CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID register. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_RESET 0x00000000
/* The byte offset of the CORE_MAC_TX_TIMESTAMP_STATUS_PKTID register from the beginning of the
 * component. */
#define CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_OFST	 0xd38

/*
 * Register : MAC_Auxiliary_Control
 *
 * The Auxiliary Timestamp Control register controls the Auxiliary Timestamp
 * snapshot.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [0]    | RW     | 0x0   | CORE_MAC_AUXILIARY_CONTROL_ATSFC
 *  [3:1]  | R      | 0x0   | CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1
 *  [4]    | RW     | 0x0   | CORE_MAC_AUXILIARY_CONTROL_ATSEN0
 *  [5]    | RW     | 0x0   | CORE_MAC_AUXILIARY_CONTROL_ATSEN1
 *  [6]    | R      | 0x0   | CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2
 *  [7]    | R      | 0x0   | CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3
 *  [31:8] | R      | 0x0   | CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8
 *
 */
/*
 * Field : ATSFC
 *
 * Auxiliary Snapshot FIFO Clear.
 *
 * When set, this bit resets the pointers of the Auxiliary Snapshot FIFO. This bit
 * is cleared when the pointers are reset and the FIFO is empty. When this bit is
 * high, the auxiliary snapshots are stored in the FIFO.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_ATSFC register field.
 */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_ATSFC register field.
 */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_MSB	    0
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_ATSFC register field. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_WIDTH	    1
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_ATSFC register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_ATSFC register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_ATSFC register field. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_RESET	    0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_ATSFC field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_ATSFC register field value suitable for setting the
 * register. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSFC_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register
 * field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_LSB	   1
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register
 * field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_MSB	   3
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_WIDTH	   3
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_SET_MSK	   0x0000000e
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_CLR_MSK	   0xfffffff1
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_RESET	   0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 register field value suitable for setting the
 * register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : ATSEN0
 *
 * Auxiliary Snapshot 0 Enable.
 *
 * This bit controls the capturing of Auxiliary Snapshot Trigger 0. When this bit
 * is set, the auxiliary snapshot of the event on ptp_aux_trig_i[0] input is
 * enabled. When this bit is reset, the events on this input are ignored.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field.
 */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_LSB	     4
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field.
 */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_MSB	     4
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_WIDTH	     1
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_RESET	     0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_ATSEN0 field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_ATSEN0 register field value suitable for setting the
 * register. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN0_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : ATSEN1
 *
 * Auxiliary Snapshot 1 Enable.
 *
 * This bit controls the capturing of Auxiliary Snapshot Trigger 1. When this bit
 * is set, the auxiliary snapshot of the event on ptp_aux_trig_i[1] input is
 * enabled. When this bit is reset, the events on this input are ignored.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field.
 */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_LSB	     5
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field.
 */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_MSB	     5
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_WIDTH	     1
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_SET_MSK    0x00000020
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_CLR_MSK    0xffffffdf
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_RESET	     0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_ATSEN1 field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_ATSEN1 register field value suitable for setting the
 * register. */
#define CORE_MAC_AUXILIARY_CONTROL_ATSEN1_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_ATSEN2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2
 * register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_LSB	      6
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2
 * register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_MSB	      6
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_WIDTH      1
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_SET_MSK    0x00000040
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_RESET      0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 register field value suitable for setting
 * the register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Reserved_ATSEN3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3
 * register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_LSB	      7
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3
 * register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_MSB	      7
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_WIDTH      1
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_SET_MSK    0x00000080
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_RESET      0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 register field value suitable for setting
 * the register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_31_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register
 * field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_LSB	    8
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register
 * field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_MSB	    31
/* The width in bits of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_WIDTH	    24
/* The mask used to set the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_SET_MSK    0xffffff00
/* The mask used to clear the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register field value. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_CLR_MSK    0x000000ff
/* The reset value of the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register field. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_RESET	    0x0
/* Extracts the CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 field value from a register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 register field value suitable for setting the
 * register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_AUXILIARY_CONTROL.
 */
struct CORE_MAC_AUXILIARY_CONTROL_s {
	volatile uint32_t ATSFC : 1;		  /* CORE_MAC_AUXILIARY_CONTROL_ATSFC */
	const volatile uint32_t Reserved_3_1 : 3; /* CORE_MAC_AUXILIARY_CONTROL_RESERVED_3_1 */
	volatile uint32_t ATSEN0 : 1;		  /* CORE_MAC_AUXILIARY_CONTROL_ATSEN0 */
	volatile uint32_t ATSEN1 : 1;		  /* CORE_MAC_AUXILIARY_CONTROL_ATSEN1 */
	const volatile uint32_t
		Reserved_ATSEN2 : 1; /* CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN2 */
	const volatile uint32_t
		Reserved_ATSEN3 : 1;		    /* CORE_MAC_AUXILIARY_CONTROL_RESERVED_ATSEN3 */
	const volatile uint32_t Reserved_31_8 : 24; /* CORE_MAC_AUXILIARY_CONTROL_RESERVED_31_8 */
};

/* The typedef declaration for register CORE_MAC_AUXILIARY_CONTROL. */
typedef struct CORE_MAC_AUXILIARY_CONTROL_s CORE_MAC_AUXILIARY_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_AUXILIARY_CONTROL register. */
#define CORE_MAC_AUXILIARY_CONTROL_RESET 0x00000000
/* The byte offset of the CORE_MAC_AUXILIARY_CONTROL register from the beginning of the component.
 */
#define CORE_MAC_AUXILIARY_CONTROL_OFST	 0xd40

/*
 * Register : MAC_Auxiliary_Timestamp_Nanoseconds
 *
 * The Auxiliary Timestamp - Nanoseconds register, along with
 * MAC_Auxiliary_Timestamp_Seconds, gives the 64-bit timestamp stored as auxiliary
 * snapshot. These two registers form the read port of a 64-bit wide FIFO with a
 * depth of 4, 8, or 16 as selected while configuring the controller.
 *
 * You can store multiple snapshots in this FIFO. Bits[29:25] in
 * MAC_Timestamp_Status indicate the fill-level of the FIFO. The top of the FIFO is
 * removed only when the last byte of MAC_Auxiliary_Timestamp_Seconds register is
 * read. In the Little-endian mode, this means Bits[31:24] are read and in Big-
 * endian mode, Bits[7:0] are read.
 *
 * This register and MAC_Auxiliary_Timestamp_Seconds register are present only when
 * you select the Add IEEE 1588 Auxiliary Snapshot option while configuring the
 * controller.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------------
 *  [30:0] | R      | 0x0   | CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO
 *  [31]   | R      | 0x0   | CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31
 *
 */
/*
 * Field : AUXTSLO
 *
 * Auxiliary Timestamp Low. Contains the lower 31 bits (nanoseconds field) of the
 * auxiliary timestamp.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO
 * register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO
 * register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_MSB	    30
/* The width in bits of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_WIDTH	    31
/* The mask used to set the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO register field value.
 */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_SET_MSK    0x7fffffff
/* The mask used to clear the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO register field value.
 */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_CLR_MSK    0x80000000
/* The reset value of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_RESET	    0x0
/* Extracts the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO field value from a register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_GET(value) (((value)&0x7fffffff) >> 0)
/* Produces a CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO register field value suitable for
 * setting the register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO_SET(value) (((value) << 0) & 0x7fffffff)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_LSB	31
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_MSB	31
/* The width in bits of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_WIDTH	1
/* The mask used to set the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field
 * value. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_SET_MSK	0x80000000
/* The mask used to clear the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field
 * value. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_CLR_MSK	0x7fffffff
/* The reset value of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_RESET	0x0
/* Extracts the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 field value from a register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 register field value suitable for
 * setting the register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31_SET(value)                            \
	(((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS.
 */
struct CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_s {
	const volatile uint32_t AUXTSLO : 31; /* CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_AUXTSLO */
	const volatile uint32_t
		Reserved_31 : 1; /* CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESERVED_31 */
};

/* The typedef declaration for register CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS. */
typedef struct CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_s
	CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS register from the beginning of
 * the component. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_OFST  0xd48

/*
 * Register : MAC_Auxiliary_Timestamp_Seconds
 *
 * The Auxiliary Timestamp - Seconds register contains the lower 32 bits of the
 * Seconds field of the auxiliary timestamp register.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------
 *  [31:0] | R      | 0x0   | CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI
 *
 */
/*
 * Field : AUXTSHI
 *
 * Auxiliary Timestamp High. Contains the lower 32 bits of the Seconds field of the
 * auxiliary timestamp.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI
 * register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_LSB	0
/* The Most Significant Bit (MSB) position of the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI
 * register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_MSB	31
/* The width in bits of the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_WIDTH	32
/* The mask used to set the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI register field value. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_SET_MSK	0xffffffff
/* The mask used to clear the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI register field value. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_CLR_MSK	0x00000000
/* The reset value of the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI register field. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_RESET	0x0
/* Extracts the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI field value from a register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI register field value suitable for setting
 * the register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS.
 */
struct CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_s {
	const volatile uint32_t AUXTSHI : 32; /* CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_AUXTSHI */
};

/* The typedef declaration for register CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS. */
typedef struct CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_s CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS register. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS register from the beginning of the
 * component. */
#define CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_OFST  0xd4c

/*
 * Register : MAC_Timestamp_Ingress_Asym_Corr
 *
 * The MAC Timestamp Ingress Asymmetry Correction register contains the Ingress
 * Asymmetry Correction value to be used while updating correction field in some
 * PTP messages.
 *
 * Ideally, Ingress Asymmetry correction needs to be done in the receive side, when
 * the corresponding packet is received. But when one-step time stamping is
 * enabled, the controller performs ingress asymmetry correction on the transmit
 * (egress) side, which still holds good for packets that are received and
 * transmitted on the same port (for example, Pdelay Resp, which is sent for a
 * Pdelay Request received in the same port).
 *
 * In other cases (for example, transparent bridge), this feature can still be used
 * if all receive ports have the same ingress correction value. If not, then OSTIAC
 * must be programmed to 0x0.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC
 *
 */
/*
 * Field : OSTIAC
 *
 * One-Step Timestamp Ingress Asymmetry Correction.
 *
 * This field contains the ingress path asymmetry value to be added to
 * correctionField of Sync and Pdelay_Resp PTP packet. The programmed value should
 * be in units of nanoseconds and multiplied by 2^16. For example, 2.5 ns is
 * represented as 0x00028000.
 *
 * The value can also be negative and then is represented in twos complement form
 * with bit 31 representing the sign bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC
 * register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC
 * register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_MSB	       31
/* The width in bits of the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_WIDTH      32
/* The mask used to set the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC register field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC register field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC field value from a register. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC register field value suitable for setting
 * the register. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR.
 */
struct CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_s {
	volatile uint32_t OSTIAC : 32; /* CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OSTIAC */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR. */
typedef struct CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_s CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR register. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR register from the beginning of the
 * component. */
#define CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_OFST  0xd50

/*
 * Register : MAC_Timestamp_Egress_Asym_Corr
 *
 * The MAC Timestamp Egress Asymmetry Correction register contains the Egress
 * Asymmetry Correction value to be used while updating the correction field in for
 * some PTP message types.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC
 *
 */
/*
 * Field : OSTEAC
 *
 * One-Step Timestamp Egress Asymmetry Correction.
 *
 * This field contains the egress path asymmetry value to be subtracted from
 * correctionField of Delay_Req and Pdelay_Req PTP packet. The programmed value
 * must be the negated value in units of nanoseconds multiplied by 2^16.
 *
 * For example, if the required correction is +2.5 ns, then the programmed value
 * must be 0xFFFD_8000, which is twos complement of 0x0002_8000 (2.5 * 2^16).
 * Similarly, if the required correction is -3.3 ns, then the programmed value is
 * 0x0003_4CCC (3.3 * 2^16).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC
 * register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC
 * register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_MSB	      31
/* The width in bits of the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_WIDTH      32
/* The mask used to set the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC register field value. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC register field value. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_RESET      0x0
/* Extracts the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC field value from a register. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC register field value suitable for setting
 * the register. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR.
 */
struct CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_s {
	volatile uint32_t OSTEAC : 32; /* CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OSTEAC */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR. */
typedef struct CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_s CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR register. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR register from the beginning of the
 * component. */
#define CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_OFST  0xd54

/*
 * Register : MAC_Timestamp_Ingress_Corr_Nanosecond
 *
 * The MAC Timestamp Ingress Correction Nanosecond register contains the correction
 * value to be used with the captured timestamp value in the ingress path. This is
 * used to compensate the errors due to timestamp synchronization from the PTP
 * clock domain to the MAC Rx clock domain, and the latency incurred between the
 * message timestamp point and the point at which the timestamp snapshot is taken.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC
 *
 */
/*
 * Field : TSIC
 *
 * Timestamp Ingress Correction.
 *
 * This field contains the ingress path correction value in nanoseconds as defined
 * by the "Ingress Correction" expression.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC
 * register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_LSB	   0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC
 * register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_MSB	   31
/* The width in bits of the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_WIDTH	   32
/* The mask used to set the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC register field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_SET_MSK	   0xffffffff
/* The mask used to clear the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC register field value.
 */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_CLR_MSK	   0x00000000
/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_RESET	   0x0
/* Extracts the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC field value from a register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC register field value suitable for
 * setting the register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND.
 */
struct CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_s {
	volatile uint32_t TSIC : 32; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_TSIC */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND. */
typedef struct CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_s
	CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND register from the beginning of
 * the component. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_OFST	 0xd58

/*
 * Register : MAC_Timestamp_Ingress_Corr_Subnanosecond
 *
 * The MAC Timestamp Ingress Correction Sub-Nanosecond register contains the sub-
 * nanosecond part of the correction value to be used with the captured timestamp
 * value, for ingress directions.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------------------------
 *  [7:0]   | R      | 0x0   | CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0
 *  [15:8]  | RW     | 0x0   | CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS
 *  [31:16] | R      | 0x0   | CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16
 *
 */
/*
 * Field : Reserved_7_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_LSB	   0
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_MSB	   7
/* The width in bits of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register
 * field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_WIDTH   8
/* The mask used to set the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register
 * field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_SET_MSK 0x000000ff
/* The mask used to clear the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register
 * field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_CLR_MSK 0xffffff00
/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field.
 */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_RESET   0x0
/* Extracts the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 field value from a
 * register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_GET(value)                      \
	(((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field value
 * suitable for setting the register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_SET(value)                      \
	(((value) << 0) & 0x000000ff)

/*
 * Field : TSICSNS
 *
 * Timestamp Ingress Correction, sub-nanoseconds.
 *
 * This field contains the sub-nanoseconds part of the ingress path correction
 * value as defined by the "Ingress Correction" expression.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_LSB	 8
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_MSB	 15
/* The width in bits of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_WIDTH	 8
/* The mask used to set the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field
 * value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_SET_MSK	 0x0000ff00
/* The mask used to clear the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field
 * value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_CLR_MSK	 0xffff00ff
/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_RESET	 0x0
/* Extracts the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS field value from a register.
 */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS register field value suitable
 * for setting the register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS_SET(value)                           \
	(((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_LSB     16
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_MSB     31
/* The width in bits of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_WIDTH   16
/* The mask used to set the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_SET_MSK 0xffff0000
/* The mask used to clear the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field value. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_CLR_MSK 0x0000ffff
/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_RESET   0x0
/* Extracts the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 field value from a
 * register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_GET(value)                    \
	(((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register field value
 * suitable for setting the register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_SET(value)                    \
	(((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND.
 */
struct CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_s {
	const volatile uint32_t
		Reserved_7_0 : 8; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 */
	volatile uint32_t TSICSNS : 8; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_TSICSNS */
	const volatile uint32_t Reserved_31_16 : 16; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESERVED_31_16
						      */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND. */
typedef struct CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_s
	CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND register. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND register from the beginning
 * of the component. */
#define CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_OFST  0xd5c

/*
 * Register : MAC_Timestamp_Egress_Corr_Nanosecond
 *
 * The MAC Egress Timestamp Correction Nanosecond register contains the correction
 * value to be used with the captured timestamp value in the egress path. This is
 * used to compensate the errors due to timestamp synchronization from PTP clock
 * domain to MAC Tx clock domain, and the latency incurred between the point at
 * which the timestamp snapshot is taken and the message timestamp point.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC
 *
 */
/*
 * Field : TSEC
 *
 * Timestamp Egress Correction.
 *
 * This field contains the nanoseconds part of the egress path correction value as
 * defined by the "Egress Correction" expression,
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC
 * register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC
 * register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_MSB	  31
/* The width in bits of the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_WIDTH	  32
/* The mask used to set the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC register field value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC register field value.
 */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_CLR_MSK	  0x00000000
/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_RESET	  0x0
/* Extracts the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC field value from a register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC register field value suitable for
 * setting the register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND.
 */
struct CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_s {
	volatile uint32_t TSEC : 32; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_TSEC */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND. */
typedef struct CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_s
	CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND register from the beginning of
 * the component. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_OFST	0xd60

/*
 * Register : MAC_Timestamp_Egress_Corr_Subnanosecond
 *
 * The MAC Timestamp Correction Egress Sub-nanosecond register contains the sub-
 * nanosecond part of the correction value to be used with the captured timestamp
 * value, for egress directions.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------------------
 *  [7:0]   | R      | 0x0   | CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0
 *  [15:8]  | RW     | 0x0   | CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS
 *  [31:16] | R      | 0x0   | CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16
 *
 */
/*
 * Field : Reserved_7_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_LSB	  0
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_MSB	  7
/* The width in bits of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register
 * field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_WIDTH	  8
/* The mask used to set the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field
 * value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_SET_MSK 0x000000ff
/* The mask used to clear the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register
 * field value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_CLR_MSK 0xffffff00
/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field.
 */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_RESET	  0x0
/* Extracts the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 field value from a
 * register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_GET(value)                       \
	(((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 register field value
 * suitable for setting the register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0_SET(value)                       \
	(((value) << 0) & 0x000000ff)

/*
 * Field : TSECSNS
 *
 * Timestamp Egress Correction, sub-nanoseconds.
 *
 * This field contains the sub-nanoseconds part of the egress path correction value
 * as defined by the "Egress Correction" expression.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_LSB	8
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_MSB	15
/* The width in bits of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_WIDTH	8
/* The mask used to set the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field
 * value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_SET_MSK	0x0000ff00
/* The mask used to clear the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field
 * value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_CLR_MSK	0xffff00ff
/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_RESET	0x0
/* Extracts the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS field value from a register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS register field value suitable for
 * setting the register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS_SET(value)                            \
	(((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_LSB	    16
/* The Most Significant Bit (MSB) position of the
 * CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_MSB	    31
/* The width in bits of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_WIDTH   16
/* The mask used to set the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_SET_MSK 0xffff0000
/* The mask used to clear the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field value. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_CLR_MSK 0x0000ffff
/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register
 * field. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_RESET   0x0
/* Extracts the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 field value from a
 * register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_GET(value)                     \
	(((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16 register field value
 * suitable for setting the register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16_SET(value)                     \
	(((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND.
 */
struct CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_s {
	const volatile uint32_t
		Reserved_7_0 : 8; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_7_0 */
	volatile uint32_t TSECSNS : 8; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_TSECSNS */
	const volatile uint32_t Reserved_31_16 : 16; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESERVED_31_16
						      */
};

/* The typedef declaration for register CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND. */
typedef struct CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_s
	CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND register. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_RESET 0x00000000
/* The byte offset of the CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND register from the beginning
 * of the component. */
#define CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_OFST  0xd64

/*
 * Register : MAC_PPS_Control
 *
 * The PPS Control register is present only when the Timestamp feature is selected
 * and External Timestamp is not enabled.
 *
 * Bits[30:24] of this register are valid only when four Flexible PPS outputs are
 * selected. Bits[22:16] are valid only when three or more Flexible PPS outputs are
 * selected. Bits[14:8] are valid only when two or more Flexible PPS outputs are
 * selected. Bits[6:4] are valid only when Flexible PPS feature is selected.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [3:0]   | RW     | 0x0   | CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0
 *  [4]     | RW     | 0x0   | CORE_MAC_PPS_CONTROL_PPSEN0
 *  [6:5]   | RW     | 0x0   | CORE_MAC_PPS_CONTROL_TRGTMODSEL0
 *  [7]     | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_7
 *  [10:8]  | RW     | 0x0   | CORE_MAC_PPS_CONTROL_PPSCMD1
 *  [12:11] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_12_11
 *  [14:13] | RW     | 0x0   | CORE_MAC_PPS_CONTROL_TRGTMODSEL1
 *  [15]    | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_15
 *  [18:16] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2
 *  [20:19] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_20_19
 *  [22:21] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2
 *  [23]    | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_23
 *  [26:24] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3
 *  [28:27] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_28_27
 *  [30:29] | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3
 *  [31]    | R      | 0x0   | CORE_MAC_PPS_CONTROL_RESERVED_31
 *
 */
/*
 * Field : PPSCTRL0_PPSCMD0
 *
 * PPSCMD0: Flexible PPS Output (ptp_pps_o[0]) Control
 *
 * Programming these bits with a non-zero value instructs the MAC to initiate an
 * event. When the command is transferred or synchronized to the PTP clock domain,
 * these bits get cleared automatically. The software should ensure that these bits
 * are programmed only when they are all-zero. The following list describes the
 * values of PPSCMD0:
 *
 * * 0000: No Command
 *
 * * 0001: START Single Pulse
 *
 * This command generates a single pulse rising at the start point defined in
 * Target Time registers and of a duration defined in the PPS0 Width register.
 *
 * * 0010: START Pulse Train
 *
 * This command generates the train of pulses rising at the start point defined in
 * the Target Time registers and of a duration defined in the PPS0 Width register
 * and repeated at interval defined in the PPS Interval register. By default, the
 * PPS pulse train is free-running unless stopped by the "Stop Pulse train at time"
 * or "Stop Pulse Train immediately" commands.
 *
 * * 0011: Cancel START
 *
 * This command cancels the START Single Pulse and START Pulse Train commands if
 * the system time has not crossed the programmed start time.
 *
 * * 0100: STOP Pulse train at time
 *
 * This command stops the train of pulses initiated by the START Pulse Train
 * command (PPSCMD = 0010) after the time programmed in the Target Time registers
 * elapses.
 *
 * * 0101: STOP Pulse Train immediately
 *
 * This command immediately stops the train of pulses initiated by the START Pulse
 * Train command (PPSCMD = 0010).
 *
 * * 0110: Cancel STOP Pulse train
 *
 * This command cancels the STOP pulse train at time command if the programmed stop
 * time has not elapsed. The PPS pulse train becomes free-running on the successful
 * execution of this command.
 *
 * * 0111-1111: Reserved
 *
 * This field can be the PPS Output Frequency Control (PPSCTRL0) or the Flexible
 * PPS Output (ptp_pps_o[0]) Control (PPSCMD0)
 *
 * PPSCTRL0: PPS Output Frequency Control
 *
 * This field controls the frequency of the PPS0 output (ptp_pps_o[0]) signal. The
 * default value of PPSCTRL is 0000, and the PPS output is 1 pulse (of width
 * clk_ptp_ref_i) every second. For other values of PPSCTRL, the PPS output becomes
 * a generated clock of following frequencies:
 *
 * * 0001: The binary rollover is 2 Hz, and the digital rollover is 1 Hz.
 *
 * * 0010: The binary rollover is 4 Hz, and the digital rollover is 2 Hz.
 *
 * * 0011: The binary rollover is 8 Hz, and the digital rollover is 4 Hz.
 *
 * * 0100: The binary rollover is 16 Hz, and the digital rollover is 8 Hz.
 *
 * * ...
 *
 * * 1111: The binary rollover is 32.768 KHz and the digital rollover is 16.384
 *   KHz.
 *
 * In the binary rollover mode, the PPS output (ptp_pps_o) has a duty cycle of 50
 * percent with these frequencies.
 *
 * In the digital rollover mode, the PPS output frequency is an average number. The
 * actual clock is of different frequency that gets synchronized every second. For
 * example:
 *
 * When PPSCTRL = 0001, the PPS (1 Hz) has a low period of 537 ms and a high period
 * of 463 ms
 *
 * When PPSCTRL = 0010, the PPS (2 Hz) is a sequence of:
 *
 * * One clock of 50 percent duty cycle and 537 ms period
 *
 * * Second clock of 463 ms period (268 ms low and 195 ms high)
 *
 * When PPSCTRL = 0011, the PPS (4 Hz) is a sequence of:
 *
 * * Three clocks of 50 percent duty cycle and 268 ms period
 *
 * * Fourth clock of 195 ms period (134 ms low and 61 ms high)
 *
 * This behavior is because of the non-linear toggling of bits in the digital
 * rollover mode in the MAC_System_Time_Nanoseconds register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register
 * field. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register
 * field. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_MSB	 3
/* The width in bits of the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register field. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_WIDTH	 4
/* The mask used to set the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register field value. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_SET_MSK	 0x0000000f
/* The mask used to clear the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register field value. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_CLR_MSK	 0xfffffff0
/* The reset value of the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register field. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_RESET	 0x0
/* Extracts the CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 field value from a register. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : PPSEN0
 *
 * Flexible PPS Output Mode Enable.
 *
 * When this bit is set, Bits[3:0] function as PPSCMD. When this bit is reset,
 * Bits[3:0] function as PPSCTRL (Fixed PPS mode).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_PPSEN0 register field. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_LSB	       4
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_PPSEN0 register field. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_MSB	       4
/* The width in bits of the CORE_MAC_PPS_CONTROL_PPSEN0 register field. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_WIDTH      1
/* The mask used to set the CORE_MAC_PPS_CONTROL_PPSEN0 register field value. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_SET_MSK    0x00000010
/* The mask used to clear the CORE_MAC_PPS_CONTROL_PPSEN0 register field value. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_CLR_MSK    0xffffffef
/* The reset value of the CORE_MAC_PPS_CONTROL_PPSEN0 register field. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_RESET      0x0
/* Extracts the CORE_MAC_PPS_CONTROL_PPSEN0 field value from a register. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_PPS_CONTROL_PPSEN0 register field value suitable for setting the register. */
#define CORE_MAC_PPS_CONTROL_PPSEN0_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : TRGTMODSEL0
 *
 * Target Time Register Mode for PPS0 Output.
 *
 * This field indicates the Target Time registers mode for PPS0 output signal:
 *
 * * 00: Target Time registers are programmed only for generating the interrupt
 *   event. The Flexible PPS function must not be enabled in this mode, otherwise
 *   spurious transitions might be observed on the corresponding ptp_pps_o output
 *   port
 *
 * * 01: Reserved
 *
 * * 10: Target Time registers are programmed for generating the interrupt event
 *   and starting or stopping the PPS0 output signal generation.
 *
 * * 11: Target Time registers are programmed only for starting or stopping the
 *   PPS0 output signal generation. No interrupt is asserted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field.
 */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_LSB	    5
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field.
 */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_MSB	    6
/* The width in bits of the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_WIDTH	    2
/* The mask used to set the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field value. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_SET_MSK    0x00000060
/* The mask used to clear the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field value. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_CLR_MSK    0xffffff9f
/* The reset value of the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_RESET	    0x0
/* Extracts the CORE_MAC_PPS_CONTROL_TRGTMODSEL0 field value from a register. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_GET(value) (((value)&0x00000060) >> 5)
/* Produces a CORE_MAC_PPS_CONTROL_TRGTMODSEL0 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL0_SET(value) (((value) << 5) & 0x00000060)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_7 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_LSB	   7
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_7 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_MSB	   7
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_7 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_WIDTH	   1
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_7 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_SET_MSK	   0x00000080
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_7 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_CLR_MSK	   0xffffff7f
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_7 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_RESET	   0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_7 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_7 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PPSCMD1
 *
 * Flexible PPS1 Output Control.
 *
 * This field controls the flexible PPS1 output (ptp_pps_o[1]) signal.
 *
 * This field is similar to the PPSCMD0 field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_PPSCMD1 register field. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_LSB	8
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_PPSCMD1 register field. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_MSB	10
/* The width in bits of the CORE_MAC_PPS_CONTROL_PPSCMD1 register field. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_WIDTH	3
/* The mask used to set the CORE_MAC_PPS_CONTROL_PPSCMD1 register field value. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_SET_MSK	0x00000700
/* The mask used to clear the CORE_MAC_PPS_CONTROL_PPSCMD1 register field value. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_CLR_MSK	0xfffff8ff
/* The reset value of the CORE_MAC_PPS_CONTROL_PPSCMD1 register field. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_RESET	0x0
/* Extracts the CORE_MAC_PPS_CONTROL_PPSCMD1 field value from a register. */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_GET(value) (((value)&0x00000700) >> 8)
/* Produces a CORE_MAC_PPS_CONTROL_PPSCMD1 register field value suitable for setting the register.
 */
#define CORE_MAC_PPS_CONTROL_PPSCMD1_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : Reserved_12_11
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_12_11 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_LSB	       11
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_12_11 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_MSB	       12
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_12_11 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_WIDTH      2
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_12_11 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_SET_MSK    0x00001800
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_12_11 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_CLR_MSK    0xffffe7ff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_12_11 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_RESET      0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_12_11 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_GET(value) (((value)&0x00001800) >> 11)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_12_11 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_12_11_SET(value) (((value) << 11) & 0x00001800)

/*
 * Field : TRGTMODSEL1
 *
 * Target Time Register Mode for PPS1 Output.
 *
 * This field indicates the Target Time registers mode for PPS1 output signal.
 *
 * This field is similar to the TRGTMODSEL0 field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field.
 */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_LSB	    13
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field.
 */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_MSB	    14
/* The width in bits of the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_WIDTH	    2
/* The mask used to set the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field value. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_SET_MSK    0x00006000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field value. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_CLR_MSK    0xffff9fff
/* The reset value of the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_RESET	    0x0
/* Extracts the CORE_MAC_PPS_CONTROL_TRGTMODSEL1 field value from a register. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_GET(value) (((value)&0x00006000) >> 13)
/* Produces a CORE_MAC_PPS_CONTROL_TRGTMODSEL1 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_TRGTMODSEL1_SET(value) (((value) << 13) & 0x00006000)

/*
 * Field : Reserved_15
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_15 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_LSB	    15
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_15 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_MSB	    15
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_15 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_WIDTH	    1
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_15 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_SET_MSK    0x00008000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_15 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_CLR_MSK    0xffff7fff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_15 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_RESET	    0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_15 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_GET(value) (((value)&0x00008000) >> 15)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_15 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_15_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Reserved_PPSCMD2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_LSB	 16
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_MSB	 18
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_WIDTH	 3
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_SET_MSK	 0x00070000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_CLR_MSK	 0xfff8ffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_RESET	 0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_GET(value) (((value)&0x00070000) >> 16)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_20_19
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_20_19 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_LSB	       19
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_20_19 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_MSB	       20
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_20_19 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_WIDTH      2
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_20_19 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_SET_MSK    0x00180000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_20_19 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_CLR_MSK    0xffe7ffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_20_19 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_RESET      0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_20_19 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_GET(value) (((value)&0x00180000) >> 19)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_20_19 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_20_19_SET(value) (((value) << 19) & 0x00180000)

/*
 * Field : Reserved_TRGTMODSEL2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2
 * register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_LSB	     21
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_MSB	     22
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_WIDTH	     2
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_SET_MSK    0x00600000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_CLR_MSK    0xff9fffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_RESET	     0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_GET(value) (((value)&0x00600000) >> 21)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 register field value suitable for setting
 * the register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2_SET(value) (((value) << 21) & 0x00600000)

/*
 * Field : Reserved_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_23 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_LSB	    23
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_23 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_MSB	    23
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_23 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_WIDTH	    1
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_23 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_SET_MSK    0x00800000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_23 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_CLR_MSK    0xff7fffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_23 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_RESET	    0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_23 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_GET(value) (((value)&0x00800000) >> 23)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_23 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_23_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : Reserved_PPSCMD3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_LSB	 24
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_MSB	 26
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_WIDTH	 3
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_SET_MSK	 0x07000000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_CLR_MSK	 0xf8ffffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_RESET	 0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_GET(value) (((value)&0x07000000) >> 24)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : Reserved_28_27
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_28_27 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_LSB	       27
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_28_27 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_MSB	       28
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_28_27 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_WIDTH      2
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_28_27 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_SET_MSK    0x18000000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_28_27 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_CLR_MSK    0xe7ffffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_28_27 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_RESET      0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_28_27 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_GET(value) (((value)&0x18000000) >> 27)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_28_27 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_28_27_SET(value) (((value) << 27) & 0x18000000)

/*
 * Field : Reserved_TRGTMODSEL3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3
 * register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_LSB	     29
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 register
 * field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_MSB	     30
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_WIDTH	     2
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_SET_MSK    0x60000000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_CLR_MSK    0x9fffffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_RESET	     0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_GET(value) (((value)&0x60000000) >> 29)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 register field value suitable for setting
 * the register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3_SET(value) (((value) << 29) & 0x60000000)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_31 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_LSB	    31
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS_CONTROL_RESERVED_31 register field.
 */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_MSB	    31
/* The width in bits of the CORE_MAC_PPS_CONTROL_RESERVED_31 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_WIDTH	    1
/* The mask used to set the CORE_MAC_PPS_CONTROL_RESERVED_31 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_SET_MSK    0x80000000
/* The mask used to clear the CORE_MAC_PPS_CONTROL_RESERVED_31 register field value. */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_CLR_MSK    0x7fffffff
/* The reset value of the CORE_MAC_PPS_CONTROL_RESERVED_31 register field. */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_RESET	    0x0
/* Extracts the CORE_MAC_PPS_CONTROL_RESERVED_31 field value from a register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_PPS_CONTROL_RESERVED_31 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS_CONTROL_RESERVED_31_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS_CONTROL.
 */
struct CORE_MAC_PPS_CONTROL_s {
	volatile uint32_t PPSCTRL0_PPSCMD0 : 4;	      /* CORE_MAC_PPS_CONTROL_PPSCTRL0_PPSCMD0 */
	volatile uint32_t PPSEN0 : 1;		      /* CORE_MAC_PPS_CONTROL_PPSEN0 */
	volatile uint32_t TRGTMODSEL0 : 2;	      /* CORE_MAC_PPS_CONTROL_TRGTMODSEL0 */
	const volatile uint32_t Reserved_7 : 1;	      /* CORE_MAC_PPS_CONTROL_RESERVED_7 */
	volatile uint32_t PPSCMD1 : 3;		      /* CORE_MAC_PPS_CONTROL_PPSCMD1 */
	const volatile uint32_t Reserved_12_11 : 2;   /* CORE_MAC_PPS_CONTROL_RESERVED_12_11 */
	volatile uint32_t TRGTMODSEL1 : 2;	      /* CORE_MAC_PPS_CONTROL_TRGTMODSEL1 */
	const volatile uint32_t Reserved_15 : 1;      /* CORE_MAC_PPS_CONTROL_RESERVED_15 */
	const volatile uint32_t Reserved_PPSCMD2 : 3; /* CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD2 */
	const volatile uint32_t Reserved_20_19 : 2;   /* CORE_MAC_PPS_CONTROL_RESERVED_20_19 */
	const volatile uint32_t
		Reserved_TRGTMODSEL2 : 2;	 /* CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL2 */
	const volatile uint32_t Reserved_23 : 1; /* CORE_MAC_PPS_CONTROL_RESERVED_23 */
	const volatile uint32_t Reserved_PPSCMD3 : 3; /* CORE_MAC_PPS_CONTROL_RESERVED_PPSCMD3 */
	const volatile uint32_t Reserved_28_27 : 2;   /* CORE_MAC_PPS_CONTROL_RESERVED_28_27 */
	const volatile uint32_t
		Reserved_TRGTMODSEL3 : 2;	 /* CORE_MAC_PPS_CONTROL_RESERVED_TRGTMODSEL3 */
	const volatile uint32_t Reserved_31 : 1; /* CORE_MAC_PPS_CONTROL_RESERVED_31 */
};

/* The typedef declaration for register CORE_MAC_PPS_CONTROL. */
typedef struct CORE_MAC_PPS_CONTROL_s CORE_MAC_PPS_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS_CONTROL register. */
#define CORE_MAC_PPS_CONTROL_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS_CONTROL register from the beginning of the component. */
#define CORE_MAC_PPS_CONTROL_OFST  0xd70

/*
 * Register : MAC_PPS0_Target_Time_Seconds
 *
 * The PPS0 Target Time Seconds register, along with PPS0 Target Time Nanoseconds
 * register, is used to schedule an interrupt event [Bit 1 of MAC_Timestamp_Status]
 * when the system time exceeds the value programmed in these registers.
 *
 * This register is present only when more than one Flexible PPS output is selected
 * while configuring the controller.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0
 *
 */
/*
 * Field : TSTRH0
 *
 * PPS0 Target Time Seconds Register.
 *
 * This field stores the time in seconds. When the timestamp value matches or
 * exceeds both Target Timestamp registers, the MAC starts or stops the PPS signal
 * output and generates an interrupt (if enabled) based on Bits[6:5] of
 * MAC_PPS_Control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register
 * field. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register
 * field. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_MSB	    31
/* The width in bits of the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register field. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_WIDTH	    32
/* The mask used to set the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register field value. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register field value. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register field. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_RESET	    0x0
/* Extracts the CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 field value from a register. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS0_TARGET_TIME_SECONDS.
 */
struct CORE_MAC_PPS0_TARGET_TIME_SECONDS_s {
	volatile uint32_t TSTRH0 : 32; /* CORE_MAC_PPS0_TARGET_TIME_SECONDS_TSTRH0 */
};

/* The typedef declaration for register CORE_MAC_PPS0_TARGET_TIME_SECONDS. */
typedef struct CORE_MAC_PPS0_TARGET_TIME_SECONDS_s CORE_MAC_PPS0_TARGET_TIME_SECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS0_TARGET_TIME_SECONDS register. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS0_TARGET_TIME_SECONDS register from the beginning of the
 * component. */
#define CORE_MAC_PPS0_TARGET_TIME_SECONDS_OFST	0xd80

/*
 * Register : MAC_PPS0_Target_Time_Nanoseconds
 *
 * The PPS0 Target Time Nanoseconds register is present only when more than one
 * Flexible PPS output is selected.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [30:0] | RW     | 0x0   | CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0
 *  [31]   | RW     | 0x0   | CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0
 *
 */
/*
 * Field : TTSL0
 *
 * Target Time Low for PPS0 Register.
 *
 * This register stores the time in (signed) nanoseconds. When the value of the
 * timestamp matches the value in both Target Timestamp registers, the MAC starts
 * or stops the PPS signal output and generates an interrupt (if enabled) based on
 * the TRGTMODSEL0 field (Bits [6:5]) in MAC_PPS_Control.
 *
 * When the TSCTRLSSR bit is set in the MAC_Timestamp_Control register, this value
 * should not exceed 0x3B9A_C9FF. The actual start or stop time of the PPS signal
 * output might have an error margin up to one unit of sub-second increment value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0
 * register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0
 * register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_MSB	       30
/* The width in bits of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_WIDTH      31
/* The mask used to set the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 register field value. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_SET_MSK    0x7fffffff
/* The mask used to clear the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 register field value. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_CLR_MSK    0x80000000
/* The reset value of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_RESET      0x0
/* Extracts the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 field value from a register. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_GET(value) (((value)&0x7fffffff) >> 0)
/* Produces a CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 register field value suitable for setting
 * the register. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0_SET(value) (((value) << 0) & 0x7fffffff)

/*
 * Field : TRGTBUSY0
 *
 * PPS0 Target Time Register Busy.
 *
 * The MAC sets this bit when the PPSCMD0 field in the MAC_PPS_Control register is
 * programmed to 010 or 011. Programming the PPSCMD0 field to 010 or 011 instructs
 * the MAC to synchronize the Target Time registers to the PTP clock domain.
 *
 * The MAC clears this bit after synchronizing the Target Time registers to the PTP
 * clock domain The application must not update the Target Time registers when this
 * bit is read as 1. Otherwise, the synchronization of the previous programmed time
 * gets corrupted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0
 * register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0
 * register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_MSB	   31
/* The width in bits of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_WIDTH	   1
/* The mask used to set the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 register field value. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 register field value.
 */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 register field. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_RESET	   0x0
/* Extracts the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 field value from a register. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 register field value suitable for
 * setting the register. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS.
 */
struct CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_s {
	volatile uint32_t TTSL0 : 31;	 /* CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TTSL0 */
	volatile uint32_t TRGTBUSY0 : 1; /* CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_TRGTBUSY0 */
};

/* The typedef declaration for register CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS. */
typedef struct CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_s CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS register. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS register from the beginning of the
 * component. */
#define CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_OFST  0xd84

/*
 * Register : MAC_PPS0_Interval
 *
 * The PPS0 Interval register contains the number of units of sub-second increment
 * value between the rising edges of PPS0 signal output (ptp_pps_o[0]).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_PPS0_INTERVAL_PPSINT0
 *
 */
/*
 * Field : PPSINT0
 *
 * PPS0 Output Signal Interval.
 *
 * These bits store the interval between the rising edges of PPS0 signal output.
 * The interval is stored in terms of number of units of sub-second increment
 * value.
 *
 * You need to program one value less than the required interval. For example, if
 * the PTP reference clock is 50 MHz (period of 20 ns), and desired interval
 * between the rising edges of PPS0 signal output is 100 ns (that is, five units of
 * sub-second increment value), you should program value 4 (5 - 1) in this
 * register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS0_INTERVAL_PPSINT0 register field. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS0_INTERVAL_PPSINT0 register field. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_MSB	  31
/* The width in bits of the CORE_MAC_PPS0_INTERVAL_PPSINT0 register field. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_WIDTH	  32
/* The mask used to set the CORE_MAC_PPS0_INTERVAL_PPSINT0 register field value. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_MAC_PPS0_INTERVAL_PPSINT0 register field value. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_CLR_MSK	  0x00000000
/* The reset value of the CORE_MAC_PPS0_INTERVAL_PPSINT0 register field. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_RESET	  0x0
/* Extracts the CORE_MAC_PPS0_INTERVAL_PPSINT0 field value from a register. */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_PPS0_INTERVAL_PPSINT0 register field value suitable for setting the register.
 */
#define CORE_MAC_PPS0_INTERVAL_PPSINT0_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS0_INTERVAL.
 */
struct CORE_MAC_PPS0_INTERVAL_s {
	volatile uint32_t PPSINT0 : 32; /* CORE_MAC_PPS0_INTERVAL_PPSINT0 */
};

/* The typedef declaration for register CORE_MAC_PPS0_INTERVAL. */
typedef struct CORE_MAC_PPS0_INTERVAL_s CORE_MAC_PPS0_INTERVAL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS0_INTERVAL register. */
#define CORE_MAC_PPS0_INTERVAL_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS0_INTERVAL register from the beginning of the component. */
#define CORE_MAC_PPS0_INTERVAL_OFST  0xd88

/*
 * Register : MAC_PPS0_Width
 *
 * The PPS0 Width register contains the number of units of sub-second increment
 * value between the rising and corresponding falling edges of PPS0 signal output
 * (ptp_pps_o[0]).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_PPS0_WIDTH_PPSWIDTH0
 *
 */
/*
 * Field : PPSWIDTH0
 *
 * PPS0 Output Signal Width.
 *
 * These bits store the width between the rising edge and corresponding falling
 * edge of PPS0 signal output. The width is stored in terms of number of units of
 * sub-second increment value.
 *
 * You need to program one value less than the required interval. For example, if
 * PTP reference clock is 50 MHz (period of 20 ns), and width between the rising
 * and corresponding falling edges of PPS0 signal output is 80 ns (that is, four
 * units of sub-second increment value), you should program value 3 (4 - 1) in this
 * register.
 *
 * Note:  The value programmed in this register must be lesser than the value
 * programmed in MAC_PPS0_Interval.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_MSB	 31
/* The width in bits of the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_WIDTH	 32
/* The mask used to set the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field value. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field value. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_RESET	 0x0
/* Extracts the CORE_MAC_PPS0_WIDTH_PPSWIDTH0 field value from a register. */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_PPS0_WIDTH_PPSWIDTH0 register field value suitable for setting the register.
 */
#define CORE_MAC_PPS0_WIDTH_PPSWIDTH0_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS0_WIDTH.
 */
struct CORE_MAC_PPS0_WIDTH_s {
	volatile uint32_t PPSWIDTH0 : 32; /* CORE_MAC_PPS0_WIDTH_PPSWIDTH0 */
};

/* The typedef declaration for register CORE_MAC_PPS0_WIDTH. */
typedef struct CORE_MAC_PPS0_WIDTH_s CORE_MAC_PPS0_WIDTH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS0_WIDTH register. */
#define CORE_MAC_PPS0_WIDTH_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS0_WIDTH register from the beginning of the component. */
#define CORE_MAC_PPS0_WIDTH_OFST  0xd8c

/*
 * Register : MAC_PPS1_Target_Time_Seconds
 *
 * The PPS1 Target Time Seconds register, along with PPS1 Target Time Nanoseconds
 * register, is used to schedule an interrupt event [Bit 1 of MAC_Timestamp_Status]
 * when the system time exceeds the value programmed in these registers.
 *
 * This register is present only when more than one Flexible PPS output is selected
 * while configuring the controller.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1
 *
 */
/*
 * Field : TSTRH1
 *
 * PPS1 Target Time Seconds.
 *
 * This field stores the time in seconds. When the timestamp value matches or
 * exceeds both Target Timestamp registers, the MAC starts or stops the PPS signal
 * output and generates an interrupt (if enabled) based on Bits[14:13] of
 * MAC_PPS_Control register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register
 * field. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_LSB	    0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register
 * field. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_MSB	    31
/* The width in bits of the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register field. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_WIDTH	    32
/* The mask used to set the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register field value. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register field value. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register field. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_RESET	    0x0
/* Extracts the CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 field value from a register. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 register field value suitable for setting the
 * register. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS1_TARGET_TIME_SECONDS.
 */
struct CORE_MAC_PPS1_TARGET_TIME_SECONDS_s {
	volatile uint32_t TSTRH1 : 32; /* CORE_MAC_PPS1_TARGET_TIME_SECONDS_TSTRH1 */
};

/* The typedef declaration for register CORE_MAC_PPS1_TARGET_TIME_SECONDS. */
typedef struct CORE_MAC_PPS1_TARGET_TIME_SECONDS_s CORE_MAC_PPS1_TARGET_TIME_SECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS1_TARGET_TIME_SECONDS register. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS1_TARGET_TIME_SECONDS register from the beginning of the
 * component. */
#define CORE_MAC_PPS1_TARGET_TIME_SECONDS_OFST	0xd90

/*
 * Register : MAC_PPS1_Target_Time_Nanoseconds
 *
 * This register is present only when more than one Flexible PPS output is selected
 * while configuring the controller.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------------
 *  [30:0] | RW     | 0x0   | CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1
 *  [31]   | RW     | 0x0   | CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1
 *
 */
/*
 * Field : TTSL1
 *
 * Target Time Low for PPS1 Register.
 *
 * This register stores the time in (signed) nanoseconds. When the value of the
 * timestamp matches the both Target Timestamp registers, then based on the
 * TRGTMODSEL1 field in the MAC_PPS_Control register, the MAC starts or stops the
 * PPS signal output and generates an interrupt (if enabled).
 *
 * This value should not exceed 0x3B9A_C9FF when the TSCTRLSSR field is set in the
 * MAC_Timestamp_Control register. The actual start or stop time of the PPS signal
 * output might have an error margin up to one unit of sub-second increment value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1
 * register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1
 * register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_MSB	       30
/* The width in bits of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_WIDTH      31
/* The mask used to set the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 register field value. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_SET_MSK    0x7fffffff
/* The mask used to clear the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 register field value. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_CLR_MSK    0x80000000
/* The reset value of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_RESET      0x0
/* Extracts the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 field value from a register. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_GET(value) (((value)&0x7fffffff) >> 0)
/* Produces a CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 register field value suitable for setting
 * the register. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1_SET(value) (((value) << 0) & 0x7fffffff)

/*
 * Field : TRGTBUSY1
 *
 * PPS1 Target Time Register Busy.
 *
 * The MAC sets this bit when the PPSCMD1 field in MAC_PPS_Control register is
 * programmed to 010 or 011. Programming the PPSCMD1 field to 010 or 011 instructs
 * the MAC to synchronize the Target Time registers to the PTP clock domain.
 *
 * The MAC clears this bit after synchronizing the Target Time registers to the PTP
 * clock domain The application must not update the Target Time registers when this
 * bit is read as 1. Otherwise, the synchronization of the previous programmed time
 * gets corrupted.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1
 * register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_LSB	   31
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1
 * register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_MSB	   31
/* The width in bits of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_WIDTH	   1
/* The mask used to set the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 register field value. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_SET_MSK	   0x80000000
/* The mask used to clear the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 register field value.
 */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_CLR_MSK	   0x7fffffff
/* The reset value of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 register field. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_RESET	   0x0
/* Extracts the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 field value from a register. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_GET(value) (((value)&0x80000000) >> 31)
/* Produces a CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 register field value suitable for
 * setting the register. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS.
 */
struct CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_s {
	volatile uint32_t TTSL1 : 31;	 /* CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TTSL1 */
	volatile uint32_t TRGTBUSY1 : 1; /* CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_TRGTBUSY1 */
};

/* The typedef declaration for register CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS. */
typedef struct CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_s CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS register. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS register from the beginning of the
 * component. */
#define CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_OFST  0xd94

/*
 * Register : MAC_PPS1_Interval
 *
 * The PPS1 Interval register contains the number of units of sub-second increment
 * value between the rising edges of PPS1 signal output (ptp_pps_o[1]).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_PPS1_INTERVAL_PPSINT1
 *
 */
/*
 * Field : PPSINT1
 *
 * PPS1 Output Signal Interval.
 *
 * These bits store the interval between the rising edges of PPS1 signal output.
 * The interval is stored in terms of number of units of sub-second increment
 * value.
 *
 * You need to program one value less than the required interval. For example, if
 * the PTP reference clock is 50 MHz (period of 20 ns), and desired interval
 * between the rising edges of PPS1 signal output is 100 ns (that is, five units of
 * sub-second increment value), you should program value 4 (5 - 1) in this
 * register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS1_INTERVAL_PPSINT1 register field. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_LSB	  0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS1_INTERVAL_PPSINT1 register field. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_MSB	  31
/* The width in bits of the CORE_MAC_PPS1_INTERVAL_PPSINT1 register field. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_WIDTH	  32
/* The mask used to set the CORE_MAC_PPS1_INTERVAL_PPSINT1 register field value. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_SET_MSK	  0xffffffff
/* The mask used to clear the CORE_MAC_PPS1_INTERVAL_PPSINT1 register field value. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_CLR_MSK	  0x00000000
/* The reset value of the CORE_MAC_PPS1_INTERVAL_PPSINT1 register field. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_RESET	  0x0
/* Extracts the CORE_MAC_PPS1_INTERVAL_PPSINT1 field value from a register. */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_PPS1_INTERVAL_PPSINT1 register field value suitable for setting the register.
 */
#define CORE_MAC_PPS1_INTERVAL_PPSINT1_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS1_INTERVAL.
 */
struct CORE_MAC_PPS1_INTERVAL_s {
	volatile uint32_t PPSINT1 : 32; /* CORE_MAC_PPS1_INTERVAL_PPSINT1 */
};

/* The typedef declaration for register CORE_MAC_PPS1_INTERVAL. */
typedef struct CORE_MAC_PPS1_INTERVAL_s CORE_MAC_PPS1_INTERVAL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS1_INTERVAL register. */
#define CORE_MAC_PPS1_INTERVAL_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS1_INTERVAL register from the beginning of the component. */
#define CORE_MAC_PPS1_INTERVAL_OFST  0xd98

/*
 * Register : MAC_PPS1_Width
 *
 * The PPS1 Width register contains the number of units of sub-second increment
 * value between the rising and corresponding falling edges of PPS1 signal output
 * (ptp_pps_o[1]).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_PPS1_WIDTH_PPSWIDTH1
 *
 */
/*
 * Field : PPSWIDTH1
 *
 * PPS1 Output Signal Width.
 *
 * These bits store the width between the rising edge and corresponding falling
 * edge of PPS1 signal output. The width is stored in terms of number of units of
 * sub-second increment value.
 *
 * You need to program one value less than the required interval. For example, if
 * PTP reference clock is 50 MHz (period of 20 ns), and width between the rising
 * and corresponding falling edges of PPS1 signal output is 80 ns (that is, four
 * units of sub-second increment value), you should program value 3 (4 - 1) in this
 * register.
 *
 * Note:  The value programmed in this register must be lesser than the value
 * programmed in MAC_PPS1_Interval.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_LSB	 0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_MSB	 31
/* The width in bits of the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_WIDTH	 32
/* The mask used to set the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field value. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_SET_MSK	 0xffffffff
/* The mask used to clear the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field value. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_CLR_MSK	 0x00000000
/* The reset value of the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_RESET	 0x0
/* Extracts the CORE_MAC_PPS1_WIDTH_PPSWIDTH1 field value from a register. */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_PPS1_WIDTH_PPSWIDTH1 register field value suitable for setting the register.
 */
#define CORE_MAC_PPS1_WIDTH_PPSWIDTH1_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PPS1_WIDTH.
 */
struct CORE_MAC_PPS1_WIDTH_s {
	volatile uint32_t PPSWIDTH1 : 32; /* CORE_MAC_PPS1_WIDTH_PPSWIDTH1 */
};

/* The typedef declaration for register CORE_MAC_PPS1_WIDTH. */
typedef struct CORE_MAC_PPS1_WIDTH_s CORE_MAC_PPS1_WIDTH_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PPS1_WIDTH register. */
#define CORE_MAC_PPS1_WIDTH_RESET 0x00000000
/* The byte offset of the CORE_MAC_PPS1_WIDTH register from the beginning of the component. */
#define CORE_MAC_PPS1_WIDTH_OFST  0xd9c

/*
 * Register : MAC_PTO_Control
 *
 * This register controls the PTP Offload Engine operation. This register is
 * available only when the Enable PTP Timestamp Offload feature is selected.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------
 *  [0]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_PTOEN
 *  [1]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_ASYNCEN
 *  [2]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_APDREQEN
 *  [3]     | R      | 0x0   | CORE_MAC_PTO_CONTROL_RESERVED_3
 *  [4]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_ASYNCTRIG
 *  [5]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_APDREQTRIG
 *  [6]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_DRRDIS
 *  [7]     | RW     | 0x0   | CORE_MAC_PTO_CONTROL_PDRDIS
 *  [15:8]  | RW     | 0x0   | CORE_MAC_PTO_CONTROL_DN
 *  [31:16] | R      | 0x0   | CORE_MAC_PTO_CONTROL_RESERVED_31_16
 *
 */
/*
 * Field : PTOEN
 *
 * PTP Offload Enable.
 *
 * When this bit is set, the PTP Offload feature is enabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_PTOEN register field. */
#define CORE_MAC_PTO_CONTROL_PTOEN_LSB	      0
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_PTOEN register field. */
#define CORE_MAC_PTO_CONTROL_PTOEN_MSB	      0
/* The width in bits of the CORE_MAC_PTO_CONTROL_PTOEN register field. */
#define CORE_MAC_PTO_CONTROL_PTOEN_WIDTH      1
/* The mask used to set the CORE_MAC_PTO_CONTROL_PTOEN register field value. */
#define CORE_MAC_PTO_CONTROL_PTOEN_SET_MSK    0x00000001
/* The mask used to clear the CORE_MAC_PTO_CONTROL_PTOEN register field value. */
#define CORE_MAC_PTO_CONTROL_PTOEN_CLR_MSK    0xfffffffe
/* The reset value of the CORE_MAC_PTO_CONTROL_PTOEN register field. */
#define CORE_MAC_PTO_CONTROL_PTOEN_RESET      0x0
/* Extracts the CORE_MAC_PTO_CONTROL_PTOEN field value from a register. */
#define CORE_MAC_PTO_CONTROL_PTOEN_GET(value) (((value)&0x00000001) >> 0)
/* Produces a CORE_MAC_PTO_CONTROL_PTOEN register field value suitable for setting the register. */
#define CORE_MAC_PTO_CONTROL_PTOEN_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : ASYNCEN
 *
 * Automatic PTP SYNC message Enable.
 *
 * When this bit is set, PTP SYNC message is generated periodically based on
 * interval programmed or trigger from application, when the MAC is programmed to
 * be in Clock Master mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_ASYNCEN register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_LSB	1
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_ASYNCEN register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_MSB	1
/* The width in bits of the CORE_MAC_PTO_CONTROL_ASYNCEN register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_WIDTH	1
/* The mask used to set the CORE_MAC_PTO_CONTROL_ASYNCEN register field value. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_SET_MSK	0x00000002
/* The mask used to clear the CORE_MAC_PTO_CONTROL_ASYNCEN register field value. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_CLR_MSK	0xfffffffd
/* The reset value of the CORE_MAC_PTO_CONTROL_ASYNCEN register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_RESET	0x0
/* Extracts the CORE_MAC_PTO_CONTROL_ASYNCEN field value from a register. */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_GET(value) (((value)&0x00000002) >> 1)
/* Produces a CORE_MAC_PTO_CONTROL_ASYNCEN register field value suitable for setting the register.
 */
#define CORE_MAC_PTO_CONTROL_ASYNCEN_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : APDREQEN
 *
 * Automatic PTP Pdelay_Req message Enable.
 *
 * When this bit is set, PTP Pdelay_Req message is generated periodically based on
 * interval programmed or trigger from application, when the MAC is programmed to
 * be in Peer-to-Peer Transparent mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_APDREQEN register field. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_LSB	 2
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_APDREQEN register field. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_MSB	 2
/* The width in bits of the CORE_MAC_PTO_CONTROL_APDREQEN register field. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_WIDTH	 1
/* The mask used to set the CORE_MAC_PTO_CONTROL_APDREQEN register field value. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_SET_MSK	 0x00000004
/* The mask used to clear the CORE_MAC_PTO_CONTROL_APDREQEN register field value. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_CLR_MSK	 0xfffffffb
/* The reset value of the CORE_MAC_PTO_CONTROL_APDREQEN register field. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_RESET	 0x0
/* Extracts the CORE_MAC_PTO_CONTROL_APDREQEN field value from a register. */
#define CORE_MAC_PTO_CONTROL_APDREQEN_GET(value) (((value)&0x00000004) >> 2)
/* Produces a CORE_MAC_PTO_CONTROL_APDREQEN register field value suitable for setting the register.
 */
#define CORE_MAC_PTO_CONTROL_APDREQEN_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_RESERVED_3 register field.
 */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_LSB	   3
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_RESERVED_3 register field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_MSB	   3
/* The width in bits of the CORE_MAC_PTO_CONTROL_RESERVED_3 register field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_WIDTH	   1
/* The mask used to set the CORE_MAC_PTO_CONTROL_RESERVED_3 register field value. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_SET_MSK	   0x00000008
/* The mask used to clear the CORE_MAC_PTO_CONTROL_RESERVED_3 register field value. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_CLR_MSK	   0xfffffff7
/* The reset value of the CORE_MAC_PTO_CONTROL_RESERVED_3 register field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_RESET	   0x0
/* Extracts the CORE_MAC_PTO_CONTROL_RESERVED_3 field value from a register. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_GET(value) (((value)&0x00000008) >> 3)
/* Produces a CORE_MAC_PTO_CONTROL_RESERVED_3 register field value suitable for setting the
 * register. */
#define CORE_MAC_PTO_CONTROL_RESERVED_3_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : ASYNCTRIG
 *
 * Automatic PTP SYNC message Trigger.
 *
 * When this bit is set, one PTP SYNC message is transmitted. This bit is
 * automatically cleared after the PTP SYNC message is transmitted. The application
 * should set the ASYNCEN bit for this operation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_ASYNCTRIG register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_LSB	  4
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_ASYNCTRIG register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_MSB	  4
/* The width in bits of the CORE_MAC_PTO_CONTROL_ASYNCTRIG register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_WIDTH	  1
/* The mask used to set the CORE_MAC_PTO_CONTROL_ASYNCTRIG register field value. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_SET_MSK	  0x00000010
/* The mask used to clear the CORE_MAC_PTO_CONTROL_ASYNCTRIG register field value. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_CLR_MSK	  0xffffffef
/* The reset value of the CORE_MAC_PTO_CONTROL_ASYNCTRIG register field. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_RESET	  0x0
/* Extracts the CORE_MAC_PTO_CONTROL_ASYNCTRIG field value from a register. */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_GET(value) (((value)&0x00000010) >> 4)
/* Produces a CORE_MAC_PTO_CONTROL_ASYNCTRIG register field value suitable for setting the register.
 */
#define CORE_MAC_PTO_CONTROL_ASYNCTRIG_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : APDREQTRIG
 *
 * Automatic PTP Pdelay_Req message Trigger.
 *
 * When this bit is set, one PTP Pdelay_Req message is transmitted. This bit is
 * automatically cleared after the PTP Pdelay_Req message is transmitted. The
 * application should set the APDREQEN bit for this operation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_APDREQTRIG register field.
 */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_LSB	   5
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_APDREQTRIG register field. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_MSB	   5
/* The width in bits of the CORE_MAC_PTO_CONTROL_APDREQTRIG register field. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_WIDTH	   1
/* The mask used to set the CORE_MAC_PTO_CONTROL_APDREQTRIG register field value. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_SET_MSK	   0x00000020
/* The mask used to clear the CORE_MAC_PTO_CONTROL_APDREQTRIG register field value. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_CLR_MSK	   0xffffffdf
/* The reset value of the CORE_MAC_PTO_CONTROL_APDREQTRIG register field. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_RESET	   0x0
/* Extracts the CORE_MAC_PTO_CONTROL_APDREQTRIG field value from a register. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_GET(value) (((value)&0x00000020) >> 5)
/* Produces a CORE_MAC_PTO_CONTROL_APDREQTRIG register field value suitable for setting the
 * register. */
#define CORE_MAC_PTO_CONTROL_APDREQTRIG_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : DRRDIS
 *
 * Disable PTO Delay Request/Response response generation.
 *
 * When this bit is set, the Delay Request and Delay response is not generated for
 * received SYNC and Delay request packet respectively, as required by the
 * programmed mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_DRRDIS register field. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_LSB	       6
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_DRRDIS register field. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_MSB	       6
/* The width in bits of the CORE_MAC_PTO_CONTROL_DRRDIS register field. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_WIDTH      1
/* The mask used to set the CORE_MAC_PTO_CONTROL_DRRDIS register field value. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_SET_MSK    0x00000040
/* The mask used to clear the CORE_MAC_PTO_CONTROL_DRRDIS register field value. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_CLR_MSK    0xffffffbf
/* The reset value of the CORE_MAC_PTO_CONTROL_DRRDIS register field. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_RESET      0x0
/* Extracts the CORE_MAC_PTO_CONTROL_DRRDIS field value from a register. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a CORE_MAC_PTO_CONTROL_DRRDIS register field value suitable for setting the register. */
#define CORE_MAC_PTO_CONTROL_DRRDIS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : PDRDIS
 *
 * Disable Peer Delay Response response generation
 *
 * When this bit is set, the Peer Delay Response (Pdelay_Resp) response is not
 * generated for received Peer Delay Request (Pdelay_Req) request packet, as
 * required by the programmed mode.
 *
 * Note:  Setting this bit to 1 affects the normal PTP Offload operation and the
 * time synchronization. So, this bit must be set only if there is problem with
 * Pdelay_Resp generation in hardware and/or Pdelay_Resp generation is handled by
 * Software.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_PDRDIS register field. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_LSB	       7
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_PDRDIS register field. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_MSB	       7
/* The width in bits of the CORE_MAC_PTO_CONTROL_PDRDIS register field. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_WIDTH      1
/* The mask used to set the CORE_MAC_PTO_CONTROL_PDRDIS register field value. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_SET_MSK    0x00000080
/* The mask used to clear the CORE_MAC_PTO_CONTROL_PDRDIS register field value. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_CLR_MSK    0xffffff7f
/* The reset value of the CORE_MAC_PTO_CONTROL_PDRDIS register field. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_RESET      0x0
/* Extracts the CORE_MAC_PTO_CONTROL_PDRDIS field value from a register. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a CORE_MAC_PTO_CONTROL_PDRDIS register field value suitable for setting the register. */
#define CORE_MAC_PTO_CONTROL_PDRDIS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : DN
 *
 * Domain Number.
 *
 * This field indicates the domainNumber in which the PTP node operates.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_DN register field. */
#define CORE_MAC_PTO_CONTROL_DN_LSB	   8
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_DN register field. */
#define CORE_MAC_PTO_CONTROL_DN_MSB	   15
/* The width in bits of the CORE_MAC_PTO_CONTROL_DN register field. */
#define CORE_MAC_PTO_CONTROL_DN_WIDTH	   8
/* The mask used to set the CORE_MAC_PTO_CONTROL_DN register field value. */
#define CORE_MAC_PTO_CONTROL_DN_SET_MSK	   0x0000ff00
/* The mask used to clear the CORE_MAC_PTO_CONTROL_DN register field value. */
#define CORE_MAC_PTO_CONTROL_DN_CLR_MSK	   0xffff00ff
/* The reset value of the CORE_MAC_PTO_CONTROL_DN register field. */
#define CORE_MAC_PTO_CONTROL_DN_RESET	   0x0
/* Extracts the CORE_MAC_PTO_CONTROL_DN field value from a register. */
#define CORE_MAC_PTO_CONTROL_DN_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a CORE_MAC_PTO_CONTROL_DN register field value suitable for setting the register. */
#define CORE_MAC_PTO_CONTROL_DN_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_PTO_CONTROL_RESERVED_31_16 register
 * field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_LSB	       16
/* The Most Significant Bit (MSB) position of the CORE_MAC_PTO_CONTROL_RESERVED_31_16 register
 * field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_MSB	       31
/* The width in bits of the CORE_MAC_PTO_CONTROL_RESERVED_31_16 register field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_WIDTH      16
/* The mask used to set the CORE_MAC_PTO_CONTROL_RESERVED_31_16 register field value. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_SET_MSK    0xffff0000
/* The mask used to clear the CORE_MAC_PTO_CONTROL_RESERVED_31_16 register field value. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_CLR_MSK    0x0000ffff
/* The reset value of the CORE_MAC_PTO_CONTROL_RESERVED_31_16 register field. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_RESET      0x0
/* Extracts the CORE_MAC_PTO_CONTROL_RESERVED_31_16 field value from a register. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_PTO_CONTROL_RESERVED_31_16 register field value suitable for setting the
 * register. */
#define CORE_MAC_PTO_CONTROL_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_PTO_CONTROL.
 */
struct CORE_MAC_PTO_CONTROL_s {
	volatile uint32_t PTOEN : 1;		     /* CORE_MAC_PTO_CONTROL_PTOEN */
	volatile uint32_t ASYNCEN : 1;		     /* CORE_MAC_PTO_CONTROL_ASYNCEN */
	volatile uint32_t APDREQEN : 1;		     /* CORE_MAC_PTO_CONTROL_APDREQEN */
	const volatile uint32_t Reserved_3 : 1;	     /* CORE_MAC_PTO_CONTROL_RESERVED_3 */
	volatile uint32_t ASYNCTRIG : 1;	     /* CORE_MAC_PTO_CONTROL_ASYNCTRIG */
	volatile uint32_t APDREQTRIG : 1;	     /* CORE_MAC_PTO_CONTROL_APDREQTRIG */
	volatile uint32_t DRRDIS : 1;		     /* CORE_MAC_PTO_CONTROL_DRRDIS */
	volatile uint32_t PDRDIS : 1;		     /* CORE_MAC_PTO_CONTROL_PDRDIS */
	volatile uint32_t DN : 8;		     /* CORE_MAC_PTO_CONTROL_DN */
	const volatile uint32_t Reserved_31_16 : 16; /* CORE_MAC_PTO_CONTROL_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_PTO_CONTROL. */
typedef struct CORE_MAC_PTO_CONTROL_s CORE_MAC_PTO_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_PTO_CONTROL register. */
#define CORE_MAC_PTO_CONTROL_RESET 0x00000000
/* The byte offset of the CORE_MAC_PTO_CONTROL register from the beginning of the component. */
#define CORE_MAC_PTO_CONTROL_OFST  0xdc0

/*
 * Register : MAC_Source_Port_Identity0
 *
 * This register along with MAC_Source_Port_Identity1 and MAC_Source_Port_Identity2
 * contains the 80-bit Source Port Identity of the PTP node. These registers are
 * available only when the Enable PTP Timestamp Offload feature is selected.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0
 *
 */
/*
 * Field : SPI0
 *
 * Source Port Identity 0.
 *
 * This field indicates bits [31:0] of sourcePortIdentity of PTP node.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register
 * field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register
 * field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_MSB	       31
/* The width in bits of the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_WIDTH      32
/* The mask used to set the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_RESET      0x0
/* Extracts the CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 field value from a register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 register field value suitable for setting the
 * register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SOURCE_PORT_IDENTITY0.
 */
struct CORE_MAC_SOURCE_PORT_IDENTITY0_s {
	volatile uint32_t SPI0 : 32; /* CORE_MAC_SOURCE_PORT_IDENTITY0_SPI0 */
};

/* The typedef declaration for register CORE_MAC_SOURCE_PORT_IDENTITY0. */
typedef struct CORE_MAC_SOURCE_PORT_IDENTITY0_s CORE_MAC_SOURCE_PORT_IDENTITY0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY0 register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_RESET 0x00000000
/* The byte offset of the CORE_MAC_SOURCE_PORT_IDENTITY0 register from the beginning of the
 * component. */
#define CORE_MAC_SOURCE_PORT_IDENTITY0_OFST  0xdc4

/*
 * Register : MAC_Source_Port_Identity1
 *
 * This register along with MAC_Source_Port_Identity0 and MAC_Source_Port_Identity2
 * contains the 80-bit Source Port Identity of the PTP node. These registers are
 * available only when the Enable PTP Timestamp Offload feature is selected.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [31:0] | RW     | 0x0   | CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1
 *
 */
/*
 * Field : SPI1
 *
 * Source Port Identity 1.
 *
 * This field indicates bits [63:32] of sourcePortIdentity of PTP node.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register
 * field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register
 * field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_MSB	       31
/* The width in bits of the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_WIDTH      32
/* The mask used to set the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_SET_MSK    0xffffffff
/* The mask used to clear the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_CLR_MSK    0x00000000
/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_RESET      0x0
/* Extracts the CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 field value from a register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 register field value suitable for setting the
 * register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SOURCE_PORT_IDENTITY1.
 */
struct CORE_MAC_SOURCE_PORT_IDENTITY1_s {
	volatile uint32_t SPI1 : 32; /* CORE_MAC_SOURCE_PORT_IDENTITY1_SPI1 */
};

/* The typedef declaration for register CORE_MAC_SOURCE_PORT_IDENTITY1. */
typedef struct CORE_MAC_SOURCE_PORT_IDENTITY1_s CORE_MAC_SOURCE_PORT_IDENTITY1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY1 register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_RESET 0x00000000
/* The byte offset of the CORE_MAC_SOURCE_PORT_IDENTITY1 register from the beginning of the
 * component. */
#define CORE_MAC_SOURCE_PORT_IDENTITY1_OFST  0xdc8

/*
 * Register : MAC_Source_Port_Identity2
 *
 * This register along with MAC_Source_Port_Identity0 and MAC_Source_Port_Identity1
 * contains the 80-bit Source Port Identity of the PTP node. These registers are
 * available only when the Enable PTP Timestamp Offload feature is selected.
 *
 * Note: The values written in MAC_Source_Port_Identity0, MAC_Source_Port_Identity1
 * and MAC_Source_Port_Identity2 registers is updated in the PTP Offload logic when
 * MAC_Source_Port_Identity2 register is written, so MAC_Source_Port_Identity2
 * register must be written after MAC_Source_Port_Identity0 and
 * MAC_Source_Port_Identity1 registers are written.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2
 *  [31:16] | R      | 0x0   | CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16
 *
 */
/*
 * Field : SPI2
 *
 * Source Port Identity 2.
 *
 * This field indicates bits [79:64] of sourcePortIdentity of PTP node.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register
 * field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_LSB	       0
/* The Most Significant Bit (MSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register
 * field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_MSB	       15
/* The width in bits of the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_WIDTH      16
/* The mask used to set the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_SET_MSK    0x0000ffff
/* The mask used to clear the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_CLR_MSK    0xffff0000
/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_RESET      0x0
/* Extracts the CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 field value from a register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 register field value suitable for setting the
 * register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16
 * register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_LSB	 16
/* The Most Significant Bit (MSB) position of the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16
 * register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_MSB	 31
/* The width in bits of the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_WIDTH	 16
/* The mask used to set the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_SET_MSK	 0xffff0000
/* The mask used to clear the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 register field value. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_CLR_MSK	 0x0000ffff
/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 register field. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_RESET	 0x0
/* Extracts the CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 field value from a register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 register field value suitable for
 * setting the register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_SOURCE_PORT_IDENTITY2.
 */
struct CORE_MAC_SOURCE_PORT_IDENTITY2_s {
	volatile uint32_t SPI2 : 16; /* CORE_MAC_SOURCE_PORT_IDENTITY2_SPI2 */
	const volatile uint32_t
		Reserved_31_16 : 16; /* CORE_MAC_SOURCE_PORT_IDENTITY2_RESERVED_31_16 */
};

/* The typedef declaration for register CORE_MAC_SOURCE_PORT_IDENTITY2. */
typedef struct CORE_MAC_SOURCE_PORT_IDENTITY2_s CORE_MAC_SOURCE_PORT_IDENTITY2_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_SOURCE_PORT_IDENTITY2 register. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_RESET 0x00000000
/* The byte offset of the CORE_MAC_SOURCE_PORT_IDENTITY2 register from the beginning of the
 * component. */
#define CORE_MAC_SOURCE_PORT_IDENTITY2_OFST  0xdcc

/*
 * Register : MAC_Log_Message_Interval
 *
 * This register contains the periodic intervals for automatic PTP packet
 * generation. This register is available only when the Enable PTP Timestamp
 * Offload feature is selected.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------
 *  [7:0]   | RW     | 0x0   | CORE_MAC_LOG_MESSAGE_INTERVAL_LSI
 *  [10:8]  | RW     | 0x0   | CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR
 *  [23:11] | R      | 0x0   | CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11
 *  [31:24] | RW     | 0x0   | CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI
 *
 */
/*
 * Field : LSI
 *
 * Log Sync Interval.
 *
 * This field indicates the periodicity of the automatically generated SYNC message
 * when the PTP node is Master. Allowed values are -15 to 15. Negative value must
 * be represented in twos complement form. For example, if the required value is
 * -1, the value programmed must be 0xFF.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field.
 */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_LSB	     0
/* The Most Significant Bit (MSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field.
 */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_MSB	     7
/* The width in bits of the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_WIDTH	     8
/* The mask used to set the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_SET_MSK    0x000000ff
/* The mask used to clear the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_CLR_MSK    0xffffff00
/* The reset value of the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_RESET	     0x0
/* Extracts the CORE_MAC_LOG_MESSAGE_INTERVAL_LSI field value from a register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a CORE_MAC_LOG_MESSAGE_INTERVAL_LSI register field value suitable for setting the
 * register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LSI_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : DRSYNCR
 *
 * Delay_Req to SYNC Ratio.
 *
 * In Slave mode, this is used to control the frequency of Delay_Req messages
 * transmitted.
 *
 * * 'x0: DelayReq generated for every received SYNC messages
 *
 * * 'x1: DelayReq generated for every alternate reception of SYNC messages
 *
 * * 'x2: DelayReq generated for every 4 SYNC messages
 *
 * * 'x3: DelayReq generated for every 8 SYNC messages
 *
 * * 'x4: DelayReq generated for every 16 SYNC messages
 *
 * * 'x5: DelayReq generated for every 32 SYNC messages
 *
 * * 'x6-'x7: Reserved
 *
 * The master sends this information (logMinDelayReqInterval) in the DelayResp PTP
 * messages to the slave. The DWC_xgmac Receiver processes this value from received
 * DelayResp messages and updates this field accordingly. In Slave mode, the host
 * must not write/update this register unless it wants to override the received
 * value. In Master mode, the sum of this field and logSyncInterval (LSI) field is
 * provided in the logMinDelayReqInterval field of the generated multicast
 * Delay_Resp PTP message.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register
 * field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_LSB	 8
/* The Most Significant Bit (MSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register
 * field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_MSB	 10
/* The width in bits of the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_WIDTH	 3
/* The mask used to set the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_SET_MSK	 0x00000700
/* The mask used to clear the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_CLR_MSK	 0xfffff8ff
/* The reset value of the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_RESET	 0x0
/* Extracts the CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR field value from a register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_GET(value) (((value)&0x00000700) >> 8)
/* Produces a CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR register field value suitable for setting the
 * register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : Reserved_23_11
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11
 * register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_LSB	11
/* The Most Significant Bit (MSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11
 * register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_MSB	23
/* The width in bits of the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_WIDTH	13
/* The mask used to set the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_SET_MSK	0x00fff800
/* The mask used to clear the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_CLR_MSK	0xff0007ff
/* The reset value of the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_RESET	0x0
/* Extracts the CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 field value from a register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_GET(value) (((value)&0x00fff800) >> 11)
/* Produces a CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 register field value suitable for setting
 * the register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11_SET(value) (((value) << 11) & 0x00fff800)

/*
 * Field : LMPDRI
 *
 * Log Min Pdelay_Req Interval.
 *
 * This field indicates logMinPdelayReqInterval of PTP node. This is used to
 * schedule the periodic Pdelay request packet transmission. Allowed values are -15
 * to 15. Negative value must be represented in twos complement form. For example,
 * if the required value is -1, the value programmed must be 0xFF.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register
 * field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_LSB	24
/* The Most Significant Bit (MSB) position of the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register
 * field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_MSB	31
/* The width in bits of the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_WIDTH	8
/* The mask used to set the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_SET_MSK	0xff000000
/* The mask used to clear the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register field value. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_CLR_MSK	0x00ffffff
/* The reset value of the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register field. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_RESET	0x0
/* Extracts the CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI field value from a register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_GET(value) (((value)&0xff000000) >> 24)
/* Produces a CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI register field value suitable for setting the
 * register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register CORE_MAC_LOG_MESSAGE_INTERVAL.
 */
struct CORE_MAC_LOG_MESSAGE_INTERVAL_s {
	volatile uint32_t LSI : 8;     /* CORE_MAC_LOG_MESSAGE_INTERVAL_LSI */
	volatile uint32_t DRSYNCR : 3; /* CORE_MAC_LOG_MESSAGE_INTERVAL_DRSYNCR */
	const volatile uint32_t
		Reserved_23_11 : 13;  /* CORE_MAC_LOG_MESSAGE_INTERVAL_RESERVED_23_11 */
	volatile uint32_t LMPDRI : 8; /* CORE_MAC_LOG_MESSAGE_INTERVAL_LMPDRI */
};

/* The typedef declaration for register CORE_MAC_LOG_MESSAGE_INTERVAL. */
typedef struct CORE_MAC_LOG_MESSAGE_INTERVAL_s CORE_MAC_LOG_MESSAGE_INTERVAL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the CORE_MAC_LOG_MESSAGE_INTERVAL register. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_RESET 0x00000000
/* The byte offset of the CORE_MAC_LOG_MESSAGE_INTERVAL register from the beginning of the
 * component. */
#define CORE_MAC_LOG_MESSAGE_INTERVAL_OFST  0xdd0

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register group CORE.
 */
struct CORE_s {
	volatile CORE_MAC_TX_CONFIGURATION_t MAC_Tx_Configuration; /* CORE_MAC_TX_CONFIGURATION */
	volatile CORE_MAC_RX_CONFIGURATION_t MAC_Rx_Configuration; /* CORE_MAC_RX_CONFIGURATION */
	volatile CORE_MAC_PACKET_FILTER_t MAC_Packet_Filter;	   /* CORE_MAC_PACKET_FILTER */
	volatile CORE_MAC_WD_JB_TIMEOUT_t MAC_WD_JB_Timeout;	   /* CORE_MAC_WD_JB_TIMEOUT */
	volatile CORE_MAC_HASH_TABLE_REG0_t MAC_Hash_Table_Reg0;   /* CORE_MAC_HASH_TABLE_REG0 */
	volatile CORE_MAC_HASH_TABLE_REG1_t MAC_Hash_Table_Reg1;   /* CORE_MAC_HASH_TABLE_REG1 */
	volatile uint32_t _pad_0x18_0x4f[14];			   /* *UNDEFINED* */
	volatile CORE_MAC_VLAN_TAG_CTRL_t MAC_VLAN_Tag_Ctrl;	   /* CORE_MAC_VLAN_TAG_CTRL */
	volatile CORE_MAC_VLAN_TAG_DATA_t MAC_VLAN_Tag_Data;	   /* CORE_MAC_VLAN_TAG_DATA */
	volatile CORE_MAC_VLAN_HASH_TABLE_t MAC_VLAN_Hash_Table;   /* CORE_MAC_VLAN_HASH_TABLE */
	volatile uint32_t _pad_0x5c_0x5f;			   /* *UNDEFINED* */
	volatile CORE_MAC_VLAN_INCL_t MAC_VLAN_Incl;		   /* CORE_MAC_VLAN_INCL */
	volatile CORE_MAC_INNER_VLAN_INCL_t MAC_Inner_VLAN_Incl;   /* CORE_MAC_INNER_VLAN_INCL */
	volatile uint32_t _pad_0x68_0x6b;			   /* *UNDEFINED* */
	volatile CORE_MAC_RX_ETH_TYPE_MATCH_t
		MAC_Rx_Eth_Type_Match;				   /* CORE_MAC_RX_ETH_TYPE_MATCH */
	volatile CORE_MAC_Q0_TX_FLOW_CTRL_t MAC_Q0_Tx_Flow_Ctrl;   /* CORE_MAC_Q0_TX_FLOW_CTRL */
	volatile CORE_MAC_Q1_TX_FLOW_CTRL_t MAC_Q1_Tx_Flow_Ctrl;   /* CORE_MAC_Q1_TX_FLOW_CTRL */
	volatile CORE_MAC_Q2_TX_FLOW_CTRL_t MAC_Q2_Tx_Flow_Ctrl;   /* CORE_MAC_Q2_TX_FLOW_CTRL */
	volatile CORE_MAC_Q3_TX_FLOW_CTRL_t MAC_Q3_Tx_Flow_Ctrl;   /* CORE_MAC_Q3_TX_FLOW_CTRL */
	volatile CORE_MAC_Q4_TX_FLOW_CTRL_t MAC_Q4_Tx_Flow_Ctrl;   /* CORE_MAC_Q4_TX_FLOW_CTRL */
	volatile CORE_MAC_Q5_TX_FLOW_CTRL_t MAC_Q5_Tx_Flow_Ctrl;   /* CORE_MAC_Q5_TX_FLOW_CTRL */
	volatile CORE_MAC_Q6_TX_FLOW_CTRL_t MAC_Q6_Tx_Flow_Ctrl;   /* CORE_MAC_Q6_TX_FLOW_CTRL */
	volatile CORE_MAC_Q7_TX_FLOW_CTRL_t MAC_Q7_Tx_Flow_Ctrl;   /* CORE_MAC_Q7_TX_FLOW_CTRL */
	volatile CORE_MAC_RX_FLOW_CTRL_t MAC_Rx_Flow_Ctrl;	   /* CORE_MAC_RX_FLOW_CTRL */
	volatile CORE_MAC_RXQ_CTRL4_t MAC_RxQ_Ctrl4;		   /* CORE_MAC_RXQ_CTRL4 */
	volatile CORE_MAC_RXQ_CTRL5_t MAC_RxQ_Ctrl5;		   /* CORE_MAC_RXQ_CTRL5 */
	volatile uint32_t _pad_0x9c_0x9f;			   /* *UNDEFINED* */
	volatile CORE_MAC_RXQ_CTRL0_t MAC_RxQ_Ctrl0;		   /* CORE_MAC_RXQ_CTRL0 */
	volatile CORE_MAC_RXQ_CTRL1_t MAC_RxQ_Ctrl1;		   /* CORE_MAC_RXQ_CTRL1 */
	volatile CORE_MAC_RXQ_CTRL2_t MAC_RxQ_Ctrl2;		   /* CORE_MAC_RXQ_CTRL2 */
	volatile CORE_MAC_RXQ_CTRL3_t MAC_RxQ_Ctrl3;		   /* CORE_MAC_RXQ_CTRL3 */
	volatile CORE_MAC_INTERRUPT_STATUS_t MAC_Interrupt_Status; /* CORE_MAC_INTERRUPT_STATUS */
	volatile CORE_MAC_INTERRUPT_ENABLE_t MAC_Interrupt_Enable; /* CORE_MAC_INTERRUPT_ENABLE */
	volatile CORE_MAC_RX_TX_STATUS_t MAC_Rx_Tx_Status;	   /* CORE_MAC_RX_TX_STATUS */
	volatile uint32_t _pad_0xbc_0xcf[5];			   /* *UNDEFINED* */
	volatile CORE_MAC_LPI_CONTROL_STATUS_t
		MAC_LPI_Control_Status; /* CORE_MAC_LPI_CONTROL_STATUS */
	volatile CORE_MAC_LPI_TIMERS_CONTROL_t
		MAC_LPI_Timers_Control; /* CORE_MAC_LPI_TIMERS_CONTROL */
	volatile CORE_MAC_LPI_AUTO_ENTRY_TIMER_t
		MAC_LPI_Auto_Entry_Timer;			 /* CORE_MAC_LPI_AUTO_ENTRY_TIMER */
	volatile CORE_MAC_1US_TIC_COUNTER_t MAC_1US_Tic_Counter; /* CORE_MAC_1US_TIC_COUNTER */
	volatile uint32_t _pad_0xe0_0x10f[12];			 /* *UNDEFINED* */
	volatile CORE_MAC_VERSION_t MAC_Version;		 /* CORE_MAC_VERSION */
	volatile CORE_MAC_DEBUG_t MAC_Debug;			 /* CORE_MAC_DEBUG */
	volatile uint32_t _pad_0x118_0x11b;			 /* *UNDEFINED* */
	volatile CORE_MAC_HW_FEATURE0_t MAC_HW_Feature0;	 /* CORE_MAC_HW_FEATURE0 */
	volatile CORE_MAC_HW_FEATURE1_t MAC_HW_Feature1;	 /* CORE_MAC_HW_FEATURE1 */
	volatile CORE_MAC_HW_FEATURE2_t MAC_HW_Feature2;	 /* CORE_MAC_HW_FEATURE2 */
	volatile CORE_MAC_HW_FEATURE3_t MAC_HW_Feature3;	 /* CORE_MAC_HW_FEATURE3 */
	volatile CORE_MAC_HW_FEATURE4_t MAC_HW_Feature4;	 /* CORE_MAC_HW_FEATURE4 */
	volatile uint32_t _pad_0x130_0x13f[4];			 /* *UNDEFINED* */
	volatile CORE_MAC_EXTENDED_CONFIGURATION_t
		MAC_Extended_Configuration;	   /* CORE_MAC_EXTENDED_CONFIGURATION */
	volatile CORE_MAC_EXT_CFG1_t MAC_Ext_Cfg1; /* CORE_MAC_EXT_CFG1 */
	volatile uint32_t _pad_0x148_0x1ff[46];	   /* *UNDEFINED* */
	volatile CORE_MDIO_SINGLE_COMMAND_ADDRESS_t
		MDIO_Single_Command_Address; /* CORE_MDIO_SINGLE_COMMAND_ADDRESS */
	volatile CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_t
		MDIO_Single_Command_Control_Data; /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA */
	volatile CORE_MDIO_CONTINUOUS_WRITE_ADDRESS_t
		MDIO_Continuous_Write_Address; /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS */
	volatile CORE_MDIO_CONTINUOUS_WRITE_DATA_t
		MDIO_Continuous_Write_Data; /* CORE_MDIO_CONTINUOUS_WRITE_DATA */
	volatile CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE_t
		MDIO_Continuous_Scan_Port_Enable; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE */
	volatile CORE_MDIO_INTERRUPT_STATUS_t
		MDIO_Interrupt_Status; /* CORE_MDIO_INTERRUPT_STATUS */
	volatile CORE_MDIO_INTERRUPT_ENABLE_t
		MDIO_Interrupt_Enable; /* CORE_MDIO_INTERRUPT_ENABLE */
	volatile CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS_t
		MDIO_Port_Connect_Disconnect_Status; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS */
	volatile CORE_MDIO_CLAUSE_22_PORT_t MDIO_Clause_22_Port; /* CORE_MDIO_CLAUSE_22_PORT */
	volatile CORE_MDIO_PORT_NX4_INDIRECT_CONTROL_t
		MDIO_Port_Nx4_Indirect_Control; /* CORE_MDIO_PORT_NX4_INDIRECT_CONTROL */
	volatile uint32_t _pad_0x228_0x22f[2];	/* *UNDEFINED* */
	volatile CORE_MDIO_PORTNX4P0_DEVICE_IN_USE_t
		MDIO_PortNx4P0_Device_In_Use; /* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE */
	volatile CORE_MDIO_PORTNX4P0_LINK_STATUS_t
		MDIO_PortNx4P0_Link_Status; /* CORE_MDIO_PORTNX4P0_LINK_STATUS */
	volatile CORE_MDIO_PORTNX4P0_ALIVE_STATUS_t
		MDIO_PortNx4P0_Alive_Status; /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS */
	volatile uint32_t _pad_0x23c_0x23f;  /* *UNDEFINED* */
	volatile CORE_MDIO_PORTNX4P1_DEVICE_IN_USE_t
		MDIO_PortNx4P1_Device_In_Use; /* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE */
	volatile CORE_MDIO_PORTNX4P1_LINK_STATUS_t
		MDIO_PortNx4P1_Link_Status; /* CORE_MDIO_PORTNX4P1_LINK_STATUS */
	volatile CORE_MDIO_PORTNX4P1_ALIVE_STATUS_t
		MDIO_PortNx4P1_Alive_Status; /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS */
	volatile uint32_t _pad_0x24c_0x24f;  /* *UNDEFINED* */
	volatile CORE_MDIO_PORTNX4P2_DEVICE_IN_USE_t
		MDIO_PortNx4P2_Device_In_Use; /* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE */
	volatile CORE_MDIO_PORTNX4P2_LINK_STATUS_t
		MDIO_PortNx4P2_Link_Status; /* CORE_MDIO_PORTNX4P2_LINK_STATUS */
	volatile CORE_MDIO_PORTNX4P2_ALIVE_STATUS_t
		MDIO_PortNx4P2_Alive_Status; /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS */
	volatile uint32_t _pad_0x25c_0x25f;  /* *UNDEFINED* */
	volatile CORE_MDIO_PORTNX4P3_DEVICE_IN_USE_t
		MDIO_PortNx4P3_Device_In_Use; /* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE */
	volatile CORE_MDIO_PORTNX4P3_LINK_STATUS_t
		MDIO_PortNx4P3_Link_Status; /* CORE_MDIO_PORTNX4P3_LINK_STATUS */
	volatile CORE_MDIO_PORTNX4P3_ALIVE_STATUS_t
		MDIO_PortNx4P3_Alive_Status;		     /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS */
	volatile uint32_t _pad_0x26c_0x27f[5];		     /* *UNDEFINED* */
	volatile CORE_MAC_FPE_CTRL_STS_t MAC_FPE_CTRL_STS;   /* CORE_MAC_FPE_CTRL_STS */
	volatile uint32_t _pad_0x284_0x28f[3];		     /* *UNDEFINED* */
	volatile CORE_MAC_CSR_SW_CTRL_t MAC_CSR_SW_Ctrl;     /* CORE_MAC_CSR_SW_CTRL */
	volatile uint32_t _pad_0x294_0x2ff[27];		     /* *UNDEFINED* */
	volatile CORE_MAC_ADDRESS0_HIGH_t MAC_Address0_High; /* CORE_MAC_ADDRESS0_HIGH */
	volatile CORE_MAC_ADDRESS0_LOW_t MAC_Address0_Low;   /* CORE_MAC_ADDRESS0_LOW */
	volatile CORE_MAC_ADDRESS1_HIGH_t MAC_Address1_High; /* CORE_MAC_ADDRESS1_HIGH */
	volatile CORE_MAC_ADDRESS1_LOW_t MAC_Address1_Low;   /* CORE_MAC_ADDRESS1_LOW */
	volatile CORE_MAC_ADDRESS2_HIGH_t MAC_Address2_High; /* CORE_MAC_ADDRESS2_HIGH */
	volatile CORE_MAC_ADDRESS2_LOW_t MAC_Address2_Low;   /* CORE_MAC_ADDRESS2_LOW */
	volatile CORE_MAC_ADDRESS3_HIGH_t MAC_Address3_High; /* CORE_MAC_ADDRESS3_HIGH */
	volatile CORE_MAC_ADDRESS3_LOW_t MAC_Address3_Low;   /* CORE_MAC_ADDRESS3_LOW */
	volatile CORE_MAC_ADDRESS4_HIGH_t MAC_Address4_High; /* CORE_MAC_ADDRESS4_HIGH */
	volatile CORE_MAC_ADDRESS4_LOW_t MAC_Address4_Low;   /* CORE_MAC_ADDRESS4_LOW */
	volatile CORE_MAC_ADDRESS5_HIGH_t MAC_Address5_High; /* CORE_MAC_ADDRESS5_HIGH */
	volatile CORE_MAC_ADDRESS5_LOW_t MAC_Address5_Low;   /* CORE_MAC_ADDRESS5_LOW */
	volatile CORE_MAC_ADDRESS6_HIGH_t MAC_Address6_High; /* CORE_MAC_ADDRESS6_HIGH */
	volatile CORE_MAC_ADDRESS6_LOW_t MAC_Address6_Low;   /* CORE_MAC_ADDRESS6_LOW */
	volatile CORE_MAC_ADDRESS7_HIGH_t MAC_Address7_High; /* CORE_MAC_ADDRESS7_HIGH */
	volatile CORE_MAC_ADDRESS7_LOW_t MAC_Address7_Low;   /* CORE_MAC_ADDRESS7_LOW */
	volatile CORE_MAC_ADDRESS8_HIGH_t MAC_Address8_High; /* CORE_MAC_ADDRESS8_HIGH */
	volatile CORE_MAC_ADDRESS8_LOW_t MAC_Address8_Low;   /* CORE_MAC_ADDRESS8_LOW */
	volatile CORE_MAC_ADDRESS9_HIGH_t MAC_Address9_High; /* CORE_MAC_ADDRESS9_HIGH */
	volatile CORE_MAC_ADDRESS9_LOW_t MAC_Address9_Low;   /* CORE_MAC_ADDRESS9_LOW */
	volatile CORE_MAC_ADDRESS10_HIGH_t MAC_Address10_High; /* CORE_MAC_ADDRESS10_HIGH */
	volatile CORE_MAC_ADDRESS10_LOW_t MAC_Address10_Low;   /* CORE_MAC_ADDRESS10_LOW */
	volatile CORE_MAC_ADDRESS11_HIGH_t MAC_Address11_High; /* CORE_MAC_ADDRESS11_HIGH */
	volatile CORE_MAC_ADDRESS11_LOW_t MAC_Address11_Low;   /* CORE_MAC_ADDRESS11_LOW */
	volatile CORE_MAC_ADDRESS12_HIGH_t MAC_Address12_High; /* CORE_MAC_ADDRESS12_HIGH */
	volatile CORE_MAC_ADDRESS12_LOW_t MAC_Address12_Low;   /* CORE_MAC_ADDRESS12_LOW */
	volatile CORE_MAC_ADDRESS13_HIGH_t MAC_Address13_High; /* CORE_MAC_ADDRESS13_HIGH */
	volatile CORE_MAC_ADDRESS13_LOW_t MAC_Address13_Low;   /* CORE_MAC_ADDRESS13_LOW */
	volatile CORE_MAC_ADDRESS14_HIGH_t MAC_Address14_High; /* CORE_MAC_ADDRESS14_HIGH */
	volatile CORE_MAC_ADDRESS14_LOW_t MAC_Address14_Low;   /* CORE_MAC_ADDRESS14_LOW */
	volatile CORE_MAC_ADDRESS15_HIGH_t MAC_Address15_High; /* CORE_MAC_ADDRESS15_HIGH */
	volatile CORE_MAC_ADDRESS15_LOW_t MAC_Address15_Low;   /* CORE_MAC_ADDRESS15_LOW */
	volatile CORE_MAC_ADDRESS16_HIGH_t MAC_Address16_High; /* CORE_MAC_ADDRESS16_HIGH */
	volatile CORE_MAC_ADDRESS16_LOW_t MAC_Address16_Low;   /* CORE_MAC_ADDRESS16_LOW */
	volatile CORE_MAC_ADDRESS17_HIGH_t MAC_Address17_High; /* CORE_MAC_ADDRESS17_HIGH */
	volatile CORE_MAC_ADDRESS17_LOW_t MAC_Address17_Low;   /* CORE_MAC_ADDRESS17_LOW */
	volatile CORE_MAC_ADDRESS18_HIGH_t MAC_Address18_High; /* CORE_MAC_ADDRESS18_HIGH */
	volatile CORE_MAC_ADDRESS18_LOW_t MAC_Address18_Low;   /* CORE_MAC_ADDRESS18_LOW */
	volatile CORE_MAC_ADDRESS19_HIGH_t MAC_Address19_High; /* CORE_MAC_ADDRESS19_HIGH */
	volatile CORE_MAC_ADDRESS19_LOW_t MAC_Address19_Low;   /* CORE_MAC_ADDRESS19_LOW */
	volatile CORE_MAC_ADDRESS20_HIGH_t MAC_Address20_High; /* CORE_MAC_ADDRESS20_HIGH */
	volatile CORE_MAC_ADDRESS20_LOW_t MAC_Address20_Low;   /* CORE_MAC_ADDRESS20_LOW */
	volatile CORE_MAC_ADDRESS21_HIGH_t MAC_Address21_High; /* CORE_MAC_ADDRESS21_HIGH */
	volatile CORE_MAC_ADDRESS21_LOW_t MAC_Address21_Low;   /* CORE_MAC_ADDRESS21_LOW */
	volatile CORE_MAC_ADDRESS22_HIGH_t MAC_Address22_High; /* CORE_MAC_ADDRESS22_HIGH */
	volatile CORE_MAC_ADDRESS22_LOW_t MAC_Address22_Low;   /* CORE_MAC_ADDRESS22_LOW */
	volatile CORE_MAC_ADDRESS23_HIGH_t MAC_Address23_High; /* CORE_MAC_ADDRESS23_HIGH */
	volatile CORE_MAC_ADDRESS23_LOW_t MAC_Address23_Low;   /* CORE_MAC_ADDRESS23_LOW */
	volatile CORE_MAC_ADDRESS24_HIGH_t MAC_Address24_High; /* CORE_MAC_ADDRESS24_HIGH */
	volatile CORE_MAC_ADDRESS24_LOW_t MAC_Address24_Low;   /* CORE_MAC_ADDRESS24_LOW */
	volatile CORE_MAC_ADDRESS25_HIGH_t MAC_Address25_High; /* CORE_MAC_ADDRESS25_HIGH */
	volatile CORE_MAC_ADDRESS25_LOW_t MAC_Address25_Low;   /* CORE_MAC_ADDRESS25_LOW */
	volatile CORE_MAC_ADDRESS26_HIGH_t MAC_Address26_High; /* CORE_MAC_ADDRESS26_HIGH */
	volatile CORE_MAC_ADDRESS26_LOW_t MAC_Address26_Low;   /* CORE_MAC_ADDRESS26_LOW */
	volatile CORE_MAC_ADDRESS27_HIGH_t MAC_Address27_High; /* CORE_MAC_ADDRESS27_HIGH */
	volatile CORE_MAC_ADDRESS27_LOW_t MAC_Address27_Low;   /* CORE_MAC_ADDRESS27_LOW */
	volatile CORE_MAC_ADDRESS28_HIGH_t MAC_Address28_High; /* CORE_MAC_ADDRESS28_HIGH */
	volatile CORE_MAC_ADDRESS28_LOW_t MAC_Address28_Low;   /* CORE_MAC_ADDRESS28_LOW */
	volatile CORE_MAC_ADDRESS29_HIGH_t MAC_Address29_High; /* CORE_MAC_ADDRESS29_HIGH */
	volatile CORE_MAC_ADDRESS29_LOW_t MAC_Address29_Low;   /* CORE_MAC_ADDRESS29_LOW */
	volatile CORE_MAC_ADDRESS30_HIGH_t MAC_Address30_High; /* CORE_MAC_ADDRESS30_HIGH */
	volatile CORE_MAC_ADDRESS30_LOW_t MAC_Address30_Low;   /* CORE_MAC_ADDRESS30_LOW */
	volatile CORE_MAC_ADDRESS31_HIGH_t MAC_Address31_High; /* CORE_MAC_ADDRESS31_HIGH */
	volatile CORE_MAC_ADDRESS31_LOW_t MAC_Address31_Low;   /* CORE_MAC_ADDRESS31_LOW */
	volatile uint32_t _pad_0x400_0x6ff[192];	       /* *UNDEFINED* */
	volatile CORE_MAC_INDIR_ACCESS_CTRL_t
		MAC_Indir_Access_Ctrl; /* CORE_MAC_INDIR_ACCESS_CTRL */
	volatile CORE_MAC_INDIR_ACCESS_DATA_t
		MAC_Indir_Access_Data;			   /* CORE_MAC_INDIR_ACCESS_DATA */
	volatile uint32_t _pad_0x708_0x7ff[62];		   /* *UNDEFINED* */
	volatile CORE_MMC_CONTROL_t MMC_Control;	   /* CORE_MMC_CONTROL */
	volatile CORE_MMC_RX_INTERRUPT_t MMC_Rx_Interrupt; /* CORE_MMC_RX_INTERRUPT */
	volatile CORE_MMC_TX_INTERRUPT_t MMC_Tx_Interrupt; /* CORE_MMC_TX_INTERRUPT */
	volatile CORE_MMC_RECEIVE_INTERRUPT_ENABLE_t
		MMC_Receive_Interrupt_Enable; /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE */
	volatile CORE_MMC_TRANSMIT_INTERRUPT_ENABLE_t
		MMC_Transmit_Interrupt_Enable; /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE */
	volatile CORE_TX_OCTET_COUNT_GOOD_BAD_LOW_t
		Tx_Octet_Count_Good_Bad_Low; /* CORE_TX_OCTET_COUNT_GOOD_BAD_LOW */
	volatile CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH_t
		Tx_Octet_Count_Good_Bad_High; /* CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH */
	volatile CORE_TX_PACKET_COUNT_GOOD_BAD_LOW_t
		Tx_Packet_Count_Good_Bad_Low; /* CORE_TX_PACKET_COUNT_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x820_0x823;   /* *UNDEFINED* */
	volatile CORE_TX_BROADCAST_PACKETS_GOOD_LOW_t
		Tx_Broadcast_Packets_Good_Low; /* CORE_TX_BROADCAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x828_0x82b;    /* *UNDEFINED* */
	volatile CORE_TX_MULTICAST_PACKETS_GOOD_LOW_t
		Tx_Multicast_Packets_Good_Low; /* CORE_TX_MULTICAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x830_0x833;    /* *UNDEFINED* */
	volatile CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW_t
		Tx_64Octets_Packets_Good_Bad_Low; /* CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x838_0x83b;	  /* *UNDEFINED* */
	volatile CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_t
		Tx_65To127Octets_Packets_Good_Bad_Low; /* CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW
							*/
	volatile uint32_t _pad_0x840_0x843;	       /* *UNDEFINED* */
	volatile CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_t
		Tx_128To255Octets_Packets_Good_Bad_Low; /* CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW
							 */
	volatile uint32_t _pad_0x848_0x84b;		/* *UNDEFINED* */
	volatile CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_t
		Tx_256To511Octets_Packets_Good_Bad_Low; /* CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW
							 */
	volatile uint32_t _pad_0x850_0x853;		/* *UNDEFINED* */
	volatile CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_t
		Tx_512To1023Octets_Packets_Good_Bad_Low; /* CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW
							  */
	volatile uint32_t _pad_0x858_0x85b;		 /* *UNDEFINED* */
	volatile CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_t
		Tx_1024ToMaxOctets_Packets_Good_Bad_Low; /* CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW
							  */
	volatile uint32_t _pad_0x860_0x863;		 /* *UNDEFINED* */
	volatile CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW_t
		Tx_Unicast_Packets_Good_Bad_Low; /* CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x868_0x86b;	 /* *UNDEFINED* */
	volatile CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW_t
		Tx_Multicast_Packets_Good_Bad_Low; /* CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x870_0x873;	   /* *UNDEFINED* */
	volatile CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW_t
		Tx_Broadcast_Packets_Good_Bad_Low; /* CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x878_0x87b;	   /* *UNDEFINED* */
	volatile CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW_t
		Tx_Underflow_Error_Packets_Low; /* CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0x880_0x883;	/* *UNDEFINED* */
	volatile CORE_TX_OCTET_COUNT_GOOD_LOW_t
		Tx_Octet_Count_Good_Low; /* CORE_TX_OCTET_COUNT_GOOD_LOW */
	volatile CORE_TX_OCTET_COUNT_GOOD_HIGH_t
		Tx_Octet_Count_Good_High; /* CORE_TX_OCTET_COUNT_GOOD_HIGH */
	volatile CORE_TX_PACKET_COUNT_GOOD_LOW_t
		Tx_Packet_Count_Good_Low;   /* CORE_TX_PACKET_COUNT_GOOD_LOW */
	volatile uint32_t _pad_0x890_0x893; /* *UNDEFINED* */
	volatile CORE_TX_PAUSE_PACKETS_LOW_t Tx_Pause_Packets_Low; /* CORE_TX_PAUSE_PACKETS_LOW */
	volatile uint32_t _pad_0x898_0x89b;			   /* *UNDEFINED* */
	volatile CORE_TX_VLAN_PACKETS_GOOD_LOW_t
		Tx_VLAN_Packets_Good_Low;		   /* CORE_TX_VLAN_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x8a0_0x8a3;		   /* *UNDEFINED* */
	volatile CORE_TX_LPI_USEC_CNTR_t Tx_LPI_USEC_Cntr; /* CORE_TX_LPI_USEC_CNTR */
	volatile CORE_TX_LPI_TRAN_CNTR_t Tx_LPI_Tran_Cntr; /* CORE_TX_LPI_TRAN_CNTR */
	volatile uint32_t _pad_0x8ac_0x8ff[21];		   /* *UNDEFINED* */
	volatile CORE_RX_PACKET_COUNT_GOOD_BAD_LOW_t
		Rx_Packet_Count_Good_Bad_Low; /* CORE_RX_PACKET_COUNT_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x904_0x907;   /* *UNDEFINED* */
	volatile CORE_RX_OCTET_COUNT_GOOD_BAD_LOW_t
		Rx_Octet_Count_Good_Bad_Low; /* CORE_RX_OCTET_COUNT_GOOD_BAD_LOW */
	volatile CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH_t
		Rx_Octet_Count_Good_Bad_High; /* CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH */
	volatile CORE_RX_OCTET_COUNT_GOOD_LOW_t
		Rx_Octet_Count_Good_Low; /* CORE_RX_OCTET_COUNT_GOOD_LOW */
	volatile CORE_RX_OCTET_COUNT_GOOD_HIGH_t
		Rx_Octet_Count_Good_High; /* CORE_RX_OCTET_COUNT_GOOD_HIGH */
	volatile CORE_RX_BROADCAST_PACKETS_GOOD_LOW_t
		Rx_Broadcast_Packets_Good_Low; /* CORE_RX_BROADCAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x91c_0x91f;    /* *UNDEFINED* */
	volatile CORE_RX_MULTICAST_PACKETS_GOOD_LOW_t
		Rx_Multicast_Packets_Good_Low; /* CORE_RX_MULTICAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x924_0x927;    /* *UNDEFINED* */
	volatile CORE_RX_CRC_ERROR_PACKETS_LOW_t
		Rx_CRC_Error_Packets_Low;   /* CORE_RX_CRC_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0x92c_0x92f; /* *UNDEFINED* */
	volatile CORE_RX_RUNT_ERROR_PACKETS_t
		Rx_Runt_Error_Packets; /* CORE_RX_RUNT_ERROR_PACKETS */
	volatile CORE_RX_JABBER_ERROR_PACKETS_t
		Rx_Jabber_Error_Packets; /* CORE_RX_JABBER_ERROR_PACKETS */
	volatile CORE_RX_UNDERSIZE_PACKETS_GOOD_t
		Rx_Undersize_Packets_Good; /* CORE_RX_UNDERSIZE_PACKETS_GOOD */
	volatile CORE_RX_OVERSIZE_PACKETS_GOOD_t
		Rx_Oversize_Packets_Good; /* CORE_RX_OVERSIZE_PACKETS_GOOD */
	volatile CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW_t
		Rx_64Octets_Packets_Good_Bad_Low; /* CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x944_0x947;	  /* *UNDEFINED* */
	volatile CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW_t
		Rx_65To127Octets_Packets_Good_Bad_Low; /* CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW
							*/
	volatile uint32_t _pad_0x94c_0x94f;	       /* *UNDEFINED* */
	volatile CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW_t
		Rx_128To255Octets_Packets_Good_Bad_Low; /* CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW
							 */
	volatile uint32_t _pad_0x954_0x957;		/* *UNDEFINED* */
	volatile CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW_t
		Rx_256To511Octets_Packets_Good_Bad_Low; /* CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW
							 */
	volatile uint32_t _pad_0x95c_0x95f;		/* *UNDEFINED* */
	volatile CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW_t
		Rx_512To1023Octets_Packets_Good_Bad_Low; /* CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW
							  */
	volatile uint32_t _pad_0x964_0x967;		 /* *UNDEFINED* */
	volatile CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW_t
		Rx_1024ToMaxOctets_Packets_Good_Bad_Low; /* CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW
							  */
	volatile uint32_t _pad_0x96c_0x96f;		 /* *UNDEFINED* */
	volatile CORE_RX_UNICAST_PACKETS_GOOD_LOW_t
		Rx_Unicast_Packets_Good_Low; /* CORE_RX_UNICAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x974_0x977;  /* *UNDEFINED* */
	volatile CORE_RX_LENGTH_ERROR_PACKETS_LOW_t
		Rx_Length_Error_Packets_Low; /* CORE_RX_LENGTH_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0x97c_0x97f;  /* *UNDEFINED* */
	volatile CORE_RX_OUTOFRANGE_PACKETS_LOW_t
		Rx_OutofRange_Packets_Low;  /* CORE_RX_OUTOFRANGE_PACKETS_LOW */
	volatile uint32_t _pad_0x984_0x987; /* *UNDEFINED* */
	volatile CORE_RX_PAUSE_PACKETS_LOW_t Rx_Pause_Packets_Low; /* CORE_RX_PAUSE_PACKETS_LOW */
	volatile uint32_t _pad_0x98c_0x98f;			   /* *UNDEFINED* */
	volatile CORE_RX_FIFOOVERFLOW_PACKETS_LOW_t
		Rx_FIFOOverflow_Packets_Low; /* CORE_RX_FIFOOVERFLOW_PACKETS_LOW */
	volatile uint32_t _pad_0x994_0x997;  /* *UNDEFINED* */
	volatile CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW_t
		Rx_VLAN_Packets_Good_Bad_Low; /* CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x99c_0x99f;   /* *UNDEFINED* */
	volatile CORE_RX_WATCHDOG_ERROR_PACKETS_t
		Rx_Watchdog_Error_Packets;		   /* CORE_RX_WATCHDOG_ERROR_PACKETS */
	volatile CORE_RX_LPI_USEC_CNTR_t Rx_LPI_USEC_Cntr; /* CORE_RX_LPI_USEC_CNTR */
	volatile CORE_RX_LPI_TRAN_CNTR_t Rx_LPI_Tran_Cntr; /* CORE_RX_LPI_TRAN_CNTR */
	volatile CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW_t
		Rx_Discard_Packets_Good_Bad_Low; /* CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x9b0_0x9b3;	 /* *UNDEFINED* */
	volatile CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW_t
		Rx_Discard_Octets_Good_Bad_Low; /* CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW */
	volatile CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH_t
		Rx_Discard_Octets_Good_Bad_High; /* CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH */
	volatile CORE_RX_ALIGNMENT_ERROR_PACKETS_t
		Rx_Alignment_Error_Packets;	/* CORE_RX_ALIGNMENT_ERROR_PACKETS */
	volatile uint32_t _pad_0x9c0_0x9ff[16]; /* *UNDEFINED* */
	volatile CORE_MMC_FPE_TX_INTERRUPT_t MMC_FPE_Tx_Interrupt; /* CORE_MMC_FPE_TX_INTERRUPT */
	volatile CORE_MMC_FPE_TX_INTERRUPT_MASK_t
		MMC_FPE_Tx_Interrupt_Mask; /* CORE_MMC_FPE_TX_INTERRUPT_MASK */
	volatile CORE_MMC_TX_FPE_FRAGMENT_CNTR_t
		MMC_Tx_FPE_Fragment_Cntr; /* CORE_MMC_TX_FPE_FRAGMENT_CNTR */
	volatile CORE_MMC_TX_HOLD_REQ_CNTR_t MMC_Tx_Hold_Req_Cntr; /* CORE_MMC_TX_HOLD_REQ_CNTR */
	volatile uint32_t _pad_0xa10_0xa1f[4];			   /* *UNDEFINED* */
	volatile CORE_MMC_FPE_RX_INTERRUPT_t MMC_FPE_Rx_Interrupt; /* CORE_MMC_FPE_RX_INTERRUPT */
	volatile CORE_MMC_FPE_RX_INTERRUPT_MASK_t
		MMC_FPE_Rx_Interrupt_Mask; /* CORE_MMC_FPE_RX_INTERRUPT_MASK */
	volatile CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR_t
		MMC_Rx_Packet_Assembly_Err_Cntr; /* CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR */
	volatile CORE_MMC_RX_PACKET_SMD_ERR_CNTR_t
		MMC_Rx_Packet_SMD_Err_Cntr; /* CORE_MMC_RX_PACKET_SMD_ERR_CNTR */
	volatile CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR_t
		MMC_Rx_Packet_Assembly_OK_Cntr; /* CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR */
	volatile CORE_MMC_RX_FPE_FRAGMENT_CNTR_t
		MMC_Rx_FPE_Fragment_Cntr;      /* CORE_MMC_RX_FPE_FRAGMENT_CNTR */
	volatile uint32_t _pad_0xa38_0xa3f[2]; /* *UNDEFINED* */
	volatile CORE_TX_SINGLE_COLLISION_GOOD_PACKETS_t
		Tx_Single_Collision_Good_Packets; /* CORE_TX_SINGLE_COLLISION_GOOD_PACKETS */
	volatile CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS_t
		Tx_Multiple_Collision_Good_Packets; /* CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS */
	volatile CORE_TX_DEFERRED_PACKETS_t Tx_Deferred_Packets; /* CORE_TX_DEFERRED_PACKETS */
	volatile CORE_TX_LATE_COLLISION_PACKETS_t
		Tx_Late_Collision_Packets; /* CORE_TX_LATE_COLLISION_PACKETS */
	volatile CORE_TX_EXCESSIVE_COLLISION_PACKETS_t
		Tx_Excessive_Collision_Packets; /* CORE_TX_EXCESSIVE_COLLISION_PACKETS */
	volatile CORE_TX_CARRIER_ERROR_PACKETS_t
		Tx_Carrier_Error_Packets; /* CORE_TX_CARRIER_ERROR_PACKETS */
	volatile CORE_TX_EXCESSIVE_DEFERRAL_ERROR_t
		Tx_Excessive_Deferral_Error; /* CORE_TX_EXCESSIVE_DEFERRAL_ERROR */
	volatile CORE_MMC_IPC_RX_INTERRUPT_MASK_t
		MMC_IPC_Rx_Interrupt_Mask; /* CORE_MMC_IPC_RX_INTERRUPT_MASK */
	volatile CORE_MMC_IPC_RX_INTERRUPT_t MMC_IPC_Rx_Interrupt; /* CORE_MMC_IPC_RX_INTERRUPT */
	volatile CORE_RXIPV4_GOOD_PACKETS_LOW_t
		RxIPv4_Good_Packets_Low;    /* CORE_RXIPV4_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xa68_0xa6b; /* *UNDEFINED* */
	volatile CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW_t
		RxIPv4_Header_Error_Packets_Low; /* CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xa70_0xa73;	 /* *UNDEFINED* */
	volatile CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW_t
		RxIPv4_No_Payload_Packets_Low; /* CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW */
	volatile uint32_t _pad_0xa78_0xa7b;    /* *UNDEFINED* */
	volatile CORE_RXIPV4_FRAGMENTED_PACKETS_LOW_t
		RxIPv4_Fragmented_Packets_Low; /* CORE_RXIPV4_FRAGMENTED_PACKETS_LOW */
	volatile uint32_t _pad_0xa80_0xa83;    /* *UNDEFINED* */
	volatile CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW_t
		RxIPv4_UDP_Checksum_Disabled_Packets_Low; /* CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW
							   */
	volatile uint32_t _pad_0xa88_0xa8b;		  /* *UNDEFINED* */
	volatile CORE_RXIPV6_GOOD_PACKETS_LOW_t
		RxIPv6_Good_Packets_Low;    /* CORE_RXIPV6_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xa90_0xa93; /* *UNDEFINED* */
	volatile CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW_t
		RxIPv6_Header_Error_Packets_Low; /* CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xa98_0xa9b;	 /* *UNDEFINED* */
	volatile CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW_t
		RxIPv6_No_Payload_Packets_Low; /* CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW */
	volatile uint32_t _pad_0xaa0_0xaa3;    /* *UNDEFINED* */
	volatile CORE_RXUDP_GOOD_PACKETS_LOW_t
		RxUDP_Good_Packets_Low;	    /* CORE_RXUDP_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xaa8_0xaab; /* *UNDEFINED* */
	volatile CORE_RXUDP_ERROR_PACKETS_LOW_t
		RxUDP_Error_Packets_Low;    /* CORE_RXUDP_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xab0_0xab3; /* *UNDEFINED* */
	volatile CORE_RXTCP_GOOD_PACKETS_LOW_t
		RxTCP_Good_Packets_Low;	    /* CORE_RXTCP_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xab8_0xabb; /* *UNDEFINED* */
	volatile CORE_RXTCP_ERROR_PACKETS_LOW_t
		RxTCP_Error_Packets_Low;    /* CORE_RXTCP_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xac0_0xac3; /* *UNDEFINED* */
	volatile CORE_RXICMP_GOOD_PACKETS_LOW_t
		RxICMP_Good_Packets_Low;    /* CORE_RXICMP_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xac8_0xacb; /* *UNDEFINED* */
	volatile CORE_RXICMP_ERROR_PACKETS_LOW_t
		RxICMP_Error_Packets_Low;   /* CORE_RXICMP_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xad0_0xad3; /* *UNDEFINED* */
	volatile CORE_RXIPV4_GOOD_OCTETS_LOW_t
		RxIPv4_Good_Octets_Low;	    /* CORE_RXIPV4_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xad8_0xadb; /* *UNDEFINED* */
	volatile CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW_t
		RxIPv4_Header_Error_Octets_Low; /* CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xae0_0xae3;	/* *UNDEFINED* */
	volatile CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW_t
		RxIPv4_No_Payload_Octets_Low; /* CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW */
	volatile uint32_t _pad_0xae8_0xaeb;   /* *UNDEFINED* */
	volatile CORE_RXIPV4_FRAGMENTED_OCTETS_LOW_t
		RxIPv4_Fragmented_Octets_Low; /* CORE_RXIPV4_FRAGMENTED_OCTETS_LOW */
	volatile uint32_t _pad_0xaf0_0xaf3;   /* *UNDEFINED* */
	volatile CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW_t
		RxIPv4_UDP_Checksum_Disable_Octets_Low; /* CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW
							 */
	volatile uint32_t _pad_0xaf8_0xafb;		/* *UNDEFINED* */
	volatile CORE_RXIPV6_GOOD_OCTETS_LOW_t
		RxIPv6_Good_Octets_Low;	    /* CORE_RXIPV6_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb00_0xb03; /* *UNDEFINED* */
	volatile CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW_t
		RxIPv6_Header_Error_Octets_Low; /* CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb08_0xb0b;	/* *UNDEFINED* */
	volatile CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW_t
		RxIPv6_No_Payload_Octets_Low; /* CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW */
	volatile uint32_t _pad_0xb10_0xb13;   /* *UNDEFINED* */
	volatile CORE_RXUDP_GOOD_OCTETS_LOW_t
		RxUDP_Good_Octets_Low;	    /* CORE_RXUDP_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb18_0xb1b; /* *UNDEFINED* */
	volatile CORE_RXUDP_ERROR_OCTETS_LOW_t
		RxUDP_Error_Octets_Low;	    /* CORE_RXUDP_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb20_0xb23; /* *UNDEFINED* */
	volatile CORE_RXTCP_GOOD_OCTETS_LOW_t
		RxTCP_Good_Octets_Low;	    /* CORE_RXTCP_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb28_0xb2b; /* *UNDEFINED* */
	volatile CORE_RXTCP_ERROR_OCTETS_LOW_t
		RxTCP_Error_Octets_Low;	    /* CORE_RXTCP_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb30_0xb33; /* *UNDEFINED* */
	volatile CORE_RXICMP_GOOD_OCTETS_LOW_t
		RxICMP_Good_Octets_Low;	    /* CORE_RXICMP_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb38_0xb3b; /* *UNDEFINED* */
	volatile CORE_RXICMP_ERROR_OCTETS_LOW_t
		RxICMP_Error_Octets_Low;	/* CORE_RXICMP_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb40_0xbff[48]; /* *UNDEFINED* */
	volatile CORE_MAC_L3_L4_ADDRESS_CONTROL_t
		MAC_L3_L4_Address_Control;		 /* CORE_MAC_L3_L4_ADDRESS_CONTROL */
	volatile CORE_MAC_L3_L4_DATA_t MAC_L3_L4_Data;	 /* CORE_MAC_L3_L4_DATA */
	volatile uint32_t _pad_0xc08_0xc0f[2];		 /* *UNDEFINED* */
	volatile CORE_MAC_ARP_ADDRESS_t MAC_ARP_Address; /* CORE_MAC_ARP_ADDRESS */
	volatile uint32_t _pad_0xc14_0xcff[59];		 /* *UNDEFINED* */
	volatile CORE_MAC_TIMESTAMP_CONTROL_t
		MAC_Timestamp_Control; /* CORE_MAC_TIMESTAMP_CONTROL */
	volatile CORE_MAC_SUB_SECOND_INCREMENT_t
		MAC_Sub_Second_Increment; /* CORE_MAC_SUB_SECOND_INCREMENT */
	volatile CORE_MAC_SYSTEM_TIME_SECONDS_t
		MAC_System_Time_Seconds; /* CORE_MAC_SYSTEM_TIME_SECONDS */
	volatile CORE_MAC_SYSTEM_TIME_NANOSECONDS_t
		MAC_System_Time_Nanoseconds; /* CORE_MAC_SYSTEM_TIME_NANOSECONDS */
	volatile CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE_t
		MAC_System_Time_Seconds_Update; /* CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE */
	volatile CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE_t
		MAC_System_Time_Nanoseconds_Update; /* CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE */
	volatile CORE_MAC_TIMESTAMP_ADDEND_t MAC_Timestamp_Addend; /* CORE_MAC_TIMESTAMP_ADDEND */
	volatile CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS_t
		MAC_System_Time_Higher_Word_Seconds; /* CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS */
	volatile CORE_MAC_TIMESTAMP_STATUS_t MAC_Timestamp_Status; /* CORE_MAC_TIMESTAMP_STATUS */
	volatile uint32_t _pad_0xd24_0xd2f[3];			   /* *UNDEFINED* */
	volatile CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS_t
		MAC_Tx_Timestamp_Status_Nanoseconds; /* CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS */
	volatile CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS_t
		MAC_Tx_Timestamp_Status_Seconds; /* CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS */
	volatile CORE_MAC_TX_TIMESTAMP_STATUS_PKTID_t
		MAC_Tx_Timestamp_Status_PktID; /* CORE_MAC_TX_TIMESTAMP_STATUS_PKTID */
	volatile uint32_t _pad_0xd3c_0xd3f;    /* *UNDEFINED* */
	volatile CORE_MAC_AUXILIARY_CONTROL_t
		MAC_Auxiliary_Control;	    /* CORE_MAC_AUXILIARY_CONTROL */
	volatile uint32_t _pad_0xd44_0xd47; /* *UNDEFINED* */
	volatile CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS_t
		MAC_Auxiliary_Timestamp_Nanoseconds; /* CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS */
	volatile CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS_t
		MAC_Auxiliary_Timestamp_Seconds; /* CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS */
	volatile CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR_t
		MAC_Timestamp_Ingress_Asym_Corr; /* CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR */
	volatile CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR_t
		MAC_Timestamp_Egress_Asym_Corr; /* CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR */
	volatile CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND_t
		MAC_Timestamp_Ingress_Corr_Nanosecond; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND
							*/
	volatile CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND_t
		MAC_Timestamp_Ingress_Corr_Subnanosecond; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND
							   */
	volatile CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND_t
		MAC_Timestamp_Egress_Corr_Nanosecond; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND
						       */
	volatile CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND_t
		MAC_Timestamp_Egress_Corr_Subnanosecond; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND
							  */
	volatile uint32_t _pad_0xd68_0xd6f[2];		 /* *UNDEFINED* */
	volatile CORE_MAC_PPS_CONTROL_t MAC_PPS_Control; /* CORE_MAC_PPS_CONTROL */
	volatile uint32_t _pad_0xd74_0xd7f[3];		 /* *UNDEFINED* */
	volatile CORE_MAC_PPS0_TARGET_TIME_SECONDS_t
		MAC_PPS0_Target_Time_Seconds; /* CORE_MAC_PPS0_TARGET_TIME_SECONDS */
	volatile CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS_t
		MAC_PPS0_Target_Time_Nanoseconds; /* CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS */
	volatile CORE_MAC_PPS0_INTERVAL_t MAC_PPS0_Interval; /* CORE_MAC_PPS0_INTERVAL */
	volatile CORE_MAC_PPS0_WIDTH_t MAC_PPS0_Width;	     /* CORE_MAC_PPS0_WIDTH */
	volatile CORE_MAC_PPS1_TARGET_TIME_SECONDS_t
		MAC_PPS1_Target_Time_Seconds; /* CORE_MAC_PPS1_TARGET_TIME_SECONDS */
	volatile CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS_t
		MAC_PPS1_Target_Time_Nanoseconds; /* CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS */
	volatile CORE_MAC_PPS1_INTERVAL_t MAC_PPS1_Interval; /* CORE_MAC_PPS1_INTERVAL */
	volatile CORE_MAC_PPS1_WIDTH_t MAC_PPS1_Width;	     /* CORE_MAC_PPS1_WIDTH */
	volatile uint32_t _pad_0xda0_0xdbf[8];		     /* *UNDEFINED* */
	volatile CORE_MAC_PTO_CONTROL_t MAC_PTO_Control;     /* CORE_MAC_PTO_CONTROL */
	volatile CORE_MAC_SOURCE_PORT_IDENTITY0_t
		MAC_Source_Port_Identity0; /* CORE_MAC_SOURCE_PORT_IDENTITY0 */
	volatile CORE_MAC_SOURCE_PORT_IDENTITY1_t
		MAC_Source_Port_Identity1; /* CORE_MAC_SOURCE_PORT_IDENTITY1 */
	volatile CORE_MAC_SOURCE_PORT_IDENTITY2_t
		MAC_Source_Port_Identity2; /* CORE_MAC_SOURCE_PORT_IDENTITY2 */
	volatile CORE_MAC_LOG_MESSAGE_INTERVAL_t
		MAC_Log_Message_Interval;	  /* CORE_MAC_LOG_MESSAGE_INTERVAL */
	volatile uint32_t _pad_0xdd4_0x1000[139]; /* *UNDEFINED* */
};

/* The typedef declaration for register group CORE. */
typedef struct CORE_s CORE_t;
/* The struct declaration for the raw register contents of register group CORE. */
struct CORE_raw_s {
	volatile uint32_t MAC_Tx_Configuration;	       /* CORE_MAC_TX_CONFIGURATION */
	volatile uint32_t MAC_Rx_Configuration;	       /* CORE_MAC_RX_CONFIGURATION */
	volatile uint32_t MAC_Packet_Filter;	       /* CORE_MAC_PACKET_FILTER */
	volatile uint32_t MAC_WD_JB_Timeout;	       /* CORE_MAC_WD_JB_TIMEOUT */
	volatile uint32_t MAC_Hash_Table_Reg0;	       /* CORE_MAC_HASH_TABLE_REG0 */
	volatile uint32_t MAC_Hash_Table_Reg1;	       /* CORE_MAC_HASH_TABLE_REG1 */
	volatile uint32_t _pad_0x18_0x4f[14];	       /* *UNDEFINED* */
	volatile uint32_t MAC_VLAN_Tag_Ctrl;	       /* CORE_MAC_VLAN_TAG_CTRL */
	volatile uint32_t MAC_VLAN_Tag_Data;	       /* CORE_MAC_VLAN_TAG_DATA */
	volatile uint32_t MAC_VLAN_Hash_Table;	       /* CORE_MAC_VLAN_HASH_TABLE */
	volatile uint32_t _pad_0x5c_0x5f;	       /* *UNDEFINED* */
	volatile uint32_t MAC_VLAN_Incl;	       /* CORE_MAC_VLAN_INCL */
	volatile uint32_t MAC_Inner_VLAN_Incl;	       /* CORE_MAC_INNER_VLAN_INCL */
	volatile uint32_t _pad_0x68_0x6b;	       /* *UNDEFINED* */
	volatile uint32_t MAC_Rx_Eth_Type_Match;       /* CORE_MAC_RX_ETH_TYPE_MATCH */
	volatile uint32_t MAC_Q0_Tx_Flow_Ctrl;	       /* CORE_MAC_Q0_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q1_Tx_Flow_Ctrl;	       /* CORE_MAC_Q1_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q2_Tx_Flow_Ctrl;	       /* CORE_MAC_Q2_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q3_Tx_Flow_Ctrl;	       /* CORE_MAC_Q3_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q4_Tx_Flow_Ctrl;	       /* CORE_MAC_Q4_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q5_Tx_Flow_Ctrl;	       /* CORE_MAC_Q5_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q6_Tx_Flow_Ctrl;	       /* CORE_MAC_Q6_TX_FLOW_CTRL */
	volatile uint32_t MAC_Q7_Tx_Flow_Ctrl;	       /* CORE_MAC_Q7_TX_FLOW_CTRL */
	volatile uint32_t MAC_Rx_Flow_Ctrl;	       /* CORE_MAC_RX_FLOW_CTRL */
	volatile uint32_t MAC_RxQ_Ctrl4;	       /* CORE_MAC_RXQ_CTRL4 */
	volatile uint32_t MAC_RxQ_Ctrl5;	       /* CORE_MAC_RXQ_CTRL5 */
	volatile uint32_t _pad_0x9c_0x9f;	       /* *UNDEFINED* */
	volatile uint32_t MAC_RxQ_Ctrl0;	       /* CORE_MAC_RXQ_CTRL0 */
	volatile uint32_t MAC_RxQ_Ctrl1;	       /* CORE_MAC_RXQ_CTRL1 */
	volatile uint32_t MAC_RxQ_Ctrl2;	       /* CORE_MAC_RXQ_CTRL2 */
	volatile uint32_t MAC_RxQ_Ctrl3;	       /* CORE_MAC_RXQ_CTRL3 */
	volatile uint32_t MAC_Interrupt_Status;	       /* CORE_MAC_INTERRUPT_STATUS */
	volatile uint32_t MAC_Interrupt_Enable;	       /* CORE_MAC_INTERRUPT_ENABLE */
	volatile uint32_t MAC_Rx_Tx_Status;	       /* CORE_MAC_RX_TX_STATUS */
	volatile uint32_t _pad_0xbc_0xcf[5];	       /* *UNDEFINED* */
	volatile uint32_t MAC_LPI_Control_Status;      /* CORE_MAC_LPI_CONTROL_STATUS */
	volatile uint32_t MAC_LPI_Timers_Control;      /* CORE_MAC_LPI_TIMERS_CONTROL */
	volatile uint32_t MAC_LPI_Auto_Entry_Timer;    /* CORE_MAC_LPI_AUTO_ENTRY_TIMER */
	volatile uint32_t MAC_1US_Tic_Counter;	       /* CORE_MAC_1US_TIC_COUNTER */
	volatile uint32_t _pad_0xe0_0x10f[12];	       /* *UNDEFINED* */
	volatile uint32_t MAC_Version;		       /* CORE_MAC_VERSION */
	volatile uint32_t MAC_Debug;		       /* CORE_MAC_DEBUG */
	volatile uint32_t _pad_0x118_0x11b;	       /* *UNDEFINED* */
	volatile uint32_t MAC_HW_Feature0;	       /* CORE_MAC_HW_FEATURE0 */
	volatile uint32_t MAC_HW_Feature1;	       /* CORE_MAC_HW_FEATURE1 */
	volatile uint32_t MAC_HW_Feature2;	       /* CORE_MAC_HW_FEATURE2 */
	volatile uint32_t MAC_HW_Feature3;	       /* CORE_MAC_HW_FEATURE3 */
	volatile uint32_t MAC_HW_Feature4;	       /* CORE_MAC_HW_FEATURE4 */
	volatile uint32_t _pad_0x130_0x13f[4];	       /* *UNDEFINED* */
	volatile uint32_t MAC_Extended_Configuration;  /* CORE_MAC_EXTENDED_CONFIGURATION */
	volatile uint32_t MAC_Ext_Cfg1;		       /* CORE_MAC_EXT_CFG1 */
	volatile uint32_t _pad_0x148_0x1ff[46];	       /* *UNDEFINED* */
	volatile uint32_t MDIO_Single_Command_Address; /* CORE_MDIO_SINGLE_COMMAND_ADDRESS */
	volatile uint32_t
		MDIO_Single_Command_Control_Data;	 /* CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA */
	volatile uint32_t MDIO_Continuous_Write_Address; /* CORE_MDIO_CONTINUOUS_WRITE_ADDRESS */
	volatile uint32_t MDIO_Continuous_Write_Data;	 /* CORE_MDIO_CONTINUOUS_WRITE_DATA */
	volatile uint32_t
		MDIO_Continuous_Scan_Port_Enable; /* CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE */
	volatile uint32_t MDIO_Interrupt_Status;  /* CORE_MDIO_INTERRUPT_STATUS */
	volatile uint32_t MDIO_Interrupt_Enable;  /* CORE_MDIO_INTERRUPT_ENABLE */
	volatile uint32_t
		MDIO_Port_Connect_Disconnect_Status; /* CORE_MDIO_PORT_CONNECT_DISCONNECT_STATUS */
	volatile uint32_t MDIO_Clause_22_Port;	     /* CORE_MDIO_CLAUSE_22_PORT */
	volatile uint32_t MDIO_Port_Nx4_Indirect_Control; /* CORE_MDIO_PORT_NX4_INDIRECT_CONTROL */
	volatile uint32_t _pad_0x228_0x22f[2];		  /* *UNDEFINED* */
	volatile uint32_t MDIO_PortNx4P0_Device_In_Use;	  /* CORE_MDIO_PORTNX4P0_DEVICE_IN_USE */
	volatile uint32_t MDIO_PortNx4P0_Link_Status;	  /* CORE_MDIO_PORTNX4P0_LINK_STATUS */
	volatile uint32_t MDIO_PortNx4P0_Alive_Status;	  /* CORE_MDIO_PORTNX4P0_ALIVE_STATUS */
	volatile uint32_t _pad_0x23c_0x23f;		  /* *UNDEFINED* */
	volatile uint32_t MDIO_PortNx4P1_Device_In_Use;	  /* CORE_MDIO_PORTNX4P1_DEVICE_IN_USE */
	volatile uint32_t MDIO_PortNx4P1_Link_Status;	  /* CORE_MDIO_PORTNX4P1_LINK_STATUS */
	volatile uint32_t MDIO_PortNx4P1_Alive_Status;	  /* CORE_MDIO_PORTNX4P1_ALIVE_STATUS */
	volatile uint32_t _pad_0x24c_0x24f;		  /* *UNDEFINED* */
	volatile uint32_t MDIO_PortNx4P2_Device_In_Use;	  /* CORE_MDIO_PORTNX4P2_DEVICE_IN_USE */
	volatile uint32_t MDIO_PortNx4P2_Link_Status;	  /* CORE_MDIO_PORTNX4P2_LINK_STATUS */
	volatile uint32_t MDIO_PortNx4P2_Alive_Status;	  /* CORE_MDIO_PORTNX4P2_ALIVE_STATUS */
	volatile uint32_t _pad_0x25c_0x25f;		  /* *UNDEFINED* */
	volatile uint32_t MDIO_PortNx4P3_Device_In_Use;	  /* CORE_MDIO_PORTNX4P3_DEVICE_IN_USE */
	volatile uint32_t MDIO_PortNx4P3_Link_Status;	  /* CORE_MDIO_PORTNX4P3_LINK_STATUS */
	volatile uint32_t MDIO_PortNx4P3_Alive_Status;	  /* CORE_MDIO_PORTNX4P3_ALIVE_STATUS */
	volatile uint32_t _pad_0x26c_0x27f[5];		  /* *UNDEFINED* */
	volatile uint32_t MAC_FPE_CTRL_STS;		  /* CORE_MAC_FPE_CTRL_STS */
	volatile uint32_t _pad_0x284_0x28f[3];		  /* *UNDEFINED* */
	volatile uint32_t MAC_CSR_SW_Ctrl;		  /* CORE_MAC_CSR_SW_CTRL */
	volatile uint32_t _pad_0x294_0x2ff[27];		  /* *UNDEFINED* */
	volatile uint32_t MAC_Address0_High;		  /* CORE_MAC_ADDRESS0_HIGH */
	volatile uint32_t MAC_Address0_Low;		  /* CORE_MAC_ADDRESS0_LOW */
	volatile uint32_t MAC_Address1_High;		  /* CORE_MAC_ADDRESS1_HIGH */
	volatile uint32_t MAC_Address1_Low;		  /* CORE_MAC_ADDRESS1_LOW */
	volatile uint32_t MAC_Address2_High;		  /* CORE_MAC_ADDRESS2_HIGH */
	volatile uint32_t MAC_Address2_Low;		  /* CORE_MAC_ADDRESS2_LOW */
	volatile uint32_t MAC_Address3_High;		  /* CORE_MAC_ADDRESS3_HIGH */
	volatile uint32_t MAC_Address3_Low;		  /* CORE_MAC_ADDRESS3_LOW */
	volatile uint32_t MAC_Address4_High;		  /* CORE_MAC_ADDRESS4_HIGH */
	volatile uint32_t MAC_Address4_Low;		  /* CORE_MAC_ADDRESS4_LOW */
	volatile uint32_t MAC_Address5_High;		  /* CORE_MAC_ADDRESS5_HIGH */
	volatile uint32_t MAC_Address5_Low;		  /* CORE_MAC_ADDRESS5_LOW */
	volatile uint32_t MAC_Address6_High;		  /* CORE_MAC_ADDRESS6_HIGH */
	volatile uint32_t MAC_Address6_Low;		  /* CORE_MAC_ADDRESS6_LOW */
	volatile uint32_t MAC_Address7_High;		  /* CORE_MAC_ADDRESS7_HIGH */
	volatile uint32_t MAC_Address7_Low;		  /* CORE_MAC_ADDRESS7_LOW */
	volatile uint32_t MAC_Address8_High;		  /* CORE_MAC_ADDRESS8_HIGH */
	volatile uint32_t MAC_Address8_Low;		  /* CORE_MAC_ADDRESS8_LOW */
	volatile uint32_t MAC_Address9_High;		  /* CORE_MAC_ADDRESS9_HIGH */
	volatile uint32_t MAC_Address9_Low;		  /* CORE_MAC_ADDRESS9_LOW */
	volatile uint32_t MAC_Address10_High;		  /* CORE_MAC_ADDRESS10_HIGH */
	volatile uint32_t MAC_Address10_Low;		  /* CORE_MAC_ADDRESS10_LOW */
	volatile uint32_t MAC_Address11_High;		  /* CORE_MAC_ADDRESS11_HIGH */
	volatile uint32_t MAC_Address11_Low;		  /* CORE_MAC_ADDRESS11_LOW */
	volatile uint32_t MAC_Address12_High;		  /* CORE_MAC_ADDRESS12_HIGH */
	volatile uint32_t MAC_Address12_Low;		  /* CORE_MAC_ADDRESS12_LOW */
	volatile uint32_t MAC_Address13_High;		  /* CORE_MAC_ADDRESS13_HIGH */
	volatile uint32_t MAC_Address13_Low;		  /* CORE_MAC_ADDRESS13_LOW */
	volatile uint32_t MAC_Address14_High;		  /* CORE_MAC_ADDRESS14_HIGH */
	volatile uint32_t MAC_Address14_Low;		  /* CORE_MAC_ADDRESS14_LOW */
	volatile uint32_t MAC_Address15_High;		  /* CORE_MAC_ADDRESS15_HIGH */
	volatile uint32_t MAC_Address15_Low;		  /* CORE_MAC_ADDRESS15_LOW */
	volatile uint32_t MAC_Address16_High;		  /* CORE_MAC_ADDRESS16_HIGH */
	volatile uint32_t MAC_Address16_Low;		  /* CORE_MAC_ADDRESS16_LOW */
	volatile uint32_t MAC_Address17_High;		  /* CORE_MAC_ADDRESS17_HIGH */
	volatile uint32_t MAC_Address17_Low;		  /* CORE_MAC_ADDRESS17_LOW */
	volatile uint32_t MAC_Address18_High;		  /* CORE_MAC_ADDRESS18_HIGH */
	volatile uint32_t MAC_Address18_Low;		  /* CORE_MAC_ADDRESS18_LOW */
	volatile uint32_t MAC_Address19_High;		  /* CORE_MAC_ADDRESS19_HIGH */
	volatile uint32_t MAC_Address19_Low;		  /* CORE_MAC_ADDRESS19_LOW */
	volatile uint32_t MAC_Address20_High;		  /* CORE_MAC_ADDRESS20_HIGH */
	volatile uint32_t MAC_Address20_Low;		  /* CORE_MAC_ADDRESS20_LOW */
	volatile uint32_t MAC_Address21_High;		  /* CORE_MAC_ADDRESS21_HIGH */
	volatile uint32_t MAC_Address21_Low;		  /* CORE_MAC_ADDRESS21_LOW */
	volatile uint32_t MAC_Address22_High;		  /* CORE_MAC_ADDRESS22_HIGH */
	volatile uint32_t MAC_Address22_Low;		  /* CORE_MAC_ADDRESS22_LOW */
	volatile uint32_t MAC_Address23_High;		  /* CORE_MAC_ADDRESS23_HIGH */
	volatile uint32_t MAC_Address23_Low;		  /* CORE_MAC_ADDRESS23_LOW */
	volatile uint32_t MAC_Address24_High;		  /* CORE_MAC_ADDRESS24_HIGH */
	volatile uint32_t MAC_Address24_Low;		  /* CORE_MAC_ADDRESS24_LOW */
	volatile uint32_t MAC_Address25_High;		  /* CORE_MAC_ADDRESS25_HIGH */
	volatile uint32_t MAC_Address25_Low;		  /* CORE_MAC_ADDRESS25_LOW */
	volatile uint32_t MAC_Address26_High;		  /* CORE_MAC_ADDRESS26_HIGH */
	volatile uint32_t MAC_Address26_Low;		  /* CORE_MAC_ADDRESS26_LOW */
	volatile uint32_t MAC_Address27_High;		  /* CORE_MAC_ADDRESS27_HIGH */
	volatile uint32_t MAC_Address27_Low;		  /* CORE_MAC_ADDRESS27_LOW */
	volatile uint32_t MAC_Address28_High;		  /* CORE_MAC_ADDRESS28_HIGH */
	volatile uint32_t MAC_Address28_Low;		  /* CORE_MAC_ADDRESS28_LOW */
	volatile uint32_t MAC_Address29_High;		  /* CORE_MAC_ADDRESS29_HIGH */
	volatile uint32_t MAC_Address29_Low;		  /* CORE_MAC_ADDRESS29_LOW */
	volatile uint32_t MAC_Address30_High;		  /* CORE_MAC_ADDRESS30_HIGH */
	volatile uint32_t MAC_Address30_Low;		  /* CORE_MAC_ADDRESS30_LOW */
	volatile uint32_t MAC_Address31_High;		  /* CORE_MAC_ADDRESS31_HIGH */
	volatile uint32_t MAC_Address31_Low;		  /* CORE_MAC_ADDRESS31_LOW */
	volatile uint32_t _pad_0x400_0x6ff[192];	  /* *UNDEFINED* */
	volatile uint32_t MAC_Indir_Access_Ctrl;	  /* CORE_MAC_INDIR_ACCESS_CTRL */
	volatile uint32_t MAC_Indir_Access_Data;	  /* CORE_MAC_INDIR_ACCESS_DATA */
	volatile uint32_t _pad_0x708_0x7ff[62];		  /* *UNDEFINED* */
	volatile uint32_t MMC_Control;			  /* CORE_MMC_CONTROL */
	volatile uint32_t MMC_Rx_Interrupt;		  /* CORE_MMC_RX_INTERRUPT */
	volatile uint32_t MMC_Tx_Interrupt;		  /* CORE_MMC_TX_INTERRUPT */
	volatile uint32_t MMC_Receive_Interrupt_Enable;	  /* CORE_MMC_RECEIVE_INTERRUPT_ENABLE */
	volatile uint32_t MMC_Transmit_Interrupt_Enable;  /* CORE_MMC_TRANSMIT_INTERRUPT_ENABLE */
	volatile uint32_t Tx_Octet_Count_Good_Bad_Low;	  /* CORE_TX_OCTET_COUNT_GOOD_BAD_LOW */
	volatile uint32_t Tx_Octet_Count_Good_Bad_High;	  /* CORE_TX_OCTET_COUNT_GOOD_BAD_HIGH */
	volatile uint32_t Tx_Packet_Count_Good_Bad_Low;	  /* CORE_TX_PACKET_COUNT_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x820_0x823;		  /* *UNDEFINED* */
	volatile uint32_t Tx_Broadcast_Packets_Good_Low;  /* CORE_TX_BROADCAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x828_0x82b;		  /* *UNDEFINED* */
	volatile uint32_t Tx_Multicast_Packets_Good_Low;  /* CORE_TX_MULTICAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x830_0x833;		  /* *UNDEFINED* */
	volatile uint32_t
		Tx_64Octets_Packets_Good_Bad_Low; /* CORE_TX_64OCTETS_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x838_0x83b;	  /* *UNDEFINED* */
	volatile uint32_t Tx_65To127Octets_Packets_Good_Bad_Low; /* CORE_TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW
								  */
	volatile uint32_t _pad_0x840_0x843;			 /* *UNDEFINED* */
	volatile uint32_t Tx_128To255Octets_Packets_Good_Bad_Low; /* CORE_TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW
								   */
	volatile uint32_t _pad_0x848_0x84b;			  /* *UNDEFINED* */
	volatile uint32_t Tx_256To511Octets_Packets_Good_Bad_Low; /* CORE_TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW
								   */
	volatile uint32_t _pad_0x850_0x853;			  /* *UNDEFINED* */
	volatile uint32_t Tx_512To1023Octets_Packets_Good_Bad_Low; /* CORE_TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW
								    */
	volatile uint32_t _pad_0x858_0x85b;			   /* *UNDEFINED* */
	volatile uint32_t Tx_1024ToMaxOctets_Packets_Good_Bad_Low; /* CORE_TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW
								    */
	volatile uint32_t _pad_0x860_0x863;			   /* *UNDEFINED* */
	volatile uint32_t
		Tx_Unicast_Packets_Good_Bad_Low; /* CORE_TX_UNICAST_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x868_0x86b;	 /* *UNDEFINED* */
	volatile uint32_t
		Tx_Multicast_Packets_Good_Bad_Low; /* CORE_TX_MULTICAST_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x870_0x873;	   /* *UNDEFINED* */
	volatile uint32_t
		Tx_Broadcast_Packets_Good_Bad_Low; /* CORE_TX_BROADCAST_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x878_0x87b;	   /* *UNDEFINED* */
	volatile uint32_t Tx_Underflow_Error_Packets_Low; /* CORE_TX_UNDERFLOW_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0x880_0x883;		  /* *UNDEFINED* */
	volatile uint32_t Tx_Octet_Count_Good_Low;	  /* CORE_TX_OCTET_COUNT_GOOD_LOW */
	volatile uint32_t Tx_Octet_Count_Good_High;	  /* CORE_TX_OCTET_COUNT_GOOD_HIGH */
	volatile uint32_t Tx_Packet_Count_Good_Low;	  /* CORE_TX_PACKET_COUNT_GOOD_LOW */
	volatile uint32_t _pad_0x890_0x893;		  /* *UNDEFINED* */
	volatile uint32_t Tx_Pause_Packets_Low;		  /* CORE_TX_PAUSE_PACKETS_LOW */
	volatile uint32_t _pad_0x898_0x89b;		  /* *UNDEFINED* */
	volatile uint32_t Tx_VLAN_Packets_Good_Low;	  /* CORE_TX_VLAN_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x8a0_0x8a3;		  /* *UNDEFINED* */
	volatile uint32_t Tx_LPI_USEC_Cntr;		  /* CORE_TX_LPI_USEC_CNTR */
	volatile uint32_t Tx_LPI_Tran_Cntr;		  /* CORE_TX_LPI_TRAN_CNTR */
	volatile uint32_t _pad_0x8ac_0x8ff[21];		  /* *UNDEFINED* */
	volatile uint32_t Rx_Packet_Count_Good_Bad_Low;	  /* CORE_RX_PACKET_COUNT_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x904_0x907;		  /* *UNDEFINED* */
	volatile uint32_t Rx_Octet_Count_Good_Bad_Low;	  /* CORE_RX_OCTET_COUNT_GOOD_BAD_LOW */
	volatile uint32_t Rx_Octet_Count_Good_Bad_High;	  /* CORE_RX_OCTET_COUNT_GOOD_BAD_HIGH */
	volatile uint32_t Rx_Octet_Count_Good_Low;	  /* CORE_RX_OCTET_COUNT_GOOD_LOW */
	volatile uint32_t Rx_Octet_Count_Good_High;	  /* CORE_RX_OCTET_COUNT_GOOD_HIGH */
	volatile uint32_t Rx_Broadcast_Packets_Good_Low;  /* CORE_RX_BROADCAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x91c_0x91f;		  /* *UNDEFINED* */
	volatile uint32_t Rx_Multicast_Packets_Good_Low;  /* CORE_RX_MULTICAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x924_0x927;		  /* *UNDEFINED* */
	volatile uint32_t Rx_CRC_Error_Packets_Low;	  /* CORE_RX_CRC_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0x92c_0x92f;		  /* *UNDEFINED* */
	volatile uint32_t Rx_Runt_Error_Packets;	  /* CORE_RX_RUNT_ERROR_PACKETS */
	volatile uint32_t Rx_Jabber_Error_Packets;	  /* CORE_RX_JABBER_ERROR_PACKETS */
	volatile uint32_t Rx_Undersize_Packets_Good;	  /* CORE_RX_UNDERSIZE_PACKETS_GOOD */
	volatile uint32_t Rx_Oversize_Packets_Good;	  /* CORE_RX_OVERSIZE_PACKETS_GOOD */
	volatile uint32_t
		Rx_64Octets_Packets_Good_Bad_Low; /* CORE_RX_64OCTETS_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x944_0x947;	  /* *UNDEFINED* */
	volatile uint32_t Rx_65To127Octets_Packets_Good_Bad_Low; /* CORE_RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW
								  */
	volatile uint32_t _pad_0x94c_0x94f;			 /* *UNDEFINED* */
	volatile uint32_t Rx_128To255Octets_Packets_Good_Bad_Low; /* CORE_RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW
								   */
	volatile uint32_t _pad_0x954_0x957;			  /* *UNDEFINED* */
	volatile uint32_t Rx_256To511Octets_Packets_Good_Bad_Low; /* CORE_RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW
								   */
	volatile uint32_t _pad_0x95c_0x95f;			  /* *UNDEFINED* */
	volatile uint32_t Rx_512To1023Octets_Packets_Good_Bad_Low; /* CORE_RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW
								    */
	volatile uint32_t _pad_0x964_0x967;			   /* *UNDEFINED* */
	volatile uint32_t Rx_1024ToMaxOctets_Packets_Good_Bad_Low; /* CORE_RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW
								    */
	volatile uint32_t _pad_0x96c_0x96f;			   /* *UNDEFINED* */
	volatile uint32_t Rx_Unicast_Packets_Good_Low;	/* CORE_RX_UNICAST_PACKETS_GOOD_LOW */
	volatile uint32_t _pad_0x974_0x977;		/* *UNDEFINED* */
	volatile uint32_t Rx_Length_Error_Packets_Low;	/* CORE_RX_LENGTH_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0x97c_0x97f;		/* *UNDEFINED* */
	volatile uint32_t Rx_OutofRange_Packets_Low;	/* CORE_RX_OUTOFRANGE_PACKETS_LOW */
	volatile uint32_t _pad_0x984_0x987;		/* *UNDEFINED* */
	volatile uint32_t Rx_Pause_Packets_Low;		/* CORE_RX_PAUSE_PACKETS_LOW */
	volatile uint32_t _pad_0x98c_0x98f;		/* *UNDEFINED* */
	volatile uint32_t Rx_FIFOOverflow_Packets_Low;	/* CORE_RX_FIFOOVERFLOW_PACKETS_LOW */
	volatile uint32_t _pad_0x994_0x997;		/* *UNDEFINED* */
	volatile uint32_t Rx_VLAN_Packets_Good_Bad_Low; /* CORE_RX_VLAN_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x99c_0x99f;		/* *UNDEFINED* */
	volatile uint32_t Rx_Watchdog_Error_Packets;	/* CORE_RX_WATCHDOG_ERROR_PACKETS */
	volatile uint32_t Rx_LPI_USEC_Cntr;		/* CORE_RX_LPI_USEC_CNTR */
	volatile uint32_t Rx_LPI_Tran_Cntr;		/* CORE_RX_LPI_TRAN_CNTR */
	volatile uint32_t
		Rx_Discard_Packets_Good_Bad_Low;	  /* CORE_RX_DISCARD_PACKETS_GOOD_BAD_LOW */
	volatile uint32_t _pad_0x9b0_0x9b3;		  /* *UNDEFINED* */
	volatile uint32_t Rx_Discard_Octets_Good_Bad_Low; /* CORE_RX_DISCARD_OCTETS_GOOD_BAD_LOW */
	volatile uint32_t
		Rx_Discard_Octets_Good_Bad_High;      /* CORE_RX_DISCARD_OCTETS_GOOD_BAD_HIGH */
	volatile uint32_t Rx_Alignment_Error_Packets; /* CORE_RX_ALIGNMENT_ERROR_PACKETS */
	volatile uint32_t _pad_0x9c0_0x9ff[16];	      /* *UNDEFINED* */
	volatile uint32_t MMC_FPE_Tx_Interrupt;	      /* CORE_MMC_FPE_TX_INTERRUPT */
	volatile uint32_t MMC_FPE_Tx_Interrupt_Mask;  /* CORE_MMC_FPE_TX_INTERRUPT_MASK */
	volatile uint32_t MMC_Tx_FPE_Fragment_Cntr;   /* CORE_MMC_TX_FPE_FRAGMENT_CNTR */
	volatile uint32_t MMC_Tx_Hold_Req_Cntr;	      /* CORE_MMC_TX_HOLD_REQ_CNTR */
	volatile uint32_t _pad_0xa10_0xa1f[4];	      /* *UNDEFINED* */
	volatile uint32_t MMC_FPE_Rx_Interrupt;	      /* CORE_MMC_FPE_RX_INTERRUPT */
	volatile uint32_t MMC_FPE_Rx_Interrupt_Mask;  /* CORE_MMC_FPE_RX_INTERRUPT_MASK */
	volatile uint32_t
		MMC_Rx_Packet_Assembly_Err_Cntr;	  /* CORE_MMC_RX_PACKET_ASSEMBLY_ERR_CNTR */
	volatile uint32_t MMC_Rx_Packet_SMD_Err_Cntr;	  /* CORE_MMC_RX_PACKET_SMD_ERR_CNTR */
	volatile uint32_t MMC_Rx_Packet_Assembly_OK_Cntr; /* CORE_MMC_RX_PACKET_ASSEMBLY_OK_CNTR */
	volatile uint32_t MMC_Rx_FPE_Fragment_Cntr;	  /* CORE_MMC_RX_FPE_FRAGMENT_CNTR */
	volatile uint32_t _pad_0xa38_0xa3f[2];		  /* *UNDEFINED* */
	volatile uint32_t
		Tx_Single_Collision_Good_Packets; /* CORE_TX_SINGLE_COLLISION_GOOD_PACKETS */
	volatile uint32_t
		Tx_Multiple_Collision_Good_Packets;  /* CORE_TX_MULTIPLE_COLLISION_GOOD_PACKETS */
	volatile uint32_t Tx_Deferred_Packets;	     /* CORE_TX_DEFERRED_PACKETS */
	volatile uint32_t Tx_Late_Collision_Packets; /* CORE_TX_LATE_COLLISION_PACKETS */
	volatile uint32_t Tx_Excessive_Collision_Packets; /* CORE_TX_EXCESSIVE_COLLISION_PACKETS */
	volatile uint32_t Tx_Carrier_Error_Packets;	  /* CORE_TX_CARRIER_ERROR_PACKETS */
	volatile uint32_t Tx_Excessive_Deferral_Error;	  /* CORE_TX_EXCESSIVE_DEFERRAL_ERROR */
	volatile uint32_t MMC_IPC_Rx_Interrupt_Mask;	  /* CORE_MMC_IPC_RX_INTERRUPT_MASK */
	volatile uint32_t MMC_IPC_Rx_Interrupt;		  /* CORE_MMC_IPC_RX_INTERRUPT */
	volatile uint32_t RxIPv4_Good_Packets_Low;	  /* CORE_RXIPV4_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xa68_0xa6b;		  /* *UNDEFINED* */
	volatile uint32_t
		RxIPv4_Header_Error_Packets_Low;	 /* CORE_RXIPV4_HEADER_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xa70_0xa73;		 /* *UNDEFINED* */
	volatile uint32_t RxIPv4_No_Payload_Packets_Low; /* CORE_RXIPV4_NO_PAYLOAD_PACKETS_LOW */
	volatile uint32_t _pad_0xa78_0xa7b;		 /* *UNDEFINED* */
	volatile uint32_t RxIPv4_Fragmented_Packets_Low; /* CORE_RXIPV4_FRAGMENTED_PACKETS_LOW */
	volatile uint32_t _pad_0xa80_0xa83;		 /* *UNDEFINED* */
	volatile uint32_t RxIPv4_UDP_Checksum_Disabled_Packets_Low; /* CORE_RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW
								     */
	volatile uint32_t _pad_0xa88_0xa8b;			    /* *UNDEFINED* */
	volatile uint32_t RxIPv6_Good_Packets_Low; /* CORE_RXIPV6_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xa90_0xa93;	   /* *UNDEFINED* */
	volatile uint32_t
		RxIPv6_Header_Error_Packets_Low;	  /* CORE_RXIPV6_HEADER_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xa98_0xa9b;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv6_No_Payload_Packets_Low;  /* CORE_RXIPV6_NO_PAYLOAD_PACKETS_LOW */
	volatile uint32_t _pad_0xaa0_0xaa3;		  /* *UNDEFINED* */
	volatile uint32_t RxUDP_Good_Packets_Low;	  /* CORE_RXUDP_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xaa8_0xaab;		  /* *UNDEFINED* */
	volatile uint32_t RxUDP_Error_Packets_Low;	  /* CORE_RXUDP_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xab0_0xab3;		  /* *UNDEFINED* */
	volatile uint32_t RxTCP_Good_Packets_Low;	  /* CORE_RXTCP_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xab8_0xabb;		  /* *UNDEFINED* */
	volatile uint32_t RxTCP_Error_Packets_Low;	  /* CORE_RXTCP_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xac0_0xac3;		  /* *UNDEFINED* */
	volatile uint32_t RxICMP_Good_Packets_Low;	  /* CORE_RXICMP_GOOD_PACKETS_LOW */
	volatile uint32_t _pad_0xac8_0xacb;		  /* *UNDEFINED* */
	volatile uint32_t RxICMP_Error_Packets_Low;	  /* CORE_RXICMP_ERROR_PACKETS_LOW */
	volatile uint32_t _pad_0xad0_0xad3;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv4_Good_Octets_Low;	  /* CORE_RXIPV4_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xad8_0xadb;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv4_Header_Error_Octets_Low; /* CORE_RXIPV4_HEADER_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xae0_0xae3;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv4_No_Payload_Octets_Low;	  /* CORE_RXIPV4_NO_PAYLOAD_OCTETS_LOW */
	volatile uint32_t _pad_0xae8_0xaeb;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv4_Fragmented_Octets_Low;	  /* CORE_RXIPV4_FRAGMENTED_OCTETS_LOW */
	volatile uint32_t _pad_0xaf0_0xaf3;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv4_UDP_Checksum_Disable_Octets_Low; /* CORE_RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW
								   */
	volatile uint32_t _pad_0xaf8_0xafb;			  /* *UNDEFINED* */
	volatile uint32_t RxIPv6_Good_Octets_Low;		  /* CORE_RXIPV6_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb00_0xb03;			  /* *UNDEFINED* */
	volatile uint32_t RxIPv6_Header_Error_Octets_Low; /* CORE_RXIPV6_HEADER_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb08_0xb0b;		  /* *UNDEFINED* */
	volatile uint32_t RxIPv6_No_Payload_Octets_Low;	  /* CORE_RXIPV6_NO_PAYLOAD_OCTETS_LOW */
	volatile uint32_t _pad_0xb10_0xb13;		  /* *UNDEFINED* */
	volatile uint32_t RxUDP_Good_Octets_Low;	  /* CORE_RXUDP_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb18_0xb1b;		  /* *UNDEFINED* */
	volatile uint32_t RxUDP_Error_Octets_Low;	  /* CORE_RXUDP_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb20_0xb23;		  /* *UNDEFINED* */
	volatile uint32_t RxTCP_Good_Octets_Low;	  /* CORE_RXTCP_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb28_0xb2b;		  /* *UNDEFINED* */
	volatile uint32_t RxTCP_Error_Octets_Low;	  /* CORE_RXTCP_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb30_0xb33;		  /* *UNDEFINED* */
	volatile uint32_t RxICMP_Good_Octets_Low;	  /* CORE_RXICMP_GOOD_OCTETS_LOW */
	volatile uint32_t _pad_0xb38_0xb3b;		  /* *UNDEFINED* */
	volatile uint32_t RxICMP_Error_Octets_Low;	  /* CORE_RXICMP_ERROR_OCTETS_LOW */
	volatile uint32_t _pad_0xb40_0xbff[48];		  /* *UNDEFINED* */
	volatile uint32_t MAC_L3_L4_Address_Control;	  /* CORE_MAC_L3_L4_ADDRESS_CONTROL */
	volatile uint32_t MAC_L3_L4_Data;		  /* CORE_MAC_L3_L4_DATA */
	volatile uint32_t _pad_0xc08_0xc0f[2];		  /* *UNDEFINED* */
	volatile uint32_t MAC_ARP_Address;		  /* CORE_MAC_ARP_ADDRESS */
	volatile uint32_t _pad_0xc14_0xcff[59];		  /* *UNDEFINED* */
	volatile uint32_t MAC_Timestamp_Control;	  /* CORE_MAC_TIMESTAMP_CONTROL */
	volatile uint32_t MAC_Sub_Second_Increment;	  /* CORE_MAC_SUB_SECOND_INCREMENT */
	volatile uint32_t MAC_System_Time_Seconds;	  /* CORE_MAC_SYSTEM_TIME_SECONDS */
	volatile uint32_t MAC_System_Time_Nanoseconds;	  /* CORE_MAC_SYSTEM_TIME_NANOSECONDS */
	volatile uint32_t MAC_System_Time_Seconds_Update; /* CORE_MAC_SYSTEM_TIME_SECONDS_UPDATE */
	volatile uint32_t
		MAC_System_Time_Nanoseconds_Update; /* CORE_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE */
	volatile uint32_t MAC_Timestamp_Addend;	    /* CORE_MAC_TIMESTAMP_ADDEND */
	volatile uint32_t
		MAC_System_Time_Higher_Word_Seconds; /* CORE_MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS */
	volatile uint32_t MAC_Timestamp_Status;	     /* CORE_MAC_TIMESTAMP_STATUS */
	volatile uint32_t _pad_0xd24_0xd2f[3];	     /* *UNDEFINED* */
	volatile uint32_t
		MAC_Tx_Timestamp_Status_Nanoseconds; /* CORE_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS */
	volatile uint32_t
		MAC_Tx_Timestamp_Status_Seconds;	 /* CORE_MAC_TX_TIMESTAMP_STATUS_SECONDS */
	volatile uint32_t MAC_Tx_Timestamp_Status_PktID; /* CORE_MAC_TX_TIMESTAMP_STATUS_PKTID */
	volatile uint32_t _pad_0xd3c_0xd3f;		 /* *UNDEFINED* */
	volatile uint32_t MAC_Auxiliary_Control;	 /* CORE_MAC_AUXILIARY_CONTROL */
	volatile uint32_t _pad_0xd44_0xd47;		 /* *UNDEFINED* */
	volatile uint32_t
		MAC_Auxiliary_Timestamp_Nanoseconds; /* CORE_MAC_AUXILIARY_TIMESTAMP_NANOSECONDS */
	volatile uint32_t
		MAC_Auxiliary_Timestamp_Seconds; /* CORE_MAC_AUXILIARY_TIMESTAMP_SECONDS */
	volatile uint32_t
		MAC_Timestamp_Ingress_Asym_Corr;	  /* CORE_MAC_TIMESTAMP_INGRESS_ASYM_CORR */
	volatile uint32_t MAC_Timestamp_Egress_Asym_Corr; /* CORE_MAC_TIMESTAMP_EGRESS_ASYM_CORR */
	volatile uint32_t MAC_Timestamp_Ingress_Corr_Nanosecond; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND
								  */
	volatile uint32_t MAC_Timestamp_Ingress_Corr_Subnanosecond; /* CORE_MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND
								     */
	volatile uint32_t MAC_Timestamp_Egress_Corr_Nanosecond; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND
								 */
	volatile uint32_t MAC_Timestamp_Egress_Corr_Subnanosecond; /* CORE_MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND
								    */
	volatile uint32_t _pad_0xd68_0xd6f[2];			   /* *UNDEFINED* */
	volatile uint32_t MAC_PPS_Control;			   /* CORE_MAC_PPS_CONTROL */
	volatile uint32_t _pad_0xd74_0xd7f[3];			   /* *UNDEFINED* */
	volatile uint32_t MAC_PPS0_Target_Time_Seconds; /* CORE_MAC_PPS0_TARGET_TIME_SECONDS */
	volatile uint32_t
		MAC_PPS0_Target_Time_Nanoseconds;	/* CORE_MAC_PPS0_TARGET_TIME_NANOSECONDS */
	volatile uint32_t MAC_PPS0_Interval;		/* CORE_MAC_PPS0_INTERVAL */
	volatile uint32_t MAC_PPS0_Width;		/* CORE_MAC_PPS0_WIDTH */
	volatile uint32_t MAC_PPS1_Target_Time_Seconds; /* CORE_MAC_PPS1_TARGET_TIME_SECONDS */
	volatile uint32_t
		MAC_PPS1_Target_Time_Nanoseconds;    /* CORE_MAC_PPS1_TARGET_TIME_NANOSECONDS */
	volatile uint32_t MAC_PPS1_Interval;	     /* CORE_MAC_PPS1_INTERVAL */
	volatile uint32_t MAC_PPS1_Width;	     /* CORE_MAC_PPS1_WIDTH */
	volatile uint32_t _pad_0xda0_0xdbf[8];	     /* *UNDEFINED* */
	volatile uint32_t MAC_PTO_Control;	     /* CORE_MAC_PTO_CONTROL */
	volatile uint32_t MAC_Source_Port_Identity0; /* CORE_MAC_SOURCE_PORT_IDENTITY0 */
	volatile uint32_t MAC_Source_Port_Identity1; /* CORE_MAC_SOURCE_PORT_IDENTITY1 */
	volatile uint32_t MAC_Source_Port_Identity2; /* CORE_MAC_SOURCE_PORT_IDENTITY2 */
	volatile uint32_t MAC_Log_Message_Interval;  /* CORE_MAC_LOG_MESSAGE_INTERVAL */
	volatile uint32_t _pad_0xdd4_0x1000[139];    /* *UNDEFINED* */
};

/* The typedef declaration for the raw register contents of register group CORE. */
typedef struct CORE_raw_s CORE_raw_t;
#endif /* __ASSEMBLY__ */

/*
 * Component : DWCCXG_MTL
 * Mac Transaction Layer (MTL) Common/General Registers.
 *
 */
/*
 * Register : MTL_Operation_Mode
 *
 * The Operation Mode register establishes the Transmit and Receive operating modes
 * and commands.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------
 *  [0]    | R      | 0x0   | MTL_OPERATION_MODE_RESERVED_0
 *  [1]    | R      | 0x0   | MTL_OPERATION_MODE_RESERVED_FTS
 *  [2]    | RW     | 0x0   | MTL_OPERATION_MODE_RAA
 *  [4:3]  | R      | 0x0   | MTL_OPERATION_MODE_RESERVED_4_3
 *  [6:5]  | RW     | 0x0   | MTL_OPERATION_MODE_ETSALG
 *  [31:7] | R      | 0x0   | MTL_OPERATION_MODE_RESERVED_31_7
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_OPERATION_MODE_RESERVED_0 register field. */
#define MTL_OPERATION_MODE_RESERVED_0_LSB	 0
/* The Most Significant Bit (MSB) position of the MTL_OPERATION_MODE_RESERVED_0 register field. */
#define MTL_OPERATION_MODE_RESERVED_0_MSB	 0
/* The width in bits of the MTL_OPERATION_MODE_RESERVED_0 register field. */
#define MTL_OPERATION_MODE_RESERVED_0_WIDTH	 1
/* The mask used to set the MTL_OPERATION_MODE_RESERVED_0 register field value. */
#define MTL_OPERATION_MODE_RESERVED_0_SET_MSK	 0x00000001
/* The mask used to clear the MTL_OPERATION_MODE_RESERVED_0 register field value. */
#define MTL_OPERATION_MODE_RESERVED_0_CLR_MSK	 0xfffffffe
/* The reset value of the MTL_OPERATION_MODE_RESERVED_0 register field. */
#define MTL_OPERATION_MODE_RESERVED_0_RESET	 0x0
/* Extracts the MTL_OPERATION_MODE_RESERVED_0 field value from a register. */
#define MTL_OPERATION_MODE_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_OPERATION_MODE_RESERVED_0 register field value suitable for setting the register.
 */
#define MTL_OPERATION_MODE_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_FTS
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_OPERATION_MODE_RESERVED_FTS register field.
 */
#define MTL_OPERATION_MODE_RESERVED_FTS_LSB	   1
/* The Most Significant Bit (MSB) position of the MTL_OPERATION_MODE_RESERVED_FTS register field. */
#define MTL_OPERATION_MODE_RESERVED_FTS_MSB	   1
/* The width in bits of the MTL_OPERATION_MODE_RESERVED_FTS register field. */
#define MTL_OPERATION_MODE_RESERVED_FTS_WIDTH	   1
/* The mask used to set the MTL_OPERATION_MODE_RESERVED_FTS register field value. */
#define MTL_OPERATION_MODE_RESERVED_FTS_SET_MSK	   0x00000002
/* The mask used to clear the MTL_OPERATION_MODE_RESERVED_FTS register field value. */
#define MTL_OPERATION_MODE_RESERVED_FTS_CLR_MSK	   0xfffffffd
/* The reset value of the MTL_OPERATION_MODE_RESERVED_FTS register field. */
#define MTL_OPERATION_MODE_RESERVED_FTS_RESET	   0x0
/* Extracts the MTL_OPERATION_MODE_RESERVED_FTS field value from a register. */
#define MTL_OPERATION_MODE_RESERVED_FTS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_OPERATION_MODE_RESERVED_FTS register field value suitable for setting the
 * register. */
#define MTL_OPERATION_MODE_RESERVED_FTS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : RAA
 *
 * Receive Arbitration Algorithm.
 *
 * This field is used to select the arbitration algorithm for the Rx side.
 *
 * * 0: Strict Priority (SP)
 *
 * Queue 0 has the lowest priority and the last queue has the highest priority.
 *
 * * 1: Weighted Strict Priority (WSP)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_OPERATION_MODE_RAA register field. */
#define MTL_OPERATION_MODE_RAA_LSB	  2
/* The Most Significant Bit (MSB) position of the MTL_OPERATION_MODE_RAA register field. */
#define MTL_OPERATION_MODE_RAA_MSB	  2
/* The width in bits of the MTL_OPERATION_MODE_RAA register field. */
#define MTL_OPERATION_MODE_RAA_WIDTH	  1
/* The mask used to set the MTL_OPERATION_MODE_RAA register field value. */
#define MTL_OPERATION_MODE_RAA_SET_MSK	  0x00000004
/* The mask used to clear the MTL_OPERATION_MODE_RAA register field value. */
#define MTL_OPERATION_MODE_RAA_CLR_MSK	  0xfffffffb
/* The reset value of the MTL_OPERATION_MODE_RAA register field. */
#define MTL_OPERATION_MODE_RAA_RESET	  0x0
/* Extracts the MTL_OPERATION_MODE_RAA field value from a register. */
#define MTL_OPERATION_MODE_RAA_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_OPERATION_MODE_RAA register field value suitable for setting the register. */
#define MTL_OPERATION_MODE_RAA_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_4_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_OPERATION_MODE_RESERVED_4_3 register field.
 */
#define MTL_OPERATION_MODE_RESERVED_4_3_LSB	   3
/* The Most Significant Bit (MSB) position of the MTL_OPERATION_MODE_RESERVED_4_3 register field. */
#define MTL_OPERATION_MODE_RESERVED_4_3_MSB	   4
/* The width in bits of the MTL_OPERATION_MODE_RESERVED_4_3 register field. */
#define MTL_OPERATION_MODE_RESERVED_4_3_WIDTH	   2
/* The mask used to set the MTL_OPERATION_MODE_RESERVED_4_3 register field value. */
#define MTL_OPERATION_MODE_RESERVED_4_3_SET_MSK	   0x00000018
/* The mask used to clear the MTL_OPERATION_MODE_RESERVED_4_3 register field value. */
#define MTL_OPERATION_MODE_RESERVED_4_3_CLR_MSK	   0xffffffe7
/* The reset value of the MTL_OPERATION_MODE_RESERVED_4_3 register field. */
#define MTL_OPERATION_MODE_RESERVED_4_3_RESET	   0x0
/* Extracts the MTL_OPERATION_MODE_RESERVED_4_3 field value from a register. */
#define MTL_OPERATION_MODE_RESERVED_4_3_GET(value) (((value)&0x00000018) >> 3)
/* Produces a MTL_OPERATION_MODE_RESERVED_4_3 register field value suitable for setting the
 * register. */
#define MTL_OPERATION_MODE_RESERVED_4_3_SET(value) (((value) << 3) & 0x00000018)

/*
 * Field : ETSALG
 *
 * ETS Algorithm.
 *
 * This field selects the type of ETS algorithm to be applied for traffic classes
 * whose transmission selection algorithm (TSA) is set to ETS:
 *
 * * 2'b00: WRR algorithm
 *
 * * 2'b01: WFQ algorithm when Data Center Bridging feature is selected. Otherwise,
 *   reserved
 *
 * * 2'b10: DWRR algorithm when Data Center Bridging feature is selected.
 *   Otherwise, reserved.
 *
 * * 2'b11: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_OPERATION_MODE_ETSALG register field. */
#define MTL_OPERATION_MODE_ETSALG_LSB	     5
/* The Most Significant Bit (MSB) position of the MTL_OPERATION_MODE_ETSALG register field. */
#define MTL_OPERATION_MODE_ETSALG_MSB	     6
/* The width in bits of the MTL_OPERATION_MODE_ETSALG register field. */
#define MTL_OPERATION_MODE_ETSALG_WIDTH	     2
/* The mask used to set the MTL_OPERATION_MODE_ETSALG register field value. */
#define MTL_OPERATION_MODE_ETSALG_SET_MSK    0x00000060
/* The mask used to clear the MTL_OPERATION_MODE_ETSALG register field value. */
#define MTL_OPERATION_MODE_ETSALG_CLR_MSK    0xffffff9f
/* The reset value of the MTL_OPERATION_MODE_ETSALG register field. */
#define MTL_OPERATION_MODE_ETSALG_RESET	     0x0
/* Extracts the MTL_OPERATION_MODE_ETSALG field value from a register. */
#define MTL_OPERATION_MODE_ETSALG_GET(value) (((value)&0x00000060) >> 5)
/* Produces a MTL_OPERATION_MODE_ETSALG register field value suitable for setting the register. */
#define MTL_OPERATION_MODE_ETSALG_SET(value) (((value) << 5) & 0x00000060)

/*
 * Field : Reserved_31_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_OPERATION_MODE_RESERVED_31_7 register field.
 */
#define MTL_OPERATION_MODE_RESERVED_31_7_LSB	    7
/* The Most Significant Bit (MSB) position of the MTL_OPERATION_MODE_RESERVED_31_7 register field.
 */
#define MTL_OPERATION_MODE_RESERVED_31_7_MSB	    31
/* The width in bits of the MTL_OPERATION_MODE_RESERVED_31_7 register field. */
#define MTL_OPERATION_MODE_RESERVED_31_7_WIDTH	    25
/* The mask used to set the MTL_OPERATION_MODE_RESERVED_31_7 register field value. */
#define MTL_OPERATION_MODE_RESERVED_31_7_SET_MSK    0xffffff80
/* The mask used to clear the MTL_OPERATION_MODE_RESERVED_31_7 register field value. */
#define MTL_OPERATION_MODE_RESERVED_31_7_CLR_MSK    0x0000007f
/* The reset value of the MTL_OPERATION_MODE_RESERVED_31_7 register field. */
#define MTL_OPERATION_MODE_RESERVED_31_7_RESET	    0x0
/* Extracts the MTL_OPERATION_MODE_RESERVED_31_7 field value from a register. */
#define MTL_OPERATION_MODE_RESERVED_31_7_GET(value) (((value)&0xffffff80) >> 7)
/* Produces a MTL_OPERATION_MODE_RESERVED_31_7 register field value suitable for setting the
 * register. */
#define MTL_OPERATION_MODE_RESERVED_31_7_SET(value) (((value) << 7) & 0xffffff80)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_OPERATION_MODE.
 */
struct MTL_OPERATION_MODE_s {
	const volatile uint32_t Reserved_0 : 1;	    /* MTL_OPERATION_MODE_RESERVED_0 */
	const volatile uint32_t Reserved_FTS : 1;   /* MTL_OPERATION_MODE_RESERVED_FTS */
	volatile uint32_t RAA : 1;		    /* MTL_OPERATION_MODE_RAA */
	const volatile uint32_t Reserved_4_3 : 2;   /* MTL_OPERATION_MODE_RESERVED_4_3 */
	volatile uint32_t ETSALG : 2;		    /* MTL_OPERATION_MODE_ETSALG */
	const volatile uint32_t Reserved_31_7 : 25; /* MTL_OPERATION_MODE_RESERVED_31_7 */
};

/* The typedef declaration for register MTL_OPERATION_MODE. */
typedef struct MTL_OPERATION_MODE_s MTL_OPERATION_MODE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_OPERATION_MODE register. */
#define MTL_OPERATION_MODE_RESET 0x00000000
/* The byte offset of the MTL_OPERATION_MODE register from the beginning of the component. */
#define MTL_OPERATION_MODE_OFST	 0x0

/*
 * Register : MTL_Interrupt_Status
 *
 * The software driver (application) reads this register during interrupt service
 * routine or polling to determine the interrupt status of MTL queues and the MAC.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [0]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q0IS
 *  [1]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q1IS
 *  [2]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q2IS
 *  [3]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q3IS
 *  [4]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q4IS
 *  [5]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q5IS
 *  [6]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q6IS
 *  [7]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q7IS
 *  [8]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q8IS
 *  [9]     | R      | 0x0   | MTL_INTERRUPT_STATUS_Q9IS
 *  [10]    | R      | 0x0   | MTL_INTERRUPT_STATUS_Q10IS
 *  [11]    | R      | 0x0   | MTL_INTERRUPT_STATUS_Q11IS
 *  [12]    | R      | 0x0   | MTL_INTERRUPT_STATUS_Q12IS
 *  [13]    | R      | 0x0   | MTL_INTERRUPT_STATUS_Q13IS
 *  [14]    | R      | 0x0   | MTL_INTERRUPT_STATUS_Q14IS
 *  [15]    | R      | 0x0   | MTL_INTERRUPT_STATUS_Q15IS
 *  [16]    | R      | 0x0   | MTL_INTERRUPT_STATUS_MACIS
 *  [17]    | R      | 0x0   | MTL_INTERRUPT_STATUS_DBGIS
 *  [18]    | R      | 0x0   | MTL_INTERRUPT_STATUS_ESTIS
 *  [19]    | R      | 0x0   | MTL_INTERRUPT_STATUS_TINS
 *  [20]    | R      | 0x0   | MTL_INTERRUPT_STATUS_RESERVED_SGFIS
 *  [22:21] | R      | 0x0   | MTL_INTERRUPT_STATUS_RESERVED_22_21
 *  [23]    | R      | 0x0   | MTL_INTERRUPT_STATUS_RESERVED_MTLPIS
 *  [31:24] | R      | 0x0   | MTL_INTERRUPT_STATUS_RESERVED_31_24
 *
 */
/*
 * Field : Q0IS
 *
 * Traffic Class/Queue 0 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 0. To
 * reset this bit, the software must read Traffic Class/Queue 0 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q0IS register field. */
#define MTL_INTERRUPT_STATUS_Q0IS_LSB	     0
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q0IS register field. */
#define MTL_INTERRUPT_STATUS_Q0IS_MSB	     0
/* The width in bits of the MTL_INTERRUPT_STATUS_Q0IS register field. */
#define MTL_INTERRUPT_STATUS_Q0IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q0IS register field value. */
#define MTL_INTERRUPT_STATUS_Q0IS_SET_MSK    0x00000001
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q0IS register field value. */
#define MTL_INTERRUPT_STATUS_Q0IS_CLR_MSK    0xfffffffe
/* The reset value of the MTL_INTERRUPT_STATUS_Q0IS register field. */
#define MTL_INTERRUPT_STATUS_Q0IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q0IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q0IS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_INTERRUPT_STATUS_Q0IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q0IS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Q1IS
 *
 * Traffic Class/Queue 1 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 1. To
 * reset this bit, the software must read Traffic Class/Queue 1 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q1IS register field. */
#define MTL_INTERRUPT_STATUS_Q1IS_LSB	     1
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q1IS register field. */
#define MTL_INTERRUPT_STATUS_Q1IS_MSB	     1
/* The width in bits of the MTL_INTERRUPT_STATUS_Q1IS register field. */
#define MTL_INTERRUPT_STATUS_Q1IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q1IS register field value. */
#define MTL_INTERRUPT_STATUS_Q1IS_SET_MSK    0x00000002
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q1IS register field value. */
#define MTL_INTERRUPT_STATUS_Q1IS_CLR_MSK    0xfffffffd
/* The reset value of the MTL_INTERRUPT_STATUS_Q1IS register field. */
#define MTL_INTERRUPT_STATUS_Q1IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q1IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q1IS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_INTERRUPT_STATUS_Q1IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q1IS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Q2IS
 *
 * Traffic Class/Queue 2 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 2. To
 * reset this bit, the software must read Traffic Class/Queue 2 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q2IS register field. */
#define MTL_INTERRUPT_STATUS_Q2IS_LSB	     2
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q2IS register field. */
#define MTL_INTERRUPT_STATUS_Q2IS_MSB	     2
/* The width in bits of the MTL_INTERRUPT_STATUS_Q2IS register field. */
#define MTL_INTERRUPT_STATUS_Q2IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q2IS register field value. */
#define MTL_INTERRUPT_STATUS_Q2IS_SET_MSK    0x00000004
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q2IS register field value. */
#define MTL_INTERRUPT_STATUS_Q2IS_CLR_MSK    0xfffffffb
/* The reset value of the MTL_INTERRUPT_STATUS_Q2IS register field. */
#define MTL_INTERRUPT_STATUS_Q2IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q2IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q2IS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_INTERRUPT_STATUS_Q2IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q2IS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Q3IS
 *
 * Traffic Class/Queue 3 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 3. To
 * reset this bit, the software must read Traffic Class/Queue 3 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q3IS register field. */
#define MTL_INTERRUPT_STATUS_Q3IS_LSB	     3
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q3IS register field. */
#define MTL_INTERRUPT_STATUS_Q3IS_MSB	     3
/* The width in bits of the MTL_INTERRUPT_STATUS_Q3IS register field. */
#define MTL_INTERRUPT_STATUS_Q3IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q3IS register field value. */
#define MTL_INTERRUPT_STATUS_Q3IS_SET_MSK    0x00000008
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q3IS register field value. */
#define MTL_INTERRUPT_STATUS_Q3IS_CLR_MSK    0xfffffff7
/* The reset value of the MTL_INTERRUPT_STATUS_Q3IS register field. */
#define MTL_INTERRUPT_STATUS_Q3IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q3IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q3IS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_INTERRUPT_STATUS_Q3IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q3IS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Q4IS
 *
 * Traffic Class/Queue 4 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 4. To
 * reset this bit, the software must read Traffic Class/Queue 4 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q4IS register field. */
#define MTL_INTERRUPT_STATUS_Q4IS_LSB	     4
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q4IS register field. */
#define MTL_INTERRUPT_STATUS_Q4IS_MSB	     4
/* The width in bits of the MTL_INTERRUPT_STATUS_Q4IS register field. */
#define MTL_INTERRUPT_STATUS_Q4IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q4IS register field value. */
#define MTL_INTERRUPT_STATUS_Q4IS_SET_MSK    0x00000010
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q4IS register field value. */
#define MTL_INTERRUPT_STATUS_Q4IS_CLR_MSK    0xffffffef
/* The reset value of the MTL_INTERRUPT_STATUS_Q4IS register field. */
#define MTL_INTERRUPT_STATUS_Q4IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q4IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q4IS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_INTERRUPT_STATUS_Q4IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q4IS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Q5IS
 *
 * Traffic Class/Queue 5 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from traffic Class/Queue 5. To
 * reset this bit, the software must read traffic Class/Queue 5 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q5IS register field. */
#define MTL_INTERRUPT_STATUS_Q5IS_LSB	     5
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q5IS register field. */
#define MTL_INTERRUPT_STATUS_Q5IS_MSB	     5
/* The width in bits of the MTL_INTERRUPT_STATUS_Q5IS register field. */
#define MTL_INTERRUPT_STATUS_Q5IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q5IS register field value. */
#define MTL_INTERRUPT_STATUS_Q5IS_SET_MSK    0x00000020
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q5IS register field value. */
#define MTL_INTERRUPT_STATUS_Q5IS_CLR_MSK    0xffffffdf
/* The reset value of the MTL_INTERRUPT_STATUS_Q5IS register field. */
#define MTL_INTERRUPT_STATUS_Q5IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q5IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q5IS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a MTL_INTERRUPT_STATUS_Q5IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q5IS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Q6IS
 *
 * Traffic Class/Queue 6 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 6. To
 * reset this bit, the software must read Traffic Class/Queue 6 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q6IS register field. */
#define MTL_INTERRUPT_STATUS_Q6IS_LSB	     6
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q6IS register field. */
#define MTL_INTERRUPT_STATUS_Q6IS_MSB	     6
/* The width in bits of the MTL_INTERRUPT_STATUS_Q6IS register field. */
#define MTL_INTERRUPT_STATUS_Q6IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q6IS register field value. */
#define MTL_INTERRUPT_STATUS_Q6IS_SET_MSK    0x00000040
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q6IS register field value. */
#define MTL_INTERRUPT_STATUS_Q6IS_CLR_MSK    0xffffffbf
/* The reset value of the MTL_INTERRUPT_STATUS_Q6IS register field. */
#define MTL_INTERRUPT_STATUS_Q6IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q6IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q6IS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a MTL_INTERRUPT_STATUS_Q6IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q6IS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : Q7IS
 *
 * Traffic Class/Queue 7 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Traffic Class/Queue 7. To
 * reset this bit, the software must read Traffic Class/Queue 7 Interrupt Control
 * and Status register to get the exact cause of the interrupt and clear its
 * source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q7IS register field. */
#define MTL_INTERRUPT_STATUS_Q7IS_LSB	     7
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q7IS register field. */
#define MTL_INTERRUPT_STATUS_Q7IS_MSB	     7
/* The width in bits of the MTL_INTERRUPT_STATUS_Q7IS register field. */
#define MTL_INTERRUPT_STATUS_Q7IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q7IS register field value. */
#define MTL_INTERRUPT_STATUS_Q7IS_SET_MSK    0x00000080
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q7IS register field value. */
#define MTL_INTERRUPT_STATUS_Q7IS_CLR_MSK    0xffffff7f
/* The reset value of the MTL_INTERRUPT_STATUS_Q7IS register field. */
#define MTL_INTERRUPT_STATUS_Q7IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q7IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q7IS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_INTERRUPT_STATUS_Q7IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q7IS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Q8IS
 *
 * Queue 8 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 8. To reset this bit,
 * the software must read Queue 8 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q8IS register field. */
#define MTL_INTERRUPT_STATUS_Q8IS_LSB	     8
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q8IS register field. */
#define MTL_INTERRUPT_STATUS_Q8IS_MSB	     8
/* The width in bits of the MTL_INTERRUPT_STATUS_Q8IS register field. */
#define MTL_INTERRUPT_STATUS_Q8IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q8IS register field value. */
#define MTL_INTERRUPT_STATUS_Q8IS_SET_MSK    0x00000100
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q8IS register field value. */
#define MTL_INTERRUPT_STATUS_Q8IS_CLR_MSK    0xfffffeff
/* The reset value of the MTL_INTERRUPT_STATUS_Q8IS register field. */
#define MTL_INTERRUPT_STATUS_Q8IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q8IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q8IS_GET(value) (((value)&0x00000100) >> 8)
/* Produces a MTL_INTERRUPT_STATUS_Q8IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q8IS_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : Q9IS
 *
 * Queue 9 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 9. To reset this bit,
 * the software must read Queue 9 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q9IS register field. */
#define MTL_INTERRUPT_STATUS_Q9IS_LSB	     9
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q9IS register field. */
#define MTL_INTERRUPT_STATUS_Q9IS_MSB	     9
/* The width in bits of the MTL_INTERRUPT_STATUS_Q9IS register field. */
#define MTL_INTERRUPT_STATUS_Q9IS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q9IS register field value. */
#define MTL_INTERRUPT_STATUS_Q9IS_SET_MSK    0x00000200
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q9IS register field value. */
#define MTL_INTERRUPT_STATUS_Q9IS_CLR_MSK    0xfffffdff
/* The reset value of the MTL_INTERRUPT_STATUS_Q9IS register field. */
#define MTL_INTERRUPT_STATUS_Q9IS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q9IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q9IS_GET(value) (((value)&0x00000200) >> 9)
/* Produces a MTL_INTERRUPT_STATUS_Q9IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q9IS_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : Q10IS
 *
 * Queue 10 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 10. To reset this bit,
 * the software must read Queue 10 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q10IS register field. */
#define MTL_INTERRUPT_STATUS_Q10IS_LSB	      10
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q10IS register field. */
#define MTL_INTERRUPT_STATUS_Q10IS_MSB	      10
/* The width in bits of the MTL_INTERRUPT_STATUS_Q10IS register field. */
#define MTL_INTERRUPT_STATUS_Q10IS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q10IS register field value. */
#define MTL_INTERRUPT_STATUS_Q10IS_SET_MSK    0x00000400
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q10IS register field value. */
#define MTL_INTERRUPT_STATUS_Q10IS_CLR_MSK    0xfffffbff
/* The reset value of the MTL_INTERRUPT_STATUS_Q10IS register field. */
#define MTL_INTERRUPT_STATUS_Q10IS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q10IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q10IS_GET(value) (((value)&0x00000400) >> 10)
/* Produces a MTL_INTERRUPT_STATUS_Q10IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q10IS_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : Q11IS
 *
 * Queue 11 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 11. To reset this bit,
 * the software must read Queue 11 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q11IS register field. */
#define MTL_INTERRUPT_STATUS_Q11IS_LSB	      11
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q11IS register field. */
#define MTL_INTERRUPT_STATUS_Q11IS_MSB	      11
/* The width in bits of the MTL_INTERRUPT_STATUS_Q11IS register field. */
#define MTL_INTERRUPT_STATUS_Q11IS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q11IS register field value. */
#define MTL_INTERRUPT_STATUS_Q11IS_SET_MSK    0x00000800
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q11IS register field value. */
#define MTL_INTERRUPT_STATUS_Q11IS_CLR_MSK    0xfffff7ff
/* The reset value of the MTL_INTERRUPT_STATUS_Q11IS register field. */
#define MTL_INTERRUPT_STATUS_Q11IS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q11IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q11IS_GET(value) (((value)&0x00000800) >> 11)
/* Produces a MTL_INTERRUPT_STATUS_Q11IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q11IS_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : Q12IS
 *
 * Queue 12 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 12. To reset this bit,
 * the software must read Queue 12 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q12IS register field. */
#define MTL_INTERRUPT_STATUS_Q12IS_LSB	      12
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q12IS register field. */
#define MTL_INTERRUPT_STATUS_Q12IS_MSB	      12
/* The width in bits of the MTL_INTERRUPT_STATUS_Q12IS register field. */
#define MTL_INTERRUPT_STATUS_Q12IS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q12IS register field value. */
#define MTL_INTERRUPT_STATUS_Q12IS_SET_MSK    0x00001000
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q12IS register field value. */
#define MTL_INTERRUPT_STATUS_Q12IS_CLR_MSK    0xffffefff
/* The reset value of the MTL_INTERRUPT_STATUS_Q12IS register field. */
#define MTL_INTERRUPT_STATUS_Q12IS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q12IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q12IS_GET(value) (((value)&0x00001000) >> 12)
/* Produces a MTL_INTERRUPT_STATUS_Q12IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q12IS_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : Q13IS
 *
 * Queue 13 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 13. To reset this bit,
 * the software must read Queue 13 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q13IS register field. */
#define MTL_INTERRUPT_STATUS_Q13IS_LSB	      13
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q13IS register field. */
#define MTL_INTERRUPT_STATUS_Q13IS_MSB	      13
/* The width in bits of the MTL_INTERRUPT_STATUS_Q13IS register field. */
#define MTL_INTERRUPT_STATUS_Q13IS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q13IS register field value. */
#define MTL_INTERRUPT_STATUS_Q13IS_SET_MSK    0x00002000
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q13IS register field value. */
#define MTL_INTERRUPT_STATUS_Q13IS_CLR_MSK    0xffffdfff
/* The reset value of the MTL_INTERRUPT_STATUS_Q13IS register field. */
#define MTL_INTERRUPT_STATUS_Q13IS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q13IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q13IS_GET(value) (((value)&0x00002000) >> 13)
/* Produces a MTL_INTERRUPT_STATUS_Q13IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q13IS_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : Q14IS
 *
 * Queue 14 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 14. To reset this bit,
 * the software must read Queue 14 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q14IS register field. */
#define MTL_INTERRUPT_STATUS_Q14IS_LSB	      14
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q14IS register field. */
#define MTL_INTERRUPT_STATUS_Q14IS_MSB	      14
/* The width in bits of the MTL_INTERRUPT_STATUS_Q14IS register field. */
#define MTL_INTERRUPT_STATUS_Q14IS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q14IS register field value. */
#define MTL_INTERRUPT_STATUS_Q14IS_SET_MSK    0x00004000
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q14IS register field value. */
#define MTL_INTERRUPT_STATUS_Q14IS_CLR_MSK    0xffffbfff
/* The reset value of the MTL_INTERRUPT_STATUS_Q14IS register field. */
#define MTL_INTERRUPT_STATUS_Q14IS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q14IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q14IS_GET(value) (((value)&0x00004000) >> 14)
/* Produces a MTL_INTERRUPT_STATUS_Q14IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q14IS_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : Q15IS
 *
 * Queue 15 Interrupt Status.
 *
 * This bit indicates that there is an interrupt from Queue 15. To reset this bit,
 * the software must read Queue 15 Interrupt Control and Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_Q15IS register field. */
#define MTL_INTERRUPT_STATUS_Q15IS_LSB	      15
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_Q15IS register field. */
#define MTL_INTERRUPT_STATUS_Q15IS_MSB	      15
/* The width in bits of the MTL_INTERRUPT_STATUS_Q15IS register field. */
#define MTL_INTERRUPT_STATUS_Q15IS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_Q15IS register field value. */
#define MTL_INTERRUPT_STATUS_Q15IS_SET_MSK    0x00008000
/* The mask used to clear the MTL_INTERRUPT_STATUS_Q15IS register field value. */
#define MTL_INTERRUPT_STATUS_Q15IS_CLR_MSK    0xffff7fff
/* The reset value of the MTL_INTERRUPT_STATUS_Q15IS register field. */
#define MTL_INTERRUPT_STATUS_Q15IS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_Q15IS field value from a register. */
#define MTL_INTERRUPT_STATUS_Q15IS_GET(value) (((value)&0x00008000) >> 15)
/* Produces a MTL_INTERRUPT_STATUS_Q15IS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_Q15IS_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : MACIS
 *
 * MAC Interrupt Status.
 *
 * This bit indicates an interrupt event in the MAC. To reset this bit to 1'b0, the
 * software must read the corresponding register in the MAC to get the exact cause
 * of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_MACIS register field. */
#define MTL_INTERRUPT_STATUS_MACIS_LSB	      16
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_MACIS register field. */
#define MTL_INTERRUPT_STATUS_MACIS_MSB	      16
/* The width in bits of the MTL_INTERRUPT_STATUS_MACIS register field. */
#define MTL_INTERRUPT_STATUS_MACIS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_MACIS register field value. */
#define MTL_INTERRUPT_STATUS_MACIS_SET_MSK    0x00010000
/* The mask used to clear the MTL_INTERRUPT_STATUS_MACIS register field value. */
#define MTL_INTERRUPT_STATUS_MACIS_CLR_MSK    0xfffeffff
/* The reset value of the MTL_INTERRUPT_STATUS_MACIS register field. */
#define MTL_INTERRUPT_STATUS_MACIS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_MACIS field value from a register. */
#define MTL_INTERRUPT_STATUS_MACIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a MTL_INTERRUPT_STATUS_MACIS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_MACIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : DBGIS
 *
 * Debug Interrupt Status.
 *
 * This bit indicates an interrupt event during the slave access. To reset this
 * bit, the software must read the FIFO Debug Access Status register to get the
 * exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_DBGIS register field. */
#define MTL_INTERRUPT_STATUS_DBGIS_LSB	      17
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_DBGIS register field. */
#define MTL_INTERRUPT_STATUS_DBGIS_MSB	      17
/* The width in bits of the MTL_INTERRUPT_STATUS_DBGIS register field. */
#define MTL_INTERRUPT_STATUS_DBGIS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_DBGIS register field value. */
#define MTL_INTERRUPT_STATUS_DBGIS_SET_MSK    0x00020000
/* The mask used to clear the MTL_INTERRUPT_STATUS_DBGIS register field value. */
#define MTL_INTERRUPT_STATUS_DBGIS_CLR_MSK    0xfffdffff
/* The reset value of the MTL_INTERRUPT_STATUS_DBGIS register field. */
#define MTL_INTERRUPT_STATUS_DBGIS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_DBGIS field value from a register. */
#define MTL_INTERRUPT_STATUS_DBGIS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a MTL_INTERRUPT_STATUS_DBGIS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_DBGIS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : ESTIS
 *
 * EST (TAS- IEEE 802.1Qbv) Interrupt Status
 *
 * This bit indicates an interrupt event during the operation of IEEE 802.1Qbv. To
 * reset this bit, the application must clear the error/event that has caused the
 * interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                         | Value | Description
 * :-------------------------------------------------------------|:------|:----------------------------------------------
 *  MTL_INTERRUPT_STATUS_ESTIS_E_INACTIVE | 0x0   | EST (TAS- 802.1Qbv) Interrupt status not
 * :                                                             |       | detected
 *  MTL_INTERRUPT_STATUS_ESTIS_E_ACTIVE   | 0x1   | EST (TAS- 802.1Qbv) Interrupt status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_INTERRUPT_STATUS_ESTIS
 *
 * EST (TAS- 802.1Qbv) Interrupt status not detected
 */
#define MTL_INTERRUPT_STATUS_ESTIS_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_INTERRUPT_STATUS_ESTIS
 *
 * EST (TAS- 802.1Qbv) Interrupt status detected
 */
#define MTL_INTERRUPT_STATUS_ESTIS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_ESTIS register field. */
#define MTL_INTERRUPT_STATUS_ESTIS_LSB	      18
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_ESTIS register field. */
#define MTL_INTERRUPT_STATUS_ESTIS_MSB	      18
/* The width in bits of the MTL_INTERRUPT_STATUS_ESTIS register field. */
#define MTL_INTERRUPT_STATUS_ESTIS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_ESTIS register field value. */
#define MTL_INTERRUPT_STATUS_ESTIS_SET_MSK    0x00040000
/* The mask used to clear the MTL_INTERRUPT_STATUS_ESTIS register field value. */
#define MTL_INTERRUPT_STATUS_ESTIS_CLR_MSK    0xfffbffff
/* The reset value of the MTL_INTERRUPT_STATUS_ESTIS register field. */
#define MTL_INTERRUPT_STATUS_ESTIS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_ESTIS field value from a register. */
#define MTL_INTERRUPT_STATUS_ESTIS_GET(value) (((value)&0x00040000) >> 18)
/* Produces a MTL_INTERRUPT_STATUS_ESTIS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_ESTIS_SET(value) (((value) << 18) & 0x00040000)

/*
 * Field : TINS
 *
 * TBS Interrupt Status
 *
 * This bit is set when a frame is dropped in any of the queues in TBS. Access
 * restriction applies. Clears on write of 1.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                        | Value | Description
 * :------------------------------------------------------------|:------|:----------------------------------
 *  MTL_INTERRUPT_STATUS_TINS_E_INACTIVE | 0x0   | TBS Interrupt status not detected
 *  MTL_INTERRUPT_STATUS_TINS_E_ACTIVE   | 0x1   | TBS Interrupt status detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_INTERRUPT_STATUS_TINS
 *
 * TBS Interrupt status not detected
 */
#define MTL_INTERRUPT_STATUS_TINS_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_INTERRUPT_STATUS_TINS
 *
 * TBS Interrupt status detected
 */
#define MTL_INTERRUPT_STATUS_TINS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_TINS register field. */
#define MTL_INTERRUPT_STATUS_TINS_LSB	     19
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_TINS register field. */
#define MTL_INTERRUPT_STATUS_TINS_MSB	     19
/* The width in bits of the MTL_INTERRUPT_STATUS_TINS register field. */
#define MTL_INTERRUPT_STATUS_TINS_WIDTH	     1
/* The mask used to set the MTL_INTERRUPT_STATUS_TINS register field value. */
#define MTL_INTERRUPT_STATUS_TINS_SET_MSK    0x00080000
/* The mask used to clear the MTL_INTERRUPT_STATUS_TINS register field value. */
#define MTL_INTERRUPT_STATUS_TINS_CLR_MSK    0xfff7ffff
/* The reset value of the MTL_INTERRUPT_STATUS_TINS register field. */
#define MTL_INTERRUPT_STATUS_TINS_RESET	     0x0
/* Extracts the MTL_INTERRUPT_STATUS_TINS field value from a register. */
#define MTL_INTERRUPT_STATUS_TINS_GET(value) (((value)&0x00080000) >> 19)
/* Produces a MTL_INTERRUPT_STATUS_TINS register field value suitable for setting the register. */
#define MTL_INTERRUPT_STATUS_TINS_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : Reserved_SGFIS
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_RESERVED_SGFIS register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_LSB	       20
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_RESERVED_SGFIS register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_MSB	       20
/* The width in bits of the MTL_INTERRUPT_STATUS_RESERVED_SGFIS register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_WIDTH      1
/* The mask used to set the MTL_INTERRUPT_STATUS_RESERVED_SGFIS register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_SET_MSK    0x00100000
/* The mask used to clear the MTL_INTERRUPT_STATUS_RESERVED_SGFIS register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_CLR_MSK    0xffefffff
/* The reset value of the MTL_INTERRUPT_STATUS_RESERVED_SGFIS register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_RESERVED_SGFIS field value from a register. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_GET(value) (((value)&0x00100000) >> 20)
/* Produces a MTL_INTERRUPT_STATUS_RESERVED_SGFIS register field value suitable for setting the
 * register. */
#define MTL_INTERRUPT_STATUS_RESERVED_SGFIS_SET(value) (((value) << 20) & 0x00100000)

/*
 * Field : Reserved_22_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_RESERVED_22_21 register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_LSB	       21
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_RESERVED_22_21 register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_MSB	       22
/* The width in bits of the MTL_INTERRUPT_STATUS_RESERVED_22_21 register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_WIDTH      2
/* The mask used to set the MTL_INTERRUPT_STATUS_RESERVED_22_21 register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_SET_MSK    0x00600000
/* The mask used to clear the MTL_INTERRUPT_STATUS_RESERVED_22_21 register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_CLR_MSK    0xff9fffff
/* The reset value of the MTL_INTERRUPT_STATUS_RESERVED_22_21 register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_RESERVED_22_21 field value from a register. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_GET(value) (((value)&0x00600000) >> 21)
/* Produces a MTL_INTERRUPT_STATUS_RESERVED_22_21 register field value suitable for setting the
 * register. */
#define MTL_INTERRUPT_STATUS_RESERVED_22_21_SET(value) (((value) << 21) & 0x00600000)

/*
 * Field : Reserved_MTLPIS
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_LSB	23
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_MSB	23
/* The width in bits of the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_WIDTH	1
/* The mask used to set the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_SET_MSK	0x00800000
/* The mask used to clear the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_CLR_MSK	0xff7fffff
/* The reset value of the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_RESET	0x0
/* Extracts the MTL_INTERRUPT_STATUS_RESERVED_MTLPIS field value from a register. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_GET(value) (((value)&0x00800000) >> 23)
/* Produces a MTL_INTERRUPT_STATUS_RESERVED_MTLPIS register field value suitable for setting the
 * register. */
#define MTL_INTERRUPT_STATUS_RESERVED_MTLPIS_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : Reserved_31_24
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_INTERRUPT_STATUS_RESERVED_31_24 register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_LSB	       24
/* The Most Significant Bit (MSB) position of the MTL_INTERRUPT_STATUS_RESERVED_31_24 register
 * field. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_MSB	       31
/* The width in bits of the MTL_INTERRUPT_STATUS_RESERVED_31_24 register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_WIDTH      8
/* The mask used to set the MTL_INTERRUPT_STATUS_RESERVED_31_24 register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_SET_MSK    0xff000000
/* The mask used to clear the MTL_INTERRUPT_STATUS_RESERVED_31_24 register field value. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_CLR_MSK    0x00ffffff
/* The reset value of the MTL_INTERRUPT_STATUS_RESERVED_31_24 register field. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_RESET      0x0
/* Extracts the MTL_INTERRUPT_STATUS_RESERVED_31_24 field value from a register. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_GET(value) (((value)&0xff000000) >> 24)
/* Produces a MTL_INTERRUPT_STATUS_RESERVED_31_24 register field value suitable for setting the
 * register. */
#define MTL_INTERRUPT_STATUS_RESERVED_31_24_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_INTERRUPT_STATUS.
 */
struct MTL_INTERRUPT_STATUS_s {
	const volatile uint32_t Q0IS : 1;	     /* MTL_INTERRUPT_STATUS_Q0IS */
	const volatile uint32_t Q1IS : 1;	     /* MTL_INTERRUPT_STATUS_Q1IS */
	const volatile uint32_t Q2IS : 1;	     /* MTL_INTERRUPT_STATUS_Q2IS */
	const volatile uint32_t Q3IS : 1;	     /* MTL_INTERRUPT_STATUS_Q3IS */
	const volatile uint32_t Q4IS : 1;	     /* MTL_INTERRUPT_STATUS_Q4IS */
	const volatile uint32_t Q5IS : 1;	     /* MTL_INTERRUPT_STATUS_Q5IS */
	const volatile uint32_t Q6IS : 1;	     /* MTL_INTERRUPT_STATUS_Q6IS */
	const volatile uint32_t Q7IS : 1;	     /* MTL_INTERRUPT_STATUS_Q7IS */
	const volatile uint32_t Q8IS : 1;	     /* MTL_INTERRUPT_STATUS_Q8IS */
	const volatile uint32_t Q9IS : 1;	     /* MTL_INTERRUPT_STATUS_Q9IS */
	const volatile uint32_t Q10IS : 1;	     /* MTL_INTERRUPT_STATUS_Q10IS */
	const volatile uint32_t Q11IS : 1;	     /* MTL_INTERRUPT_STATUS_Q11IS */
	const volatile uint32_t Q12IS : 1;	     /* MTL_INTERRUPT_STATUS_Q12IS */
	const volatile uint32_t Q13IS : 1;	     /* MTL_INTERRUPT_STATUS_Q13IS */
	const volatile uint32_t Q14IS : 1;	     /* MTL_INTERRUPT_STATUS_Q14IS */
	const volatile uint32_t Q15IS : 1;	     /* MTL_INTERRUPT_STATUS_Q15IS */
	const volatile uint32_t MACIS : 1;	     /* MTL_INTERRUPT_STATUS_MACIS */
	const volatile uint32_t DBGIS : 1;	     /* MTL_INTERRUPT_STATUS_DBGIS */
	const volatile uint32_t ESTIS : 1;	     /* MTL_INTERRUPT_STATUS_ESTIS */
	const volatile uint32_t TINS : 1;	     /* MTL_INTERRUPT_STATUS_TINS */
	const volatile uint32_t Reserved_SGFIS : 1;  /* MTL_INTERRUPT_STATUS_RESERVED_SGFIS */
	const volatile uint32_t Reserved_22_21 : 2;  /* MTL_INTERRUPT_STATUS_RESERVED_22_21 */
	const volatile uint32_t Reserved_MTLPIS : 1; /* MTL_INTERRUPT_STATUS_RESERVED_MTLPIS */
	const volatile uint32_t Reserved_31_24 : 8;  /* MTL_INTERRUPT_STATUS_RESERVED_31_24 */
};

/* The typedef declaration for register MTL_INTERRUPT_STATUS. */
typedef struct MTL_INTERRUPT_STATUS_s MTL_INTERRUPT_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_INTERRUPT_STATUS register. */
#define MTL_INTERRUPT_STATUS_RESET 0x00000000
/* The byte offset of the MTL_INTERRUPT_STATUS register from the beginning of the component. */
#define MTL_INTERRUPT_STATUS_OFST  0x20

/*
 * Register : MTL_RxQ_DMA_Map0
 *
 * The Receive Queue and DMA Channel Mapping 0 register controls the static or
 * dynamic mapping of Receive Queues 0-3 to Receive DMA Channels.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------
 *  [2:0]   | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q0MDMACH
 *  [6:3]   | R      | 0x0   | MTL_RXQ_DMA_MAP0_RESERVED_6_Y
 *  [7]     | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q0DDMACH
 *  [10:8]  | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q1MDMACH
 *  [14:11] | R      | 0x0   | MTL_RXQ_DMA_MAP0_RESERVED_14_Y
 *  [15]    | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q1DDMACH
 *  [18:16] | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q2MDMACH
 *  [22:19] | R      | 0x0   | MTL_RXQ_DMA_MAP0_RESERVED_22_Y
 *  [23]    | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q2DDMACH
 *  [26:24] | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q3MDMACH
 *  [30:27] | R      | 0x0   | MTL_RXQ_DMA_MAP0_RESERVED_30_Y
 *  [31]    | RW     | 0x0   | MTL_RXQ_DMA_MAP0_Q3DDMACH
 *
 */
/*
 * Field : Q0MDMACH
 *
 * Receive Queue 0 Mapped to DMA Channel
 *
 * This field controls the routing of the packet received in Receive Queue 0 to the
 * DMA channel. This field is valid when the Q0DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of this register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q0MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_LSB	     0
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q0MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_MSB	     2
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q0MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q0MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_SET_MSK    0x00000007
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q0MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_CLR_MSK    0xfffffff8
/* The reset value of the MTL_RXQ_DMA_MAP0_Q0MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q0MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_GET(value) (((value)&0x00000007) >> 0)
/* Produces a MTL_RXQ_DMA_MAP0_Q0MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q0MDMACH_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : Reserved_6_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_LSB	 3
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_MSB	 6
/* The width in bits of the MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_WIDTH	 4
/* The mask used to set the MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_SET_MSK	 0x00000078
/* The mask used to clear the MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_CLR_MSK	 0xffffff87
/* The reset value of the MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_RESET	 0x0
/* Extracts the MTL_RXQ_DMA_MAP0_RESERVED_6_Y field value from a register. */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_GET(value) (((value)&0x00000078) >> 3)
/* Produces a MTL_RXQ_DMA_MAP0_RESERVED_6_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP0_RESERVED_6_Y_SET(value) (((value) << 3) & 0x00000078)

/*
 * Field : Q0DDMACH
 *
 * Receive Queue 0 Enabled for Dynamic DMA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 0 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 0 are
 * routed to the DMA Channel programmed in the Q0MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q0DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_LSB	     7
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q0DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_MSB	     7
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q0DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q0DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_SET_MSK    0x00000080
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q0DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_CLR_MSK    0xffffff7f
/* The reset value of the MTL_RXQ_DMA_MAP0_Q0DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q0DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_RXQ_DMA_MAP0_Q0DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q0DDMACH_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Q1MDMACH
 *
 * Receive Queue 1 Mapped to DMA Channel
 *
 * This field controls the routing of the received packet in Receive Queue 1 to the
 * DMA channel. This field is valid when the Q1DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of this register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q1MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_LSB	     8
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q1MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_MSB	     10
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q1MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q1MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_SET_MSK    0x00000700
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q1MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_CLR_MSK    0xfffff8ff
/* The reset value of the MTL_RXQ_DMA_MAP0_Q1MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q1MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_GET(value) (((value)&0x00000700) >> 8)
/* Produces a MTL_RXQ_DMA_MAP0_Q1MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q1MDMACH_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : Reserved_14_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_LSB	  11
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_MSB	  14
/* The width in bits of the MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_WIDTH	  4
/* The mask used to set the MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_SET_MSK	  0x00007800
/* The mask used to clear the MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_CLR_MSK	  0xffff87ff
/* The reset value of the MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_RESET	  0x0
/* Extracts the MTL_RXQ_DMA_MAP0_RESERVED_14_Y field value from a register. */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_GET(value) (((value)&0x00007800) >> 11)
/* Produces a MTL_RXQ_DMA_MAP0_RESERVED_14_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP0_RESERVED_14_Y_SET(value) (((value) << 11) & 0x00007800)

/*
 * Field : Q1DDMACH
 *
 * Receive Queue 1 Enabled for Dynamic DMA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 1 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address registers or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 1 are
 * routed to the DMA Channel programmed in the Q1MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q1DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_LSB	     15
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q1DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_MSB	     15
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q1DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q1DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_SET_MSK    0x00008000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q1DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_CLR_MSK    0xffff7fff
/* The reset value of the MTL_RXQ_DMA_MAP0_Q1DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q1DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_GET(value) (((value)&0x00008000) >> 15)
/* Produces a MTL_RXQ_DMA_MAP0_Q1DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q1DDMACH_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Q2MDMACH
 *
 * Receive Queue 2 Mapped to DMA Channel
 *
 * This field controls the routing of the received packet in Receive Queue 2 to the
 * DMA channel. This field is valid when the Q2DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of this register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q2MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_LSB	     16
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q2MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_MSB	     18
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q2MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q2MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_SET_MSK    0x00070000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q2MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_CLR_MSK    0xfff8ffff
/* The reset value of the MTL_RXQ_DMA_MAP0_Q2MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q2MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_GET(value) (((value)&0x00070000) >> 16)
/* Produces a MTL_RXQ_DMA_MAP0_Q2MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q2MDMACH_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_22_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_LSB	  19
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_MSB	  22
/* The width in bits of the MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_WIDTH	  4
/* The mask used to set the MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_SET_MSK	  0x00780000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_CLR_MSK	  0xff87ffff
/* The reset value of the MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_RESET	  0x0
/* Extracts the MTL_RXQ_DMA_MAP0_RESERVED_22_Y field value from a register. */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_GET(value) (((value)&0x00780000) >> 19)
/* Produces a MTL_RXQ_DMA_MAP0_RESERVED_22_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP0_RESERVED_22_Y_SET(value) (((value) << 19) & 0x00780000)

/*
 * Field : Q2DDMACH
 *
 * Receive Queue 2 Enabled for Dynamic MA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 2 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address registers or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 2 are
 * routed to the DMA Channel programmed in the Q2MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q2DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_LSB	     23
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q2DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_MSB	     23
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q2DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q2DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_SET_MSK    0x00800000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q2DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_CLR_MSK    0xff7fffff
/* The reset value of the MTL_RXQ_DMA_MAP0_Q2DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q2DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_GET(value) (((value)&0x00800000) >> 23)
/* Produces a MTL_RXQ_DMA_MAP0_Q2DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q2DDMACH_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : Q3MDMACH
 *
 * Receive Queue 3 Mapped to DMA Channel
 *
 * This field controls the routing of the received packet in Receive Queue 3 to the
 * DMA channel. This field is valid when the Q3DDMACH field is reset.
 *
 * * 4'b0000: DMA Channel 0
 *
 * * 4'b0001: DMA Channel 1
 *
 * * 4'b0010: DMA Channel 2
 *
 * * 4'b0011: DMA Channel 3
 *
 * * 4'b0100: DMA Channel 4
 *
 * * 4'b0101: DMA Channel 5
 *
 * * 4'b0110: DMA Channel 6
 *
 * * 4'b0111: DMA Channel 7
 *
 * * 4'b1000: DMA Channel 8
 *
 * * 4'b1001: DMA Channel 9
 *
 * * 4'b1010: DMA Channel 10
 *
 * * 4'b1011: DMA Channel 11
 *
 * * 4'b1100: DMA Channel 12
 *
 * * 4'b1101: DMA Channel 13
 *
 * * 4'b1110: DMA Channel 14
 *
 * * 4'b1111: DMA Channel 15
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q3MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_LSB	     24
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q3MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_MSB	     26
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q3MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q3MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_SET_MSK    0x07000000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q3MDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_CLR_MSK    0xf8ffffff
/* The reset value of the MTL_RXQ_DMA_MAP0_Q3MDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q3MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_GET(value) (((value)&0x07000000) >> 24)
/* Produces a MTL_RXQ_DMA_MAP0_Q3MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q3MDMACH_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : Reserved_30_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_LSB	  27
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_MSB	  30
/* The width in bits of the MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_WIDTH	  4
/* The mask used to set the MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_SET_MSK	  0x78000000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field value. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_CLR_MSK	  0x87ffffff
/* The reset value of the MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_RESET	  0x0
/* Extracts the MTL_RXQ_DMA_MAP0_RESERVED_30_Y field value from a register. */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_GET(value) (((value)&0x78000000) >> 27)
/* Produces a MTL_RXQ_DMA_MAP0_RESERVED_30_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP0_RESERVED_30_Y_SET(value) (((value) << 27) & 0x78000000)

/*
 * Field : Q3DDMACH
 *
 * Receive Queue 3 Enabled for Dynamic DMA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 3 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address registers or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 3 are
 * routed to the DMA Channel programmed in the Q3MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP0_Q3DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_LSB	     31
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP0_Q3DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_MSB	     31
/* The width in bits of the MTL_RXQ_DMA_MAP0_Q3DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP0_Q3DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_SET_MSK    0x80000000
/* The mask used to clear the MTL_RXQ_DMA_MAP0_Q3DDMACH register field value. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_CLR_MSK    0x7fffffff
/* The reset value of the MTL_RXQ_DMA_MAP0_Q3DDMACH register field. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP0_Q3DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_GET(value) (((value)&0x80000000) >> 31)
/* Produces a MTL_RXQ_DMA_MAP0_Q3DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP0_Q3DDMACH_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_RXQ_DMA_MAP0.
 */
struct MTL_RXQ_DMA_MAP0_s {
	volatile uint32_t Q0MDMACH : 3;		   /* MTL_RXQ_DMA_MAP0_Q0MDMACH */
	const volatile uint32_t Reserved_6_y : 4;  /* MTL_RXQ_DMA_MAP0_RESERVED_6_Y */
	volatile uint32_t Q0DDMACH : 1;		   /* MTL_RXQ_DMA_MAP0_Q0DDMACH */
	volatile uint32_t Q1MDMACH : 3;		   /* MTL_RXQ_DMA_MAP0_Q1MDMACH */
	const volatile uint32_t Reserved_14_y : 4; /* MTL_RXQ_DMA_MAP0_RESERVED_14_Y */
	volatile uint32_t Q1DDMACH : 1;		   /* MTL_RXQ_DMA_MAP0_Q1DDMACH */
	volatile uint32_t Q2MDMACH : 3;		   /* MTL_RXQ_DMA_MAP0_Q2MDMACH */
	const volatile uint32_t Reserved_22_y : 4; /* MTL_RXQ_DMA_MAP0_RESERVED_22_Y */
	volatile uint32_t Q2DDMACH : 1;		   /* MTL_RXQ_DMA_MAP0_Q2DDMACH */
	volatile uint32_t Q3MDMACH : 3;		   /* MTL_RXQ_DMA_MAP0_Q3MDMACH */
	const volatile uint32_t Reserved_30_y : 4; /* MTL_RXQ_DMA_MAP0_RESERVED_30_Y */
	volatile uint32_t Q3DDMACH : 1;		   /* MTL_RXQ_DMA_MAP0_Q3DDMACH */
};

/* The typedef declaration for register MTL_RXQ_DMA_MAP0. */
typedef struct MTL_RXQ_DMA_MAP0_s MTL_RXQ_DMA_MAP0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_RXQ_DMA_MAP0 register. */
#define MTL_RXQ_DMA_MAP0_RESET 0x00000000
/* The byte offset of the MTL_RXQ_DMA_MAP0 register from the beginning of the component. */
#define MTL_RXQ_DMA_MAP0_OFST  0x30

/*
 * Register : MTL_RxQ_DMA_Map1
 *
 * The Receive Queue and DMA Channel Mapping 1 register controls the static or
 * dynamic mapping of Receive Queues 4-7 to Receive DMA Channels.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------
 *  [2:0]   | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q4MDMACH
 *  [6:3]   | R      | 0x0   | MTL_RXQ_DMA_MAP1_RESERVED_6_Y
 *  [7]     | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q4DDMACH
 *  [10:8]  | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q5MDMACH
 *  [14:11] | R      | 0x0   | MTL_RXQ_DMA_MAP1_RESERVED_14_Y
 *  [15]    | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q5DDMACH
 *  [18:16] | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q6MDMACH
 *  [22:19] | R      | 0x0   | MTL_RXQ_DMA_MAP1_RESERVED_22_Y
 *  [23]    | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q6DDMACH
 *  [26:24] | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q7MDMACH
 *  [30:27] | R      | 0x0   | MTL_RXQ_DMA_MAP1_RESERVED_30_Y
 *  [31]    | RW     | 0x0   | MTL_RXQ_DMA_MAP1_Q7DDMACH
 *
 */
/*
 * Field : Q4MDMACH
 *
 * Receive Queue 4 Mapped to DMA Channel
 *
 * This field controls the routing of the packet received in Receive Queue 4 to the
 * DMA channel. This field is valid when the Q4DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of MTL_RxQ_DMA_Map0 register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q4MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_LSB	     0
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q4MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_MSB	     2
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q4MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q4MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_SET_MSK    0x00000007
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q4MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_CLR_MSK    0xfffffff8
/* The reset value of the MTL_RXQ_DMA_MAP1_Q4MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q4MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_GET(value) (((value)&0x00000007) >> 0)
/* Produces a MTL_RXQ_DMA_MAP1_Q4MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q4MDMACH_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : Reserved_6_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_LSB	 3
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_MSB	 6
/* The width in bits of the MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_WIDTH	 4
/* The mask used to set the MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_SET_MSK	 0x00000078
/* The mask used to clear the MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_CLR_MSK	 0xffffff87
/* The reset value of the MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_RESET	 0x0
/* Extracts the MTL_RXQ_DMA_MAP1_RESERVED_6_Y field value from a register. */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_GET(value) (((value)&0x00000078) >> 3)
/* Produces a MTL_RXQ_DMA_MAP1_RESERVED_6_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP1_RESERVED_6_Y_SET(value) (((value) << 3) & 0x00000078)

/*
 * Field : Q4DDMACH
 *
 * Receive Queue 4 Enabled for Dynamic DMA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 4 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 4 are
 * routed to the DMA Channel programmed in the Q4MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q4DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_LSB	     7
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q4DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_MSB	     7
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q4DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q4DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_SET_MSK    0x00000080
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q4DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_CLR_MSK    0xffffff7f
/* The reset value of the MTL_RXQ_DMA_MAP1_Q4DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q4DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_RXQ_DMA_MAP1_Q4DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q4DDMACH_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Q5MDMACH
 *
 * Receive Queue 5 Mapped to DMA Channel
 *
 * This field controls the routing of the received packet in Receive Queue 5 to the
 * DMA channel. This field is valid when the Q5DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of MTL_RxQ_DMA_Map0 register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q5MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_LSB	     8
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q5MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_MSB	     10
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q5MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q5MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_SET_MSK    0x00000700
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q5MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_CLR_MSK    0xfffff8ff
/* The reset value of the MTL_RXQ_DMA_MAP1_Q5MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q5MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_GET(value) (((value)&0x00000700) >> 8)
/* Produces a MTL_RXQ_DMA_MAP1_Q5MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q5MDMACH_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : Reserved_14_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_LSB	  11
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_MSB	  14
/* The width in bits of the MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_WIDTH	  4
/* The mask used to set the MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_SET_MSK	  0x00007800
/* The mask used to clear the MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_CLR_MSK	  0xffff87ff
/* The reset value of the MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_RESET	  0x0
/* Extracts the MTL_RXQ_DMA_MAP1_RESERVED_14_Y field value from a register. */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_GET(value) (((value)&0x00007800) >> 11)
/* Produces a MTL_RXQ_DMA_MAP1_RESERVED_14_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP1_RESERVED_14_Y_SET(value) (((value) << 11) & 0x00007800)

/*
 * Field : Q5DDMACH
 *
 * Receive Queue 5 Enabled for Dynamic DMA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 5 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address registers or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 5 are
 * routed to the DMA Channel programmed in the Q5MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q5DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_LSB	     15
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q5DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_MSB	     15
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q5DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q5DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_SET_MSK    0x00008000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q5DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_CLR_MSK    0xffff7fff
/* The reset value of the MTL_RXQ_DMA_MAP1_Q5DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q5DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_GET(value) (((value)&0x00008000) >> 15)
/* Produces a MTL_RXQ_DMA_MAP1_Q5DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q5DDMACH_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Q6MDMACH
 *
 * Receive Queue 6 Mapped to DMA Channel
 *
 * This field controls the routing of the received packet in Receive Queue 6 to the
 * DMA channel. This field is valid when the Q6DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of MTL_RxQ_DMA_Map0 register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q6MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_LSB	     16
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q6MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_MSB	     18
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q6MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q6MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_SET_MSK    0x00070000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q6MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_CLR_MSK    0xfff8ffff
/* The reset value of the MTL_RXQ_DMA_MAP1_Q6MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q6MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_GET(value) (((value)&0x00070000) >> 16)
/* Produces a MTL_RXQ_DMA_MAP1_Q6MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q6MDMACH_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_22_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_LSB	  19
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_MSB	  22
/* The width in bits of the MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_WIDTH	  4
/* The mask used to set the MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_SET_MSK	  0x00780000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_CLR_MSK	  0xff87ffff
/* The reset value of the MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_RESET	  0x0
/* Extracts the MTL_RXQ_DMA_MAP1_RESERVED_22_Y field value from a register. */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_GET(value) (((value)&0x00780000) >> 19)
/* Produces a MTL_RXQ_DMA_MAP1_RESERVED_22_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP1_RESERVED_22_Y_SET(value) (((value) << 19) & 0x00780000)

/*
 * Field : Q6DDMACH
 *
 * Receive Queue 6 Enabled for Dynamic MA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 6 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address registers or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 6 are
 * routed to the DMA Channel programmed in the Q6MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q6DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_LSB	     23
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q6DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_MSB	     23
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q6DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q6DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_SET_MSK    0x00800000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q6DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_CLR_MSK    0xff7fffff
/* The reset value of the MTL_RXQ_DMA_MAP1_Q6DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q6DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_GET(value) (((value)&0x00800000) >> 23)
/* Produces a MTL_RXQ_DMA_MAP1_Q6DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q6DDMACH_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : Q7MDMACH
 *
 * Receive Queue 7 Mapped to DMA Channel
 *
 * This field controls the routing of the received packet in Receive Queue 7 to the
 * DMA channel. This field is valid when the Q7DDMACH field is reset. The encoding
 * is the same as Q3MDMACH of MTL_RxQ_DMA_Map0 register.
 *
 * The width of this field depends on the number of Receive DMA channels, therefore
 * all values might not be valid in certain configurations. For example, if the
 * number of Rx DMA channels selected is 2, the only valid values are 0 and 1.
 * Other values are reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q7MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_LSB	     24
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q7MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_MSB	     26
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q7MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_WIDTH	     3
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q7MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_SET_MSK    0x07000000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q7MDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_CLR_MSK    0xf8ffffff
/* The reset value of the MTL_RXQ_DMA_MAP1_Q7MDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q7MDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_GET(value) (((value)&0x07000000) >> 24)
/* Produces a MTL_RXQ_DMA_MAP1_Q7MDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q7MDMACH_SET(value) (((value) << 24) & 0x07000000)

/*
 * Field : Reserved_30_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_LSB	  27
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_MSB	  30
/* The width in bits of the MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_WIDTH	  4
/* The mask used to set the MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_SET_MSK	  0x78000000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field value. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_CLR_MSK	  0x87ffffff
/* The reset value of the MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_RESET	  0x0
/* Extracts the MTL_RXQ_DMA_MAP1_RESERVED_30_Y field value from a register. */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_GET(value) (((value)&0x78000000) >> 27)
/* Produces a MTL_RXQ_DMA_MAP1_RESERVED_30_Y register field value suitable for setting the register.
 */
#define MTL_RXQ_DMA_MAP1_RESERVED_30_Y_SET(value) (((value) << 27) & 0x78000000)

/*
 * Field : Q7DDMACH
 *
 * Receive Queue 7 Enabled for Dynamic DMA Channel Selection
 *
 * When set, this bit indicates that each packet received in Receive Queue 7 is
 * routed to a DMA channel as decided in the MAC Receiver based on the DMA channel
 * number programmed in the L3-L4 filter registers, RSS lookup table, the Ethernet
 * DA address registers or VLAN filter registers.
 *
 * When reset, this bit indicates that all packets received in Receive Queue 7 are
 * routed to the DMA Channel programmed in the Q7MDMACH field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_RXQ_DMA_MAP1_Q7DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_LSB	     31
/* The Most Significant Bit (MSB) position of the MTL_RXQ_DMA_MAP1_Q7DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_MSB	     31
/* The width in bits of the MTL_RXQ_DMA_MAP1_Q7DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_WIDTH	     1
/* The mask used to set the MTL_RXQ_DMA_MAP1_Q7DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_SET_MSK    0x80000000
/* The mask used to clear the MTL_RXQ_DMA_MAP1_Q7DDMACH register field value. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_CLR_MSK    0x7fffffff
/* The reset value of the MTL_RXQ_DMA_MAP1_Q7DDMACH register field. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_RESET	     0x0
/* Extracts the MTL_RXQ_DMA_MAP1_Q7DDMACH field value from a register. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_GET(value) (((value)&0x80000000) >> 31)
/* Produces a MTL_RXQ_DMA_MAP1_Q7DDMACH register field value suitable for setting the register. */
#define MTL_RXQ_DMA_MAP1_Q7DDMACH_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_RXQ_DMA_MAP1.
 */
struct MTL_RXQ_DMA_MAP1_s {
	volatile uint32_t Q4MDMACH : 3;		   /* MTL_RXQ_DMA_MAP1_Q4MDMACH */
	const volatile uint32_t Reserved_6_y : 4;  /* MTL_RXQ_DMA_MAP1_RESERVED_6_Y */
	volatile uint32_t Q4DDMACH : 1;		   /* MTL_RXQ_DMA_MAP1_Q4DDMACH */
	volatile uint32_t Q5MDMACH : 3;		   /* MTL_RXQ_DMA_MAP1_Q5MDMACH */
	const volatile uint32_t Reserved_14_y : 4; /* MTL_RXQ_DMA_MAP1_RESERVED_14_Y */
	volatile uint32_t Q5DDMACH : 1;		   /* MTL_RXQ_DMA_MAP1_Q5DDMACH */
	volatile uint32_t Q6MDMACH : 3;		   /* MTL_RXQ_DMA_MAP1_Q6MDMACH */
	const volatile uint32_t Reserved_22_y : 4; /* MTL_RXQ_DMA_MAP1_RESERVED_22_Y */
	volatile uint32_t Q6DDMACH : 1;		   /* MTL_RXQ_DMA_MAP1_Q6DDMACH */
	volatile uint32_t Q7MDMACH : 3;		   /* MTL_RXQ_DMA_MAP1_Q7MDMACH */
	const volatile uint32_t Reserved_30_y : 4; /* MTL_RXQ_DMA_MAP1_RESERVED_30_Y */
	volatile uint32_t Q7DDMACH : 1;		   /* MTL_RXQ_DMA_MAP1_Q7DDMACH */
};

/* The typedef declaration for register MTL_RXQ_DMA_MAP1. */
typedef struct MTL_RXQ_DMA_MAP1_s MTL_RXQ_DMA_MAP1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_RXQ_DMA_MAP1 register. */
#define MTL_RXQ_DMA_MAP1_RESET 0x00000000
/* The byte offset of the MTL_RXQ_DMA_MAP1 register from the beginning of the component. */
#define MTL_RXQ_DMA_MAP1_OFST  0x34

/*
 * Register : MTL_TC_Prty_Map0
 *
 * This register contains the priority values assigned to traffic classes 0 to 3.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------
 *  [7:0]   | RW     | 0x0   | MTL_TC_PRTY_MAP0_PSTC0
 *  [15:8]  | RW     | 0x0   | MTL_TC_PRTY_MAP0_PSTC1
 *  [23:16] | RW     | 0x0   | MTL_TC_PRTY_MAP0_PSTC2
 *  [31:24] | RW     | 0x0   | MTL_TC_PRTY_MAP0_PSTC3
 *
 */
/*
 * Field : PSTC0
 *
 * Priorities Mapped to Traffic Class 0.
 *
 * This field holds the priorities assigned to traffic class 0, programmed by the
 * application. This field determines if the transmit queues associated with the
 * traffic class 0 should be blocked from transmitting for the specified pause time
 * when a PFC packet is received with priorities matching the priorities programmed
 * in this field. Each bit corresponds to a priority. For example, PSTC0[7]
 * corresponds to priority 7 and so on.
 *
 * If the content of this field is not mutually exclusive to the corresponding
 * fields of other traffic classes, that is, if the same priority is mapped to
 * multiple traffic classes, DWC_xgmac blocks all queues with matching priority for
 * a specified time.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP0_PSTC0 register field. */
#define MTL_TC_PRTY_MAP0_PSTC0_LSB	  0
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP0_PSTC0 register field. */
#define MTL_TC_PRTY_MAP0_PSTC0_MSB	  7
/* The width in bits of the MTL_TC_PRTY_MAP0_PSTC0 register field. */
#define MTL_TC_PRTY_MAP0_PSTC0_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP0_PSTC0 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC0_SET_MSK	  0x000000ff
/* The mask used to clear the MTL_TC_PRTY_MAP0_PSTC0 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC0_CLR_MSK	  0xffffff00
/* The reset value of the MTL_TC_PRTY_MAP0_PSTC0 register field. */
#define MTL_TC_PRTY_MAP0_PSTC0_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP0_PSTC0 field value from a register. */
#define MTL_TC_PRTY_MAP0_PSTC0_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a MTL_TC_PRTY_MAP0_PSTC0 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP0_PSTC0_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : PSTC1
 *
 * Priorities Mapped to Traffic Class 1.
 *
 * This field is similar to the PSTC0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP0_PSTC1 register field. */
#define MTL_TC_PRTY_MAP0_PSTC1_LSB	  8
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP0_PSTC1 register field. */
#define MTL_TC_PRTY_MAP0_PSTC1_MSB	  15
/* The width in bits of the MTL_TC_PRTY_MAP0_PSTC1 register field. */
#define MTL_TC_PRTY_MAP0_PSTC1_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP0_PSTC1 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC1_SET_MSK	  0x0000ff00
/* The mask used to clear the MTL_TC_PRTY_MAP0_PSTC1 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC1_CLR_MSK	  0xffff00ff
/* The reset value of the MTL_TC_PRTY_MAP0_PSTC1 register field. */
#define MTL_TC_PRTY_MAP0_PSTC1_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP0_PSTC1 field value from a register. */
#define MTL_TC_PRTY_MAP0_PSTC1_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_TC_PRTY_MAP0_PSTC1 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP0_PSTC1_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PSTC2
 *
 * Priorities Mapped to Traffic Class 2.
 *
 * This field is similar to the PSTC0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP0_PSTC2 register field. */
#define MTL_TC_PRTY_MAP0_PSTC2_LSB	  16
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP0_PSTC2 register field. */
#define MTL_TC_PRTY_MAP0_PSTC2_MSB	  23
/* The width in bits of the MTL_TC_PRTY_MAP0_PSTC2 register field. */
#define MTL_TC_PRTY_MAP0_PSTC2_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP0_PSTC2 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC2_SET_MSK	  0x00ff0000
/* The mask used to clear the MTL_TC_PRTY_MAP0_PSTC2 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC2_CLR_MSK	  0xff00ffff
/* The reset value of the MTL_TC_PRTY_MAP0_PSTC2 register field. */
#define MTL_TC_PRTY_MAP0_PSTC2_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP0_PSTC2 field value from a register. */
#define MTL_TC_PRTY_MAP0_PSTC2_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a MTL_TC_PRTY_MAP0_PSTC2 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP0_PSTC2_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : PSTC3
 *
 * Priorities Mapped to Traffic Class 3.
 *
 * This field is similar to the PSTC0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP0_PSTC3 register field. */
#define MTL_TC_PRTY_MAP0_PSTC3_LSB	  24
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP0_PSTC3 register field. */
#define MTL_TC_PRTY_MAP0_PSTC3_MSB	  31
/* The width in bits of the MTL_TC_PRTY_MAP0_PSTC3 register field. */
#define MTL_TC_PRTY_MAP0_PSTC3_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP0_PSTC3 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC3_SET_MSK	  0xff000000
/* The mask used to clear the MTL_TC_PRTY_MAP0_PSTC3 register field value. */
#define MTL_TC_PRTY_MAP0_PSTC3_CLR_MSK	  0x00ffffff
/* The reset value of the MTL_TC_PRTY_MAP0_PSTC3 register field. */
#define MTL_TC_PRTY_MAP0_PSTC3_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP0_PSTC3 field value from a register. */
#define MTL_TC_PRTY_MAP0_PSTC3_GET(value) (((value)&0xff000000) >> 24)
/* Produces a MTL_TC_PRTY_MAP0_PSTC3 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP0_PSTC3_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TC_PRTY_MAP0.
 */
struct MTL_TC_PRTY_MAP0_s {
	volatile uint32_t PSTC0 : 8; /* MTL_TC_PRTY_MAP0_PSTC0 */
	volatile uint32_t PSTC1 : 8; /* MTL_TC_PRTY_MAP0_PSTC1 */
	volatile uint32_t PSTC2 : 8; /* MTL_TC_PRTY_MAP0_PSTC2 */
	volatile uint32_t PSTC3 : 8; /* MTL_TC_PRTY_MAP0_PSTC3 */
};

/* The typedef declaration for register MTL_TC_PRTY_MAP0. */
typedef struct MTL_TC_PRTY_MAP0_s MTL_TC_PRTY_MAP0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TC_PRTY_MAP0 register. */
#define MTL_TC_PRTY_MAP0_RESET 0x00000000
/* The byte offset of the MTL_TC_PRTY_MAP0 register from the beginning of the component. */
#define MTL_TC_PRTY_MAP0_OFST  0x40

/*
 * Register : MTL_TC_Prty_Map1
 *
 * This register contains the priority values assigned to traffic classes 4 to 7.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------
 *  [7:0]   | RW     | 0x0   | MTL_TC_PRTY_MAP1_PSTC4
 *  [15:8]  | RW     | 0x0   | MTL_TC_PRTY_MAP1_PSTC5
 *  [23:16] | RW     | 0x0   | MTL_TC_PRTY_MAP1_PSTC6
 *  [31:24] | RW     | 0x0   | MTL_TC_PRTY_MAP1_PSTC7
 *
 */
/*
 * Field : PSTC4
 *
 * Priorities Mapped to Traffic Class 4.
 *
 * This field is similar to the PSTC0 field of the MTL_TC_Prty_Map0 register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP1_PSTC4 register field. */
#define MTL_TC_PRTY_MAP1_PSTC4_LSB	  0
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP1_PSTC4 register field. */
#define MTL_TC_PRTY_MAP1_PSTC4_MSB	  7
/* The width in bits of the MTL_TC_PRTY_MAP1_PSTC4 register field. */
#define MTL_TC_PRTY_MAP1_PSTC4_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP1_PSTC4 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC4_SET_MSK	  0x000000ff
/* The mask used to clear the MTL_TC_PRTY_MAP1_PSTC4 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC4_CLR_MSK	  0xffffff00
/* The reset value of the MTL_TC_PRTY_MAP1_PSTC4 register field. */
#define MTL_TC_PRTY_MAP1_PSTC4_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP1_PSTC4 field value from a register. */
#define MTL_TC_PRTY_MAP1_PSTC4_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a MTL_TC_PRTY_MAP1_PSTC4 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP1_PSTC4_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : PSTC5
 *
 * Priorities Mapped to Traffic Class 5.
 *
 * This field is similar to the PSTC0 field of the MTL_TC_Prty_Map0 register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP1_PSTC5 register field. */
#define MTL_TC_PRTY_MAP1_PSTC5_LSB	  8
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP1_PSTC5 register field. */
#define MTL_TC_PRTY_MAP1_PSTC5_MSB	  15
/* The width in bits of the MTL_TC_PRTY_MAP1_PSTC5 register field. */
#define MTL_TC_PRTY_MAP1_PSTC5_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP1_PSTC5 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC5_SET_MSK	  0x0000ff00
/* The mask used to clear the MTL_TC_PRTY_MAP1_PSTC5 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC5_CLR_MSK	  0xffff00ff
/* The reset value of the MTL_TC_PRTY_MAP1_PSTC5 register field. */
#define MTL_TC_PRTY_MAP1_PSTC5_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP1_PSTC5 field value from a register. */
#define MTL_TC_PRTY_MAP1_PSTC5_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_TC_PRTY_MAP1_PSTC5 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP1_PSTC5_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : PSTC6
 *
 * Priorities Mapped to Traffic Class 6.
 *
 * This field is similar to the PSTC0 field of the MTL_TC_Prty_Map0 register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP1_PSTC6 register field. */
#define MTL_TC_PRTY_MAP1_PSTC6_LSB	  16
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP1_PSTC6 register field. */
#define MTL_TC_PRTY_MAP1_PSTC6_MSB	  23
/* The width in bits of the MTL_TC_PRTY_MAP1_PSTC6 register field. */
#define MTL_TC_PRTY_MAP1_PSTC6_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP1_PSTC6 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC6_SET_MSK	  0x00ff0000
/* The mask used to clear the MTL_TC_PRTY_MAP1_PSTC6 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC6_CLR_MSK	  0xff00ffff
/* The reset value of the MTL_TC_PRTY_MAP1_PSTC6 register field. */
#define MTL_TC_PRTY_MAP1_PSTC6_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP1_PSTC6 field value from a register. */
#define MTL_TC_PRTY_MAP1_PSTC6_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a MTL_TC_PRTY_MAP1_PSTC6 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP1_PSTC6_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : PSTC7
 *
 * Priorities Mapped to Traffic Class 7.
 *
 * This field is similar to the PSTC0 field of the MTL_TC_Prty_Map0 register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TC_PRTY_MAP1_PSTC7 register field. */
#define MTL_TC_PRTY_MAP1_PSTC7_LSB	  24
/* The Most Significant Bit (MSB) position of the MTL_TC_PRTY_MAP1_PSTC7 register field. */
#define MTL_TC_PRTY_MAP1_PSTC7_MSB	  31
/* The width in bits of the MTL_TC_PRTY_MAP1_PSTC7 register field. */
#define MTL_TC_PRTY_MAP1_PSTC7_WIDTH	  8
/* The mask used to set the MTL_TC_PRTY_MAP1_PSTC7 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC7_SET_MSK	  0xff000000
/* The mask used to clear the MTL_TC_PRTY_MAP1_PSTC7 register field value. */
#define MTL_TC_PRTY_MAP1_PSTC7_CLR_MSK	  0x00ffffff
/* The reset value of the MTL_TC_PRTY_MAP1_PSTC7 register field. */
#define MTL_TC_PRTY_MAP1_PSTC7_RESET	  0x0
/* Extracts the MTL_TC_PRTY_MAP1_PSTC7 field value from a register. */
#define MTL_TC_PRTY_MAP1_PSTC7_GET(value) (((value)&0xff000000) >> 24)
/* Produces a MTL_TC_PRTY_MAP1_PSTC7 register field value suitable for setting the register. */
#define MTL_TC_PRTY_MAP1_PSTC7_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TC_PRTY_MAP1.
 */
struct MTL_TC_PRTY_MAP1_s {
	volatile uint32_t PSTC4 : 8; /* MTL_TC_PRTY_MAP1_PSTC4 */
	volatile uint32_t PSTC5 : 8; /* MTL_TC_PRTY_MAP1_PSTC5 */
	volatile uint32_t PSTC6 : 8; /* MTL_TC_PRTY_MAP1_PSTC6 */
	volatile uint32_t PSTC7 : 8; /* MTL_TC_PRTY_MAP1_PSTC7 */
};

/* The typedef declaration for register MTL_TC_PRTY_MAP1. */
typedef struct MTL_TC_PRTY_MAP1_s MTL_TC_PRTY_MAP1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TC_PRTY_MAP1 register. */
#define MTL_TC_PRTY_MAP1_RESET 0x00000000
/* The byte offset of the MTL_TC_PRTY_MAP1 register from the beginning of the component. */
#define MTL_TC_PRTY_MAP1_OFST  0x44

/*
 * Register : MTL_TBS_CTRL
 *
 * This register controls the operation of Time Based Scheduling.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------
 *  [0]    | RW     | 0x0   | MTL_TBS_CTRL_ESTM
 *  [1]    | RW     | 0x0   | MTL_TBS_CTRL_LEOV
 *  [2]    | RW     | 0x0   | MTL_TBS_CTRL_TIEN
 *  [3]    | R      | 0x0   | MTL_TBS_CTRL_RESERVED_3
 *  [6:4]  | RW     | 0x0   | MTL_TBS_CTRL_LEGOS
 *  [7]    | R      | 0x0   | MTL_TBS_CTRL_RESERVED_7
 *  [31:8] | RW     | 0x0   | MTL_TBS_CTRL_LEOS
 *
 */
/*
 * Field : ESTM
 *
 * EST offset Mode
 *
 * When this bit is set, the Launch Time value used in Time Based Scheduling is
 * interpreted as an EST offset value and is added to the Base Time Register (BTR)
 * of the current list.
 *
 * When reset, the Launch Time value is used as an absolute value that should be
 * compared with the System time [39:8].
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:----------------------------
 *  MTL_TBS_CTRL_ESTM_E_DISABLE | 0x0   | EST offset Mode is disabled
 *  MTL_TBS_CTRL_ESTM_E_ENABLE  | 0x1   | EST offset Mode is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_TBS_CTRL_ESTM
 *
 * EST offset Mode is disabled
 */
#define MTL_TBS_CTRL_ESTM_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_TBS_CTRL_ESTM
 *
 * EST offset Mode is enabled
 */
#define MTL_TBS_CTRL_ESTM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_ESTM register field. */
#define MTL_TBS_CTRL_ESTM_LSB	     0
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_ESTM register field. */
#define MTL_TBS_CTRL_ESTM_MSB	     0
/* The width in bits of the MTL_TBS_CTRL_ESTM register field. */
#define MTL_TBS_CTRL_ESTM_WIDTH	     1
/* The mask used to set the MTL_TBS_CTRL_ESTM register field value. */
#define MTL_TBS_CTRL_ESTM_SET_MSK    0x00000001
/* The mask used to clear the MTL_TBS_CTRL_ESTM register field value. */
#define MTL_TBS_CTRL_ESTM_CLR_MSK    0xfffffffe
/* The reset value of the MTL_TBS_CTRL_ESTM register field. */
#define MTL_TBS_CTRL_ESTM_RESET	     0x0
/* Extracts the MTL_TBS_CTRL_ESTM field value from a register. */
#define MTL_TBS_CTRL_ESTM_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TBS_CTRL_ESTM register field value suitable for setting the register. */
#define MTL_TBS_CTRL_ESTM_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : LEOV
 *
 * Launch Expiry Offset Valid
 *
 * When set indicates the LEOS field is valid. When not set, indicates the Launch
 * Expiry Offset is not valid and the MTL must not check for Launch expiry time.
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:----------------------
 *  MTL_TBS_CTRL_LEOV_E_INVALID | 0x0   | LEOS field is invalid
 *  MTL_TBS_CTRL_LEOV_E_VALID   | 0x1   | LEOS field is valid
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_TBS_CTRL_LEOV
 *
 * LEOS field is invalid
 */
#define MTL_TBS_CTRL_LEOV_E_INVALID 0x0
/*
 * Enumerated value for register field MTL_TBS_CTRL_LEOV
 *
 * LEOS field is valid
 */
#define MTL_TBS_CTRL_LEOV_E_VALID   0x1

/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_LEOV register field. */
#define MTL_TBS_CTRL_LEOV_LSB	     1
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_LEOV register field. */
#define MTL_TBS_CTRL_LEOV_MSB	     1
/* The width in bits of the MTL_TBS_CTRL_LEOV register field. */
#define MTL_TBS_CTRL_LEOV_WIDTH	     1
/* The mask used to set the MTL_TBS_CTRL_LEOV register field value. */
#define MTL_TBS_CTRL_LEOV_SET_MSK    0x00000002
/* The mask used to clear the MTL_TBS_CTRL_LEOV register field value. */
#define MTL_TBS_CTRL_LEOV_CLR_MSK    0xfffffffd
/* The reset value of the MTL_TBS_CTRL_LEOV register field. */
#define MTL_TBS_CTRL_LEOV_RESET	     0x0
/* Extracts the MTL_TBS_CTRL_LEOV field value from a register. */
#define MTL_TBS_CTRL_LEOV_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_TBS_CTRL_LEOV register field value suitable for setting the register. */
#define MTL_TBS_CTRL_LEOV_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TIEN
 *
 * TBS Interrupt Enable
 *
 * When set indicates that TBS interrupt (occurs due to frame drop) is enabled.
 * Value valid only when TIEN is set.
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:--------------------------
 *  MTL_TBS_CTRL_TIEN_E_INVALID | 0x0   | TBS interrupt is enabled
 *  MTL_TBS_CTRL_TIEN_E_VALID   | 0x1   | TBS interrupt is disabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_TBS_CTRL_TIEN
 *
 * TBS interrupt is enabled
 */
#define MTL_TBS_CTRL_TIEN_E_INVALID 0x0
/*
 * Enumerated value for register field MTL_TBS_CTRL_TIEN
 *
 * TBS interrupt is disabled
 */
#define MTL_TBS_CTRL_TIEN_E_VALID   0x1

/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_TIEN register field. */
#define MTL_TBS_CTRL_TIEN_LSB	     2
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_TIEN register field. */
#define MTL_TBS_CTRL_TIEN_MSB	     2
/* The width in bits of the MTL_TBS_CTRL_TIEN register field. */
#define MTL_TBS_CTRL_TIEN_WIDTH	     1
/* The mask used to set the MTL_TBS_CTRL_TIEN register field value. */
#define MTL_TBS_CTRL_TIEN_SET_MSK    0x00000004
/* The mask used to clear the MTL_TBS_CTRL_TIEN register field value. */
#define MTL_TBS_CTRL_TIEN_CLR_MSK    0xfffffffb
/* The reset value of the MTL_TBS_CTRL_TIEN register field. */
#define MTL_TBS_CTRL_TIEN_RESET	     0x0
/* Extracts the MTL_TBS_CTRL_TIEN field value from a register. */
#define MTL_TBS_CTRL_TIEN_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_TBS_CTRL_TIEN register field value suitable for setting the register. */
#define MTL_TBS_CTRL_TIEN_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_RESERVED_3 register field. */
#define MTL_TBS_CTRL_RESERVED_3_LSB	   3
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_RESERVED_3 register field. */
#define MTL_TBS_CTRL_RESERVED_3_MSB	   3
/* The width in bits of the MTL_TBS_CTRL_RESERVED_3 register field. */
#define MTL_TBS_CTRL_RESERVED_3_WIDTH	   1
/* The mask used to set the MTL_TBS_CTRL_RESERVED_3 register field value. */
#define MTL_TBS_CTRL_RESERVED_3_SET_MSK	   0x00000008
/* The mask used to clear the MTL_TBS_CTRL_RESERVED_3 register field value. */
#define MTL_TBS_CTRL_RESERVED_3_CLR_MSK	   0xfffffff7
/* The reset value of the MTL_TBS_CTRL_RESERVED_3 register field. */
#define MTL_TBS_CTRL_RESERVED_3_RESET	   0x0
/* Extracts the MTL_TBS_CTRL_RESERVED_3 field value from a register. */
#define MTL_TBS_CTRL_RESERVED_3_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_TBS_CTRL_RESERVED_3 register field value suitable for setting the register. */
#define MTL_TBS_CTRL_RESERVED_3_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : LEGOS
 *
 * Launch Expiry GSN Offset
 *
 * The number GSN slots that has to be added to the Launch GSN to compute the
 * Launch Expiry time. Value valid only when LEOV is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_LEGOS register field. */
#define MTL_TBS_CTRL_LEGOS_LSB	      4
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_LEGOS register field. */
#define MTL_TBS_CTRL_LEGOS_MSB	      6
/* The width in bits of the MTL_TBS_CTRL_LEGOS register field. */
#define MTL_TBS_CTRL_LEGOS_WIDTH      3
/* The mask used to set the MTL_TBS_CTRL_LEGOS register field value. */
#define MTL_TBS_CTRL_LEGOS_SET_MSK    0x00000070
/* The mask used to clear the MTL_TBS_CTRL_LEGOS register field value. */
#define MTL_TBS_CTRL_LEGOS_CLR_MSK    0xffffff8f
/* The reset value of the MTL_TBS_CTRL_LEGOS register field. */
#define MTL_TBS_CTRL_LEGOS_RESET      0x0
/* Extracts the MTL_TBS_CTRL_LEGOS field value from a register. */
#define MTL_TBS_CTRL_LEGOS_GET(value) (((value)&0x00000070) >> 4)
/* Produces a MTL_TBS_CTRL_LEGOS register field value suitable for setting the register. */
#define MTL_TBS_CTRL_LEGOS_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_RESERVED_7 register field. */
#define MTL_TBS_CTRL_RESERVED_7_LSB	   7
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_RESERVED_7 register field. */
#define MTL_TBS_CTRL_RESERVED_7_MSB	   7
/* The width in bits of the MTL_TBS_CTRL_RESERVED_7 register field. */
#define MTL_TBS_CTRL_RESERVED_7_WIDTH	   1
/* The mask used to set the MTL_TBS_CTRL_RESERVED_7 register field value. */
#define MTL_TBS_CTRL_RESERVED_7_SET_MSK	   0x00000080
/* The mask used to clear the MTL_TBS_CTRL_RESERVED_7 register field value. */
#define MTL_TBS_CTRL_RESERVED_7_CLR_MSK	   0xffffff7f
/* The reset value of the MTL_TBS_CTRL_RESERVED_7 register field. */
#define MTL_TBS_CTRL_RESERVED_7_RESET	   0x0
/* Extracts the MTL_TBS_CTRL_RESERVED_7 field value from a register. */
#define MTL_TBS_CTRL_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_TBS_CTRL_RESERVED_7 register field value suitable for setting the register. */
#define MTL_TBS_CTRL_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : LEOS
 *
 * Launch Expiry Offset
 *
 * The value in units of 256 nanoseconds that has to be added to the Launch time to
 * compute the Launch Expiry time. Value valid only when LEOV is set.
 *
 * Max value: 999,999,999 ns, additionally should be smaller than CTR-1 value when
 * ESTM mode is set, as this value is a modulo CTR value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TBS_CTRL_LEOS register field. */
#define MTL_TBS_CTRL_LEOS_LSB	     8
/* The Most Significant Bit (MSB) position of the MTL_TBS_CTRL_LEOS register field. */
#define MTL_TBS_CTRL_LEOS_MSB	     31
/* The width in bits of the MTL_TBS_CTRL_LEOS register field. */
#define MTL_TBS_CTRL_LEOS_WIDTH	     24
/* The mask used to set the MTL_TBS_CTRL_LEOS register field value. */
#define MTL_TBS_CTRL_LEOS_SET_MSK    0xffffff00
/* The mask used to clear the MTL_TBS_CTRL_LEOS register field value. */
#define MTL_TBS_CTRL_LEOS_CLR_MSK    0x000000ff
/* The reset value of the MTL_TBS_CTRL_LEOS register field. */
#define MTL_TBS_CTRL_LEOS_RESET	     0x0
/* Extracts the MTL_TBS_CTRL_LEOS field value from a register. */
#define MTL_TBS_CTRL_LEOS_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a MTL_TBS_CTRL_LEOS register field value suitable for setting the register. */
#define MTL_TBS_CTRL_LEOS_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TBS_CTRL.
 */
struct MTL_TBS_CTRL_s {
	volatile uint32_t ESTM : 1;		/* MTL_TBS_CTRL_ESTM */
	volatile uint32_t LEOV : 1;		/* MTL_TBS_CTRL_LEOV */
	volatile uint32_t TIEN : 1;		/* MTL_TBS_CTRL_TIEN */
	const volatile uint32_t Reserved_3 : 1; /* MTL_TBS_CTRL_RESERVED_3 */
	volatile uint32_t LEGOS : 3;		/* MTL_TBS_CTRL_LEGOS */
	const volatile uint32_t Reserved_7 : 1; /* MTL_TBS_CTRL_RESERVED_7 */
	volatile uint32_t LEOS : 24;		/* MTL_TBS_CTRL_LEOS */
};

/* The typedef declaration for register MTL_TBS_CTRL. */
typedef struct MTL_TBS_CTRL_s MTL_TBS_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TBS_CTRL register. */
#define MTL_TBS_CTRL_RESET 0x00000000
/* The byte offset of the MTL_TBS_CTRL register from the beginning of the component. */
#define MTL_TBS_CTRL_OFST  0x48

/*
 * Register : MTL_TBS_STATS
 *
 * This register provides the One Hot encoded Queue numbers that have the frame
 * drop related error
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------
 *  [7:0]  | RW     | 0x0   | MTL_TBS_STATS_EDQN
 *  [31:8] | R      | 0x0   | MTL_TBS_STATS_RESERVED_31_X
 *
 */
/*
 * Field : EDQN
 *
 * Expiry drop Queue number
 *
 * EDQN can have multiple bits set corresponding to the Queue numbers that have
 * experienced error described in TINS field of status register.
 *
 * Access restriction applies. Self-set to 1 on internal event. Clears on write of
 * 1.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TBS_STATS_EDQN register field. */
#define MTL_TBS_STATS_EDQN_LSB	      0
/* The Most Significant Bit (MSB) position of the MTL_TBS_STATS_EDQN register field. */
#define MTL_TBS_STATS_EDQN_MSB	      7
/* The width in bits of the MTL_TBS_STATS_EDQN register field. */
#define MTL_TBS_STATS_EDQN_WIDTH      8
/* The mask used to set the MTL_TBS_STATS_EDQN register field value. */
#define MTL_TBS_STATS_EDQN_SET_MSK    0x000000ff
/* The mask used to clear the MTL_TBS_STATS_EDQN register field value. */
#define MTL_TBS_STATS_EDQN_CLR_MSK    0xffffff00
/* The reset value of the MTL_TBS_STATS_EDQN register field. */
#define MTL_TBS_STATS_EDQN_RESET      0x0
/* Extracts the MTL_TBS_STATS_EDQN field value from a register. */
#define MTL_TBS_STATS_EDQN_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a MTL_TBS_STATS_EDQN register field value suitable for setting the register. */
#define MTL_TBS_STATS_EDQN_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_x
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TBS_STATS_RESERVED_31_X register field. */
#define MTL_TBS_STATS_RESERVED_31_X_LSB	       8
/* The Most Significant Bit (MSB) position of the MTL_TBS_STATS_RESERVED_31_X register field. */
#define MTL_TBS_STATS_RESERVED_31_X_MSB	       31
/* The width in bits of the MTL_TBS_STATS_RESERVED_31_X register field. */
#define MTL_TBS_STATS_RESERVED_31_X_WIDTH      24
/* The mask used to set the MTL_TBS_STATS_RESERVED_31_X register field value. */
#define MTL_TBS_STATS_RESERVED_31_X_SET_MSK    0xffffff00
/* The mask used to clear the MTL_TBS_STATS_RESERVED_31_X register field value. */
#define MTL_TBS_STATS_RESERVED_31_X_CLR_MSK    0x000000ff
/* The reset value of the MTL_TBS_STATS_RESERVED_31_X register field. */
#define MTL_TBS_STATS_RESERVED_31_X_RESET      0x0
/* Extracts the MTL_TBS_STATS_RESERVED_31_X field value from a register. */
#define MTL_TBS_STATS_RESERVED_31_X_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a MTL_TBS_STATS_RESERVED_31_X register field value suitable for setting the register. */
#define MTL_TBS_STATS_RESERVED_31_X_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TBS_STATS.
 */
struct MTL_TBS_STATS_s {
	volatile uint32_t EDQN : 8;		    /* MTL_TBS_STATS_EDQN */
	const volatile uint32_t Reserved_31_x : 24; /* MTL_TBS_STATS_RESERVED_31_X */
};

/* The typedef declaration for register MTL_TBS_STATS. */
typedef struct MTL_TBS_STATS_s MTL_TBS_STATS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TBS_STATS register. */
#define MTL_TBS_STATS_RESET 0x00000000
/* The byte offset of the MTL_TBS_STATS register from the beginning of the component. */
#define MTL_TBS_STATS_OFST  0x4c

/*
 * Register : MTL_EST_Control
 *
 * This register controls the operation of Enhancements to Scheduled Transmission
 * (IEEE 802.1Qbv).
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------
 *  [0]     | RW     | 0x0   | MTL_EST_CONTROL_EEST
 *  [1]     | RW     | 0x0   | MTL_EST_CONTROL_SSWL
 *  [2]     | R      | 0x0   | MTL_EST_CONTROL_RESERVED_2
 *  [3]     | RW     | 0x0   | MTL_EST_CONTROL_QHLBF
 *  [4]     | RW     | 0x0   | MTL_EST_CONTROL_DDBF
 *  [5]     | RW     | 0x0   | MTL_EST_CONTROL_DFBS
 *  [7:6]   | RW     | 0x0   | MTL_EST_CONTROL_LCSE
 *  [10:8]  | RW     | 0x0   | MTL_EST_CONTROL_TILS
 *  [22:11] | RW     | 0x0   | MTL_EST_CONTROL_CTOV
 *  [31:23] | RW     | 0x0   | MTL_EST_CONTROL_PTOV
 *
 */
/*
 * Field : EEST
 *
 * Enable EST
 *
 * When reset, the gate control list processing is halted and all gates are assumed
 * to be in Open state. Should be set for DWC_xgmac to start processing the gate
 * control lists. During the toggle from 0 to 1, the gate control list processing
 * starts only after the SSWL bit is set.
 *
 * When ECC is selected during the configuration, if an uncorrectable error is
 * detected in the GCL memory, DWC_xgmac resets this bit and disables the EST
 * function.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:----------------
 *  MTL_EST_CONTROL_EEST_E_DISABLE | 0x0   | EST is disabled
 *  MTL_EST_CONTROL_EEST_E_ENABLE  | 0x1   | EST is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_CONTROL_EEST
 *
 * EST is disabled
 */
#define MTL_EST_CONTROL_EEST_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_CONTROL_EEST
 *
 * EST is enabled
 */
#define MTL_EST_CONTROL_EEST_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_EEST register field. */
#define MTL_EST_CONTROL_EEST_LSB	0
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_EEST register field. */
#define MTL_EST_CONTROL_EEST_MSB	0
/* The width in bits of the MTL_EST_CONTROL_EEST register field. */
#define MTL_EST_CONTROL_EEST_WIDTH	1
/* The mask used to set the MTL_EST_CONTROL_EEST register field value. */
#define MTL_EST_CONTROL_EEST_SET_MSK	0x00000001
/* The mask used to clear the MTL_EST_CONTROL_EEST register field value. */
#define MTL_EST_CONTROL_EEST_CLR_MSK	0xfffffffe
/* The reset value of the MTL_EST_CONTROL_EEST register field. */
#define MTL_EST_CONTROL_EEST_RESET	0x0
/* Extracts the MTL_EST_CONTROL_EEST field value from a register. */
#define MTL_EST_CONTROL_EEST_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_EST_CONTROL_EEST register field value suitable for setting the register. */
#define MTL_EST_CONTROL_EEST_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : SSWL
 *
 * Switch to software owned list
 *
 * When set, indicates that the software has programmed the list that it currently
 * owns (SWOL) and DWC_xgmac should switch to the new list based on the new BTR.
 * Hardware clears this bit when the switch to the SWOL happens to indicate the
 * completion of the switch or an non-recoverable BTR error (BTRL = "11111111"
 * indicates the iterations exceeded the value of 512 and DWC_xgmac was not able to
 * update New BTR to be equal to or greater than Current Time.) is set. When BTRE
 * is set this bit is cleared but SWOL is not updated as the switch was not
 * successful. The write to this bit is effective only when EEST bit is set to 1
 * along with it or EEST bit is previously set to 1.
 *
 * Access restriction applies. Writing 1 sets the bit. Self-cleared. Writing 0 has
 * no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-------------------------------------
 *  MTL_EST_CONTROL_SSWL_E_DISABLE | 0x0   | Switch to S/W owned list is disabled
 *  MTL_EST_CONTROL_SSWL_E_ENABLE  | 0x1   | Switch to S/W owned list is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_CONTROL_SSWL
 *
 * Switch to S/W owned list is disabled
 */
#define MTL_EST_CONTROL_SSWL_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_CONTROL_SSWL
 *
 * Switch to S/W owned list is enabled
 */
#define MTL_EST_CONTROL_SSWL_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_SSWL register field. */
#define MTL_EST_CONTROL_SSWL_LSB	1
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_SSWL register field. */
#define MTL_EST_CONTROL_SSWL_MSB	1
/* The width in bits of the MTL_EST_CONTROL_SSWL register field. */
#define MTL_EST_CONTROL_SSWL_WIDTH	1
/* The mask used to set the MTL_EST_CONTROL_SSWL register field value. */
#define MTL_EST_CONTROL_SSWL_SET_MSK	0x00000002
/* The mask used to clear the MTL_EST_CONTROL_SSWL register field value. */
#define MTL_EST_CONTROL_SSWL_CLR_MSK	0xfffffffd
/* The reset value of the MTL_EST_CONTROL_SSWL register field. */
#define MTL_EST_CONTROL_SSWL_RESET	0x0
/* Extracts the MTL_EST_CONTROL_SSWL field value from a register. */
#define MTL_EST_CONTROL_SSWL_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_EST_CONTROL_SSWL register field value suitable for setting the register. */
#define MTL_EST_CONTROL_SSWL_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_RESERVED_2 register field. */
#define MTL_EST_CONTROL_RESERVED_2_LSB	      2
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_RESERVED_2 register field. */
#define MTL_EST_CONTROL_RESERVED_2_MSB	      2
/* The width in bits of the MTL_EST_CONTROL_RESERVED_2 register field. */
#define MTL_EST_CONTROL_RESERVED_2_WIDTH      1
/* The mask used to set the MTL_EST_CONTROL_RESERVED_2 register field value. */
#define MTL_EST_CONTROL_RESERVED_2_SET_MSK    0x00000004
/* The mask used to clear the MTL_EST_CONTROL_RESERVED_2 register field value. */
#define MTL_EST_CONTROL_RESERVED_2_CLR_MSK    0xfffffffb
/* The reset value of the MTL_EST_CONTROL_RESERVED_2 register field. */
#define MTL_EST_CONTROL_RESERVED_2_RESET      0x0
/* Extracts the MTL_EST_CONTROL_RESERVED_2 field value from a register. */
#define MTL_EST_CONTROL_RESERVED_2_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_EST_CONTROL_RESERVED_2 register field value suitable for setting the register. */
#define MTL_EST_CONTROL_RESERVED_2_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : QHLBF
 *
 * Quick Assertion of HLBF Error
 *
 * When set, Time Window for Head-of-Line blocking due to Frame Size Error is 1 to
 * 2 loop count of GCL list.On reset,Time Window for Head-of-Line blocking due to
 * Frame Size Error is 2 to 3 loop counts of GCL list.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                   | Value | Description
 * :-------------------------------------------------------|:------|:--------------------------------------
 *  MTL_EST_CONTROL_QHLBF_E_DISABLE | 0x0   | Disable Quick assertion of HLBF error
 *  MTL_EST_CONTROL_QHLBF_E_ENABLE  | 0x1   | Quick Assertion of HLBF Error
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_CONTROL_QHLBF
 *
 * Disable Quick assertion of HLBF error
 */
#define MTL_EST_CONTROL_QHLBF_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_CONTROL_QHLBF
 *
 * Quick Assertion of HLBF Error
 */
#define MTL_EST_CONTROL_QHLBF_E_ENABLE	0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_QHLBF register field. */
#define MTL_EST_CONTROL_QHLBF_LSB	 3
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_QHLBF register field. */
#define MTL_EST_CONTROL_QHLBF_MSB	 3
/* The width in bits of the MTL_EST_CONTROL_QHLBF register field. */
#define MTL_EST_CONTROL_QHLBF_WIDTH	 1
/* The mask used to set the MTL_EST_CONTROL_QHLBF register field value. */
#define MTL_EST_CONTROL_QHLBF_SET_MSK	 0x00000008
/* The mask used to clear the MTL_EST_CONTROL_QHLBF register field value. */
#define MTL_EST_CONTROL_QHLBF_CLR_MSK	 0xfffffff7
/* The reset value of the MTL_EST_CONTROL_QHLBF register field. */
#define MTL_EST_CONTROL_QHLBF_RESET	 0x0
/* Extracts the MTL_EST_CONTROL_QHLBF field value from a register. */
#define MTL_EST_CONTROL_QHLBF_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_EST_CONTROL_QHLBF register field value suitable for setting the register. */
#define MTL_EST_CONTROL_QHLBF_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : DDBF
 *
 * Do not Drop frames during Frame Size Error
 *
 * When set, frames are not dropped during Head-of-Line blocking due to Frame Size
 * Error (HLBF field of EST_Status register).
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:-------------------------------------------
 *  MTL_EST_CONTROL_DDBF_E_DROP      | 0x0   | Drop frames during Frame Size Error
 *  MTL_EST_CONTROL_DDBF_E_DONT_DROP | 0x1   | Do not Drop frames during Frame Size Error
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_CONTROL_DDBF
 *
 * Drop frames during Frame Size Error
 */
#define MTL_EST_CONTROL_DDBF_E_DROP	 0x0
/*
 * Enumerated value for register field MTL_EST_CONTROL_DDBF
 *
 * Do not Drop frames during Frame Size Error
 */
#define MTL_EST_CONTROL_DDBF_E_DONT_DROP 0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_DDBF register field. */
#define MTL_EST_CONTROL_DDBF_LSB	4
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_DDBF register field. */
#define MTL_EST_CONTROL_DDBF_MSB	4
/* The width in bits of the MTL_EST_CONTROL_DDBF register field. */
#define MTL_EST_CONTROL_DDBF_WIDTH	1
/* The mask used to set the MTL_EST_CONTROL_DDBF register field value. */
#define MTL_EST_CONTROL_DDBF_SET_MSK	0x00000010
/* The mask used to clear the MTL_EST_CONTROL_DDBF register field value. */
#define MTL_EST_CONTROL_DDBF_CLR_MSK	0xffffffef
/* The reset value of the MTL_EST_CONTROL_DDBF register field. */
#define MTL_EST_CONTROL_DDBF_RESET	0x0
/* Extracts the MTL_EST_CONTROL_DDBF field value from a register. */
#define MTL_EST_CONTROL_DDBF_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_EST_CONTROL_DDBF register field value suitable for setting the register. */
#define MTL_EST_CONTROL_DDBF_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : DFBS
 *
 * Drop Frames causing Scheduling Error
 *
 * When set frames reported to cause HOL Blocking due to not getting scheduled
 * (HLBS field of EST_Status register) after 4,8,16,32 (based on LCSE field of this
 * register) GCL iterations are dropped.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:--------------------------------------------
 *  MTL_EST_CONTROL_DFBS_E_DONT_DROP | 0x0   | Do not Drop Frames causing Scheduling Error
 *  MTL_EST_CONTROL_DFBS_E_DROP      | 0x1   | Drop Frames causing Scheduling Error
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_CONTROL_DFBS
 *
 * Do not Drop Frames causing Scheduling Error
 */
#define MTL_EST_CONTROL_DFBS_E_DONT_DROP 0x0
/*
 * Enumerated value for register field MTL_EST_CONTROL_DFBS
 *
 * Drop Frames causing Scheduling Error
 */
#define MTL_EST_CONTROL_DFBS_E_DROP	 0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_DFBS register field. */
#define MTL_EST_CONTROL_DFBS_LSB	5
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_DFBS register field. */
#define MTL_EST_CONTROL_DFBS_MSB	5
/* The width in bits of the MTL_EST_CONTROL_DFBS register field. */
#define MTL_EST_CONTROL_DFBS_WIDTH	1
/* The mask used to set the MTL_EST_CONTROL_DFBS register field value. */
#define MTL_EST_CONTROL_DFBS_SET_MSK	0x00000020
/* The mask used to clear the MTL_EST_CONTROL_DFBS register field value. */
#define MTL_EST_CONTROL_DFBS_CLR_MSK	0xffffffdf
/* The reset value of the MTL_EST_CONTROL_DFBS register field. */
#define MTL_EST_CONTROL_DFBS_RESET	0x0
/* Extracts the MTL_EST_CONTROL_DFBS field value from a register. */
#define MTL_EST_CONTROL_DFBS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a MTL_EST_CONTROL_DFBS register field value suitable for setting the register. */
#define MTL_EST_CONTROL_DFBS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : LCSE
 *
 * Loop Count to report Scheduling Error
 *
 * Programmable number of GCL list iterations before reporting an HLBS error
 * defined in EST_Status register.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:--------------
 *  MTL_EST_CONTROL_LCSE_E_M_4_ITERNS  | 0x0   | 4 iterations
 *  MTL_EST_CONTROL_LCSE_E_M_8_ITERNS  | 0x1   | 8 iterations
 *  MTL_EST_CONTROL_LCSE_E_M_16_ITERNS | 0x2   | 16 iterations
 *  MTL_EST_CONTROL_LCSE_E_M_32_ITERNS | 0x3   | 32 iterations
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_CONTROL_LCSE
 *
 * 4 iterations
 */
#define MTL_EST_CONTROL_LCSE_E_M_4_ITERNS  0x0
/*
 * Enumerated value for register field MTL_EST_CONTROL_LCSE
 *
 * 8 iterations
 */
#define MTL_EST_CONTROL_LCSE_E_M_8_ITERNS  0x1
/*
 * Enumerated value for register field MTL_EST_CONTROL_LCSE
 *
 * 16 iterations
 */
#define MTL_EST_CONTROL_LCSE_E_M_16_ITERNS 0x2
/*
 * Enumerated value for register field MTL_EST_CONTROL_LCSE
 *
 * 32 iterations
 */
#define MTL_EST_CONTROL_LCSE_E_M_32_ITERNS 0x3

/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_LCSE register field. */
#define MTL_EST_CONTROL_LCSE_LSB	6
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_LCSE register field. */
#define MTL_EST_CONTROL_LCSE_MSB	7
/* The width in bits of the MTL_EST_CONTROL_LCSE register field. */
#define MTL_EST_CONTROL_LCSE_WIDTH	2
/* The mask used to set the MTL_EST_CONTROL_LCSE register field value. */
#define MTL_EST_CONTROL_LCSE_SET_MSK	0x000000c0
/* The mask used to clear the MTL_EST_CONTROL_LCSE register field value. */
#define MTL_EST_CONTROL_LCSE_CLR_MSK	0xffffff3f
/* The reset value of the MTL_EST_CONTROL_LCSE register field. */
#define MTL_EST_CONTROL_LCSE_RESET	0x0
/* Extracts the MTL_EST_CONTROL_LCSE field value from a register. */
#define MTL_EST_CONTROL_LCSE_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a MTL_EST_CONTROL_LCSE register field value suitable for setting the register. */
#define MTL_EST_CONTROL_LCSE_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : TILS
 *
 * Time Interval Left Shift Amount
 *
 * This field provides the left shift amount for the programmed Time Interval
 * values used in the Gate Control Lists.
 *
 * * 000: No left shift needed (equal to x1ns)
 *
 * * 001: Left shift TI by 1 bit (equal to x2ns)
 *
 * * 010: Left shift TI by 2 bits (equal to x4ns)
 *
 * * ...
 *
 * * 111: Left shift TI by 7 bits (equal to x128ns)
 *
 * Based on the configuration, one or more bits of this field must be treated as
 * Reserved/Read-Only.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_TILS register field. */
#define MTL_EST_CONTROL_TILS_LSB	8
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_TILS register field. */
#define MTL_EST_CONTROL_TILS_MSB	10
/* The width in bits of the MTL_EST_CONTROL_TILS register field. */
#define MTL_EST_CONTROL_TILS_WIDTH	3
/* The mask used to set the MTL_EST_CONTROL_TILS register field value. */
#define MTL_EST_CONTROL_TILS_SET_MSK	0x00000700
/* The mask used to clear the MTL_EST_CONTROL_TILS register field value. */
#define MTL_EST_CONTROL_TILS_CLR_MSK	0xfffff8ff
/* The reset value of the MTL_EST_CONTROL_TILS register field. */
#define MTL_EST_CONTROL_TILS_RESET	0x0
/* Extracts the MTL_EST_CONTROL_TILS field value from a register. */
#define MTL_EST_CONTROL_TILS_GET(value) (((value)&0x00000700) >> 8)
/* Produces a MTL_EST_CONTROL_TILS register field value suitable for setting the register. */
#define MTL_EST_CONTROL_TILS_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : CTOV
 *
 * Current Time Offset Value
 *
 * Provides a 12 bit time offset value in nanosecond that is added to the current
 * time to compensate for all the implementation pipeline delays such as the CDC
 * sync delay, buffering delays, data path delays, and so on. This offset helps to
 * ensure that the impact of gate controls is visible on the line exactly at the
 * pre-determined schedule (or as close to the schedule as possible).
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_CTOV register field. */
#define MTL_EST_CONTROL_CTOV_LSB	11
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_CTOV register field. */
#define MTL_EST_CONTROL_CTOV_MSB	22
/* The width in bits of the MTL_EST_CONTROL_CTOV register field. */
#define MTL_EST_CONTROL_CTOV_WIDTH	12
/* The mask used to set the MTL_EST_CONTROL_CTOV register field value. */
#define MTL_EST_CONTROL_CTOV_SET_MSK	0x007ff800
/* The mask used to clear the MTL_EST_CONTROL_CTOV register field value. */
#define MTL_EST_CONTROL_CTOV_CLR_MSK	0xff8007ff
/* The reset value of the MTL_EST_CONTROL_CTOV register field. */
#define MTL_EST_CONTROL_CTOV_RESET	0x0
/* Extracts the MTL_EST_CONTROL_CTOV field value from a register. */
#define MTL_EST_CONTROL_CTOV_GET(value) (((value)&0x007ff800) >> 11)
/* Produces a MTL_EST_CONTROL_CTOV register field value suitable for setting the register. */
#define MTL_EST_CONTROL_CTOV_SET(value) (((value) << 11) & 0x007ff800)

/*
 * Field : PTOV
 *
 * PTP Time Offset Value
 *
 * The value of PTP Clock period multiplied by 9 in nanoseconds. This value is
 * needed to avoid transmission overruns at the beginning of the installation of a
 * new GCL.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_CONTROL_PTOV register field. */
#define MTL_EST_CONTROL_PTOV_LSB	23
/* The Most Significant Bit (MSB) position of the MTL_EST_CONTROL_PTOV register field. */
#define MTL_EST_CONTROL_PTOV_MSB	31
/* The width in bits of the MTL_EST_CONTROL_PTOV register field. */
#define MTL_EST_CONTROL_PTOV_WIDTH	9
/* The mask used to set the MTL_EST_CONTROL_PTOV register field value. */
#define MTL_EST_CONTROL_PTOV_SET_MSK	0xff800000
/* The mask used to clear the MTL_EST_CONTROL_PTOV register field value. */
#define MTL_EST_CONTROL_PTOV_CLR_MSK	0x007fffff
/* The reset value of the MTL_EST_CONTROL_PTOV register field. */
#define MTL_EST_CONTROL_PTOV_RESET	0x0
/* Extracts the MTL_EST_CONTROL_PTOV field value from a register. */
#define MTL_EST_CONTROL_PTOV_GET(value) (((value)&0xff800000) >> 23)
/* Produces a MTL_EST_CONTROL_PTOV register field value suitable for setting the register. */
#define MTL_EST_CONTROL_PTOV_SET(value) (((value) << 23) & 0xff800000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_CONTROL.
 */
struct MTL_EST_CONTROL_s {
	volatile uint32_t EEST : 1;		/* MTL_EST_CONTROL_EEST */
	volatile uint32_t SSWL : 1;		/* MTL_EST_CONTROL_SSWL */
	const volatile uint32_t Reserved_2 : 1; /* MTL_EST_CONTROL_RESERVED_2 */
	volatile uint32_t QHLBF : 1;		/* MTL_EST_CONTROL_QHLBF */
	volatile uint32_t DDBF : 1;		/* MTL_EST_CONTROL_DDBF */
	volatile uint32_t DFBS : 1;		/* MTL_EST_CONTROL_DFBS */
	volatile uint32_t LCSE : 2;		/* MTL_EST_CONTROL_LCSE */
	volatile uint32_t TILS : 3;		/* MTL_EST_CONTROL_TILS */
	volatile uint32_t CTOV : 12;		/* MTL_EST_CONTROL_CTOV */
	volatile uint32_t PTOV : 9;		/* MTL_EST_CONTROL_PTOV */
};

/* The typedef declaration for register MTL_EST_CONTROL. */
typedef struct MTL_EST_CONTROL_s MTL_EST_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_CONTROL register. */
#define MTL_EST_CONTROL_RESET 0x00000000
/* The byte offset of the MTL_EST_CONTROL register from the beginning of the component. */
#define MTL_EST_CONTROL_OFST  0x50

/*
 * Register : MTL_EST_Overhead
 *
 * This register indicates the value of Overhead.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------
 *  [7:0]   | RW     | 0x0   | MTL_EST_OVERHEAD_OVHD
 *  [15:8]  | R      | 0x0   | MTL_EST_OVERHEAD_RESERVED_15_8
 *  [20:16] | R      | 0x0   | MTL_EST_OVERHEAD_RESERVED_ABYT
 *  [31:21] | R      | 0x0   | MTL_EST_OVERHEAD_RESERVED_31_21
 *
 */
/*
 * Field : OVHD
 *
 * Overhead Bytes Value
 *
 * Fixed overhead to be programmed for all the frames to account for Scheduler
 * Delay.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_OVERHEAD_OVHD register field. */
#define MTL_EST_OVERHEAD_OVHD_LSB	 0
/* The Most Significant Bit (MSB) position of the MTL_EST_OVERHEAD_OVHD register field. */
#define MTL_EST_OVERHEAD_OVHD_MSB	 7
/* The width in bits of the MTL_EST_OVERHEAD_OVHD register field. */
#define MTL_EST_OVERHEAD_OVHD_WIDTH	 8
/* The mask used to set the MTL_EST_OVERHEAD_OVHD register field value. */
#define MTL_EST_OVERHEAD_OVHD_SET_MSK	 0x000000ff
/* The mask used to clear the MTL_EST_OVERHEAD_OVHD register field value. */
#define MTL_EST_OVERHEAD_OVHD_CLR_MSK	 0xffffff00
/* The reset value of the MTL_EST_OVERHEAD_OVHD register field. */
#define MTL_EST_OVERHEAD_OVHD_RESET	 0x0
/* Extracts the MTL_EST_OVERHEAD_OVHD field value from a register. */
#define MTL_EST_OVERHEAD_OVHD_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a MTL_EST_OVERHEAD_OVHD register field value suitable for setting the register. */
#define MTL_EST_OVERHEAD_OVHD_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_OVERHEAD_RESERVED_15_8 register field. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the MTL_EST_OVERHEAD_RESERVED_15_8 register field. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_MSB	  15
/* The width in bits of the MTL_EST_OVERHEAD_RESERVED_15_8 register field. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_WIDTH	  8
/* The mask used to set the MTL_EST_OVERHEAD_RESERVED_15_8 register field value. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the MTL_EST_OVERHEAD_RESERVED_15_8 register field value. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the MTL_EST_OVERHEAD_RESERVED_15_8 register field. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_RESET	  0x0
/* Extracts the MTL_EST_OVERHEAD_RESERVED_15_8 field value from a register. */
#define MTL_EST_OVERHEAD_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_EST_OVERHEAD_RESERVED_15_8 register field value suitable for setting the register.
 */
#define MTL_EST_OVERHEAD_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_ABYT
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_OVERHEAD_RESERVED_ABYT register field. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_LSB	  16
/* The Most Significant Bit (MSB) position of the MTL_EST_OVERHEAD_RESERVED_ABYT register field. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_MSB	  20
/* The width in bits of the MTL_EST_OVERHEAD_RESERVED_ABYT register field. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_WIDTH	  5
/* The mask used to set the MTL_EST_OVERHEAD_RESERVED_ABYT register field value. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_SET_MSK	  0x001f0000
/* The mask used to clear the MTL_EST_OVERHEAD_RESERVED_ABYT register field value. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_CLR_MSK	  0xffe0ffff
/* The reset value of the MTL_EST_OVERHEAD_RESERVED_ABYT register field. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_RESET	  0x0
/* Extracts the MTL_EST_OVERHEAD_RESERVED_ABYT field value from a register. */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_GET(value) (((value)&0x001f0000) >> 16)
/* Produces a MTL_EST_OVERHEAD_RESERVED_ABYT register field value suitable for setting the register.
 */
#define MTL_EST_OVERHEAD_RESERVED_ABYT_SET(value) (((value) << 16) & 0x001f0000)

/*
 * Field : Reserved_31_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_OVERHEAD_RESERVED_31_21 register field.
 */
#define MTL_EST_OVERHEAD_RESERVED_31_21_LSB	   21
/* The Most Significant Bit (MSB) position of the MTL_EST_OVERHEAD_RESERVED_31_21 register field. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_MSB	   31
/* The width in bits of the MTL_EST_OVERHEAD_RESERVED_31_21 register field. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_WIDTH	   11
/* The mask used to set the MTL_EST_OVERHEAD_RESERVED_31_21 register field value. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_SET_MSK	   0xffe00000
/* The mask used to clear the MTL_EST_OVERHEAD_RESERVED_31_21 register field value. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_CLR_MSK	   0x001fffff
/* The reset value of the MTL_EST_OVERHEAD_RESERVED_31_21 register field. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_RESET	   0x0
/* Extracts the MTL_EST_OVERHEAD_RESERVED_31_21 field value from a register. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_GET(value) (((value)&0xffe00000) >> 21)
/* Produces a MTL_EST_OVERHEAD_RESERVED_31_21 register field value suitable for setting the
 * register. */
#define MTL_EST_OVERHEAD_RESERVED_31_21_SET(value) (((value) << 21) & 0xffe00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_OVERHEAD.
 */
struct MTL_EST_OVERHEAD_s {
	volatile uint32_t OVHD : 8;		     /* MTL_EST_OVERHEAD_OVHD */
	const volatile uint32_t Reserved_15_8 : 8;   /* MTL_EST_OVERHEAD_RESERVED_15_8 */
	const volatile uint32_t Reserved_ABYT : 5;   /* MTL_EST_OVERHEAD_RESERVED_ABYT */
	const volatile uint32_t Reserved_31_21 : 11; /* MTL_EST_OVERHEAD_RESERVED_31_21 */
};

/* The typedef declaration for register MTL_EST_OVERHEAD. */
typedef struct MTL_EST_OVERHEAD_s MTL_EST_OVERHEAD_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_OVERHEAD register. */
#define MTL_EST_OVERHEAD_RESET 0x00000000
/* The byte offset of the MTL_EST_OVERHEAD register from the beginning of the component. */
#define MTL_EST_OVERHEAD_OFST  0x54

/*
 * Register : MTL_EST_Status
 *
 * This register provides Status related to Enhancements to Scheduled Transmission
 * (IEEE 802.1Qbv).
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------
 *  [0]     | RW     | 0x0   | MTL_EST_STATUS_SWLC
 *  [1]     | RW     | 0x0   | MTL_EST_STATUS_BTRE
 *  [2]     | R      | 0x0   | MTL_EST_STATUS_HLBF
 *  [3]     | R      | 0x0   | MTL_EST_STATUS_HLBS
 *  [4]     | RW     | 0x0   | MTL_EST_STATUS_CGCE
 *  [6:5]   | R      | 0x0   | MTL_EST_STATUS_RESERVED_6_5
 *  [7]     | R      | 0x0   | MTL_EST_STATUS_SWOL
 *  [15:8]  | R      | 0x0   | MTL_EST_STATUS_BTRL
 *  [19:16] | R      | 0x0   | MTL_EST_STATUS_CGSN
 *  [31:20] | R      | 0x0   | MTL_EST_STATUS_RESERVED_31_20
 *
 */
/*
 * Field : SWLC
 *
 * Switch to Software Owned List Complete
 *
 * When this field is set, indicates that DWC_xgmac has successfully switched to
 * the SWOL, and the SWOL bit is updated to that effect. This field is cleared when
 * the SSWL field of EST_Control register transitions from 0 to 1, or on a software
 * write.
 *
 * Access restriction applies. Self-set to 1 on internal event. Clears on write of
 * 1. Writing 0 has no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-----------------------------------------------
 *  MTL_EST_STATUS_SWLC_E_INACTIVE | 0x0   | Switch to S/W owned list Complete not detected
 *  MTL_EST_STATUS_SWLC_E_ACTIVE   | 0x1   | Switch to S/W owned list Complete detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_STATUS_SWLC
 *
 * Switch to S/W owned list Complete not detected
 */
#define MTL_EST_STATUS_SWLC_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_EST_STATUS_SWLC
 *
 * Switch to S/W owned list Complete detected
 */
#define MTL_EST_STATUS_SWLC_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_SWLC register field. */
#define MTL_EST_STATUS_SWLC_LSB	       0
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_SWLC register field. */
#define MTL_EST_STATUS_SWLC_MSB	       0
/* The width in bits of the MTL_EST_STATUS_SWLC register field. */
#define MTL_EST_STATUS_SWLC_WIDTH      1
/* The mask used to set the MTL_EST_STATUS_SWLC register field value. */
#define MTL_EST_STATUS_SWLC_SET_MSK    0x00000001
/* The mask used to clear the MTL_EST_STATUS_SWLC register field value. */
#define MTL_EST_STATUS_SWLC_CLR_MSK    0xfffffffe
/* The reset value of the MTL_EST_STATUS_SWLC register field. */
#define MTL_EST_STATUS_SWLC_RESET      0x0
/* Extracts the MTL_EST_STATUS_SWLC field value from a register. */
#define MTL_EST_STATUS_SWLC_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_EST_STATUS_SWLC register field value suitable for setting the register. */
#define MTL_EST_STATUS_SWLC_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : BTRE
 *
 * BTR Error
 *
 * When this field is set, indicates a programming error in the BTR of SWOL where
 * the programmed value is less than current time. If the BTRL = "11111111", SWOL
 * is not updated and software should reprogram the BTR to a value greater than
 * current time and set the SSWL bit to re-initiate the switch to SWOL. Otherwise,
 * if the value of BTRL < "11111111", SWOL is updated and this field indicates the
 * number of iterations (of + CycleTime) taken by DWC_xgmac to update the BTR to a
 * value greater than Current Time.
 *
 * Access restriction applies. Self-set to 1 on internal event. Clears on write of
 * 1. Writing 0 has no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-----------------------
 *  MTL_EST_STATUS_BTRE_E_INACTIVE | 0x0   | BTR Error not detected
 *  MTL_EST_STATUS_BTRE_E_ACTIVE   | 0x1   | BTR Error detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_STATUS_BTRE
 *
 * BTR Error not detected
 */
#define MTL_EST_STATUS_BTRE_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_EST_STATUS_BTRE
 *
 * BTR Error detected
 */
#define MTL_EST_STATUS_BTRE_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_BTRE register field. */
#define MTL_EST_STATUS_BTRE_LSB	       1
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_BTRE register field. */
#define MTL_EST_STATUS_BTRE_MSB	       1
/* The width in bits of the MTL_EST_STATUS_BTRE register field. */
#define MTL_EST_STATUS_BTRE_WIDTH      1
/* The mask used to set the MTL_EST_STATUS_BTRE register field value. */
#define MTL_EST_STATUS_BTRE_SET_MSK    0x00000002
/* The mask used to clear the MTL_EST_STATUS_BTRE register field value. */
#define MTL_EST_STATUS_BTRE_CLR_MSK    0xfffffffd
/* The reset value of the MTL_EST_STATUS_BTRE register field. */
#define MTL_EST_STATUS_BTRE_RESET      0x0
/* Extracts the MTL_EST_STATUS_BTRE field value from a register. */
#define MTL_EST_STATUS_BTRE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_EST_STATUS_BTRE register field value suitable for setting the register. */
#define MTL_EST_STATUS_BTRE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : HLBF
 *
 * Head-Of-Line Blocking due to Frame Size
 *
 * This field is set when HOL Blocking is noticed on one or more Queues when none
 * of the Time Intervals of open-gates in the GCL is greater than or equal to the
 * duration needed for frame (or frame fragment size when preemption is enabled)
 * transmission. The one-hot encoded Queue numbers that are experiencing HLBF are
 * indicated in the MTL_EST_Frm_Size_Error register. Additionally, the first Queue
 * number that experienced HLBF along with the frame size is captured in
 * MTL_EST_Frm_Size_Capture register. Bit cleared when MTL_EST_Frame_Size_Error
 * register is all zeros.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-------------------------------------------------
 *  MTL_EST_STATUS_HLBF_E_INACTIVE | 0x0   | Head-Of-Line Blocking due to Frame Size not
 * :                                                      |       | detected
 *  MTL_EST_STATUS_HLBF_E_ACTIVE   | 0x1   | Head-Of-Line Blocking due to Frame Size detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_STATUS_HLBF
 *
 * Head-Of-Line Blocking due to Frame Size not detected
 */
#define MTL_EST_STATUS_HLBF_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_EST_STATUS_HLBF
 *
 * Head-Of-Line Blocking due to Frame Size detected
 */
#define MTL_EST_STATUS_HLBF_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_HLBF register field. */
#define MTL_EST_STATUS_HLBF_LSB	       2
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_HLBF register field. */
#define MTL_EST_STATUS_HLBF_MSB	       2
/* The width in bits of the MTL_EST_STATUS_HLBF register field. */
#define MTL_EST_STATUS_HLBF_WIDTH      1
/* The mask used to set the MTL_EST_STATUS_HLBF register field value. */
#define MTL_EST_STATUS_HLBF_SET_MSK    0x00000004
/* The mask used to clear the MTL_EST_STATUS_HLBF register field value. */
#define MTL_EST_STATUS_HLBF_CLR_MSK    0xfffffffb
/* The reset value of the MTL_EST_STATUS_HLBF register field. */
#define MTL_EST_STATUS_HLBF_RESET      0x0
/* Extracts the MTL_EST_STATUS_HLBF field value from a register. */
#define MTL_EST_STATUS_HLBF_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_EST_STATUS_HLBF register field value suitable for setting the register. */
#define MTL_EST_STATUS_HLBF_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : HLBS
 *
 * Head-Of-Line Blocking due to Scheduling
 *
 * Set when the frame is not able to win arbitration and get scheduled even after 4
 * iterations of the GCL. Indicates to software a potential programming error. The
 * one-hot encoded values of the Queue Numbers that are not able to make progress
 * are indicated in the MTL_EST_Sch_Error register. Bit cleared when
 * MTL_EST_Sch_Error register is all zeros.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-------------------------------------------------
 *  MTL_EST_STATUS_HLBS_E_INACTIVE | 0x0   | Head-Of-Line Blocking due to Scheduling not
 * :                                                      |       | detected
 *  MTL_EST_STATUS_HLBS_E_ACTIVE   | 0x1   | Head-Of-Line Blocking due to Scheduling detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_STATUS_HLBS
 *
 * Head-Of-Line Blocking due to Scheduling not detected
 */
#define MTL_EST_STATUS_HLBS_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_EST_STATUS_HLBS
 *
 * Head-Of-Line Blocking due to Scheduling detected
 */
#define MTL_EST_STATUS_HLBS_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_HLBS register field. */
#define MTL_EST_STATUS_HLBS_LSB	       3
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_HLBS register field. */
#define MTL_EST_STATUS_HLBS_MSB	       3
/* The width in bits of the MTL_EST_STATUS_HLBS register field. */
#define MTL_EST_STATUS_HLBS_WIDTH      1
/* The mask used to set the MTL_EST_STATUS_HLBS register field value. */
#define MTL_EST_STATUS_HLBS_SET_MSK    0x00000008
/* The mask used to clear the MTL_EST_STATUS_HLBS register field value. */
#define MTL_EST_STATUS_HLBS_CLR_MSK    0xfffffff7
/* The reset value of the MTL_EST_STATUS_HLBS register field. */
#define MTL_EST_STATUS_HLBS_RESET      0x0
/* Extracts the MTL_EST_STATUS_HLBS field value from a register. */
#define MTL_EST_STATUS_HLBS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_EST_STATUS_HLBS register field value suitable for setting the register. */
#define MTL_EST_STATUS_HLBS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : CGCE
 *
 * Constant Gate Control Error
 *
 * This error occurs when the programmed Time Interval (TI) value after the
 * optional Left Shifting is more than or equal to the Cycle Time (CTR). These
 * programming guidelines imply that Gates are either always Closed or always Open
 * based on the Gate Control values; the same effect can be achieved by other
 * simpler (non TSN) programming mechanisms. As the implementation does not support
 * such a programming mechanism, an error is reported.
 *
 * Access restriction applies. Self-set to 1 on internal event. Clears on write of
 * 1. Writing 0 has no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-----------------------------------------
 *  MTL_EST_STATUS_CGCE_E_INACTIVE | 0x0   | Constant Gate Control Error not detected
 *  MTL_EST_STATUS_CGCE_E_ACTIVE   | 0x1   | Constant Gate Control Error detected
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_STATUS_CGCE
 *
 * Constant Gate Control Error not detected
 */
#define MTL_EST_STATUS_CGCE_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_EST_STATUS_CGCE
 *
 * Constant Gate Control Error detected
 */
#define MTL_EST_STATUS_CGCE_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_CGCE register field. */
#define MTL_EST_STATUS_CGCE_LSB	       4
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_CGCE register field. */
#define MTL_EST_STATUS_CGCE_MSB	       4
/* The width in bits of the MTL_EST_STATUS_CGCE register field. */
#define MTL_EST_STATUS_CGCE_WIDTH      1
/* The mask used to set the MTL_EST_STATUS_CGCE register field value. */
#define MTL_EST_STATUS_CGCE_SET_MSK    0x00000010
/* The mask used to clear the MTL_EST_STATUS_CGCE register field value. */
#define MTL_EST_STATUS_CGCE_CLR_MSK    0xffffffef
/* The reset value of the MTL_EST_STATUS_CGCE register field. */
#define MTL_EST_STATUS_CGCE_RESET      0x0
/* Extracts the MTL_EST_STATUS_CGCE field value from a register. */
#define MTL_EST_STATUS_CGCE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_EST_STATUS_CGCE register field value suitable for setting the register. */
#define MTL_EST_STATUS_CGCE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Reserved_6_5
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_RESERVED_6_5 register field. */
#define MTL_EST_STATUS_RESERVED_6_5_LSB	       5
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_RESERVED_6_5 register field. */
#define MTL_EST_STATUS_RESERVED_6_5_MSB	       6
/* The width in bits of the MTL_EST_STATUS_RESERVED_6_5 register field. */
#define MTL_EST_STATUS_RESERVED_6_5_WIDTH      2
/* The mask used to set the MTL_EST_STATUS_RESERVED_6_5 register field value. */
#define MTL_EST_STATUS_RESERVED_6_5_SET_MSK    0x00000060
/* The mask used to clear the MTL_EST_STATUS_RESERVED_6_5 register field value. */
#define MTL_EST_STATUS_RESERVED_6_5_CLR_MSK    0xffffff9f
/* The reset value of the MTL_EST_STATUS_RESERVED_6_5 register field. */
#define MTL_EST_STATUS_RESERVED_6_5_RESET      0x0
/* Extracts the MTL_EST_STATUS_RESERVED_6_5 field value from a register. */
#define MTL_EST_STATUS_RESERVED_6_5_GET(value) (((value)&0x00000060) >> 5)
/* Produces a MTL_EST_STATUS_RESERVED_6_5 register field value suitable for setting the register. */
#define MTL_EST_STATUS_RESERVED_6_5_SET(value) (((value) << 5) & 0x00000060)

/*
 * Field : SWOL
 *
 * Software Owned List
 *
 * When this field is 0, indicates that the Gate control list number 0 is owned by
 * software. When this field is 1, indicates that the Gate Control list 1 is owned
 * by the software. Any reads/writes by the software (using indirect access through
 * GCL_Control) is directed to the list indicated by this value, by default. The
 * inverse of this value is treated as HWOL.
 *
 * R/W operations performed by DWC_xgmac are directed to the list pointed by HWOL,
 * by default.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-----------------------------------------
 *  MTL_EST_STATUS_SWOL_E_INACTIVE | 0x0   | Gate control list number "0" is owned by
 * :                                                      |       | software
 *  MTL_EST_STATUS_SWOL_E_ACTIVE   | 0x1   | Gate control list number "1" is owned by
 * :                                                      |       | software
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_STATUS_SWOL
 *
 * Gate control list number "0" is owned by software
 */
#define MTL_EST_STATUS_SWOL_E_INACTIVE 0x0
/*
 * Enumerated value for register field MTL_EST_STATUS_SWOL
 *
 * Gate control list number "1" is owned by software
 */
#define MTL_EST_STATUS_SWOL_E_ACTIVE   0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_SWOL register field. */
#define MTL_EST_STATUS_SWOL_LSB	       7
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_SWOL register field. */
#define MTL_EST_STATUS_SWOL_MSB	       7
/* The width in bits of the MTL_EST_STATUS_SWOL register field. */
#define MTL_EST_STATUS_SWOL_WIDTH      1
/* The mask used to set the MTL_EST_STATUS_SWOL register field value. */
#define MTL_EST_STATUS_SWOL_SET_MSK    0x00000080
/* The mask used to clear the MTL_EST_STATUS_SWOL register field value. */
#define MTL_EST_STATUS_SWOL_CLR_MSK    0xffffff7f
/* The reset value of the MTL_EST_STATUS_SWOL register field. */
#define MTL_EST_STATUS_SWOL_RESET      0x0
/* Extracts the MTL_EST_STATUS_SWOL field value from a register. */
#define MTL_EST_STATUS_SWOL_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_EST_STATUS_SWOL register field value suitable for setting the register. */
#define MTL_EST_STATUS_SWOL_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : BTRL
 *
 * BTR Error Loop Count
 *
 * Provides the minimum count (N which is divided by 4) for which the equation,
 * Current Time =< New BTR + (N * 4 * New Cycle Time) becomes true. N = "11111111"
 * indicates that the iterations exceeded the value of 512 and DWC_xgmac is unable
 * to update New BTR to be equal to or greater than Current Time. Software
 * intervention is needed to update the New BTR.
 *
 * This field is cleared when BTRE field of this register is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_BTRL register field. */
#define MTL_EST_STATUS_BTRL_LSB	       8
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_BTRL register field. */
#define MTL_EST_STATUS_BTRL_MSB	       15
/* The width in bits of the MTL_EST_STATUS_BTRL register field. */
#define MTL_EST_STATUS_BTRL_WIDTH      8
/* The mask used to set the MTL_EST_STATUS_BTRL register field value. */
#define MTL_EST_STATUS_BTRL_SET_MSK    0x0000ff00
/* The mask used to clear the MTL_EST_STATUS_BTRL register field value. */
#define MTL_EST_STATUS_BTRL_CLR_MSK    0xffff00ff
/* The reset value of the MTL_EST_STATUS_BTRL register field. */
#define MTL_EST_STATUS_BTRL_RESET      0x0
/* Extracts the MTL_EST_STATUS_BTRL field value from a register. */
#define MTL_EST_STATUS_BTRL_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_EST_STATUS_BTRL register field value suitable for setting the register. */
#define MTL_EST_STATUS_BTRL_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : CGSN
 *
 * Current GCL Slot Number.
 *
 * Indicates the slot number of the GCL list. Slot number is a modulo 16 count of
 * the GCL List loops executed so far. Even if a new GCL list is installed, the
 * count is incremental.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_CGSN register field. */
#define MTL_EST_STATUS_CGSN_LSB	       16
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_CGSN register field. */
#define MTL_EST_STATUS_CGSN_MSB	       19
/* The width in bits of the MTL_EST_STATUS_CGSN register field. */
#define MTL_EST_STATUS_CGSN_WIDTH      4
/* The mask used to set the MTL_EST_STATUS_CGSN register field value. */
#define MTL_EST_STATUS_CGSN_SET_MSK    0x000f0000
/* The mask used to clear the MTL_EST_STATUS_CGSN register field value. */
#define MTL_EST_STATUS_CGSN_CLR_MSK    0xfff0ffff
/* The reset value of the MTL_EST_STATUS_CGSN register field. */
#define MTL_EST_STATUS_CGSN_RESET      0x0
/* Extracts the MTL_EST_STATUS_CGSN field value from a register. */
#define MTL_EST_STATUS_CGSN_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a MTL_EST_STATUS_CGSN register field value suitable for setting the register. */
#define MTL_EST_STATUS_CGSN_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : Reserved_31_20
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_STATUS_RESERVED_31_20 register field. */
#define MTL_EST_STATUS_RESERVED_31_20_LSB	 20
/* The Most Significant Bit (MSB) position of the MTL_EST_STATUS_RESERVED_31_20 register field. */
#define MTL_EST_STATUS_RESERVED_31_20_MSB	 31
/* The width in bits of the MTL_EST_STATUS_RESERVED_31_20 register field. */
#define MTL_EST_STATUS_RESERVED_31_20_WIDTH	 12
/* The mask used to set the MTL_EST_STATUS_RESERVED_31_20 register field value. */
#define MTL_EST_STATUS_RESERVED_31_20_SET_MSK	 0xfff00000
/* The mask used to clear the MTL_EST_STATUS_RESERVED_31_20 register field value. */
#define MTL_EST_STATUS_RESERVED_31_20_CLR_MSK	 0x000fffff
/* The reset value of the MTL_EST_STATUS_RESERVED_31_20 register field. */
#define MTL_EST_STATUS_RESERVED_31_20_RESET	 0x0
/* Extracts the MTL_EST_STATUS_RESERVED_31_20 field value from a register. */
#define MTL_EST_STATUS_RESERVED_31_20_GET(value) (((value)&0xfff00000) >> 20)
/* Produces a MTL_EST_STATUS_RESERVED_31_20 register field value suitable for setting the register.
 */
#define MTL_EST_STATUS_RESERVED_31_20_SET(value) (((value) << 20) & 0xfff00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_STATUS.
 */
struct MTL_EST_STATUS_s {
	volatile uint32_t SWLC : 1;		     /* MTL_EST_STATUS_SWLC */
	volatile uint32_t BTRE : 1;		     /* MTL_EST_STATUS_BTRE */
	const volatile uint32_t HLBF : 1;	     /* MTL_EST_STATUS_HLBF */
	const volatile uint32_t HLBS : 1;	     /* MTL_EST_STATUS_HLBS */
	volatile uint32_t CGCE : 1;		     /* MTL_EST_STATUS_CGCE */
	const volatile uint32_t Reserved_6_5 : 2;    /* MTL_EST_STATUS_RESERVED_6_5 */
	const volatile uint32_t SWOL : 1;	     /* MTL_EST_STATUS_SWOL */
	const volatile uint32_t BTRL : 8;	     /* MTL_EST_STATUS_BTRL */
	const volatile uint32_t CGSN : 4;	     /* MTL_EST_STATUS_CGSN */
	const volatile uint32_t Reserved_31_20 : 12; /* MTL_EST_STATUS_RESERVED_31_20 */
};

/* The typedef declaration for register MTL_EST_STATUS. */
typedef struct MTL_EST_STATUS_s MTL_EST_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_STATUS register. */
#define MTL_EST_STATUS_RESET 0x00000000
/* The byte offset of the MTL_EST_STATUS register from the beginning of the component. */
#define MTL_EST_STATUS_OFST  0x58

/*
 * Register : MTL_EST_Sch_Error
 *
 * This register provides the One Hot encoded Queue numbers that have the
 * scheduling related error (timeout).
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------
 *  [7:0]  | RW     | 0x0   | MTL_EST_SCH_ERROR_SETN
 *  [31:8] | R      | 0x0   | MTL_EST_SCH_ERROR_RESERVED_31_X
 *
 */
/*
 * Field : SETN
 *
 * Schedule Error TC Number
 *
 * SETN can have multiple bits set corresponding to the TC numbers that have
 * experienced error/timeout described in HLBS field of status register.
 *
 * Access restriction applies. Self-set to 1 on internal event. Clears on write of
 * 1. Writing 0 has no effect.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_SCH_ERROR_SETN register field. */
#define MTL_EST_SCH_ERROR_SETN_LSB	  0
/* The Most Significant Bit (MSB) position of the MTL_EST_SCH_ERROR_SETN register field. */
#define MTL_EST_SCH_ERROR_SETN_MSB	  7
/* The width in bits of the MTL_EST_SCH_ERROR_SETN register field. */
#define MTL_EST_SCH_ERROR_SETN_WIDTH	  8
/* The mask used to set the MTL_EST_SCH_ERROR_SETN register field value. */
#define MTL_EST_SCH_ERROR_SETN_SET_MSK	  0x000000ff
/* The mask used to clear the MTL_EST_SCH_ERROR_SETN register field value. */
#define MTL_EST_SCH_ERROR_SETN_CLR_MSK	  0xffffff00
/* The reset value of the MTL_EST_SCH_ERROR_SETN register field. */
#define MTL_EST_SCH_ERROR_SETN_RESET	  0x0
/* Extracts the MTL_EST_SCH_ERROR_SETN field value from a register. */
#define MTL_EST_SCH_ERROR_SETN_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a MTL_EST_SCH_ERROR_SETN register field value suitable for setting the register. */
#define MTL_EST_SCH_ERROR_SETN_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_x
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_SCH_ERROR_RESERVED_31_X register field.
 */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_LSB	   8
/* The Most Significant Bit (MSB) position of the MTL_EST_SCH_ERROR_RESERVED_31_X register field. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_MSB	   31
/* The width in bits of the MTL_EST_SCH_ERROR_RESERVED_31_X register field. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_WIDTH	   24
/* The mask used to set the MTL_EST_SCH_ERROR_RESERVED_31_X register field value. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_SET_MSK	   0xffffff00
/* The mask used to clear the MTL_EST_SCH_ERROR_RESERVED_31_X register field value. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_CLR_MSK	   0x000000ff
/* The reset value of the MTL_EST_SCH_ERROR_RESERVED_31_X register field. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_RESET	   0x0
/* Extracts the MTL_EST_SCH_ERROR_RESERVED_31_X field value from a register. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a MTL_EST_SCH_ERROR_RESERVED_31_X register field value suitable for setting the
 * register. */
#define MTL_EST_SCH_ERROR_RESERVED_31_X_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_SCH_ERROR.
 */
struct MTL_EST_SCH_ERROR_s {
	volatile uint32_t SETN : 8;		    /* MTL_EST_SCH_ERROR_SETN */
	const volatile uint32_t Reserved_31_x : 24; /* MTL_EST_SCH_ERROR_RESERVED_31_X */
};

/* The typedef declaration for register MTL_EST_SCH_ERROR. */
typedef struct MTL_EST_SCH_ERROR_s MTL_EST_SCH_ERROR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_SCH_ERROR register. */
#define MTL_EST_SCH_ERROR_RESET 0x00000000
/* The byte offset of the MTL_EST_SCH_ERROR register from the beginning of the component. */
#define MTL_EST_SCH_ERROR_OFST	0x60

/*
 * Register : MTL_EST_Frm_Size_Error
 *
 * This register provides the One Hot encoded Queue numbers that have the Frame
 * Size related error.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------------
 *  [7:0]  | RW     | 0x0   | MTL_EST_FRM_SIZE_ERROR_FETN
 *  [31:8] | R      | 0x0   | MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X
 *
 */
/*
 * Field : FETN
 *
 * Frame Size Error TC Number
 *
 * FETN can have multiple bits set corresponding to the TC numbers that have
 * experienced error described in HLBF field of status register.
 *
 * Access restriction applies. Self-set to 1 on internal event. Clears on write of
 * 1. Writing 0 has no effect.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_FRM_SIZE_ERROR_FETN register field. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_LSB	       0
/* The Most Significant Bit (MSB) position of the MTL_EST_FRM_SIZE_ERROR_FETN register field. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_MSB	       7
/* The width in bits of the MTL_EST_FRM_SIZE_ERROR_FETN register field. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_WIDTH      8
/* The mask used to set the MTL_EST_FRM_SIZE_ERROR_FETN register field value. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_SET_MSK    0x000000ff
/* The mask used to clear the MTL_EST_FRM_SIZE_ERROR_FETN register field value. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_CLR_MSK    0xffffff00
/* The reset value of the MTL_EST_FRM_SIZE_ERROR_FETN register field. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_RESET      0x0
/* Extracts the MTL_EST_FRM_SIZE_ERROR_FETN field value from a register. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a MTL_EST_FRM_SIZE_ERROR_FETN register field value suitable for setting the register. */
#define MTL_EST_FRM_SIZE_ERROR_FETN_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_x
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register
 * field. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_LSB	8
/* The Most Significant Bit (MSB) position of the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register
 * field. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_MSB	31
/* The width in bits of the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register field. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_WIDTH	24
/* The mask used to set the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register field value. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_SET_MSK	0xffffff00
/* The mask used to clear the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register field value. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_CLR_MSK	0x000000ff
/* The reset value of the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register field. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_RESET	0x0
/* Extracts the MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X field value from a register. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X register field value suitable for setting the
 * register. */
#define MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_FRM_SIZE_ERROR.
 */
struct MTL_EST_FRM_SIZE_ERROR_s {
	volatile uint32_t FETN : 8;		    /* MTL_EST_FRM_SIZE_ERROR_FETN */
	const volatile uint32_t Reserved_31_x : 24; /* MTL_EST_FRM_SIZE_ERROR_RESERVED_31_X */
};

/* The typedef declaration for register MTL_EST_FRM_SIZE_ERROR. */
typedef struct MTL_EST_FRM_SIZE_ERROR_s MTL_EST_FRM_SIZE_ERROR_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_FRM_SIZE_ERROR register. */
#define MTL_EST_FRM_SIZE_ERROR_RESET 0x00000000
/* The byte offset of the MTL_EST_FRM_SIZE_ERROR register from the beginning of the component. */
#define MTL_EST_FRM_SIZE_ERROR_OFST  0x64

/*
 * Register : MTL_EST_Frm_Size_Capture
 *
 * This register captures the Frame Size and Queue Number of the first occurrence
 * of the Frame Size related error. Upon clearing, this register captures the data
 * of the next occurrence of a similar error.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------------
 *  [14:0]  | R      | 0x0   | MTL_EST_FRM_SIZE_CAPTURE_HBFS
 *  [15]    | R      | 0x0   | MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15
 *  [18:16] | R      | 0x0   | MTL_EST_FRM_SIZE_CAPTURE_HBFQ
 *  [31:19] | R      | 0x0   | MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X
 *
 */
/*
 * Field : HBFS
 *
 * Frame Size of HLBF
 *
 * Captures the Frame Size of the dropped frame of the queue number indicated in
 * the HBFQ field of this register. Contents of this register should be considered
 * invalid, if this field is zero.
 *
 * Cleared when MTL_EST_Frm_Size_Error register is all zeros.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_FRM_SIZE_CAPTURE_HBFS register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_LSB	 0
/* The Most Significant Bit (MSB) position of the MTL_EST_FRM_SIZE_CAPTURE_HBFS register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_MSB	 14
/* The width in bits of the MTL_EST_FRM_SIZE_CAPTURE_HBFS register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_WIDTH	 15
/* The mask used to set the MTL_EST_FRM_SIZE_CAPTURE_HBFS register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_SET_MSK	 0x00007fff
/* The mask used to clear the MTL_EST_FRM_SIZE_CAPTURE_HBFS register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_CLR_MSK	 0xffff8000
/* The reset value of the MTL_EST_FRM_SIZE_CAPTURE_HBFS register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_RESET	 0x0
/* Extracts the MTL_EST_FRM_SIZE_CAPTURE_HBFS field value from a register. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_GET(value) (((value)&0x00007fff) >> 0)
/* Produces a MTL_EST_FRM_SIZE_CAPTURE_HBFS register field value suitable for setting the register.
 */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFS_SET(value) (((value) << 0) & 0x00007fff)

/*
 * Field : Reserved_15
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register
 * field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_LSB	15
/* The Most Significant Bit (MSB) position of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register
 * field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_MSB	15
/* The width in bits of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_WIDTH	1
/* The mask used to set the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_SET_MSK	0x00008000
/* The mask used to clear the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_CLR_MSK	0xffff7fff
/* The reset value of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_RESET	0x0
/* Extracts the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 field value from a register. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_GET(value) (((value)&0x00008000) >> 15)
/* Produces a MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 register field value suitable for setting the
 * register. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : HBFQ
 *
 * Queue Number of HLBF
 *
 * Captures the binary value of the of the first Queue (number) experiencing HLBF
 * error (see HLBF field of MTL_EST_status register). Value once written is not
 * altered by any subsequent queue errors of similar nature. Once cleared, the
 * queue number of the next occurring HLBF error is captured.
 *
 * Width is based on the number of Tx Queues configured; remaining bits are Read-
 * Only. Cleared when MTL_EST_Frm_Size_Error register is all zeros.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_LSB	 16
/* The Most Significant Bit (MSB) position of the MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_MSB	 18
/* The width in bits of the MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_WIDTH	 3
/* The mask used to set the MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_SET_MSK	 0x00070000
/* The mask used to clear the MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_CLR_MSK	 0xfff8ffff
/* The reset value of the MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_RESET	 0x0
/* Extracts the MTL_EST_FRM_SIZE_CAPTURE_HBFQ field value from a register. */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_GET(value) (((value)&0x00070000) >> 16)
/* Produces a MTL_EST_FRM_SIZE_CAPTURE_HBFQ register field value suitable for setting the register.
 */
#define MTL_EST_FRM_SIZE_CAPTURE_HBFQ_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_31_x
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register
 * field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_LSB	  19
/* The Most Significant Bit (MSB) position of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register
 * field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_MSB	  31
/* The width in bits of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_WIDTH	  13
/* The mask used to set the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_SET_MSK	  0xfff80000
/* The mask used to clear the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register field value. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_CLR_MSK	  0x0007ffff
/* The reset value of the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register field. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_RESET	  0x0
/* Extracts the MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X field value from a register. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_GET(value) (((value)&0xfff80000) >> 19)
/* Produces a MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X register field value suitable for setting the
 * register. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X_SET(value) (((value) << 19) & 0xfff80000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_FRM_SIZE_CAPTURE.
 */
struct MTL_EST_FRM_SIZE_CAPTURE_s {
	const volatile uint32_t HBFS : 15;	    /* MTL_EST_FRM_SIZE_CAPTURE_HBFS */
	const volatile uint32_t Reserved_15 : 1;    /* MTL_EST_FRM_SIZE_CAPTURE_RESERVED_15 */
	const volatile uint32_t HBFQ : 3;	    /* MTL_EST_FRM_SIZE_CAPTURE_HBFQ */
	const volatile uint32_t Reserved_31_x : 13; /* MTL_EST_FRM_SIZE_CAPTURE_RESERVED_31_X */
};

/* The typedef declaration for register MTL_EST_FRM_SIZE_CAPTURE. */
typedef struct MTL_EST_FRM_SIZE_CAPTURE_s MTL_EST_FRM_SIZE_CAPTURE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_FRM_SIZE_CAPTURE register. */
#define MTL_EST_FRM_SIZE_CAPTURE_RESET 0x00000000
/* The byte offset of the MTL_EST_FRM_SIZE_CAPTURE register from the beginning of the component. */
#define MTL_EST_FRM_SIZE_CAPTURE_OFST  0x68

/*
 * Register : MTL_EST_Intr_Enable
 *
 * This register implements the Interrupt Enable bits for the various events that
 * generate an interrupt. Bit positions have a 1- to-1 correspondence with the
 * status bit positions in MTL_EST_Status register.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------
 *  [0]    | RW     | 0x0   | MTL_EST_INTR_ENABLE_IECC
 *  [1]    | RW     | 0x0   | MTL_EST_INTR_ENABLE_IEBE
 *  [2]    | RW     | 0x0   | MTL_EST_INTR_ENABLE_IEHF
 *  [3]    | RW     | 0x0   | MTL_EST_INTR_ENABLE_IEHS
 *  [4]    | RW     | 0x0   | MTL_EST_INTR_ENABLE_CGCE
 *  [31:5] | R      | 0x0   | MTL_EST_INTR_ENABLE_RESERVED_31_5
 *
 */
/*
 * Field : IECC
 *
 * Interrupt Enable for Switch List
 *
 * When set, generates interrupt when the configuration change is successful and
 * DWC_xgmac has switched to the new list. When reset, this event does not generate
 * an interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:--------------------------------------
 *  MTL_EST_INTR_ENABLE_IECC_E_DISABLE | 0x0   | Interrupt for Switch List is disabled
 *  MTL_EST_INTR_ENABLE_IECC_E_ENABLE  | 0x1   | Interrupt for Switch List is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IECC
 *
 * Interrupt for Switch List is disabled
 */
#define MTL_EST_INTR_ENABLE_IECC_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IECC
 *
 * Interrupt for Switch List is enabled
 */
#define MTL_EST_INTR_ENABLE_IECC_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_INTR_ENABLE_IECC register field. */
#define MTL_EST_INTR_ENABLE_IECC_LSB	    0
/* The Most Significant Bit (MSB) position of the MTL_EST_INTR_ENABLE_IECC register field. */
#define MTL_EST_INTR_ENABLE_IECC_MSB	    0
/* The width in bits of the MTL_EST_INTR_ENABLE_IECC register field. */
#define MTL_EST_INTR_ENABLE_IECC_WIDTH	    1
/* The mask used to set the MTL_EST_INTR_ENABLE_IECC register field value. */
#define MTL_EST_INTR_ENABLE_IECC_SET_MSK    0x00000001
/* The mask used to clear the MTL_EST_INTR_ENABLE_IECC register field value. */
#define MTL_EST_INTR_ENABLE_IECC_CLR_MSK    0xfffffffe
/* The reset value of the MTL_EST_INTR_ENABLE_IECC register field. */
#define MTL_EST_INTR_ENABLE_IECC_RESET	    0x0
/* Extracts the MTL_EST_INTR_ENABLE_IECC field value from a register. */
#define MTL_EST_INTR_ENABLE_IECC_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_EST_INTR_ENABLE_IECC register field value suitable for setting the register. */
#define MTL_EST_INTR_ENABLE_IECC_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : IEBE
 *
 * Interrupt Enable for BTR Error
 *
 * When set, generates interrupt when the BTR Error occurs and is indicated in the
 * status. When reset, this event does not generate an interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:------------------------------------
 *  MTL_EST_INTR_ENABLE_IEBE_E_DISABLE | 0x0   | Interrupt for BTR Error is disabled
 *  MTL_EST_INTR_ENABLE_IEBE_E_ENABLE  | 0x1   | Interrupt for BTR Error is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IEBE
 *
 * Interrupt for BTR Error is disabled
 */
#define MTL_EST_INTR_ENABLE_IEBE_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IEBE
 *
 * Interrupt for BTR Error is enabled
 */
#define MTL_EST_INTR_ENABLE_IEBE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_INTR_ENABLE_IEBE register field. */
#define MTL_EST_INTR_ENABLE_IEBE_LSB	    1
/* The Most Significant Bit (MSB) position of the MTL_EST_INTR_ENABLE_IEBE register field. */
#define MTL_EST_INTR_ENABLE_IEBE_MSB	    1
/* The width in bits of the MTL_EST_INTR_ENABLE_IEBE register field. */
#define MTL_EST_INTR_ENABLE_IEBE_WIDTH	    1
/* The mask used to set the MTL_EST_INTR_ENABLE_IEBE register field value. */
#define MTL_EST_INTR_ENABLE_IEBE_SET_MSK    0x00000002
/* The mask used to clear the MTL_EST_INTR_ENABLE_IEBE register field value. */
#define MTL_EST_INTR_ENABLE_IEBE_CLR_MSK    0xfffffffd
/* The reset value of the MTL_EST_INTR_ENABLE_IEBE register field. */
#define MTL_EST_INTR_ENABLE_IEBE_RESET	    0x0
/* Extracts the MTL_EST_INTR_ENABLE_IEBE field value from a register. */
#define MTL_EST_INTR_ENABLE_IEBE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_EST_INTR_ENABLE_IEBE register field value suitable for setting the register. */
#define MTL_EST_INTR_ENABLE_IEBE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : IEHF
 *
 * Interrupt Enable for HLBF
 *
 * When set, generates interrupt when the Head-of-Line Blocking due to Frame Size
 * error occurs and is indicated in the status. When reset, this event does not
 * generate an interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:-------------------------------
 *  MTL_EST_INTR_ENABLE_IEHF_E_DISABLE | 0x0   | Interrupt for HLBF is disabled
 *  MTL_EST_INTR_ENABLE_IEHF_E_ENABLE  | 0x1   | Interrupt for HLBF is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IEHF
 *
 * Interrupt for HLBF is disabled
 */
#define MTL_EST_INTR_ENABLE_IEHF_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IEHF
 *
 * Interrupt for HLBF is enabled
 */
#define MTL_EST_INTR_ENABLE_IEHF_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_INTR_ENABLE_IEHF register field. */
#define MTL_EST_INTR_ENABLE_IEHF_LSB	    2
/* The Most Significant Bit (MSB) position of the MTL_EST_INTR_ENABLE_IEHF register field. */
#define MTL_EST_INTR_ENABLE_IEHF_MSB	    2
/* The width in bits of the MTL_EST_INTR_ENABLE_IEHF register field. */
#define MTL_EST_INTR_ENABLE_IEHF_WIDTH	    1
/* The mask used to set the MTL_EST_INTR_ENABLE_IEHF register field value. */
#define MTL_EST_INTR_ENABLE_IEHF_SET_MSK    0x00000004
/* The mask used to clear the MTL_EST_INTR_ENABLE_IEHF register field value. */
#define MTL_EST_INTR_ENABLE_IEHF_CLR_MSK    0xfffffffb
/* The reset value of the MTL_EST_INTR_ENABLE_IEHF register field. */
#define MTL_EST_INTR_ENABLE_IEHF_RESET	    0x0
/* Extracts the MTL_EST_INTR_ENABLE_IEHF field value from a register. */
#define MTL_EST_INTR_ENABLE_IEHF_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_EST_INTR_ENABLE_IEHF register field value suitable for setting the register. */
#define MTL_EST_INTR_ENABLE_IEHF_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : IEHS
 *
 * Interrupt Enable for HLBS
 *
 * When set, generates interrupt when the Head-of-Line Blocking due to Scheduling
 * issue and is indicated in the status. When reset, this event does not generate
 * an interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:-------------------------------
 *  MTL_EST_INTR_ENABLE_IEHS_E_DISABLE | 0x0   | Interrupt for HLBS is disabled
 *  MTL_EST_INTR_ENABLE_IEHS_E_ENABLE  | 0x1   | Interrupt for HLBS is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IEHS
 *
 * Interrupt for HLBS is disabled
 */
#define MTL_EST_INTR_ENABLE_IEHS_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_IEHS
 *
 * Interrupt for HLBS is enabled
 */
#define MTL_EST_INTR_ENABLE_IEHS_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_INTR_ENABLE_IEHS register field. */
#define MTL_EST_INTR_ENABLE_IEHS_LSB	    3
/* The Most Significant Bit (MSB) position of the MTL_EST_INTR_ENABLE_IEHS register field. */
#define MTL_EST_INTR_ENABLE_IEHS_MSB	    3
/* The width in bits of the MTL_EST_INTR_ENABLE_IEHS register field. */
#define MTL_EST_INTR_ENABLE_IEHS_WIDTH	    1
/* The mask used to set the MTL_EST_INTR_ENABLE_IEHS register field value. */
#define MTL_EST_INTR_ENABLE_IEHS_SET_MSK    0x00000008
/* The mask used to clear the MTL_EST_INTR_ENABLE_IEHS register field value. */
#define MTL_EST_INTR_ENABLE_IEHS_CLR_MSK    0xfffffff7
/* The reset value of the MTL_EST_INTR_ENABLE_IEHS register field. */
#define MTL_EST_INTR_ENABLE_IEHS_RESET	    0x0
/* Extracts the MTL_EST_INTR_ENABLE_IEHS field value from a register. */
#define MTL_EST_INTR_ENABLE_IEHS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_EST_INTR_ENABLE_IEHS register field value suitable for setting the register. */
#define MTL_EST_INTR_ENABLE_IEHS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : CGCE
 *
 * Interrupt Enable for CGCE
 *
 * When set, generates interrupt when the Constant Gate Control Error occurs and is
 * indicated in the status. When reset, this event does not generate an interrupt.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:-------------------------------
 *  MTL_EST_INTR_ENABLE_CGCE_E_DISABLE | 0x0   | Interrupt for CGCE is disabled
 *  MTL_EST_INTR_ENABLE_CGCE_E_ENABLE  | 0x1   | Interrupt for CGCE is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_CGCE
 *
 * Interrupt for CGCE is disabled
 */
#define MTL_EST_INTR_ENABLE_CGCE_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_EST_INTR_ENABLE_CGCE
 *
 * Interrupt for CGCE is enabled
 */
#define MTL_EST_INTR_ENABLE_CGCE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_EST_INTR_ENABLE_CGCE register field. */
#define MTL_EST_INTR_ENABLE_CGCE_LSB	    4
/* The Most Significant Bit (MSB) position of the MTL_EST_INTR_ENABLE_CGCE register field. */
#define MTL_EST_INTR_ENABLE_CGCE_MSB	    4
/* The width in bits of the MTL_EST_INTR_ENABLE_CGCE register field. */
#define MTL_EST_INTR_ENABLE_CGCE_WIDTH	    1
/* The mask used to set the MTL_EST_INTR_ENABLE_CGCE register field value. */
#define MTL_EST_INTR_ENABLE_CGCE_SET_MSK    0x00000010
/* The mask used to clear the MTL_EST_INTR_ENABLE_CGCE register field value. */
#define MTL_EST_INTR_ENABLE_CGCE_CLR_MSK    0xffffffef
/* The reset value of the MTL_EST_INTR_ENABLE_CGCE register field. */
#define MTL_EST_INTR_ENABLE_CGCE_RESET	    0x0
/* Extracts the MTL_EST_INTR_ENABLE_CGCE field value from a register. */
#define MTL_EST_INTR_ENABLE_CGCE_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_EST_INTR_ENABLE_CGCE register field value suitable for setting the register. */
#define MTL_EST_INTR_ENABLE_CGCE_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Reserved_31_5
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_EST_INTR_ENABLE_RESERVED_31_5 register field.
 */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_LSB	     5
/* The Most Significant Bit (MSB) position of the MTL_EST_INTR_ENABLE_RESERVED_31_5 register field.
 */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_MSB	     31
/* The width in bits of the MTL_EST_INTR_ENABLE_RESERVED_31_5 register field. */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_WIDTH	     27
/* The mask used to set the MTL_EST_INTR_ENABLE_RESERVED_31_5 register field value. */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_SET_MSK    0xffffffe0
/* The mask used to clear the MTL_EST_INTR_ENABLE_RESERVED_31_5 register field value. */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_CLR_MSK    0x0000001f
/* The reset value of the MTL_EST_INTR_ENABLE_RESERVED_31_5 register field. */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_RESET	     0x0
/* Extracts the MTL_EST_INTR_ENABLE_RESERVED_31_5 field value from a register. */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_GET(value) (((value)&0xffffffe0) >> 5)
/* Produces a MTL_EST_INTR_ENABLE_RESERVED_31_5 register field value suitable for setting the
 * register. */
#define MTL_EST_INTR_ENABLE_RESERVED_31_5_SET(value) (((value) << 5) & 0xffffffe0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_EST_INTR_ENABLE.
 */
struct MTL_EST_INTR_ENABLE_s {
	volatile uint32_t IECC : 1;		    /* MTL_EST_INTR_ENABLE_IECC */
	volatile uint32_t IEBE : 1;		    /* MTL_EST_INTR_ENABLE_IEBE */
	volatile uint32_t IEHF : 1;		    /* MTL_EST_INTR_ENABLE_IEHF */
	volatile uint32_t IEHS : 1;		    /* MTL_EST_INTR_ENABLE_IEHS */
	volatile uint32_t CGCE : 1;		    /* MTL_EST_INTR_ENABLE_CGCE */
	const volatile uint32_t Reserved_31_5 : 27; /* MTL_EST_INTR_ENABLE_RESERVED_31_5 */
};

/* The typedef declaration for register MTL_EST_INTR_ENABLE. */
typedef struct MTL_EST_INTR_ENABLE_s MTL_EST_INTR_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_EST_INTR_ENABLE register. */
#define MTL_EST_INTR_ENABLE_RESET 0x00000000
/* The byte offset of the MTL_EST_INTR_ENABLE register from the beginning of the component. */
#define MTL_EST_INTR_ENABLE_OFST  0x70

/*
 * Register : MTL_GCL_Control
 *
 * This register provides the control information for reading/writing to the Gate
 * Control lists.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------
 *  [0]     | RW     | 0x0   | MTL_GCL_CONTROL_SRWO
 *  [1]     | RW     | 0x0   | MTL_GCL_CONTROL_R1W0
 *  [2]     | RW     | 0x0   | MTL_GCL_CONTROL_GCRR
 *  [3]     | R      | 0x0   | MTL_GCL_CONTROL_RESERVED_GCLS
 *  [4]     | RW     | 0x0   | MTL_GCL_CONTROL_DBGM
 *  [5]     | RW     | 0x0   | MTL_GCL_CONTROL_DBGB
 *  [7:6]   | R      | 0x0   | MTL_GCL_CONTROL_RESERVED_7_6
 *  [15:8]  | RW     | 0x0   | MTL_GCL_CONTROL_ADDR
 *  [20:16] | R      | 0x0   | MTL_GCL_CONTROL_RESERVED_20_Y
 *  [21]    | R      | 0x0   | MTL_GCL_CONTROL_GCLEIEE
 *  [22]    | R      | 0x0   | MTL_GCL_CONTROL_GCLEIAEE
 *  [23]    | R      | 0x0   | MTL_GCL_CONTROL_GCLEIEC
 *  [31:24] | R      | 0x0   | MTL_GCL_CONTROL_RESERVED_31_24
 *
 */
/*
 * Field : SRWO
 *
 * Start Read/Write Op
 *
 * * When this field is set, indicates that a Read/Write operation has started and
 *   is in progress.
 *
 * * When this field is reset by DWC_xgmac, indicates that the R/W operation is
 *   complete or an error has occurred.
 *
 * * Reads: Data can be read from MTL_GCL_Data register after this bit is reset.
 *
 * * Writes: MTL_GCL_Data should be programmed with write data before setting SRWO
 *   bit.
 *
 * Access restriction applies. Writing 1 sets the bit. Self-cleared. Writing 0 has
 * no effect.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-----------------------------
 *  MTL_GCL_CONTROL_SRWO_E_DISABLE | 0x0   | Start Read/Write Op disabled
 *  MTL_GCL_CONTROL_SRWO_E_ENABLE  | 0x1   | Start Read/Write Op enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_SRWO
 *
 * Start Read/Write Op disabled
 */
#define MTL_GCL_CONTROL_SRWO_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_SRWO
 *
 * Start Read/Write Op enabled
 */
#define MTL_GCL_CONTROL_SRWO_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_SRWO register field. */
#define MTL_GCL_CONTROL_SRWO_LSB	0
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_SRWO register field. */
#define MTL_GCL_CONTROL_SRWO_MSB	0
/* The width in bits of the MTL_GCL_CONTROL_SRWO register field. */
#define MTL_GCL_CONTROL_SRWO_WIDTH	1
/* The mask used to set the MTL_GCL_CONTROL_SRWO register field value. */
#define MTL_GCL_CONTROL_SRWO_SET_MSK	0x00000001
/* The mask used to clear the MTL_GCL_CONTROL_SRWO register field value. */
#define MTL_GCL_CONTROL_SRWO_CLR_MSK	0xfffffffe
/* The reset value of the MTL_GCL_CONTROL_SRWO register field. */
#define MTL_GCL_CONTROL_SRWO_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_SRWO field value from a register. */
#define MTL_GCL_CONTROL_SRWO_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_GCL_CONTROL_SRWO register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_SRWO_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : R1W0
 *
 * Read 1, Write 0:
 *
 * * When set to 1: Read Operation
 *
 * * When set to 0: Write Operation.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                | Value | Description
 * :----------------------------------------------------|:------|:----------------
 *  MTL_GCL_CONTROL_R1W0_E_WRITE | 0x0   | Write Operation
 *  MTL_GCL_CONTROL_R1W0_E_READ  | 0x1   | Read Operation
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_R1W0
 *
 * Write Operation
 */
#define MTL_GCL_CONTROL_R1W0_E_WRITE 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_R1W0
 *
 * Read Operation
 */
#define MTL_GCL_CONTROL_R1W0_E_READ  0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_R1W0 register field. */
#define MTL_GCL_CONTROL_R1W0_LSB	1
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_R1W0 register field. */
#define MTL_GCL_CONTROL_R1W0_MSB	1
/* The width in bits of the MTL_GCL_CONTROL_R1W0 register field. */
#define MTL_GCL_CONTROL_R1W0_WIDTH	1
/* The mask used to set the MTL_GCL_CONTROL_R1W0 register field value. */
#define MTL_GCL_CONTROL_R1W0_SET_MSK	0x00000002
/* The mask used to clear the MTL_GCL_CONTROL_R1W0 register field value. */
#define MTL_GCL_CONTROL_R1W0_CLR_MSK	0xfffffffd
/* The reset value of the MTL_GCL_CONTROL_R1W0 register field. */
#define MTL_GCL_CONTROL_R1W0_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_R1W0 field value from a register. */
#define MTL_GCL_CONTROL_R1W0_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_GCL_CONTROL_R1W0 register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_R1W0_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : GCRR
 *
 * Gate Control Related Registers
 *
 * When this field is set to 1, indicates that the R/W access is for the GCL
 * related registers (BTR, CTR, TER, LLR) whose address is provided by GCRA. When
 * 0, indicates that R/W should be directed to GCL from the address provided by
 * GCLA.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:--------------------------------------------
 *  MTL_GCL_CONTROL_GCRR_E_DISABLE | 0x0   | Gate Control Related Registers are disabled
 *  MTL_GCL_CONTROL_GCRR_E_ENABLE  | 0x1   | Gate Control Related Registers are enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCRR
 *
 * Gate Control Related Registers are disabled
 */
#define MTL_GCL_CONTROL_GCRR_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCRR
 *
 * Gate Control Related Registers are enabled
 */
#define MTL_GCL_CONTROL_GCRR_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_GCRR register field. */
#define MTL_GCL_CONTROL_GCRR_LSB	2
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_GCRR register field. */
#define MTL_GCL_CONTROL_GCRR_MSB	2
/* The width in bits of the MTL_GCL_CONTROL_GCRR register field. */
#define MTL_GCL_CONTROL_GCRR_WIDTH	1
/* The mask used to set the MTL_GCL_CONTROL_GCRR register field value. */
#define MTL_GCL_CONTROL_GCRR_SET_MSK	0x00000004
/* The mask used to clear the MTL_GCL_CONTROL_GCRR register field value. */
#define MTL_GCL_CONTROL_GCRR_CLR_MSK	0xfffffffb
/* The reset value of the MTL_GCL_CONTROL_GCRR register field. */
#define MTL_GCL_CONTROL_GCRR_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_GCRR field value from a register. */
#define MTL_GCL_CONTROL_GCRR_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_GCL_CONTROL_GCRR register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_GCRR_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_GCLS
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_RESERVED_GCLS register field. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_LSB	 3
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_RESERVED_GCLS register field. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_MSB	 3
/* The width in bits of the MTL_GCL_CONTROL_RESERVED_GCLS register field. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_WIDTH	 1
/* The mask used to set the MTL_GCL_CONTROL_RESERVED_GCLS register field value. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_SET_MSK	 0x00000008
/* The mask used to clear the MTL_GCL_CONTROL_RESERVED_GCLS register field value. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_CLR_MSK	 0xfffffff7
/* The reset value of the MTL_GCL_CONTROL_RESERVED_GCLS register field. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_RESET	 0x0
/* Extracts the MTL_GCL_CONTROL_RESERVED_GCLS field value from a register. */
#define MTL_GCL_CONTROL_RESERVED_GCLS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_GCL_CONTROL_RESERVED_GCLS register field value suitable for setting the register.
 */
#define MTL_GCL_CONTROL_RESERVED_GCLS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : DBGM
 *
 * Debug Mode
 *
 * When this field is set to 1, indicates R/W in debug mode where the memory bank
 * (for GCL and Time related registers) is explicitly provided by DBGB value. When
 * set to 0, SWOL bit is used to determine which bank to use.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                  | Value | Description
 * :------------------------------------------------------|:------|:-----------------------
 *  MTL_GCL_CONTROL_DBGM_E_DISABLE | 0x0   | Debug Mode is disabled
 *  MTL_GCL_CONTROL_DBGM_E_ENABLE  | 0x1   | Debug Mode is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_DBGM
 *
 * Debug Mode is disabled
 */
#define MTL_GCL_CONTROL_DBGM_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_DBGM
 *
 * Debug Mode is enabled
 */
#define MTL_GCL_CONTROL_DBGM_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_DBGM register field. */
#define MTL_GCL_CONTROL_DBGM_LSB	4
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_DBGM register field. */
#define MTL_GCL_CONTROL_DBGM_MSB	4
/* The width in bits of the MTL_GCL_CONTROL_DBGM register field. */
#define MTL_GCL_CONTROL_DBGM_WIDTH	1
/* The mask used to set the MTL_GCL_CONTROL_DBGM register field value. */
#define MTL_GCL_CONTROL_DBGM_SET_MSK	0x00000010
/* The mask used to clear the MTL_GCL_CONTROL_DBGM register field value. */
#define MTL_GCL_CONTROL_DBGM_CLR_MSK	0xffffffef
/* The reset value of the MTL_GCL_CONTROL_DBGM register field. */
#define MTL_GCL_CONTROL_DBGM_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_DBGM field value from a register. */
#define MTL_GCL_CONTROL_DBGM_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_GCL_CONTROL_DBGM register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_DBGM_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : DBGB
 *
 * Debug Mode Bank Select
 *
 * When this field is set to 0, indicates R/W in debug mode should be directed to
 * Bank 0 (GCL0 and corresponding Time related registers). When set to 1, indicates
 * R/W in debug mode should be directed to Bank 1 (GCL1 and corresponding Time
 * related registers). This value is used when DBGM is set and overrides the value
 * of SWOL, which is normally used.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                | Value | Description
 * :----------------------------------------------------|:------|:-----------------------------------------------
 *  MTL_GCL_CONTROL_DBGB_E_BANK0 | 0x0   | R/W in debug mode should be directed to Bank 0
 *  MTL_GCL_CONTROL_DBGB_E_BANK1 | 0x1   | R/W in debug mode should be directed to Bank 1
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_DBGB
 *
 * R/W in debug mode should be directed to Bank 0
 */
#define MTL_GCL_CONTROL_DBGB_E_BANK0 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_DBGB
 *
 * R/W in debug mode should be directed to Bank 1
 */
#define MTL_GCL_CONTROL_DBGB_E_BANK1 0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_DBGB register field. */
#define MTL_GCL_CONTROL_DBGB_LSB	5
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_DBGB register field. */
#define MTL_GCL_CONTROL_DBGB_MSB	5
/* The width in bits of the MTL_GCL_CONTROL_DBGB register field. */
#define MTL_GCL_CONTROL_DBGB_WIDTH	1
/* The mask used to set the MTL_GCL_CONTROL_DBGB register field value. */
#define MTL_GCL_CONTROL_DBGB_SET_MSK	0x00000020
/* The mask used to clear the MTL_GCL_CONTROL_DBGB register field value. */
#define MTL_GCL_CONTROL_DBGB_CLR_MSK	0xffffffdf
/* The reset value of the MTL_GCL_CONTROL_DBGB register field. */
#define MTL_GCL_CONTROL_DBGB_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_DBGB field value from a register. */
#define MTL_GCL_CONTROL_DBGB_GET(value) (((value)&0x00000020) >> 5)
/* Produces a MTL_GCL_CONTROL_DBGB register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_DBGB_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_RESERVED_7_6 register field. */
#define MTL_GCL_CONTROL_RESERVED_7_6_LSB	6
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_RESERVED_7_6 register field. */
#define MTL_GCL_CONTROL_RESERVED_7_6_MSB	7
/* The width in bits of the MTL_GCL_CONTROL_RESERVED_7_6 register field. */
#define MTL_GCL_CONTROL_RESERVED_7_6_WIDTH	2
/* The mask used to set the MTL_GCL_CONTROL_RESERVED_7_6 register field value. */
#define MTL_GCL_CONTROL_RESERVED_7_6_SET_MSK	0x000000c0
/* The mask used to clear the MTL_GCL_CONTROL_RESERVED_7_6 register field value. */
#define MTL_GCL_CONTROL_RESERVED_7_6_CLR_MSK	0xffffff3f
/* The reset value of the MTL_GCL_CONTROL_RESERVED_7_6 register field. */
#define MTL_GCL_CONTROL_RESERVED_7_6_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_RESERVED_7_6 field value from a register. */
#define MTL_GCL_CONTROL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a MTL_GCL_CONTROL_RESERVED_7_6 register field value suitable for setting the register.
 */
#define MTL_GCL_CONTROL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : ADDR
 *
 * Gate Control List Address: (GCLA when GCRR is 0).
 *
 * Provides the address (row number) of the Gate Control List at which the R/W
 * operation has to be performed. By default the Gate Control List pointed by SWOL
 * of MTL_EST_Status is selected for R/W. However, if the DBGM bit of this register
 * is set, a debug mode access is given to R/W from DBGB. The width of this field
 * is dependent on GCL Depth selected; unused bits should be treated as read-only.
 *
 * Gate Control list Related Registers Address: (GCRA when GCRR is 1).
 *
 * By default, the GCL related register set pointed by SWOL of MTL_EST_Status is
 * selected for R/W. However, if the DBGM bit of this register is set, a debug mode
 * access is given to R/W from DBGB. Only the lower 3 bits are used in this mode.
 * Higher order bits are treated as dont care values.
 *
 * * 000: BTR Low (31:0)
 *
 * * 001: BTR High (63:31)
 *
 * * 010: CTR Low (31:0)
 *
 * * 011: CTR High (39:32)
 *
 * * 100: TER (m:0)(m=GCL Width selected+7-1)
 *
 * * 101: LLR (n:0) (where n is (log{GCL Depth selected} / log2))
 *
 * * Others: Reserved
 *
 * Range Variable[x]:GCL Memory Address Width of One logical partition + 7
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_ADDR register field. */
#define MTL_GCL_CONTROL_ADDR_LSB	8
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_ADDR register field. */
#define MTL_GCL_CONTROL_ADDR_MSB	15
/* The width in bits of the MTL_GCL_CONTROL_ADDR register field. */
#define MTL_GCL_CONTROL_ADDR_WIDTH	8
/* The mask used to set the MTL_GCL_CONTROL_ADDR register field value. */
#define MTL_GCL_CONTROL_ADDR_SET_MSK	0x0000ff00
/* The mask used to clear the MTL_GCL_CONTROL_ADDR register field value. */
#define MTL_GCL_CONTROL_ADDR_CLR_MSK	0xffff00ff
/* The reset value of the MTL_GCL_CONTROL_ADDR register field. */
#define MTL_GCL_CONTROL_ADDR_RESET	0x0
/* Extracts the MTL_GCL_CONTROL_ADDR field value from a register. */
#define MTL_GCL_CONTROL_ADDR_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_GCL_CONTROL_ADDR register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_ADDR_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_20_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_RESERVED_20_Y register field. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_LSB	 16
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_RESERVED_20_Y register field. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_MSB	 20
/* The width in bits of the MTL_GCL_CONTROL_RESERVED_20_Y register field. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_WIDTH	 5
/* The mask used to set the MTL_GCL_CONTROL_RESERVED_20_Y register field value. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_SET_MSK	 0x001f0000
/* The mask used to clear the MTL_GCL_CONTROL_RESERVED_20_Y register field value. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_CLR_MSK	 0xffe0ffff
/* The reset value of the MTL_GCL_CONTROL_RESERVED_20_Y register field. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_RESET	 0x0
/* Extracts the MTL_GCL_CONTROL_RESERVED_20_Y field value from a register. */
#define MTL_GCL_CONTROL_RESERVED_20_Y_GET(value) (((value)&0x001f0000) >> 16)
/* Produces a MTL_GCL_CONTROL_RESERVED_20_Y register field value suitable for setting the register.
 */
#define MTL_GCL_CONTROL_RESERVED_20_Y_SET(value) (((value) << 16) & 0x001f0000)

/*
 * Field : GCLEIEE
 *
 * GCL ECC Inject Error Enable
 *
 * When set along with EEST bit of MTL_EST_Control register, enables the ECC error
 * injection feature.
 *
 * If GCLEIAEE is set, enables the ECC Address Error Injection, otherwise, enables
 * the ECC Data/Check Bits Error Injection (See the EIM and BLEI fields of the
 * MTL_DPP_ECC_EIC Register).
 *
 * When reset, disables the ECC error injection feature.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                     | Value | Description
 * :---------------------------------------------------------|:------|:---------------------------------
 *  MTL_GCL_CONTROL_GCLEIEE_E_DISABLE | 0x0   | GCL ECC Inject Error is disabled
 *  MTL_GCL_CONTROL_GCLEIEE_E_ENABLE  | 0x1   | GCL ECC Inject Error is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCLEIEE
 *
 * GCL ECC Inject Error is disabled
 */
#define MTL_GCL_CONTROL_GCLEIEE_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCLEIEE
 *
 * GCL ECC Inject Error is enabled
 */
#define MTL_GCL_CONTROL_GCLEIEE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_GCLEIEE register field. */
#define MTL_GCL_CONTROL_GCLEIEE_LSB	   21
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_GCLEIEE register field. */
#define MTL_GCL_CONTROL_GCLEIEE_MSB	   21
/* The width in bits of the MTL_GCL_CONTROL_GCLEIEE register field. */
#define MTL_GCL_CONTROL_GCLEIEE_WIDTH	   1
/* The mask used to set the MTL_GCL_CONTROL_GCLEIEE register field value. */
#define MTL_GCL_CONTROL_GCLEIEE_SET_MSK	   0x00200000
/* The mask used to clear the MTL_GCL_CONTROL_GCLEIEE register field value. */
#define MTL_GCL_CONTROL_GCLEIEE_CLR_MSK	   0xffdfffff
/* The reset value of the MTL_GCL_CONTROL_GCLEIEE register field. */
#define MTL_GCL_CONTROL_GCLEIEE_RESET	   0x0
/* Extracts the MTL_GCL_CONTROL_GCLEIEE field value from a register. */
#define MTL_GCL_CONTROL_GCLEIEE_GET(value) (((value)&0x00200000) >> 21)
/* Produces a MTL_GCL_CONTROL_GCLEIEE register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_GCLEIEE_SET(value) (((value) << 21) & 0x00200000)

/*
 * Field : GCLEIAEE
 *
 * GCL ECC Inject Address Error Enable
 *
 * When set along with EEST bit of MTL_EST_Control register, enables the ECC error
 * injection feature.
 *
 * When reset, disables the ECC Address error injection feature.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                      | Value | Description
 * :----------------------------------------------------------|:------|:-----------------------------------------
 *  MTL_GCL_CONTROL_GCLEIAEE_E_DISABLE | 0x0   | GCL ECC Inject Address Error is disabled
 *  MTL_GCL_CONTROL_GCLEIAEE_E_ENABLE  | 0x1   | GCL ECC Inject Address Error is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCLEIAEE
 *
 * GCL ECC Inject Address Error is disabled
 */
#define MTL_GCL_CONTROL_GCLEIAEE_E_DISABLE 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCLEIAEE
 *
 * GCL ECC Inject Address Error is enabled
 */
#define MTL_GCL_CONTROL_GCLEIAEE_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_GCLEIAEE register field. */
#define MTL_GCL_CONTROL_GCLEIAEE_LSB	    22
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_GCLEIAEE register field. */
#define MTL_GCL_CONTROL_GCLEIAEE_MSB	    22
/* The width in bits of the MTL_GCL_CONTROL_GCLEIAEE register field. */
#define MTL_GCL_CONTROL_GCLEIAEE_WIDTH	    1
/* The mask used to set the MTL_GCL_CONTROL_GCLEIAEE register field value. */
#define MTL_GCL_CONTROL_GCLEIAEE_SET_MSK    0x00400000
/* The mask used to clear the MTL_GCL_CONTROL_GCLEIAEE register field value. */
#define MTL_GCL_CONTROL_GCLEIAEE_CLR_MSK    0xffbfffff
/* The reset value of the MTL_GCL_CONTROL_GCLEIAEE register field. */
#define MTL_GCL_CONTROL_GCLEIAEE_RESET	    0x0
/* Extracts the MTL_GCL_CONTROL_GCLEIAEE field value from a register. */
#define MTL_GCL_CONTROL_GCLEIAEE_GET(value) (((value)&0x00400000) >> 22)
/* Produces a MTL_GCL_CONTROL_GCLEIAEE register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_GCLEIAEE_SET(value) (((value) << 22) & 0x00400000)

/*
 * Field : GCLEIEC
 *
 * ECC Inject Error Control for GCL Memory
 *
 * When GCLEIEE bit of this register is set, following are the errors inserted
 * based on the value encoded in this field.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                    | Value | Description
 * :--------------------------------------------------------|:------|:--------------------
 *  MTL_GCL_CONTROL_GCLEIEC_E_M_1BIT | 0x0   | Insert 1 bit error
 *  MTL_GCL_CONTROL_GCLEIEC_E_M_2BIT | 0x1   | Insert 2 bit errors
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCLEIEC
 *
 * Insert 1 bit error
 */
#define MTL_GCL_CONTROL_GCLEIEC_E_M_1BIT 0x0
/*
 * Enumerated value for register field MTL_GCL_CONTROL_GCLEIEC
 *
 * Insert 2 bit errors
 */
#define MTL_GCL_CONTROL_GCLEIEC_E_M_2BIT 0x1

/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_GCLEIEC register field. */
#define MTL_GCL_CONTROL_GCLEIEC_LSB	   23
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_GCLEIEC register field. */
#define MTL_GCL_CONTROL_GCLEIEC_MSB	   23
/* The width in bits of the MTL_GCL_CONTROL_GCLEIEC register field. */
#define MTL_GCL_CONTROL_GCLEIEC_WIDTH	   1
/* The mask used to set the MTL_GCL_CONTROL_GCLEIEC register field value. */
#define MTL_GCL_CONTROL_GCLEIEC_SET_MSK	   0x00800000
/* The mask used to clear the MTL_GCL_CONTROL_GCLEIEC register field value. */
#define MTL_GCL_CONTROL_GCLEIEC_CLR_MSK	   0xff7fffff
/* The reset value of the MTL_GCL_CONTROL_GCLEIEC register field. */
#define MTL_GCL_CONTROL_GCLEIEC_RESET	   0x0
/* Extracts the MTL_GCL_CONTROL_GCLEIEC field value from a register. */
#define MTL_GCL_CONTROL_GCLEIEC_GET(value) (((value)&0x00800000) >> 23)
/* Produces a MTL_GCL_CONTROL_GCLEIEC register field value suitable for setting the register. */
#define MTL_GCL_CONTROL_GCLEIEC_SET(value) (((value) << 23) & 0x00800000)

/*
 * Field : Reserved_31_24
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_GCL_CONTROL_RESERVED_31_24 register field. */
#define MTL_GCL_CONTROL_RESERVED_31_24_LSB	  24
/* The Most Significant Bit (MSB) position of the MTL_GCL_CONTROL_RESERVED_31_24 register field. */
#define MTL_GCL_CONTROL_RESERVED_31_24_MSB	  31
/* The width in bits of the MTL_GCL_CONTROL_RESERVED_31_24 register field. */
#define MTL_GCL_CONTROL_RESERVED_31_24_WIDTH	  8
/* The mask used to set the MTL_GCL_CONTROL_RESERVED_31_24 register field value. */
#define MTL_GCL_CONTROL_RESERVED_31_24_SET_MSK	  0xff000000
/* The mask used to clear the MTL_GCL_CONTROL_RESERVED_31_24 register field value. */
#define MTL_GCL_CONTROL_RESERVED_31_24_CLR_MSK	  0x00ffffff
/* The reset value of the MTL_GCL_CONTROL_RESERVED_31_24 register field. */
#define MTL_GCL_CONTROL_RESERVED_31_24_RESET	  0x0
/* Extracts the MTL_GCL_CONTROL_RESERVED_31_24 field value from a register. */
#define MTL_GCL_CONTROL_RESERVED_31_24_GET(value) (((value)&0xff000000) >> 24)
/* Produces a MTL_GCL_CONTROL_RESERVED_31_24 register field value suitable for setting the register.
 */
#define MTL_GCL_CONTROL_RESERVED_31_24_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_GCL_CONTROL.
 */
struct MTL_GCL_CONTROL_s {
	volatile uint32_t SRWO : 1;		    /* MTL_GCL_CONTROL_SRWO */
	volatile uint32_t R1W0 : 1;		    /* MTL_GCL_CONTROL_R1W0 */
	volatile uint32_t GCRR : 1;		    /* MTL_GCL_CONTROL_GCRR */
	const volatile uint32_t Reserved_GCLS : 1;  /* MTL_GCL_CONTROL_RESERVED_GCLS */
	volatile uint32_t DBGM : 1;		    /* MTL_GCL_CONTROL_DBGM */
	volatile uint32_t DBGB : 1;		    /* MTL_GCL_CONTROL_DBGB */
	const volatile uint32_t Reserved_7_6 : 2;   /* MTL_GCL_CONTROL_RESERVED_7_6 */
	volatile uint32_t ADDR : 8;		    /* MTL_GCL_CONTROL_ADDR */
	const volatile uint32_t Reserved_20_y : 5;  /* MTL_GCL_CONTROL_RESERVED_20_Y */
	const volatile uint32_t GCLEIEE : 1;	    /* MTL_GCL_CONTROL_GCLEIEE */
	const volatile uint32_t GCLEIAEE : 1;	    /* MTL_GCL_CONTROL_GCLEIAEE */
	const volatile uint32_t GCLEIEC : 1;	    /* MTL_GCL_CONTROL_GCLEIEC */
	const volatile uint32_t Reserved_31_24 : 8; /* MTL_GCL_CONTROL_RESERVED_31_24 */
};

/* The typedef declaration for register MTL_GCL_CONTROL. */
typedef struct MTL_GCL_CONTROL_s MTL_GCL_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_GCL_CONTROL register. */
#define MTL_GCL_CONTROL_RESET 0x00000000
/* The byte offset of the MTL_GCL_CONTROL register from the beginning of the component. */
#define MTL_GCL_CONTROL_OFST  0x80

/*
 * Register : MTL_GCL_Data
 *
 * This register holds the read data or write data in case of reads and writes
 * respectively.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------
 *  [31:0] | RW     | 0x0   | MTL_GCL_DATA_GCD
 *
 */
/*
 * Field : GCD
 *
 * Gate Control Data
 *
 * The data corresponding to the address selected in the GCL_Control register. Used
 * for both Read and Write operations.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_GCL_DATA_GCD register field. */
#define MTL_GCL_DATA_GCD_LSB	    0
/* The Most Significant Bit (MSB) position of the MTL_GCL_DATA_GCD register field. */
#define MTL_GCL_DATA_GCD_MSB	    31
/* The width in bits of the MTL_GCL_DATA_GCD register field. */
#define MTL_GCL_DATA_GCD_WIDTH	    32
/* The mask used to set the MTL_GCL_DATA_GCD register field value. */
#define MTL_GCL_DATA_GCD_SET_MSK    0xffffffff
/* The mask used to clear the MTL_GCL_DATA_GCD register field value. */
#define MTL_GCL_DATA_GCD_CLR_MSK    0x00000000
/* The reset value of the MTL_GCL_DATA_GCD register field. */
#define MTL_GCL_DATA_GCD_RESET	    0x0
/* Extracts the MTL_GCL_DATA_GCD field value from a register. */
#define MTL_GCL_DATA_GCD_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a MTL_GCL_DATA_GCD register field value suitable for setting the register. */
#define MTL_GCL_DATA_GCD_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_GCL_DATA.
 */
struct MTL_GCL_DATA_s {
	volatile uint32_t GCD : 32; /* MTL_GCL_DATA_GCD */
};

/* The typedef declaration for register MTL_GCL_DATA. */
typedef struct MTL_GCL_DATA_s MTL_GCL_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_GCL_DATA register. */
#define MTL_GCL_DATA_RESET 0x00000000
/* The byte offset of the MTL_GCL_DATA register from the beginning of the component. */
#define MTL_GCL_DATA_OFST  0x84

/*
 * Register : MTL_FPE_CTRL_STS
 *
 * This register controls the operation of, and provides status for Frame
 * Preemption (IEEE 802.1Qbu/802.3br).
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------
 *  [1:0]   | RW     | 0x0   | MTL_FPE_CTRL_STS_AFSZ
 *  [6:2]   | R      | 0x0   | MTL_FPE_CTRL_STS_RESERVED_6_2
 *  [7]     | RW     | 0x0   | MTL_FPE_CTRL_STS_LBHT
 *  [15:8]  | RW     | 0x0   | MTL_FPE_CTRL_STS_PEC
 *  [27:16] | R      | 0x0   | MTL_FPE_CTRL_STS_RESERVED_27_16
 *  [28]    | R      | 0x0   | MTL_FPE_CTRL_STS_HRS
 *  [31:29] | R      | 0x0   | MTL_FPE_CTRL_STS_RESERVED_31_29
 *
 */
/*
 * Field : AFSZ
 *
 * Additional Fragment Size
 *
 * Used to indicate, in units of 64 bytes, the minimum number of bytes over 64
 * bytes required in non-final fragments of preempted frames. The minimum non-final
 * fragment size is (AFSZ +1) * 64 bytes
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_AFSZ register field. */
#define MTL_FPE_CTRL_STS_AFSZ_LSB	 0
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_AFSZ register field. */
#define MTL_FPE_CTRL_STS_AFSZ_MSB	 1
/* The width in bits of the MTL_FPE_CTRL_STS_AFSZ register field. */
#define MTL_FPE_CTRL_STS_AFSZ_WIDTH	 2
/* The mask used to set the MTL_FPE_CTRL_STS_AFSZ register field value. */
#define MTL_FPE_CTRL_STS_AFSZ_SET_MSK	 0x00000003
/* The mask used to clear the MTL_FPE_CTRL_STS_AFSZ register field value. */
#define MTL_FPE_CTRL_STS_AFSZ_CLR_MSK	 0xfffffffc
/* The reset value of the MTL_FPE_CTRL_STS_AFSZ register field. */
#define MTL_FPE_CTRL_STS_AFSZ_RESET	 0x0
/* Extracts the MTL_FPE_CTRL_STS_AFSZ field value from a register. */
#define MTL_FPE_CTRL_STS_AFSZ_GET(value) (((value)&0x00000003) >> 0)
/* Produces a MTL_FPE_CTRL_STS_AFSZ register field value suitable for setting the register. */
#define MTL_FPE_CTRL_STS_AFSZ_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : Reserved_6_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_RESERVED_6_2 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_LSB	 2
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_RESERVED_6_2 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_MSB	 6
/* The width in bits of the MTL_FPE_CTRL_STS_RESERVED_6_2 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_WIDTH	 5
/* The mask used to set the MTL_FPE_CTRL_STS_RESERVED_6_2 register field value. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_SET_MSK	 0x0000007c
/* The mask used to clear the MTL_FPE_CTRL_STS_RESERVED_6_2 register field value. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_CLR_MSK	 0xffffff83
/* The reset value of the MTL_FPE_CTRL_STS_RESERVED_6_2 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_RESET	 0x0
/* Extracts the MTL_FPE_CTRL_STS_RESERVED_6_2 field value from a register. */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_GET(value) (((value)&0x0000007c) >> 2)
/* Produces a MTL_FPE_CTRL_STS_RESERVED_6_2 register field value suitable for setting the register.
 */
#define MTL_FPE_CTRL_STS_RESERVED_6_2_SET(value) (((value) << 2) & 0x0000007c)

/*
 * Field : LBHT
 *
 * Level Based Hold Transition
 *
 * When set to 1, enables hold operation in second row of EST GCL if hold request
 * is set in second GCL row for first loop of new GCL, even though hold request is
 * also set in the first GCL row. This is deviation from original behavior where a
 * transition from release request to hold request is required.
 *
 * When set to 0, enables hold operation only on transition from release request to
 * hold request.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_LBHT register field. */
#define MTL_FPE_CTRL_STS_LBHT_LSB	 7
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_LBHT register field. */
#define MTL_FPE_CTRL_STS_LBHT_MSB	 7
/* The width in bits of the MTL_FPE_CTRL_STS_LBHT register field. */
#define MTL_FPE_CTRL_STS_LBHT_WIDTH	 1
/* The mask used to set the MTL_FPE_CTRL_STS_LBHT register field value. */
#define MTL_FPE_CTRL_STS_LBHT_SET_MSK	 0x00000080
/* The mask used to clear the MTL_FPE_CTRL_STS_LBHT register field value. */
#define MTL_FPE_CTRL_STS_LBHT_CLR_MSK	 0xffffff7f
/* The reset value of the MTL_FPE_CTRL_STS_LBHT register field. */
#define MTL_FPE_CTRL_STS_LBHT_RESET	 0x0
/* Extracts the MTL_FPE_CTRL_STS_LBHT field value from a register. */
#define MTL_FPE_CTRL_STS_LBHT_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_FPE_CTRL_STS_LBHT register field value suitable for setting the register. */
#define MTL_FPE_CTRL_STS_LBHT_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : PEC
 *
 * Preemption Classification
 *
 * When set indicates the corresponding Queue must be classified as preemptable,
 * when '0' Queue is classified as express. When both EST (Qbv) and Preemption are
 * enabled, Queue-0 is always assumed to be preemptable. When EST (Qbv) is enabled
 * Queues categorized as preemptable here are always assumed to be in "Open" state
 * in the Gate Control List.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_PEC register field. */
#define MTL_FPE_CTRL_STS_PEC_LSB	8
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_PEC register field. */
#define MTL_FPE_CTRL_STS_PEC_MSB	15
/* The width in bits of the MTL_FPE_CTRL_STS_PEC register field. */
#define MTL_FPE_CTRL_STS_PEC_WIDTH	8
/* The mask used to set the MTL_FPE_CTRL_STS_PEC register field value. */
#define MTL_FPE_CTRL_STS_PEC_SET_MSK	0x0000ff00
/* The mask used to clear the MTL_FPE_CTRL_STS_PEC register field value. */
#define MTL_FPE_CTRL_STS_PEC_CLR_MSK	0xffff00ff
/* The reset value of the MTL_FPE_CTRL_STS_PEC register field. */
#define MTL_FPE_CTRL_STS_PEC_RESET	0x0
/* Extracts the MTL_FPE_CTRL_STS_PEC field value from a register. */
#define MTL_FPE_CTRL_STS_PEC_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_FPE_CTRL_STS_PEC register field value suitable for setting the register. */
#define MTL_FPE_CTRL_STS_PEC_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : Reserved_27_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_RESERVED_27_16 register field.
 */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_LSB	   16
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_RESERVED_27_16 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_MSB	   27
/* The width in bits of the MTL_FPE_CTRL_STS_RESERVED_27_16 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_WIDTH	   12
/* The mask used to set the MTL_FPE_CTRL_STS_RESERVED_27_16 register field value. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_SET_MSK	   0x0fff0000
/* The mask used to clear the MTL_FPE_CTRL_STS_RESERVED_27_16 register field value. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_CLR_MSK	   0xf000ffff
/* The reset value of the MTL_FPE_CTRL_STS_RESERVED_27_16 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_RESET	   0x0
/* Extracts the MTL_FPE_CTRL_STS_RESERVED_27_16 field value from a register. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_GET(value) (((value)&0x0fff0000) >> 16)
/* Produces a MTL_FPE_CTRL_STS_RESERVED_27_16 register field value suitable for setting the
 * register. */
#define MTL_FPE_CTRL_STS_RESERVED_27_16_SET(value) (((value) << 16) & 0x0fff0000)

/*
 * Field : HRS
 *
 * Hold/Release Status
 *
 * * 1: Indicates a Set-and-Hold-MAC operation was last executed and the pMAC is in
 *   Hold State.
 *
 * * 0: Indicates a Set-and-Release-MAC operation was last executed and the pMAC is
 *   in Release State.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                   | Value | Description
 * :-------------------------------------------------------|:------|:------------------------------------------------
 *  MTL_FPE_CTRL_STS_HRS_E_SET_REL  | 0x0   | Indicates a Set-and-Release-MAC operation was
 * :                                                       |       | last executed and the pMAC is
 * in Release State MTL_FPE_CTRL_STS_HRS_E_SET_HOLD | 0x1   | Indicates a Set-and-Hold-MAC operation
 * was last :                                                       |       | executed and the pMAC
 * is in Hold State
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field MTL_FPE_CTRL_STS_HRS
 *
 * Indicates a Set-and-Release-MAC operation was last executed and the pMAC is in
 * Release State
 */
#define MTL_FPE_CTRL_STS_HRS_E_SET_REL	0x0
/*
 * Enumerated value for register field MTL_FPE_CTRL_STS_HRS
 *
 * Indicates a Set-and-Hold-MAC operation was last executed and the pMAC is in Hold
 * State
 */
#define MTL_FPE_CTRL_STS_HRS_E_SET_HOLD 0x1

/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_HRS register field. */
#define MTL_FPE_CTRL_STS_HRS_LSB	28
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_HRS register field. */
#define MTL_FPE_CTRL_STS_HRS_MSB	28
/* The width in bits of the MTL_FPE_CTRL_STS_HRS register field. */
#define MTL_FPE_CTRL_STS_HRS_WIDTH	1
/* The mask used to set the MTL_FPE_CTRL_STS_HRS register field value. */
#define MTL_FPE_CTRL_STS_HRS_SET_MSK	0x10000000
/* The mask used to clear the MTL_FPE_CTRL_STS_HRS register field value. */
#define MTL_FPE_CTRL_STS_HRS_CLR_MSK	0xefffffff
/* The reset value of the MTL_FPE_CTRL_STS_HRS register field. */
#define MTL_FPE_CTRL_STS_HRS_RESET	0x0
/* Extracts the MTL_FPE_CTRL_STS_HRS field value from a register. */
#define MTL_FPE_CTRL_STS_HRS_GET(value) (((value)&0x10000000) >> 28)
/* Produces a MTL_FPE_CTRL_STS_HRS register field value suitable for setting the register. */
#define MTL_FPE_CTRL_STS_HRS_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : Reserved_31_29
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_CTRL_STS_RESERVED_31_29 register field.
 */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_LSB	   29
/* The Most Significant Bit (MSB) position of the MTL_FPE_CTRL_STS_RESERVED_31_29 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_MSB	   31
/* The width in bits of the MTL_FPE_CTRL_STS_RESERVED_31_29 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_WIDTH	   3
/* The mask used to set the MTL_FPE_CTRL_STS_RESERVED_31_29 register field value. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_SET_MSK	   0xe0000000
/* The mask used to clear the MTL_FPE_CTRL_STS_RESERVED_31_29 register field value. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_CLR_MSK	   0x1fffffff
/* The reset value of the MTL_FPE_CTRL_STS_RESERVED_31_29 register field. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_RESET	   0x0
/* Extracts the MTL_FPE_CTRL_STS_RESERVED_31_29 field value from a register. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_GET(value) (((value)&0xe0000000) >> 29)
/* Produces a MTL_FPE_CTRL_STS_RESERVED_31_29 register field value suitable for setting the
 * register. */
#define MTL_FPE_CTRL_STS_RESERVED_31_29_SET(value) (((value) << 29) & 0xe0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_FPE_CTRL_STS.
 */
struct MTL_FPE_CTRL_STS_s {
	volatile uint32_t AFSZ : 2;		     /* MTL_FPE_CTRL_STS_AFSZ */
	const volatile uint32_t Reserved_6_2 : 5;    /* MTL_FPE_CTRL_STS_RESERVED_6_2 */
	volatile uint32_t LBHT : 1;		     /* MTL_FPE_CTRL_STS_LBHT */
	volatile uint32_t PEC : 8;		     /* MTL_FPE_CTRL_STS_PEC */
	const volatile uint32_t Reserved_27_16 : 12; /* MTL_FPE_CTRL_STS_RESERVED_27_16 */
	const volatile uint32_t HRS : 1;	     /* MTL_FPE_CTRL_STS_HRS */
	const volatile uint32_t Reserved_31_29 : 3;  /* MTL_FPE_CTRL_STS_RESERVED_31_29 */
};

/* The typedef declaration for register MTL_FPE_CTRL_STS. */
typedef struct MTL_FPE_CTRL_STS_s MTL_FPE_CTRL_STS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_FPE_CTRL_STS register. */
#define MTL_FPE_CTRL_STS_RESET 0x00000000
/* The byte offset of the MTL_FPE_CTRL_STS register from the beginning of the component. */
#define MTL_FPE_CTRL_STS_OFST  0x90

/*
 * Register : MTL_FPE_Advance
 *
 * This register holds the Hold and Release Advance time.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------
 *  [15:0]  | RW     | 0x0   | MTL_FPE_ADVANCE_HADV
 *  [31:16] | RW     | 0x0   | MTL_FPE_ADVANCE_RADV
 *
 */
/*
 * Field : HADV
 *
 * Hold Advance
 *
 * The maximum time in nanoseconds that can elapse between issuing a HOLD to the
 * MAC and the MAC ceasing to transmit any preemptable frame that is in the process
 * of transmission or any preemptable frames that are queued for transmission.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_ADVANCE_HADV register field. */
#define MTL_FPE_ADVANCE_HADV_LSB	0
/* The Most Significant Bit (MSB) position of the MTL_FPE_ADVANCE_HADV register field. */
#define MTL_FPE_ADVANCE_HADV_MSB	15
/* The width in bits of the MTL_FPE_ADVANCE_HADV register field. */
#define MTL_FPE_ADVANCE_HADV_WIDTH	16
/* The mask used to set the MTL_FPE_ADVANCE_HADV register field value. */
#define MTL_FPE_ADVANCE_HADV_SET_MSK	0x0000ffff
/* The mask used to clear the MTL_FPE_ADVANCE_HADV register field value. */
#define MTL_FPE_ADVANCE_HADV_CLR_MSK	0xffff0000
/* The reset value of the MTL_FPE_ADVANCE_HADV register field. */
#define MTL_FPE_ADVANCE_HADV_RESET	0x0
/* Extracts the MTL_FPE_ADVANCE_HADV field value from a register. */
#define MTL_FPE_ADVANCE_HADV_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a MTL_FPE_ADVANCE_HADV register field value suitable for setting the register. */
#define MTL_FPE_ADVANCE_HADV_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : RADV
 *
 * Release Advance
 *
 * The maximum time in nanoseconds that can elapse between issuing a RELEASE to the
 * MAC and the MAC being ready to resume transmission of preemptable frames, in the
 * absence of there being any express frames available for transmission.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_FPE_ADVANCE_RADV register field. */
#define MTL_FPE_ADVANCE_RADV_LSB	16
/* The Most Significant Bit (MSB) position of the MTL_FPE_ADVANCE_RADV register field. */
#define MTL_FPE_ADVANCE_RADV_MSB	31
/* The width in bits of the MTL_FPE_ADVANCE_RADV register field. */
#define MTL_FPE_ADVANCE_RADV_WIDTH	16
/* The mask used to set the MTL_FPE_ADVANCE_RADV register field value. */
#define MTL_FPE_ADVANCE_RADV_SET_MSK	0xffff0000
/* The mask used to clear the MTL_FPE_ADVANCE_RADV register field value. */
#define MTL_FPE_ADVANCE_RADV_CLR_MSK	0x0000ffff
/* The reset value of the MTL_FPE_ADVANCE_RADV register field. */
#define MTL_FPE_ADVANCE_RADV_RESET	0x0
/* Extracts the MTL_FPE_ADVANCE_RADV field value from a register. */
#define MTL_FPE_ADVANCE_RADV_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a MTL_FPE_ADVANCE_RADV register field value suitable for setting the register. */
#define MTL_FPE_ADVANCE_RADV_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_FPE_ADVANCE.
 */
struct MTL_FPE_ADVANCE_s {
	volatile uint32_t HADV : 16; /* MTL_FPE_ADVANCE_HADV */
	volatile uint32_t RADV : 16; /* MTL_FPE_ADVANCE_RADV */
};

/* The typedef declaration for register MTL_FPE_ADVANCE. */
typedef struct MTL_FPE_ADVANCE_s MTL_FPE_ADVANCE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_FPE_ADVANCE register. */
#define MTL_FPE_ADVANCE_RESET 0x00000000
/* The byte offset of the MTL_FPE_ADVANCE register from the beginning of the component. */
#define MTL_FPE_ADVANCE_OFST  0x94

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register group MTL.
 */
struct MTL_s {
	volatile MTL_OPERATION_MODE_t MTL_Operation_Mode;	      /* MTL_OPERATION_MODE */
	volatile uint32_t _pad_0x4_0x1f[7];			      /* *UNDEFINED* */
	volatile MTL_INTERRUPT_STATUS_t MTL_Interrupt_Status;	      /* MTL_INTERRUPT_STATUS */
	volatile uint32_t _pad_0x24_0x2f[3];			      /* *UNDEFINED* */
	volatile MTL_RXQ_DMA_MAP0_t MTL_RxQ_DMA_Map0;		      /* MTL_RXQ_DMA_MAP0 */
	volatile MTL_RXQ_DMA_MAP1_t MTL_RxQ_DMA_Map1;		      /* MTL_RXQ_DMA_MAP1 */
	volatile uint32_t _pad_0x38_0x3f[2];			      /* *UNDEFINED* */
	volatile MTL_TC_PRTY_MAP0_t MTL_TC_Prty_Map0;		      /* MTL_TC_PRTY_MAP0 */
	volatile MTL_TC_PRTY_MAP1_t MTL_TC_Prty_Map1;		      /* MTL_TC_PRTY_MAP1 */
	volatile MTL_TBS_CTRL_t MTL_TBS_CTRL;			      /* MTL_TBS_CTRL */
	volatile MTL_TBS_STATS_t MTL_TBS_STATS;			      /* MTL_TBS_STATS */
	volatile MTL_EST_CONTROL_t MTL_EST_Control;		      /* MTL_EST_CONTROL */
	volatile MTL_EST_OVERHEAD_t MTL_EST_Overhead;		      /* MTL_EST_OVERHEAD */
	volatile MTL_EST_STATUS_t MTL_EST_Status;		      /* MTL_EST_STATUS */
	volatile uint32_t _pad_0x5c_0x5f;			      /* *UNDEFINED* */
	volatile MTL_EST_SCH_ERROR_t MTL_EST_Sch_Error;		      /* MTL_EST_SCH_ERROR */
	volatile MTL_EST_FRM_SIZE_ERROR_t MTL_EST_Frm_Size_Error;     /* MTL_EST_FRM_SIZE_ERROR */
	volatile MTL_EST_FRM_SIZE_CAPTURE_t MTL_EST_Frm_Size_Capture; /* MTL_EST_FRM_SIZE_CAPTURE */
	volatile uint32_t _pad_0x6c_0x6f;			      /* *UNDEFINED* */
	volatile MTL_EST_INTR_ENABLE_t MTL_EST_Intr_Enable;	      /* MTL_EST_INTR_ENABLE */
	volatile uint32_t _pad_0x74_0x7f[3];			      /* *UNDEFINED* */
	volatile MTL_GCL_CONTROL_t MTL_GCL_Control;		      /* MTL_GCL_CONTROL */
	volatile MTL_GCL_DATA_t MTL_GCL_Data;			      /* MTL_GCL_DATA */
	volatile uint32_t _pad_0x88_0x8f[2];			      /* *UNDEFINED* */
	volatile MTL_FPE_CTRL_STS_t MTL_FPE_CTRL_STS;		      /* MTL_FPE_CTRL_STS */
	volatile MTL_FPE_ADVANCE_t MTL_FPE_Advance;		      /* MTL_FPE_ADVANCE */
	volatile uint32_t _pad_0x98_0x100[26];			      /* *UNDEFINED* */
};

/* The typedef declaration for register group MTL. */
typedef struct MTL_s MTL_t;
/* The struct declaration for the raw register contents of register group MTL. */
struct MTL_raw_s {
	volatile uint32_t MTL_Operation_Mode;	    /* MTL_OPERATION_MODE */
	volatile uint32_t _pad_0x4_0x1f[7];	    /* *UNDEFINED* */
	volatile uint32_t MTL_Interrupt_Status;	    /* MTL_INTERRUPT_STATUS */
	volatile uint32_t _pad_0x24_0x2f[3];	    /* *UNDEFINED* */
	volatile uint32_t MTL_RxQ_DMA_Map0;	    /* MTL_RXQ_DMA_MAP0 */
	volatile uint32_t MTL_RxQ_DMA_Map1;	    /* MTL_RXQ_DMA_MAP1 */
	volatile uint32_t _pad_0x38_0x3f[2];	    /* *UNDEFINED* */
	volatile uint32_t MTL_TC_Prty_Map0;	    /* MTL_TC_PRTY_MAP0 */
	volatile uint32_t MTL_TC_Prty_Map1;	    /* MTL_TC_PRTY_MAP1 */
	volatile uint32_t MTL_TBS_CTRL;		    /* MTL_TBS_CTRL */
	volatile uint32_t MTL_TBS_STATS;	    /* MTL_TBS_STATS */
	volatile uint32_t MTL_EST_Control;	    /* MTL_EST_CONTROL */
	volatile uint32_t MTL_EST_Overhead;	    /* MTL_EST_OVERHEAD */
	volatile uint32_t MTL_EST_Status;	    /* MTL_EST_STATUS */
	volatile uint32_t _pad_0x5c_0x5f;	    /* *UNDEFINED* */
	volatile uint32_t MTL_EST_Sch_Error;	    /* MTL_EST_SCH_ERROR */
	volatile uint32_t MTL_EST_Frm_Size_Error;   /* MTL_EST_FRM_SIZE_ERROR */
	volatile uint32_t MTL_EST_Frm_Size_Capture; /* MTL_EST_FRM_SIZE_CAPTURE */
	volatile uint32_t _pad_0x6c_0x6f;	    /* *UNDEFINED* */
	volatile uint32_t MTL_EST_Intr_Enable;	    /* MTL_EST_INTR_ENABLE */
	volatile uint32_t _pad_0x74_0x7f[3];	    /* *UNDEFINED* */
	volatile uint32_t MTL_GCL_Control;	    /* MTL_GCL_CONTROL */
	volatile uint32_t MTL_GCL_Data;		    /* MTL_GCL_DATA */
	volatile uint32_t _pad_0x88_0x8f[2];	    /* *UNDEFINED* */
	volatile uint32_t MTL_FPE_CTRL_STS;	    /* MTL_FPE_CTRL_STS */
	volatile uint32_t MTL_FPE_Advance;	    /* MTL_FPE_ADVANCE */
	volatile uint32_t _pad_0x98_0x100[26];	    /* *UNDEFINED* */
};

/* The typedef declaration for the raw register contents of register group MTL. */
typedef struct MTL_raw_s MTL_raw_t;
#endif /* __ASSEMBLY__ */

/*
 * Component : MTL_TCQx
 * MTL Traffic Class/Queue (#i) Registers.
 *
 */
/*
 * Register : MTL_TxQ0_Operation_Mode
 *
 * The Queue 0 Transmit Operation Mode register establishes the Transmit queue
 * operating modes and commands.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------
 *  [0]     | RW     | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ
 *  [1]     | RW     | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF
 *  [3:2]   | RW     | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN
 *  [6:4]   | RW     | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC
 *  [7]     | R      | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7
 *  [10:8]  | RW     | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP
 *  [15:11] | R      | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y
 *  [22:16] | RW     | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS
 *  [31:23] | R      | 0x0   | MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y
 *
 */
/*
 * Field : FTQ
 *
 * Flush Transmit Queue.
 *
 * When this bit is set, the Tx Queue Controller logic is reset to its default
 * values. Therefore, all the data in the Tx queue is lost or flushed. This bit is
 * internally reset when the flushing operation is complete. You should not write
 * to this register until this bit is reset. The data which is already accepted by
 * the MAC transmitter is not flushed. It is scheduled for transmission and results
 * in underflow and runt packet transmission.
 *
 * Note:  The flush operation is complete only when the Tx queue is empty. To
 * complete this flush operation, the PHY Tx clock (clk_tx_312pt5_i) must be
 * active.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_LSB	0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_MSB	0
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_WIDTH	1
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_SET_MSK	0x00000001
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_CLR_MSK	0xfffffffe
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_RESET	0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TSF
 *
 * Transmit Store and Forward.
 *
 * When this bit is set, the transmission starts when a full packet resides in the
 * MTL Tx Queue. When this bit is set, the values specified in the TTC field are
 * ignored. This bit should be changed only when the transmission is stopped.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_LSB	1
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_MSB	1
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_WIDTH	1
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_SET_MSK	0x00000002
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_CLR_MSK	0xfffffffd
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_RESET	0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TXQEN
 *
 * Transmit Queue Enable.
 *
 * This field is used to enable/disable the transmit queue.
 *
 * * 2'b00: Not enabled
 *
 * * 2'b01: Audio Video Bridging
 *
 * * 2'b10: Enabled
 *
 * * 2'b11: Reserved
 *
 * The queue is enabled by default in single queue configuration. Therefore, this
 * field is reserved when the number of transmit queues selected is one and has a
 * reset value of 2'b10.
 *
 * In multiple Tx queues configuration, all the queues are disabled by default.
 * Enable the Tx queue by programming this field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_LSB	  2
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_MSB	  3
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_WIDTH	  2
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_SET_MSK	  0x0000000c
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_CLR_MSK	  0xfffffff3
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : TTC
 *
 * Transmit Threshold Control.
 *
 * These bits control the threshold level of the MTL Tx Queue. Transmission starts
 * when the packet size within the MTL Tx Queue is larger than the threshold. In
 * addition, full packets with length less than the threshold are also transmitted.
 * These bits are used only when the TSF bit is reset.
 *
 * * 3'b000: 64
 *
 * * 3'b001: Reserved
 *
 * * 3'b010: 96
 *
 * * 3'b011: 128
 *
 * * 3'b100: 192
 *
 * * 3'b101: 256
 *
 * * 3'b110: 384
 *
 * * 3'b111: 512
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_LSB	4
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_MSB	6
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_WIDTH	3
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_SET_MSK	0x00000070
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_CLR_MSK	0xffffff8f
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_RESET	0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_GET(value) (((value)&0x00000070) >> 4)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7
 * register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_LSB	       7
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7
 * register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_MSB	       7
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_WIDTH      1
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_SET_MSK    0x00000080
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_CLR_MSK    0xffffff7f
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_RESET      0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Q2TCMAP
 *
 * Queue to Traffic Class Mapping.
 *
 * This field is used to map Queue0 to a traffic class (TC). The actual width of
 * this field depends on the number of traffic classes selected during
 * configuration.
 *
 * * 3'b000: TC0
 *
 * * 3'b001: TC1
 *
 * * 3'b010: TC2
 *
 * * 3'b011: TC3
 *
 * * 3'b100: TC4
 *
 * * 3'b101: TC5
 *
 * * 3'b110: TC6
 *
 * * 3'b111: TC7
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_LSB	    8
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_MSB	    10
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_WIDTH	    3
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_SET_MSK    0x00000700
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_CLR_MSK    0xfffff8ff
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_RESET	    0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_GET(value) (((value)&0x00000700) >> 8)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP_SET(value) (((value) << 8) & 0x00000700)

/*
 * Field : Reserved_15_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y
 * register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_LSB	  11
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y
 * register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_MSB	  15
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_WIDTH	  5
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_SET_MSK	  0x0000f800
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y register field value.
 */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_CLR_MSK	  0xffff07ff
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_GET(value) (((value)&0x0000f800) >> 11)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y_SET(value) (((value) << 11) & 0x0000f800)

/*
 * Field : TQS
 *
 * Transmit Queue Size.
 *
 * This field indicates the size of the allocated Transmit queues in blocks of 256
 * bytes. The sixteenth bit is the starting bit of this field. The width of this
 * field depends on the Tx memory size selected in your configuration. For example,
 * if the memory size is 2048, the width of this field is 3 bits:
 *
 * LOG2(2048/256) = LOG2(8) = 3 bits
 *
 * A value of 0 indicates 256 bytes. When this queue is enabled (TXQEN=10), a
 * minimum value of 7 (size = 2048) is recommended so that the queue can store more
 * than a complete max-sized Ethernet packet.
 *
 * This field is reserved and RO in single queue configuration, and its reset value
 * corresponds to the transmit FIFO size
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_LSB	16
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register
 * field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_MSB	22
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_WIDTH	7
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_SET_MSK	0x007f0000
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_CLR_MSK	0xff80ffff
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_RESET	0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_GET(value) (((value)&0x007f0000) >> 16)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS_SET(value) (((value) << 16) & 0x007f0000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y
 * register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_LSB	  23
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y
 * register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_MSB	  31
/* The width in bits of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_WIDTH	  9
/* The mask used to set the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y register field value. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_SET_MSK	  0xff800000
/* The mask used to clear the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y register field value.
 */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_CLR_MSK	  0x007fffff
/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y register field. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y field value from a register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_GET(value) (((value)&0xff800000) >> 23)
/* Produces a MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y_SET(value) (((value) << 23) & 0xff800000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_TXQx_OPERATION_MODE.
 */
struct MTL_TCQx_MTL_TXQx_OPERATION_MODE_s {
	volatile uint32_t FTQ : 1;		/* MTL_TCQx_MTL_TXQx_OPERATION_MODE_FTQ */
	volatile uint32_t TSF : 1;		/* MTL_TCQx_MTL_TXQx_OPERATION_MODE_TSF */
	volatile uint32_t TXQEN : 2;		/* MTL_TCQx_MTL_TXQx_OPERATION_MODE_TXQEN */
	volatile uint32_t TTC : 3;		/* MTL_TCQx_MTL_TXQx_OPERATION_MODE_TTC */
	const volatile uint32_t Reserved_7 : 1; /* MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_7 */
	volatile uint32_t Q2TCMAP : 3;		/* MTL_TCQx_MTL_TXQx_OPERATION_MODE_Q2TCMAP */
	const volatile uint32_t
		Reserved_15_y : 5; /* MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_15_Y */
	volatile uint32_t TQS : 7; /* MTL_TCQx_MTL_TXQx_OPERATION_MODE_TQS */
	const volatile uint32_t
		Reserved_31_y : 9; /* MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESERVED_31_Y */
};

/* The typedef declaration for register MTL_TCQx_MTL_TXQx_OPERATION_MODE. */
typedef struct MTL_TCQx_MTL_TXQx_OPERATION_MODE_s MTL_TCQx_MTL_TXQx_OPERATION_MODE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_TXQx_OPERATION_MODE register. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_TXQx_OPERATION_MODE register from the beginning of the
 * component. */
#define MTL_TCQx_MTL_TXQx_OPERATION_MODE_OFST  0x0

/*
 * Register : MTL_TxQ0_Underflow
 *
 * The Queue 0 Underflow Counter register contains the counter for packets aborted
 * because of Transmit queue underflow.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [10:0]  | R      | 0x0   | MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT
 *  [14:11] | R      | 0x0   | MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11
 *  [15]    | R      | 0x0   | MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF
 *  [31:16] | R      | 0x0   | MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16
 *
 */
/*
 * Field : UFPKTCNT
 *
 * Underflow Packet Counter.
 *
 * This field indicates the number of packets aborted by the controller because of
 * Transmit Queue Underflow. This counter is incremented each time the MAC aborts
 * an outgoing packet because of underflow. The counter is reset when this register
 * is read with mci_be_i[0] at 1'b1.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register
 * field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_LSB	0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register
 * field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_MSB	10
/* The width in bits of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_WIDTH	11
/* The mask used to set the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_SET_MSK	0x000007ff
/* The mask used to clear the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_CLR_MSK	0xfffff800
/* The reset value of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_RESET	0x0
/* Extracts the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT field value from a register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_GET(value) (((value)&0x000007ff) >> 0)
/* Produces a MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT_SET(value) (((value) << 0) & 0x000007ff)

/*
 * Field : Reserved_14_11
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11
 * register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_LSB	      11
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11
 * register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_MSB	      14
/* The width in bits of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_WIDTH      4
/* The mask used to set the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_SET_MSK    0x00007800
/* The mask used to clear the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_CLR_MSK    0xffff87ff
/* The reset value of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_RESET      0x0
/* Extracts the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 field value from a register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_GET(value) (((value)&0x00007800) >> 11)
/* Produces a MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11_SET(value) (((value) << 11) & 0x00007800)

/*
 * Field : UFCNTOVF
 *
 * Overflow Bit for Underflow Packet Counter.
 *
 * This bit is set every time the Tx Queue Underflow Packet Counter field
 * overflows, that is, it has crossed the maximum count. In such a scenario, the
 * overflow packet counter is reset to all-zeros and this bit indicates that the
 * rollover happened.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register
 * field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_LSB	15
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register
 * field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_MSB	15
/* The width in bits of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_WIDTH	1
/* The mask used to set the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_SET_MSK	0x00008000
/* The mask used to clear the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_CLR_MSK	0xffff7fff
/* The reset value of the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_RESET	0x0
/* Extracts the MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF field value from a register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_GET(value) (((value)&0x00008000) >> 15)
/* Produces a MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16
 * register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_LSB	      16
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16
 * register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_MSB	      31
/* The width in bits of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_WIDTH      16
/* The mask used to set the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_SET_MSK    0xffff0000
/* The mask used to clear the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 register field value. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_CLR_MSK    0x0000ffff
/* The reset value of the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 register field. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_RESET      0x0
/* Extracts the MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 field value from a register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_TXQx_UNDERFLOW.
 */
struct MTL_TCQx_MTL_TXQx_UNDERFLOW_s {
	const volatile uint32_t UFPKTCNT : 11;	    /* MTL_TCQx_MTL_TXQx_UNDERFLOW_UFPKTCNT */
	const volatile uint32_t Reserved_14_11 : 4; /* MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_14_11 */
	const volatile uint32_t UFCNTOVF : 1;	    /* MTL_TCQx_MTL_TXQx_UNDERFLOW_UFCNTOVF */
	const volatile uint32_t
		Reserved_31_16 : 16; /* MTL_TCQx_MTL_TXQx_UNDERFLOW_RESERVED_31_16 */
};

/* The typedef declaration for register MTL_TCQx_MTL_TXQx_UNDERFLOW. */
typedef struct MTL_TCQx_MTL_TXQx_UNDERFLOW_s MTL_TCQx_MTL_TXQx_UNDERFLOW_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_TXQx_UNDERFLOW register. */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_TXQx_UNDERFLOW register from the beginning of the component.
 */
#define MTL_TCQx_MTL_TXQx_UNDERFLOW_OFST  0x4

/*
 * Register : MTL_TxQ0_Debug
 *
 * The Queue 0 Transmit Debug register gives the debug status of various blocks
 * related to the Transmit Queue 0 and Traffic Class 0.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------
 *  [0]    | R      | 0x0   | MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED
 *  [2:1]  | R      | 0x0   | MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS
 *  [3]    | R      | 0x0   | MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS
 *  [4]    | R      | 0x0   | MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS
 *  [5]    | R      | 0x0   | MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS
 *  [31:6] | R      | 0x0   | MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6
 *
 */
/*
 * Field : TCPAUSED
 *
 * Traffic Class in Pause.
 *
 * When this bit is high and the Rx flow control is enabled, it indicates that the
 * Traffic Class 0 is in the Pause condition because of the following:
 *
 * * Reception of the PFC packet for the priorities assigned to the Traffic Class 0
 *   when PFC is enabled
 *
 * * Reception of IEEE 802.3-2018 Pause packet when Priority Based Flow Control
 *   (PFC) is disabled
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field.
 */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_LSB	    0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field.
 */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_MSB	    0
/* The width in bits of the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_WIDTH	    1
/* The mask used to set the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_SET_MSK    0x00000001
/* The mask used to clear the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_CLR_MSK    0xfffffffe
/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_RESET	    0x0
/* Extracts the MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED field value from a register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TRCSTS
 *
 * MTL Tx Queue Read Controller Status.
 *
 * This field indicates the state of the Tx Queue Read Controller:
 *
 * * 2'b00: Idle state
 *
 * * 2'b01: Read state (transferring data to the MAC transmitter)
 *
 * * 2'b10: Waiting for pending Tx Status from the MAC transmitter
 *
 * * 2'b11: Flushing the Tx queue because of the Packet Abort request from the MAC
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_LSB	  1
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_MSB	  2
/* The width in bits of the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_WIDTH	  2
/* The mask used to set the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_SET_MSK	  0x00000006
/* The mask used to clear the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_CLR_MSK	  0xfffffff9
/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS field value from a register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_GET(value) (((value)&0x00000006) >> 1)
/* Produces a MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS_SET(value) (((value) << 1) & 0x00000006)

/*
 * Field : TWCSTS
 *
 * MTL Tx Queue Write Controller Status.
 *
 * When high, this bit indicates that the MTL Tx Queue Write Controller is active,
 * and it is transferring the data to the Tx Queue.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_LSB	  3
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_MSB	  3
/* The width in bits of the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_WIDTH	  1
/* The mask used to set the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_SET_MSK	  0x00000008
/* The mask used to clear the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_CLR_MSK	  0xfffffff7
/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS field value from a register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : TXQSTS
 *
 * MTL Tx Queue Not Empty Status.
 *
 * When this bit is high, it indicates that the MTL Tx Queue is not empty and some
 * data is left for transmission.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_LSB	  4
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_MSB	  4
/* The width in bits of the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_WIDTH	  1
/* The mask used to set the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_SET_MSK	  0x00000010
/* The mask used to clear the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_CLR_MSK	  0xffffffef
/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS field value from a register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : TRCPSTS
 *
 * MTL TRC Pending Status
 *
 * When this bit is high, it indicates that the MTL Tx Read Controller (TRC) has a
 * pending status from MAC.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field.
 */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_LSB	   5
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_MSB	   5
/* The width in bits of the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_WIDTH	   1
/* The mask used to set the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_SET_MSK	   0x00000020
/* The mask used to clear the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_CLR_MSK	   0xffffffdf
/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS field value from a register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_31_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register
 * field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_LSB	 6
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register
 * field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_MSB	 31
/* The width in bits of the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_WIDTH	 26
/* The mask used to set the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_SET_MSK	 0xffffffc0
/* The mask used to clear the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register field value. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_CLR_MSK	 0x0000003f
/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register field. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_RESET	 0x0
/* Extracts the MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 field value from a register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_GET(value) (((value)&0xffffffc0) >> 6)
/* Produces a MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6_SET(value) (((value) << 6) & 0xffffffc0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_TXQx_DEBUG.
 */
struct MTL_TCQx_MTL_TXQx_DEBUG_s {
	const volatile uint32_t TCPAUSED : 1;	    /* MTL_TCQx_MTL_TXQx_DEBUG_TCPAUSED */
	const volatile uint32_t TRCSTS : 2;	    /* MTL_TCQx_MTL_TXQx_DEBUG_TRCSTS */
	const volatile uint32_t TWCSTS : 1;	    /* MTL_TCQx_MTL_TXQx_DEBUG_TWCSTS */
	const volatile uint32_t TXQSTS : 1;	    /* MTL_TCQx_MTL_TXQx_DEBUG_TXQSTS */
	const volatile uint32_t TRCPSTS : 1;	    /* MTL_TCQx_MTL_TXQx_DEBUG_TRCPSTS */
	const volatile uint32_t Reserved_31_6 : 26; /* MTL_TCQx_MTL_TXQx_DEBUG_RESERVED_31_6 */
};

/* The typedef declaration for register MTL_TCQx_MTL_TXQx_DEBUG. */
typedef struct MTL_TCQx_MTL_TXQx_DEBUG_s MTL_TCQx_MTL_TXQx_DEBUG_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_TXQx_DEBUG register. */
#define MTL_TCQx_MTL_TXQx_DEBUG_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_TXQx_DEBUG register from the beginning of the component. */
#define MTL_TCQx_MTL_TXQx_DEBUG_OFST  0x8

/*
 * Register : MTC_TCx_ETS_Control
 *
 * This register configures the transmission selection algorithm, for Traffic Class
 * 0.This register is not available in single traffic class configuration.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------
 *  [1:0]  | RW     | 0x0   | MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA
 *  [2]    | R      | 0x0   | MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN
 *  [3]    | R      | 0x0   | MTL_TCQx_MTC_TCx_ETS_CONTROL_CC
 *  [6:4]  | R      | 0x0   | MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC
 *  [31:7] | R      | 0x0   | MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7
 *
 */
/*
 * Field : TSA
 *
 * Transmission Selection Algorithm.
 *
 * This field is used to assign a transmission selection algorithm for this traffic
 * class.
 *
 * * 2'b00: Strict priority
 *
 * * 2'b01: CBS
 *
 * * 2'b10: ETS
 *
 * * 2'b11: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_LSB	    0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_MSB	    1
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_WIDTH	    2
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_SET_MSK    0x00000003
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_CLR_MSK    0xfffffffc
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_RESET	    0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_GET(value) (((value)&0x00000003) >> 0)
/* Produces a MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : CBSEN
 *
 * Credit Based Shaper Enable
 *
 * This field indicates that TSA field of this register is enabled for CBS
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register
 * field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_LSB	      2
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_MSB	      2
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_WIDTH      1
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_SET_MSK    0x00000004
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_CLR_MSK    0xfffffffb
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_RESET      0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_CC
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_LSB	   3
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_MSB	   3
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_WIDTH	   1
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_SET_MSK	   0x00000008
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_CLR_MSK	   0xfffffff7
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_RESET	   0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_CONTROL_CC field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_TCQx_MTC_TCx_ETS_CONTROL_CC register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_CC_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_SLC
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_LSB	    4
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_MSB	    6
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_WIDTH	    3
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_SET_MSK    0x00000070
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_CLR_MSK    0xffffff8f
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_RESET	    0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_GET(value) (((value)&0x00000070) >> 4)
/* Produces a MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_31_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7
 * register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_LSB	      7
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7
 * register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_MSB	      31
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_WIDTH      25
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_SET_MSK    0xffffff80
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 register field value. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_CLR_MSK    0x0000007f
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 register field. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_RESET      0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_GET(value) (((value)&0xffffff80) >> 7)
/* Produces a MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7_SET(value) (((value) << 7) & 0xffffff80)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTC_TCx_ETS_CONTROL.
 */
struct MTL_TCQx_MTC_TCx_ETS_CONTROL_s {
	volatile uint32_t TSA : 2;		    /* MTL_TCQx_MTC_TCx_ETS_CONTROL_TSA */
	const volatile uint32_t CBSEN : 1;	    /* MTL_TCQx_MTC_TCx_ETS_CONTROL_CBSEN */
	const volatile uint32_t CC : 1;		    /* MTL_TCQx_MTC_TCx_ETS_CONTROL_CC */
	const volatile uint32_t SLC : 3;	    /* MTL_TCQx_MTC_TCx_ETS_CONTROL_SLC */
	const volatile uint32_t Reserved_31_7 : 25; /* MTL_TCQx_MTC_TCx_ETS_CONTROL_RESERVED_31_7 */
};

/* The typedef declaration for register MTL_TCQx_MTC_TCx_ETS_CONTROL. */
typedef struct MTL_TCQx_MTC_TCx_ETS_CONTROL_s MTL_TCQx_MTC_TCx_ETS_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTC_TCx_ETS_CONTROL register. */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTC_TCx_ETS_CONTROL register from the beginning of the component.
 */
#define MTL_TCQx_MTC_TCx_ETS_CONTROL_OFST  0x10

/*
 * Register : MTC_TCx_ETS_Status
 *
 * This register contains the information of average bits transmitted over a slot
 * interval of 10 million bit times, for Traffic Class 0.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [23:0]  | R      | 0x0   | MTL_TCQx_MTC_TCx_ETS_STATUS_ABS
 *  [31:24] | R      | 0x0   | MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24
 *
 */
/*
 * Field : ABS
 *
 * Average Bits per Slot.
 *
 * This field contains the average transmitted bits per slot computed over every
 * slot of 10 million bit times (1ms in 10G mode, 10ms in 1G mode). The maximum
 * value is 0x989680.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field.
 */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_LSB	   0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_MSB	   23
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_WIDTH	   24
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field value. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_SET_MSK	   0x00ffffff
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field value. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_CLR_MSK	   0xff000000
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_RESET	   0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_STATUS_ABS field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_GET(value) (((value)&0x00ffffff) >> 0)
/* Produces a MTL_TCQx_MTC_TCx_ETS_STATUS_ABS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_ABS_SET(value) (((value) << 0) & 0x00ffffff)

/*
 * Field : Reserved_31_24
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24
 * register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_LSB	      24
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24
 * register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_MSB	      31
/* The width in bits of the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_WIDTH      8
/* The mask used to set the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 register field value. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_SET_MSK    0xff000000
/* The mask used to clear the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 register field value. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_CLR_MSK    0x00ffffff
/* The reset value of the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 register field. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_RESET      0x0
/* Extracts the MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 field value from a register. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_GET(value) (((value)&0xff000000) >> 24)
/* Produces a MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24_SET(value) (((value) << 24) & 0xff000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTC_TCx_ETS_STATUS.
 */
struct MTL_TCQx_MTC_TCx_ETS_STATUS_s {
	const volatile uint32_t ABS : 24;	    /* MTL_TCQx_MTC_TCx_ETS_STATUS_ABS */
	const volatile uint32_t Reserved_31_24 : 8; /* MTL_TCQx_MTC_TCx_ETS_STATUS_RESERVED_31_24 */
};

/* The typedef declaration for register MTL_TCQx_MTC_TCx_ETS_STATUS. */
typedef struct MTL_TCQx_MTC_TCx_ETS_STATUS_s MTL_TCQx_MTC_TCx_ETS_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTC_TCx_ETS_STATUS register. */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTC_TCx_ETS_STATUS register from the beginning of the component.
 */
#define MTL_TCQx_MTC_TCx_ETS_STATUS_OFST  0x14

/*
 * Register : MTC_TCx_Quantum_Weight
 *
 * The TC1 Quantum or Weights register provides the average traffic transmitted in
 * Traffic Class 1. For TCn, where n = 1 to 7, this register is not available when
 * the number of traffic classes selected is less than n + 1
 *
 * This register is not available in corresponding Queues 8-15 registers..
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------
 *  [20:0]  | RW     | 0x0   | MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW
 *  [31:21] | R      | 0x0   | MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21
 *
 */
/*
 * Field : QW
 *
 * idleSlopeCredit, Quantum or Weights.
 *
 * * idleSlopeCredit
 *
 * * - When Audio Video Bridging feature is enabled, this field contains the
 *   idleSlopeCredit value required for the credit-based shaper algorithm for Queue
 *   1. This is the rate of change of credit in bits per cycle (3.2 ns for 2.5/10
 *   Gbps; 8 ns for 1000 Mbps) when the credit is increasing. The software should
 *   program this field with computed credit in bits per cycle scaled by 1024. The
 *   maximum value is portTransmitRate, that is, 0x2000 in 1000/2500 Mbps mode and
 *   0x8000 in 10 Gbps mode. Bits[20:16] must be written to zero.
 *
 * * Quantum
 *
 * * - When the TSA is set to ETS and ETSALG is set to DWRR algorithm for Traffic
 *   Class 1 traffic, this field contains the quantum value in bytes to be added to
 *   credit during every queue scanning cycle. The maximum value is 0x1312D0 bytes.
 *
 * * Weights
 *
 * * - When TSA is set to ETS and ETSALG is set to WFQ algorithm for Traffic Class1
 *   traffic, this field contains the weight for this queue. The maximum value is
 *   0x3FFF where weight of 0 indicates 100% bandwidth. Bits [20:14] must be
 *   written to zero.
 *
 * * - When TSA is set to ETS and ETSALG is set to WRR algorithm for Traffic Class
 *   1 traffic, this field contains the weight for this queue. The maximum value is
 *   0x64. Bits[20:7] must be written to zero. This field is reserved and RO when
 *   the number of traffic classes selected is less than two. This field is
 *   reserved in corresponding Queues 8-15 register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register
 * field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_LSB	      0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register field.
 */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_MSB	      20
/* The width in bits of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_WIDTH      21
/* The mask used to set the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register field value. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_SET_MSK    0x001fffff
/* The mask used to clear the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register field value. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_CLR_MSK    0xffe00000
/* The reset value of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_RESET      0x0
/* Extracts the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW field value from a register. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_GET(value) (((value)&0x001fffff) >> 0)
/* Produces a MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW_SET(value) (((value) << 0) & 0x001fffff)

/*
 * Field : Reserved_31_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21
 * register field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_LSB	  21
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21
 * register field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_MSB	  31
/* The width in bits of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 register field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_WIDTH	  11
/* The mask used to set the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 register field value. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_SET_MSK	  0xffe00000
/* The mask used to clear the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 register field value.
 */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_CLR_MSK	  0x001fffff
/* The reset value of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 register field. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_RESET	  0x0
/* Extracts the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 field value from a register. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_GET(value) (((value)&0xffe00000) >> 21)
/* Produces a MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21_SET(value) (((value) << 21) & 0xffe00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT.
 */
struct MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_s {
	volatile uint32_t QW : 21; /* MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_QW */
	const volatile uint32_t
		Reserved_31_21 : 11; /* MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESERVED_31_21 */
};

/* The typedef declaration for register MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT. */
typedef struct MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_s MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT register. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT register from the beginning of the
 * component. */
#define MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_OFST  0x18

/*
 * Register : MTL_RxQ0_Operation_Mode
 *
 * The Queue 0 Receive Operation Mode register establishes the Receive queue
 * operating modes and command.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------
 *  [1:0]   | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC
 *  [2]     | R      | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2
 *  [3]     | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF
 *  [4]     | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF
 *  [5]     | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF
 *  [6]     | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF
 *  [7]     | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC
 *  [15:8]  | R      | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8
 *  [21:16] | RW     | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS
 *  [31:22] | R      | 0x0   | MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y
 *
 */
/*
 * Field : RTC
 *
 * Receive Queue Threshold Control.
 *
 * These bits control the threshold level of the MTL Rx queue (in bytes):
 *
 * * 2'b00: 64
 *
 * * 2'b01: Reserved
 *
 * * 2'b10: 96
 *
 * * 2'b11: 128
 *
 * The received packet is transferred to the application or DMA when the packet
 * size within the MTL Rx queue is larger than the threshold. In addition, full
 * packets with length less than the threshold are automatically transferred. The
 * value of 11 is not applicable if the size of the configured Rx Queue is 128
 * bytes.
 *
 * This field is valid only when the RSF bit is zero. This field is ignored when
 * the RSF bit is set to 1.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_LSB	0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_MSB	1
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_WIDTH	2
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_SET_MSK	0x00000003
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_CLR_MSK	0xfffffffc
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_GET(value) (((value)&0x00000003) >> 0)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : Reserved_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_LSB	       2
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_MSB	       2
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_WIDTH      1
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_SET_MSK    0x00000004
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_CLR_MSK    0xfffffffb
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_GET(value) (((value)&0x00000004) >> 2)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : FUF
 *
 * Forward Undersized Good Packets.
 *
 * When this bit is set, the Rx queue forwards the undersized good packets (with no
 * Invalid-code/GMII/CRC/Length errors and length less than 64 bytes at Rx (X)GMII
 * interface), including pad-bytes and CRC.
 *
 * When this bit is reset, the Rx queue drops all packets of length less than 64
 * bytes.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_LSB	3
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_MSB	3
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_WIDTH	1
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_SET_MSK	0x00000008
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_CLR_MSK	0xfffffff7
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : FEF
 *
 * Forward Error Packets.
 *
 * * When this bit is reset, the Rx queue drops packets with error status (CRC
 *   error, GMII_ER, watchdog timeout, or overflow). However, if the start byte
 *   (write) pointer of a packet is already transferred to the read controller side
 *   (in Threshold mode), the packet is not dropped.
 *
 * * When this bit is set, all packets except the runt error packets are forwarded
 *   to the application or DMA. If the RSF bit is set and the Rx queue overflows
 *   when a partial packet is written, the packet is dropped irrespective of the
 *   setting of this bit. However, if the RSF bit is reset and the Rx queue
 *   overflows when a partial packet is written, a partial packet might be
 *   forwarded to the application or DMA.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_LSB	4
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_MSB	4
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_WIDTH	1
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_SET_MSK	0x00000010
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_CLR_MSK	0xffffffef
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_GET(value) (((value)&0x00000010) >> 4)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : RSF
 *
 * Receive Queue Store and Forward.
 *
 * When this bit is set, DWC_xgmac reads a packet from the Rx queue only after the
 * complete packet has been written to it, ignoring the RTC field of this register.
 * When this bit is reset, the Rx queue operates in the Threshold (cut-through)
 * mode, subject to the threshold specified by the RTC field of this register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_LSB	5
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_MSB	5
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_WIDTH	1
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_SET_MSK	0x00000020
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_CLR_MSK	0xffffffdf
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_GET(value) (((value)&0x00000020) >> 5)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : DIS_TCP_EF
 *
 * Disable Dropping of TCP/IP Checksum Error Packets.
 *
 * * When this bit is set, the MAC does not drop the packets which only have the
 *   errors detected by the Receive Checksum Offload engine. Such packets have
 *   errors only in the encapsulated payload. There are no errors (including FCS
 *   error) in the Ethernet packet received by the MAC.
 *
 * * When this bit is reset, all error packets are dropped if the FEF bit is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_LSB	       6
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_MSB	       6
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_WIDTH      1
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_SET_MSK    0x00000040
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_CLR_MSK    0xffffffbf
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_GET(value) (((value)&0x00000040) >> 6)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : EHFC
 *
 * Enable Hardware Flow Control.
 *
 * When this bit is set, the flow control signal operation, based on the fill-level
 * of Rx queue, is enabled.
 *
 * When reset, the flow control operation is disabled. This bit is not used
 * (reserved and always reset) when the Rx queue is less than 4 KB.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_LSB	 7
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_MSB	 7
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_WIDTH	 1
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_SET_MSK	 0x00000080
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_CLR_MSK	 0xffffff7f
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_RESET	 0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_GET(value) (((value)&0x00000080) >> 7)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_15_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_LSB	  8
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_MSB	  15
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_WIDTH	  8
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_SET_MSK	  0x0000ff00
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 register field value.
 */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_CLR_MSK	  0xffff00ff
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : RQS
 *
 * Receive Queue Size.
 *
 * This field indicates the size of the allocated Receive queues in blocks of 256
 * bytes. The sixteenth bit is the starting bit of this field. The width of this
 * field depends on the Rx memory size selected in your configuration. For example,
 * if the memory size is 2048, the width of this field is 3 bits:
 *
 * LOG2(2048/256) = LOG2(8) = 3 bits
 *
 * A value of 0 indicates 256 bytes.
 *
 * This field is reserved and RO in single queue configuration, and its reset value
 * corresponds to the receive FIFO size. When this queue is used, a minimum value
 * of 7 (size = 2048) is recommended so that the queue can store more than a
 * complete max-sized Ethernet packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_LSB	16
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register
 * field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_MSB	21
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_WIDTH	6
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_SET_MSK	0x003f0000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_CLR_MSK	0xffc0ffff
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_GET(value) (((value)&0x003f0000) >> 16)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS_SET(value) (((value) << 16) & 0x003f0000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_LSB	  22
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y
 * register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_MSB	  31
/* The width in bits of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_WIDTH	  10
/* The mask used to set the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y register field value. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_SET_MSK	  0xffc00000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y register field value.
 */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_CLR_MSK	  0x003fffff
/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y register field. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y field value from a register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_GET(value) (((value)&0xffc00000) >> 22)
/* Produces a MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y_SET(value) (((value) << 22) & 0xffc00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_RXQx_OPERATION_MODE.
 */
struct MTL_TCQx_MTL_RXQx_OPERATION_MODE_s {
	volatile uint32_t RTC : 2;		/* MTL_TCQx_MTL_RXQx_OPERATION_MODE_RTC */
	const volatile uint32_t Reserved_2 : 1; /* MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_2 */
	volatile uint32_t FUF : 1;		/* MTL_TCQx_MTL_RXQx_OPERATION_MODE_FUF */
	volatile uint32_t FEF : 1;		/* MTL_TCQx_MTL_RXQx_OPERATION_MODE_FEF */
	volatile uint32_t RSF : 1;		/* MTL_TCQx_MTL_RXQx_OPERATION_MODE_RSF */
	volatile uint32_t DIS_TCP_EF : 1;	/* MTL_TCQx_MTL_RXQx_OPERATION_MODE_DIS_TCP_EF */
	volatile uint32_t EHFC : 1;		/* MTL_TCQx_MTL_RXQx_OPERATION_MODE_EHFC */
	const volatile uint32_t
		Reserved_15_8 : 8; /* MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_15_8 */
	volatile uint32_t RQS : 6; /* MTL_TCQx_MTL_RXQx_OPERATION_MODE_RQS */
	const volatile uint32_t
		Reserved_31_y : 10; /* MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESERVED_31_Y */
};

/* The typedef declaration for register MTL_TCQx_MTL_RXQx_OPERATION_MODE. */
typedef struct MTL_TCQx_MTL_RXQx_OPERATION_MODE_s MTL_TCQx_MTL_RXQx_OPERATION_MODE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_RXQx_OPERATION_MODE register. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_RXQx_OPERATION_MODE register from the beginning of the
 * component. */
#define MTL_TCQx_MTL_RXQx_OPERATION_MODE_OFST  0x40

/*
 * Register : MTL_RxQ0_Missed_Pkt_Overflow_Cnt
 *
 * The Queue 0 Overflow Counter register contains the counter for packets missed
 * because of Receive queue packet flush and packets discarded because of Receive
 * queue overflow.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------------------
 *  [10:0]  | R      | 0x0   | MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT
 *  [14:11] | R      | 0x0   | MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11
 *  [15]    | R      | 0x0   | MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF
 *  [26:16] | R      | 0x0   | MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT
 *  [30:27] | R      | 0x0   | MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27
 *  [31]    | R      | 0x0   | MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF
 *
 */
/*
 * Field : OVFPKTCNT
 *
 * Overflow Packet Counter.
 *
 * This field indicates the number of packets discarded by DWC_xgmac because of
 * Receive queue overflow. This counter is incremented each time DWC_xgmac discards
 * an incoming packet because of overflow. This counter is reset when this register
 * is read with mci_be_i[0] at 1'b1.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_LSB	       0
/* The Most Significant Bit (MSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_MSB	       10
/* The width in bits of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_WIDTH      11
/* The mask used to set the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_SET_MSK    0x000007ff
/* The mask used to clear the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_CLR_MSK    0xfffff800
/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT field value from a register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_GET(value) (((value)&0x000007ff) >> 0)
/* Produces a MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT_SET(value) (((value) << 0) & 0x000007ff)

/*
 * Field : Reserved_14_11
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_LSB	 11
/* The Most Significant Bit (MSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_MSB	 14
/* The width in bits of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register field.
 */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_WIDTH	 4
/* The mask used to set the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_SET_MSK 0x00007800
/* The mask used to clear the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register
 * field value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_CLR_MSK 0xffff87ff
/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register field.
 */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_RESET	 0x0
/* Extracts the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 field value from a
 * register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_GET(value)                        \
	(((value)&0x00007800) >> 11)
/* Produces a MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 register field value suitable
 * for setting the register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11_SET(value)                        \
	(((value) << 11) & 0x00007800)

/*
 * Field : OVFCNTOVF
 *
 * Overflow Counter Overflow Bit.
 *
 * When set, this bit indicates that the Rx Queue Overflow Packet Counter field
 * crossed the maximum limit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_LSB	       15
/* The Most Significant Bit (MSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_MSB	       15
/* The width in bits of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_WIDTH      1
/* The mask used to set the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_SET_MSK    0x00008000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_CLR_MSK    0xffff7fff
/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF field value from a register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_GET(value) (((value)&0x00008000) >> 15)
/* Produces a MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF_SET(value)                             \
	(((value) << 15) & 0x00008000)

/*
 * Field : MISPKTCNT
 *
 * Missed Packet Counter.
 *
 * This field indicates the number of packets missed by DWC_xgmac because the
 * application asserted ari_pkt_flush_i[] for this queue. This counter is
 * incremented each time the application issues ari_pkt_flush_i[] for this queue.
 * This counter is reset when this register is read with mci_be_i[0] at 1'b1.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_LSB	       16
/* The Most Significant Bit (MSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_MSB	       26
/* The width in bits of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_WIDTH      11
/* The mask used to set the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_SET_MSK    0x07ff0000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_CLR_MSK    0xf800ffff
/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT field value from a register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_GET(value) (((value)&0x07ff0000) >> 16)
/* Produces a MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT_SET(value)                             \
	(((value) << 16) & 0x07ff0000)

/*
 * Field : Reserved_30_27
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_LSB	 27
/* The Most Significant Bit (MSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_MSB	 30
/* The width in bits of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register field.
 */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_WIDTH	 4
/* The mask used to set the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_SET_MSK 0x78000000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register
 * field value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_CLR_MSK 0x87ffffff
/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register field.
 */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_RESET	 0x0
/* Extracts the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 field value from a
 * register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_GET(value)                        \
	(((value)&0x78000000) >> 27)
/* Produces a MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 register field value suitable
 * for setting the register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27_SET(value)                        \
	(((value) << 27) & 0x78000000)

/*
 * Field : MISCNTOVF
 *
 * Missed Packet Counter Overflow Bit.
 *
 * When set, this bit indicates that the Rx Queue Missed Packet Counter crossed the
 * maximum limit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_LSB	       31
/* The Most Significant Bit (MSB) position of the
 * MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_MSB	       31
/* The width in bits of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_WIDTH      1
/* The mask used to set the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_SET_MSK    0x80000000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field
 * value. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_CLR_MSK    0x7fffffff
/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF field value from a register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_GET(value) (((value)&0x80000000) >> 31)
/* Produces a MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF_SET(value)                             \
	(((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT.
 */
struct MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_s {
	const volatile uint32_t
		OVFPKTCNT : 11; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFPKTCNT */
	const volatile uint32_t
		Reserved_14_11 : 4; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_14_11 */
	const volatile uint32_t
		OVFCNTOVF : 1; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OVFCNTOVF */
	const volatile uint32_t
		MISPKTCNT : 11; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISPKTCNT */
	const volatile uint32_t
		Reserved_30_27 : 4; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESERVED_30_27 */
	const volatile uint32_t
		MISCNTOVF : 1; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_MISCNTOVF */
};

/* The typedef declaration for register MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT. */
typedef struct MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_s
	MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT register. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT register from the beginning of
 * the component. */
#define MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_OFST	0x44

/*
 * Register : MTL_RxQ0_Debug
 *
 * The Queue 0 Receive Debug register gives the debug status of various blocks
 * related to the Receive queue.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [0]     | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS
 *  [2:1]   | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS
 *  [3]     | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3
 *  [5:4]   | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS
 *  [15:6]  | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6
 *  [29:16] | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_PRXQ
 *  [31:30] | R      | 0x0   | MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30
 *
 */
/*
 * Field : RWCSTS
 *
 * MTL Rx Queue Write Controller Active Status.
 *
 * When high, this bit indicates that the MTL Rx queue Write controller is active,
 * and it is transferring a received packet to the Rx Queue.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_LSB	  0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_MSB	  0
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_WIDTH	  1
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_SET_MSK	  0x00000001
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_CLR_MSK	  0xfffffffe
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RRCSTS
 *
 * MTL Rx Queue Read Controller State.
 *
 * This field gives the state of the Rx queue Read controller:
 *
 * * 2'b00: Idle state
 *
 * * 2'b01: Reading packet data
 *
 * * 2'b10: Reading packet status (or timestamp)
 *
 * * 2'b11: Flushing the packet data and status
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_LSB	  1
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_MSB	  2
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_WIDTH	  2
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_SET_MSK	  0x00000006
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_CLR_MSK	  0xfffffff9
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_GET(value) (((value)&0x00000006) >> 1)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS_SET(value) (((value) << 1) & 0x00000006)

/*
 * Field : Reserved_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register
 * field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_LSB	      3
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register field.
 */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_MSB	      3
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_WIDTH      1
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_SET_MSK    0x00000008
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_CLR_MSK    0xfffffff7
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : RXQSTS
 *
 * MTL Rx Queue Fill-Level Status.
 *
 * This field gives the status of the fill-level of the Rx Queue:
 *
 * * 2'b00: Rx Queue empty
 *
 * * 2'b01: Rx Queue fill-level below flow-control deactivate threshold
 *
 * * 2'b10: Rx Queue fill-level above flow-control activate threshold
 *
 * * 2'b11: Rx Queue full
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_LSB	  4
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_MSB	  5
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_WIDTH	  2
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_SET_MSK	  0x00000030
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_CLR_MSK	  0xffffffcf
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_GET(value) (((value)&0x00000030) >> 4)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : Reserved_15_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register
 * field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_LSB	 6
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register
 * field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_MSB	 15
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_WIDTH	 10
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_SET_MSK	 0x0000ffc0
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_CLR_MSK	 0xffff003f
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_RESET	 0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_GET(value) (((value)&0x0000ffc0) >> 6)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6_SET(value) (((value) << 6) & 0x0000ffc0)

/*
 * Field : PRXQ
 *
 * Number of Packets in Receive Queue.
 *
 * This field indicates the current number of packets in the Rx Queue. The
 * theoretical maximum value for this field is 256KB/16B = 16K Packets, that is,
 * Max_Queue_Size/Min_Packet_Size.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_LSB	16
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_MSB	29
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_WIDTH	14
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_SET_MSK	0x3fff0000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_CLR_MSK	0xc000ffff
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_PRXQ field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_GET(value) (((value)&0x3fff0000) >> 16)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_PRXQ register field value suitable for setting the register.
 */
#define MTL_TCQx_MTL_RXQx_DEBUG_PRXQ_SET(value) (((value) << 16) & 0x3fff0000)

/*
 * Field : Reserved_31_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register
 * field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_LSB	  30
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register
 * field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_MSB	  31
/* The width in bits of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_WIDTH	  2
/* The mask used to set the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_SET_MSK	  0xc0000000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register field value. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_CLR_MSK	  0x3fffffff
/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register field. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 field value from a register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_RXQx_DEBUG.
 */
struct MTL_TCQx_MTL_RXQx_DEBUG_s {
	const volatile uint32_t RWCSTS : 1;	    /* MTL_TCQx_MTL_RXQx_DEBUG_RWCSTS */
	const volatile uint32_t RRCSTS : 2;	    /* MTL_TCQx_MTL_RXQx_DEBUG_RRCSTS */
	const volatile uint32_t Reserved_3 : 1;	    /* MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_3 */
	const volatile uint32_t RXQSTS : 2;	    /* MTL_TCQx_MTL_RXQx_DEBUG_RXQSTS */
	const volatile uint32_t Reserved_15_6 : 10; /* MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_15_6 */
	const volatile uint32_t PRXQ : 14;	    /* MTL_TCQx_MTL_RXQx_DEBUG_PRXQ */
	const volatile uint32_t Reserved_31_30 : 2; /* MTL_TCQx_MTL_RXQx_DEBUG_RESERVED_31_30 */
};

/* The typedef declaration for register MTL_TCQx_MTL_RXQx_DEBUG. */
typedef struct MTL_TCQx_MTL_RXQx_DEBUG_s MTL_TCQx_MTL_RXQx_DEBUG_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_RXQx_DEBUG register. */
#define MTL_TCQx_MTL_RXQx_DEBUG_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_RXQx_DEBUG register from the beginning of the component. */
#define MTL_TCQx_MTL_RXQx_DEBUG_OFST  0x48

/*
 * Register : MTL_RxQ0_Control
 *
 * The Queue 0 Receive Control register controls the receive arbitration and
 * passing of received packets to the application.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------------
 *  [2:0]  | RW     | 0x0   | MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT
 *  [3]    | RW     | 0x0   | MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT
 *  [31:4] | R      | 0x0   | MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4
 *
 */
/*
 * Field : RXQ_WEGT
 *
 * Receive Queue Weight.
 *
 * This field indicates the weight assigned to the Rx Queue 0. The weight is used
 * as the number of continuous PBL requests or contiguous packets (depending on the
 * RXQ_PKT_ARBIT) allocated to the queue in one arbitration cycle.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register
 * field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_LSB	      0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register field.
 */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_MSB	      2
/* The width in bits of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_WIDTH      3
/* The mask used to set the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register field value. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_SET_MSK    0x00000007
/* The mask used to clear the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register field value. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_CLR_MSK    0xfffffff8
/* The reset value of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT field value from a register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_GET(value) (((value)&0x00000007) >> 0)
/* Produces a MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : RXQ_PKT_ARBIT
 *
 * Receive Queue Packet Arbitration Control.
 *
 * When this bit is set, the MTL enables the packet-level arbitration. When this
 * bit is reset, the MTL enables the PBL based arbitration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register
 * field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_LSB	   3
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register
 * field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_MSB	   3
/* The width in bits of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_WIDTH	   1
/* The mask used to set the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register field value. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_SET_MSK	   0x00000008
/* The mask used to clear the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register field value. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_CLR_MSK	   0xfffffff7
/* The reset value of the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT field value from a register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_GET(value) (((value)&0x00000008) >> 3)
/* Produces a MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : Reserved_31_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register
 * field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_LSB	   4
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register
 * field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_MSB	   31
/* The width in bits of the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_WIDTH	   28
/* The mask used to set the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register field value. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_SET_MSK	   0xfffffff0
/* The mask used to clear the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register field value. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_CLR_MSK	   0x0000000f
/* The reset value of the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register field. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 field value from a register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_GET(value) (((value)&0xfffffff0) >> 4)
/* Produces a MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4_SET(value) (((value) << 4) & 0xfffffff0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_RXQx_CONTROL.
 */
struct MTL_TCQx_MTL_RXQx_CONTROL_s {
	volatile uint32_t RXQ_WEGT : 3;		    /* MTL_TCQx_MTL_RXQx_CONTROL_RXQ_WEGT */
	volatile uint32_t RXQ_PKT_ARBIT : 1;	    /* MTL_TCQx_MTL_RXQx_CONTROL_RXQ_PKT_ARBIT */
	const volatile uint32_t Reserved_31_4 : 28; /* MTL_TCQx_MTL_RXQx_CONTROL_RESERVED_31_4 */
};

/* The typedef declaration for register MTL_TCQx_MTL_RXQx_CONTROL. */
typedef struct MTL_TCQx_MTL_RXQx_CONTROL_s MTL_TCQx_MTL_RXQx_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_RXQx_CONTROL register. */
#define MTL_TCQx_MTL_RXQx_CONTROL_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_RXQx_CONTROL register from the beginning of the component. */
#define MTL_TCQx_MTL_RXQx_CONTROL_OFST	0x4c

/*
 * Register : MTL_RxQ0_Flow_Control
 *
 * This register controls the activation and de-activation threshold in the queue
 * for PAUSE/PFC flow control.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------
 *  [0]     | R      | 0x0   | MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0
 *  [5:1]   | RW     | 0x0   | MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA
 *  [16:6]  | R      | 0x0   | MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y
 *  [21:17] | RW     | 0x0   | MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD
 *  [31:22] | R      | 0x0   | MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y
 *
 */
/*
 * Field : Reserved_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0
 * register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_LSB	     0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 register
 * field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_MSB	     0
/* The width in bits of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_WIDTH	     1
/* The mask used to set the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_SET_MSK    0x00000001
/* The mask used to clear the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_CLR_MSK    0xfffffffe
/* The reset value of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_RESET	     0x0
/* Extracts the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 field value from a register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : RFA
 *
 * Threshold for activating Flow Control.
 *
 * These bits control the threshold (fill-level of RxQ0) at which the flow control
 * is activated
 *
 * * 6'b000000: RQS value minus 1 KB, that is, FULL - 1024 bytes
 *
 * * 6'b000001: RQS value minus 1.5 KB, that is, FULL - 1536 bytes
 *
 * * 6'b000010: RQS value minus 2 KB, that is, FULL - 2048 bytes.
 *
 * * ...
 *
 * * 6'b111111: RQS value minus 32.5 KB, that is, FULL - 33280 bytes
 *
 * The flow control is triggered when EHFC=1 and the queue size (RQS value in
 * MTL_RxQ0_Operation Mode register) is equal to or more than 4KB. Note that the
 * value to be programmed in RFA should be such that the threshold is positive
 * number.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register
 * field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_LSB	      1
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register field.
 */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_MSB	      5
/* The width in bits of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_WIDTH      5
/* The mask used to set the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_SET_MSK    0x0000003e
/* The mask used to clear the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_CLR_MSK    0xffffffc1
/* The reset value of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA field value from a register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_GET(value) (((value)&0x0000003e) >> 1)
/* Produces a MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA_SET(value) (((value) << 1) & 0x0000003e)

/*
 * Field : Reserved_16_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y
 * register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_LSB	6
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y
 * register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_MSB	16
/* The width in bits of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_WIDTH	11
/* The mask used to set the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_SET_MSK	0x0001ffc0
/* The mask used to clear the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_CLR_MSK	0xfffe003f
/* The reset value of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y field value from a register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_GET(value) (((value)&0x0001ffc0) >> 6)
/* Produces a MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y_SET(value) (((value) << 6) & 0x0001ffc0)

/*
 * Field : RFD
 *
 * Threshold for deactivating Flow Control.
 *
 * These bits control the threshold (fill-level of RxQ0) at which the flow control
 * is de-asserted once it is activated.
 *
 * * 6'b000000: RQS value minus 1 KB, that is, FULL - 1024 bytes
 *
 * * 6'b000001: RQS value minus 1.5 KB, that is, FULL - 1536 bytes
 *
 * * 6'b000010: RQS value minus 2 KB, that is, FULL - 2048 bytes.
 *
 * * ...
 *
 * * 6'b111111: RQS value minus 32.5 KB, that is, FULL - 33280 bytes
 *
 * The de-assertion is effective only after flow control is asserted as per the
 * setting of RFA field. Note that the value to be programmed should be such that
 * the threshold is positive number.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register
 * field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_LSB	      17
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register field.
 */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_MSB	      21
/* The width in bits of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_WIDTH      5
/* The mask used to set the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_SET_MSK    0x003e0000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_CLR_MSK    0xffc1ffff
/* The reset value of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_RESET      0x0
/* Extracts the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD field value from a register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_GET(value) (((value)&0x003e0000) >> 17)
/* Produces a MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD_SET(value) (((value) << 17) & 0x003e0000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y
 * register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_LSB	22
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y
 * register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_MSB	31
/* The width in bits of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_WIDTH	10
/* The mask used to set the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_SET_MSK	0xffc00000
/* The mask used to clear the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y register field value. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_CLR_MSK	0x003fffff
/* The reset value of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y register field. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_RESET	0x0
/* Extracts the MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y field value from a register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_GET(value) (((value)&0xffc00000) >> 22)
/* Produces a MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y register field value suitable for setting
 * the register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y_SET(value) (((value) << 22) & 0xffc00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_RXQx_FLOW_CONTROL.
 */
struct MTL_TCQx_MTL_RXQx_FLOW_CONTROL_s {
	const volatile uint32_t Reserved_0 : 1; /* MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_0 */
	volatile uint32_t RFA : 5;		/* MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFA */
	const volatile uint32_t
		Reserved_16_y : 11; /* MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_16_Y */
	volatile uint32_t RFD : 5;  /* MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RFD */
	const volatile uint32_t
		Reserved_31_y : 10; /* MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESERVED_31_Y */
};

/* The typedef declaration for register MTL_TCQx_MTL_RXQx_FLOW_CONTROL. */
typedef struct MTL_TCQx_MTL_RXQx_FLOW_CONTROL_s MTL_TCQx_MTL_RXQx_FLOW_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL register. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_RXQx_FLOW_CONTROL register from the beginning of the
 * component. */
#define MTL_TCQx_MTL_RXQx_FLOW_CONTROL_OFST  0x50

/*
 * Register : MTL_Q0_Interrupt_Enable
 *
 * This register contains the interrupt enable bits for Traffic class/Queue 0.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------
 *  [0]     | RW     | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE
 *  [1]     | RW     | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE
 *  [15:2]  | R      | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2
 *  [16]    | RW     | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE
 *  [31:17] | R      | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17
 *
 */
/*
 * Field : TXUIE
 *
 * Transmit Queue Underflow Interrupt Enable.
 *
 * * 1: Transmit Queue Underflow interrupt is enabled.
 *
 * * 0: Transmit Queue Underflow interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_LSB	  0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_MSB	  0
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_WIDTH	  1
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_SET_MSK	  0x00000001
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_CLR_MSK	  0xfffffffe
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : ABPSIE
 *
 * Average Bits Per Slot Interrupt Enable.
 *
 * When this bit is set, average bits per slot interrupt is enabled for Traffic
 * Class 0. An interrupt is generated when the average bits per slot status is
 * updated for this traffic class.
 *
 * This bit is reserved and RO when the number of traffic classes selected is less
 * than 0.
 *
 * This field in the corresponding Queues 8 - 15 registers is always reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_LSB	   1
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_MSB	   1
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_WIDTH	   1
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_SET_MSK	   0x00000002
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_CLR_MSK	   0xfffffffd
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_15_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_LSB	  2
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_MSB	  15
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_WIDTH	  14
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_SET_MSK	  0x0000fffc
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 register field value.
 */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_CLR_MSK	  0xffff0003
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_GET(value) (((value)&0x0000fffc) >> 2)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2_SET(value) (((value) << 2) & 0x0000fffc)

/*
 * Field : RXOIE
 *
 * Receive Queue Overflow Interrupt Enable.
 *
 * * 1: Receive Queue Overflow interrupt is enabled.
 *
 * * 0: Receive Queue Overflow interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_LSB	  16
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_MSB	  16
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_WIDTH	  1
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_SET_MSK	  0x00010000
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_CLR_MSK	  0xfffeffff
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_GET(value) (((value)&0x00010000) >> 16)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : Reserved_31_17
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_LSB	   17
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_MSB	   31
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_WIDTH	   15
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_SET_MSK	   0xfffe0000
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 register field value.
 */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_CLR_MSK	   0x0001ffff
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_GET(value) (((value)&0xfffe0000) >> 17)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17_SET(value) (((value) << 17) & 0xfffe0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE.
 */
struct MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_s {
	volatile uint32_t TXUIE : 1;  /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_TXUIE */
	volatile uint32_t ABPSIE : 1; /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_ABPSIE */
	const volatile uint32_t
		Reserved_15_2 : 14;  /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_15_2 */
	volatile uint32_t RXOIE : 1; /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RXOIE */
	const volatile uint32_t
		Reserved_31_17 : 15; /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESERVED_31_17 */
};

/* The typedef declaration for register MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE. */
typedef struct MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_s MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE register from the beginning of the
 * component. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_OFST  0x70

/*
 * Register : MTL_Q0_Interrupt_Status
 *
 * This register contains the interrupt status bits for Traffic class/Queue 0.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------
 *  [0]     | RW     | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS
 *  [1]     | RW     | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS
 *  [15:2]  | R      | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2
 *  [16]    | RW     | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS
 *  [31:17] | R      | 0x0   | MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17
 *
 */
/*
 * Field : TXUNFIS
 *
 * Transmit Queue Underflow Interrupt Status.
 *
 * This bit indicates that the Transmit Queue had an Underflow during packet
 * transmission. Transmission is suspended and an Underflow Error TDES3[2] is set.
 * This bit is cleared when the application writes a 1 to this bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_LSB	    0
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_MSB	    0
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_WIDTH	    1
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_SET_MSK    0x00000001
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_CLR_MSK    0xfffffffe
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_RESET	    0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : ABPSIS
 *
 * Average Bits Per Slot Interrupt Status.
 *
 * When set, this bit indicates that the MAC has updated the ABS value for this
 * traffic class. This bit is cleared when the application writes a 1 to this bit.
 *
 * This bit is reserved and RO when the number of traffic classes selected is less
 * than 0.
 *
 * This field in corresponding Queues 8 - 15 registers is reserved and RO.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_LSB	   1
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_MSB	   1
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_WIDTH	   1
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_SET_MSK	   0x00000002
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_CLR_MSK	   0xfffffffd
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_15_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_LSB	  2
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_MSB	  15
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_WIDTH	  14
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_SET_MSK	  0x0000fffc
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 register field value.
 */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_CLR_MSK	  0xffff0003
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_RESET	  0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_GET(value) (((value)&0x0000fffc) >> 2)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2_SET(value) (((value) << 2) & 0x0000fffc)

/*
 * Field : RXOVFIS
 *
 * Receive Queue Overflow Interrupt Status.
 *
 * This bit indicates that the Receive Queue had an Overflow during packet
 * reception. If partial packet is transferred to the application, the overflow
 * status is set in the corresponding Rx status. This bit is cleared when the
 * application writes a 1 to this bit.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_LSB	    16
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register
 * field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_MSB	    16
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_WIDTH	    1
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_SET_MSK    0x00010000
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_CLR_MSK    0xfffeffff
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_RESET	    0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS register field value suitable for setting the
 * register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : Reserved_31_17
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_LSB	   17
/* The Most Significant Bit (MSB) position of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17
 * register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_MSB	   31
/* The width in bits of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_WIDTH	   15
/* The mask used to set the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 register field value. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_SET_MSK	   0xfffe0000
/* The mask used to clear the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 register field value.
 */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_CLR_MSK	   0x0001ffff
/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 register field. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_RESET	   0x0
/* Extracts the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 field value from a register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_GET(value) (((value)&0xfffe0000) >> 17)
/* Produces a MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 register field value suitable for
 * setting the register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17_SET(value) (((value) << 17) & 0xfffe0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register MTL_TCQx_MTL_Q0_INTERRUPT_STATUS.
 */
struct MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_s {
	volatile uint32_t TXUNFIS : 1; /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_TXUNFIS */
	volatile uint32_t ABPSIS : 1;  /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_ABPSIS */
	const volatile uint32_t
		Reserved_15_2 : 14;    /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_15_2 */
	volatile uint32_t RXOVFIS : 1; /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RXOVFIS */
	const volatile uint32_t
		Reserved_31_17 : 15; /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESERVED_31_17 */
};

/* The typedef declaration for register MTL_TCQx_MTL_Q0_INTERRUPT_STATUS. */
typedef struct MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_s MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS register. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_RESET 0x00000000
/* The byte offset of the MTL_TCQx_MTL_Q0_INTERRUPT_STATUS register from the beginning of the
 * component. */
#define MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_OFST  0x74

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register group MTL_TCQx.
 */
struct MTL_TCQx_s {
	volatile MTL_TCQx_MTL_TXQx_OPERATION_MODE_t
		MTL_TxQ0_Operation_Mode; /* MTL_TCQx_MTL_TXQx_OPERATION_MODE */
	volatile MTL_TCQx_MTL_TXQx_UNDERFLOW_t MTL_TxQ0_Underflow; /* MTL_TCQx_MTL_TXQx_UNDERFLOW */
	volatile MTL_TCQx_MTL_TXQx_DEBUG_t MTL_TxQ0_Debug;	   /* MTL_TCQx_MTL_TXQx_DEBUG */
	volatile uint32_t _pad_0xc_0xf;				   /* *UNDEFINED* */
	volatile MTL_TCQx_MTC_TCx_ETS_CONTROL_t
		MTC_TCx_ETS_Control; /* MTL_TCQx_MTC_TCx_ETS_CONTROL */
	volatile MTL_TCQx_MTC_TCx_ETS_STATUS_t MTC_TCx_ETS_Status; /* MTL_TCQx_MTC_TCx_ETS_STATUS */
	volatile MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT_t
		MTC_TCx_Quantum_Weight;	     /* MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT */
	volatile uint32_t _pad_0x1c_0x3f[9]; /* *UNDEFINED* */
	volatile MTL_TCQx_MTL_RXQx_OPERATION_MODE_t
		MTL_RxQ0_Operation_Mode; /* MTL_TCQx_MTL_RXQx_OPERATION_MODE */
	volatile MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT_t
		MTL_RxQ0_Missed_Pkt_Overflow_Cnt; /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT */
	volatile MTL_TCQx_MTL_RXQx_DEBUG_t MTL_RxQ0_Debug;     /* MTL_TCQx_MTL_RXQx_DEBUG */
	volatile MTL_TCQx_MTL_RXQx_CONTROL_t MTL_RxQ0_Control; /* MTL_TCQx_MTL_RXQx_CONTROL */
	volatile MTL_TCQx_MTL_RXQx_FLOW_CONTROL_t
		MTL_RxQ0_Flow_Control;	     /* MTL_TCQx_MTL_RXQx_FLOW_CONTROL */
	volatile uint32_t _pad_0x54_0x6f[7]; /* *UNDEFINED* */
	volatile MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE_t
		MTL_Q0_Interrupt_Enable; /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE */
	volatile MTL_TCQx_MTL_Q0_INTERRUPT_STATUS_t
		MTL_Q0_Interrupt_Status;     /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS */
	volatile uint32_t _pad_0x78_0x80[2]; /* *UNDEFINED* */
};

/* The typedef declaration for register group MTL_TCQx. */
typedef struct MTL_TCQx_s MTL_TCQx_t;
/* The struct declaration for the raw register contents of register group MTL_TCQx. */
struct MTL_TCQx_raw_s {
	volatile uint32_t MTL_TxQ0_Operation_Mode; /* MTL_TCQx_MTL_TXQx_OPERATION_MODE */
	volatile uint32_t MTL_TxQ0_Underflow;	   /* MTL_TCQx_MTL_TXQx_UNDERFLOW */
	volatile uint32_t MTL_TxQ0_Debug;	   /* MTL_TCQx_MTL_TXQx_DEBUG */
	volatile uint32_t _pad_0xc_0xf;		   /* *UNDEFINED* */
	volatile uint32_t MTC_TCx_ETS_Control;	   /* MTL_TCQx_MTC_TCx_ETS_CONTROL */
	volatile uint32_t MTC_TCx_ETS_Status;	   /* MTL_TCQx_MTC_TCx_ETS_STATUS */
	volatile uint32_t MTC_TCx_Quantum_Weight;  /* MTL_TCQx_MTC_TCx_QUANTUM_WEIGHT */
	volatile uint32_t _pad_0x1c_0x3f[9];	   /* *UNDEFINED* */
	volatile uint32_t MTL_RxQ0_Operation_Mode; /* MTL_TCQx_MTL_RXQx_OPERATION_MODE */
	volatile uint32_t
		MTL_RxQ0_Missed_Pkt_Overflow_Cnt;  /* MTL_TCQx_MTL_RXQx_MISSED_PKT_OVERFLOW_CNT */
	volatile uint32_t MTL_RxQ0_Debug;	   /* MTL_TCQx_MTL_RXQx_DEBUG */
	volatile uint32_t MTL_RxQ0_Control;	   /* MTL_TCQx_MTL_RXQx_CONTROL */
	volatile uint32_t MTL_RxQ0_Flow_Control;   /* MTL_TCQx_MTL_RXQx_FLOW_CONTROL */
	volatile uint32_t _pad_0x54_0x6f[7];	   /* *UNDEFINED* */
	volatile uint32_t MTL_Q0_Interrupt_Enable; /* MTL_TCQx_MTL_Q0_INTERRUPT_ENABLE */
	volatile uint32_t MTL_Q0_Interrupt_Status; /* MTL_TCQx_MTL_Q0_INTERRUPT_STATUS */
	volatile uint32_t _pad_0x78_0x80[2];	   /* *UNDEFINED* */
};

/* The typedef declaration for the raw register contents of register group MTL_TCQx. */
typedef struct MTL_TCQx_raw_s MTL_TCQx_raw_t;
#endif /* __ASSEMBLY__ */

/*
 * Component : DMA
 * DMA Common/General Registers.
 *
 */
/*
 * Register : DMA_Mode
 *
 * The Bus Mode register establishes the bus operating modes for the DMA.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_MODE_SWR
 *  [3:1]   | R      | 0x0   | DMA_MODE_RESERVED_3_1
 *  [4]     | RW     | 0x0   | DMA_MODE_TDRP
 *  [5]     | R      | 0x0   | DMA_MODE_RESERVED_TMRP
 *  [7:6]   | R      | 0x0   | DMA_MODE_RESERVED_7_6
 *  [8]     | RW     | 0x0   | DMA_MODE_DSPW
 *  [11:9]  | R      | 0x0   | DMA_MODE_RESERVED_11_9
 *  [13:12] | RW     | 0x0   | DMA_MODE_INTM
 *  [31:14] | R      | 0x0   | DMA_MODE_RESERVED_31_14
 *
 */
/*
 * Field : SWR
 *
 * Software Reset.
 *
 * When this bit is set, the MAC and the DMA controller reset the logic and all
 * internal registers of the DMA, MTL, and MAC. This bit is automatically cleared
 * after the reset operation is complete in all DWC_xgmac clock domains. Before
 * reprogramming any DWC_xgmac register, read a value of 0 from this bit.
 *
 * Note:  The reset operation is complete only when all resets in all active clock
 * domains are de-asserted. Therefore, it is essential that all PHY inputs clocks
 * (applicable for the selected PHY interface) are present for software reset
 * completion. The time to complete the software reset operation depends on the
 * frequency of the slowest active clock.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_SWR register field. */
#define DMA_MODE_SWR_LSB	0
/* The Most Significant Bit (MSB) position of the DMA_MODE_SWR register field. */
#define DMA_MODE_SWR_MSB	0
/* The width in bits of the DMA_MODE_SWR register field. */
#define DMA_MODE_SWR_WIDTH	1
/* The mask used to set the DMA_MODE_SWR register field value. */
#define DMA_MODE_SWR_SET_MSK	0x00000001
/* The mask used to clear the DMA_MODE_SWR register field value. */
#define DMA_MODE_SWR_CLR_MSK	0xfffffffe
/* The reset value of the DMA_MODE_SWR register field. */
#define DMA_MODE_SWR_RESET	0x0
/* Extracts the DMA_MODE_SWR field value from a register. */
#define DMA_MODE_SWR_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_MODE_SWR register field value suitable for setting the register. */
#define DMA_MODE_SWR_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_RESERVED_3_1 register field. */
#define DMA_MODE_RESERVED_3_1_LSB	 1
/* The Most Significant Bit (MSB) position of the DMA_MODE_RESERVED_3_1 register field. */
#define DMA_MODE_RESERVED_3_1_MSB	 3
/* The width in bits of the DMA_MODE_RESERVED_3_1 register field. */
#define DMA_MODE_RESERVED_3_1_WIDTH	 3
/* The mask used to set the DMA_MODE_RESERVED_3_1 register field value. */
#define DMA_MODE_RESERVED_3_1_SET_MSK	 0x0000000e
/* The mask used to clear the DMA_MODE_RESERVED_3_1 register field value. */
#define DMA_MODE_RESERVED_3_1_CLR_MSK	 0xfffffff1
/* The reset value of the DMA_MODE_RESERVED_3_1 register field. */
#define DMA_MODE_RESERVED_3_1_RESET	 0x0
/* Extracts the DMA_MODE_RESERVED_3_1 field value from a register. */
#define DMA_MODE_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_MODE_RESERVED_3_1 register field value suitable for setting the register. */
#define DMA_MODE_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : TDRP
 *
 * Tx Descriptor Read Priority.
 *
 * This bit controls the arbitration priority of descriptor fetches from the local
 * cache when simultaneous requests are generated from RxDMA and TxDMA channels.
 *
 * By default, when this bit is 0, the RxDMA requests get higher priority.
 *
 * When this bit is set to 1, TxDMA descriptor fetches are serviced first by the
 * arbiter before the RxDMA requests.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_TDRP register field. */
#define DMA_MODE_TDRP_LSB	 4
/* The Most Significant Bit (MSB) position of the DMA_MODE_TDRP register field. */
#define DMA_MODE_TDRP_MSB	 4
/* The width in bits of the DMA_MODE_TDRP register field. */
#define DMA_MODE_TDRP_WIDTH	 1
/* The mask used to set the DMA_MODE_TDRP register field value. */
#define DMA_MODE_TDRP_SET_MSK	 0x00000010
/* The mask used to clear the DMA_MODE_TDRP register field value. */
#define DMA_MODE_TDRP_CLR_MSK	 0xffffffef
/* The reset value of the DMA_MODE_TDRP register field. */
#define DMA_MODE_TDRP_RESET	 0x0
/* Extracts the DMA_MODE_TDRP field value from a register. */
#define DMA_MODE_TDRP_GET(value) (((value)&0x00000010) >> 4)
/* Produces a DMA_MODE_TDRP register field value suitable for setting the register. */
#define DMA_MODE_TDRP_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Reserved_TMRP
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_RESERVED_TMRP register field. */
#define DMA_MODE_RESERVED_TMRP_LSB	  5
/* The Most Significant Bit (MSB) position of the DMA_MODE_RESERVED_TMRP register field. */
#define DMA_MODE_RESERVED_TMRP_MSB	  5
/* The width in bits of the DMA_MODE_RESERVED_TMRP register field. */
#define DMA_MODE_RESERVED_TMRP_WIDTH	  1
/* The mask used to set the DMA_MODE_RESERVED_TMRP register field value. */
#define DMA_MODE_RESERVED_TMRP_SET_MSK	  0x00000020
/* The mask used to clear the DMA_MODE_RESERVED_TMRP register field value. */
#define DMA_MODE_RESERVED_TMRP_CLR_MSK	  0xffffffdf
/* The reset value of the DMA_MODE_RESERVED_TMRP register field. */
#define DMA_MODE_RESERVED_TMRP_RESET	  0x0
/* Extracts the DMA_MODE_RESERVED_TMRP field value from a register. */
#define DMA_MODE_RESERVED_TMRP_GET(value) (((value)&0x00000020) >> 5)
/* Produces a DMA_MODE_RESERVED_TMRP register field value suitable for setting the register. */
#define DMA_MODE_RESERVED_TMRP_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_RESERVED_7_6 register field. */
#define DMA_MODE_RESERVED_7_6_LSB	 6
/* The Most Significant Bit (MSB) position of the DMA_MODE_RESERVED_7_6 register field. */
#define DMA_MODE_RESERVED_7_6_MSB	 7
/* The width in bits of the DMA_MODE_RESERVED_7_6 register field. */
#define DMA_MODE_RESERVED_7_6_WIDTH	 2
/* The mask used to set the DMA_MODE_RESERVED_7_6 register field value. */
#define DMA_MODE_RESERVED_7_6_SET_MSK	 0x000000c0
/* The mask used to clear the DMA_MODE_RESERVED_7_6 register field value. */
#define DMA_MODE_RESERVED_7_6_CLR_MSK	 0xffffff3f
/* The reset value of the DMA_MODE_RESERVED_7_6 register field. */
#define DMA_MODE_RESERVED_7_6_RESET	 0x0
/* Extracts the DMA_MODE_RESERVED_7_6 field value from a register. */
#define DMA_MODE_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a DMA_MODE_RESERVED_7_6 register field value suitable for setting the register. */
#define DMA_MODE_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : DSPW
 *
 * Descriptor Posted Write.
 *
 * * 0: By default, all Rx DMA descriptor writes are non-posted and any Rx
 *   interrupt generation mechanism can be used, that is, Descriptor IOC, Watchdog
 *   timer, Byte Counter based or any combination of these.
 *
 * * 1: All Rx DMA data and descriptor writes are posted and Descriptor IOC based
 *   Rx interrupt generation does not function properly and must not be used. Only
 *   Watchdog timer, Byte Counter based or any combination of these Rx interrupt
 *   generation mechanisms must be used. The Tx/Rx DMA Descriptor IOC based Tx/Rx
 *   interrupt generation mechanism does not function properly and must not be
 *   used.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_DSPW register field. */
#define DMA_MODE_DSPW_LSB	 8
/* The Most Significant Bit (MSB) position of the DMA_MODE_DSPW register field. */
#define DMA_MODE_DSPW_MSB	 8
/* The width in bits of the DMA_MODE_DSPW register field. */
#define DMA_MODE_DSPW_WIDTH	 1
/* The mask used to set the DMA_MODE_DSPW register field value. */
#define DMA_MODE_DSPW_SET_MSK	 0x00000100
/* The mask used to clear the DMA_MODE_DSPW register field value. */
#define DMA_MODE_DSPW_CLR_MSK	 0xfffffeff
/* The reset value of the DMA_MODE_DSPW register field. */
#define DMA_MODE_DSPW_RESET	 0x0
/* Extracts the DMA_MODE_DSPW field value from a register. */
#define DMA_MODE_DSPW_GET(value) (((value)&0x00000100) >> 8)
/* Produces a DMA_MODE_DSPW register field value suitable for setting the register. */
#define DMA_MODE_DSPW_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : Reserved_11_9
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_RESERVED_11_9 register field. */
#define DMA_MODE_RESERVED_11_9_LSB	  9
/* The Most Significant Bit (MSB) position of the DMA_MODE_RESERVED_11_9 register field. */
#define DMA_MODE_RESERVED_11_9_MSB	  11
/* The width in bits of the DMA_MODE_RESERVED_11_9 register field. */
#define DMA_MODE_RESERVED_11_9_WIDTH	  3
/* The mask used to set the DMA_MODE_RESERVED_11_9 register field value. */
#define DMA_MODE_RESERVED_11_9_SET_MSK	  0x00000e00
/* The mask used to clear the DMA_MODE_RESERVED_11_9 register field value. */
#define DMA_MODE_RESERVED_11_9_CLR_MSK	  0xfffff1ff
/* The reset value of the DMA_MODE_RESERVED_11_9 register field. */
#define DMA_MODE_RESERVED_11_9_RESET	  0x0
/* Extracts the DMA_MODE_RESERVED_11_9 field value from a register. */
#define DMA_MODE_RESERVED_11_9_GET(value) (((value)&0x00000e00) >> 9)
/* Produces a DMA_MODE_RESERVED_11_9 register field value suitable for setting the register. */
#define DMA_MODE_RESERVED_11_9_SET(value) (((value) << 9) & 0x00000e00)

/*
 * Field : INTM
 *
 * Interrupt Mode.
 *
 * This field controls the behavior of the interrupt signal (sbd_intr_o,
 * sbd_perch_tx_intr_o, sbd_perch_rx_intr_o) outputs for packet transfer completion
 * events in TxDMA and RxDMA.
 *
 * * 00: sbd_perch_* are pulse signals for each completion events. sbd_intr_o is
 *   also asserted and cleared only when software clears the corresponding RI/TI
 *   status bits.
 *
 * * 01: sbd_perch_* are level signals asserted on the corresponding event and de-
 *   asserted when the software clears the corresponding RI/TI status bits. The
 *   sbd_intr_o is not asserted for these packet transfer completion events.
 *
 * * 10: sbd_perch_* are level signals asserted on the corresponding event and de-
 *   asserted when the software clears the corresponding RI/TI status bits.
 *   However, the signal is asserted again if the same event occurred again before
 *   it was cleared. The sbd_intr_o is not asserted for these packet transfer
 *   completion events.
 *
 * * 11: Reserved
 *
 * For more details see Table, "DWC_xgmac Transfer Complete Interrupt Behavior"
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_INTM register field. */
#define DMA_MODE_INTM_LSB	 12
/* The Most Significant Bit (MSB) position of the DMA_MODE_INTM register field. */
#define DMA_MODE_INTM_MSB	 13
/* The width in bits of the DMA_MODE_INTM register field. */
#define DMA_MODE_INTM_WIDTH	 2
/* The mask used to set the DMA_MODE_INTM register field value. */
#define DMA_MODE_INTM_SET_MSK	 0x00003000
/* The mask used to clear the DMA_MODE_INTM register field value. */
#define DMA_MODE_INTM_CLR_MSK	 0xffffcfff
/* The reset value of the DMA_MODE_INTM register field. */
#define DMA_MODE_INTM_RESET	 0x0
/* Extracts the DMA_MODE_INTM field value from a register. */
#define DMA_MODE_INTM_GET(value) (((value)&0x00003000) >> 12)
/* Produces a DMA_MODE_INTM register field value suitable for setting the register. */
#define DMA_MODE_INTM_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : Reserved_31_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_MODE_RESERVED_31_14 register field. */
#define DMA_MODE_RESERVED_31_14_LSB	   14
/* The Most Significant Bit (MSB) position of the DMA_MODE_RESERVED_31_14 register field. */
#define DMA_MODE_RESERVED_31_14_MSB	   31
/* The width in bits of the DMA_MODE_RESERVED_31_14 register field. */
#define DMA_MODE_RESERVED_31_14_WIDTH	   18
/* The mask used to set the DMA_MODE_RESERVED_31_14 register field value. */
#define DMA_MODE_RESERVED_31_14_SET_MSK	   0xffffc000
/* The mask used to clear the DMA_MODE_RESERVED_31_14 register field value. */
#define DMA_MODE_RESERVED_31_14_CLR_MSK	   0x00003fff
/* The reset value of the DMA_MODE_RESERVED_31_14 register field. */
#define DMA_MODE_RESERVED_31_14_RESET	   0x0
/* Extracts the DMA_MODE_RESERVED_31_14 field value from a register. */
#define DMA_MODE_RESERVED_31_14_GET(value) (((value)&0xffffc000) >> 14)
/* Produces a DMA_MODE_RESERVED_31_14 register field value suitable for setting the register. */
#define DMA_MODE_RESERVED_31_14_SET(value) (((value) << 14) & 0xffffc000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_MODE.
 */
struct DMA_MODE_s {
	volatile uint32_t SWR : 1;		     /* DMA_MODE_SWR */
	const volatile uint32_t Reserved_3_1 : 3;    /* DMA_MODE_RESERVED_3_1 */
	volatile uint32_t TDRP : 1;		     /* DMA_MODE_TDRP */
	const volatile uint32_t Reserved_TMRP : 1;   /* DMA_MODE_RESERVED_TMRP */
	const volatile uint32_t Reserved_7_6 : 2;    /* DMA_MODE_RESERVED_7_6 */
	volatile uint32_t DSPW : 1;		     /* DMA_MODE_DSPW */
	const volatile uint32_t Reserved_11_9 : 3;   /* DMA_MODE_RESERVED_11_9 */
	volatile uint32_t INTM : 2;		     /* DMA_MODE_INTM */
	const volatile uint32_t Reserved_31_14 : 18; /* DMA_MODE_RESERVED_31_14 */
};

/* The typedef declaration for register DMA_MODE. */
typedef struct DMA_MODE_s DMA_MODE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_MODE register. */
#define DMA_MODE_RESET 0x00000000
/* The byte offset of the DMA_MODE register from the beginning of the component. */
#define DMA_MODE_OFST  0x0

/*
 * Register : DMA_SysBus_Mode
 *
 * The System Bus mode register controls the behavior of the AXI master. It mainly
 * controls burst splitting and number of outstanding requests.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_SYSBUS_MODE_UNDEF
 *  [1]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN4
 *  [2]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN8
 *  [3]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN16
 *  [4]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN32
 *  [5]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN64
 *  [6]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN128
 *  [7]     | RW     | 0x0   | DMA_SYSBUS_MODE_BLEN256
 *  [9:8]   | R      | 0x0   | DMA_SYSBUS_MODE_RESERVED_9_8
 *  [10]    | RW     | 0x0   | DMA_SYSBUS_MODE_AALE
 *  [11]    | RW     | 0x0   | DMA_SYSBUS_MODE_EAME
 *  [12]    | RW     | 0x0   | DMA_SYSBUS_MODE_AAL
 *  [13]    | RW     | 0x0   | DMA_SYSBUS_MODE_ONEKBBE
 *  [14]    | RW     | 0x0   | DMA_SYSBUS_MODE_LPI_XIT_PKT
 *  [15]    | RW     | 0x0   | DMA_SYSBUS_MODE_EN_LPI
 *  [20:16] | RW     | 0x1   | DMA_SYSBUS_MODE_RD_OSR_LMT
 *  [23:21] | R      | 0x0   | DMA_SYSBUS_MODE_RESERVED_23_22
 *  [28:24] | RW     | 0x1   | DMA_SYSBUS_MODE_WR_OSR_LMT
 *  [31:29] | R      | 0x0   | DMA_SYSBUS_MODE_RESERVED_31_30
 *
 */
/*
 * Field : UNDEF
 *
 * AXI Undefined Burst Length.
 *
 * When this bit is set to 1, the AXI master can perform burst transfers that are
 * equal to or less than the maximum allowed burst length programmed in Bits[7:4].
 *
 * When this bit is set to 0, the AXI master performs one of the following burst
 * transfers:
 *
 * * Burst transfers of fixed burst lengths as indicated by the BLEN256, BLEN128,
 *   BLEN64, BLEN32, BLEN16, BLEN8, or BLEN4 field
 *
 * * Burst transfers of length 1
 *
 * When this bit is set and no BLEN bit is set, the AXI master performs bursts
 * transfers of any length upto 16.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_UNDEF register field. */
#define DMA_SYSBUS_MODE_UNDEF_LSB	 0
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_UNDEF register field. */
#define DMA_SYSBUS_MODE_UNDEF_MSB	 0
/* The width in bits of the DMA_SYSBUS_MODE_UNDEF register field. */
#define DMA_SYSBUS_MODE_UNDEF_WIDTH	 1
/* The mask used to set the DMA_SYSBUS_MODE_UNDEF register field value. */
#define DMA_SYSBUS_MODE_UNDEF_SET_MSK	 0x00000001
/* The mask used to clear the DMA_SYSBUS_MODE_UNDEF register field value. */
#define DMA_SYSBUS_MODE_UNDEF_CLR_MSK	 0xfffffffe
/* The reset value of the DMA_SYSBUS_MODE_UNDEF register field. */
#define DMA_SYSBUS_MODE_UNDEF_RESET	 0x0
/* Extracts the DMA_SYSBUS_MODE_UNDEF field value from a register. */
#define DMA_SYSBUS_MODE_UNDEF_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_SYSBUS_MODE_UNDEF register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_UNDEF_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : BLEN4
 *
 * AXI Burst Length 4.
 *
 * When this bit and the UNDEF bit is set to 0, the AXI master can select a burst
 * length of 4 on the AXI interface.
 *
 * When the UNDEF bit is set to 1, setting this bit has no effect.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN4 register field. */
#define DMA_SYSBUS_MODE_BLEN4_LSB	 1
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN4 register field. */
#define DMA_SYSBUS_MODE_BLEN4_MSB	 1
/* The width in bits of the DMA_SYSBUS_MODE_BLEN4 register field. */
#define DMA_SYSBUS_MODE_BLEN4_WIDTH	 1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN4 register field value. */
#define DMA_SYSBUS_MODE_BLEN4_SET_MSK	 0x00000002
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN4 register field value. */
#define DMA_SYSBUS_MODE_BLEN4_CLR_MSK	 0xfffffffd
/* The reset value of the DMA_SYSBUS_MODE_BLEN4 register field. */
#define DMA_SYSBUS_MODE_BLEN4_RESET	 0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN4 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN4_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_SYSBUS_MODE_BLEN4 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN4_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : BLEN8
 *
 * AXI Burst Length 8.
 *
 * When this bit and the UNDEF bit is set to 0, the AXI master can select a burst
 * length of 8 on the AXI interface.
 *
 * When the UNDEF bit is set to 1, setting this bit has no effect.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN8 register field. */
#define DMA_SYSBUS_MODE_BLEN8_LSB	 2
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN8 register field. */
#define DMA_SYSBUS_MODE_BLEN8_MSB	 2
/* The width in bits of the DMA_SYSBUS_MODE_BLEN8 register field. */
#define DMA_SYSBUS_MODE_BLEN8_WIDTH	 1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN8 register field value. */
#define DMA_SYSBUS_MODE_BLEN8_SET_MSK	 0x00000004
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN8 register field value. */
#define DMA_SYSBUS_MODE_BLEN8_CLR_MSK	 0xfffffffb
/* The reset value of the DMA_SYSBUS_MODE_BLEN8 register field. */
#define DMA_SYSBUS_MODE_BLEN8_RESET	 0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN8 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN8_GET(value) (((value)&0x00000004) >> 2)
/* Produces a DMA_SYSBUS_MODE_BLEN8 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN8_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : BLEN16
 *
 * AXI Burst Length 16.
 *
 * When this bit and the UNDEF bit is set to 0, the AXI master can select a burst
 * length of 16 on the AXI interface.
 *
 * When UNDEF is set to 1, this bit has no effect as the AXI master can always
 * select a burst length up to 16 on the AXI interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN16 register field. */
#define DMA_SYSBUS_MODE_BLEN16_LSB	  3
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN16 register field. */
#define DMA_SYSBUS_MODE_BLEN16_MSB	  3
/* The width in bits of the DMA_SYSBUS_MODE_BLEN16 register field. */
#define DMA_SYSBUS_MODE_BLEN16_WIDTH	  1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN16 register field value. */
#define DMA_SYSBUS_MODE_BLEN16_SET_MSK	  0x00000008
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN16 register field value. */
#define DMA_SYSBUS_MODE_BLEN16_CLR_MSK	  0xfffffff7
/* The reset value of the DMA_SYSBUS_MODE_BLEN16 register field. */
#define DMA_SYSBUS_MODE_BLEN16_RESET	  0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN16 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN16_GET(value) (((value)&0x00000008) >> 3)
/* Produces a DMA_SYSBUS_MODE_BLEN16 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN16_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : BLEN32
 *
 * AXI Burst Length 32.
 *
 * When this bit is set to 1, the AXI master can select a burst length of 32 on the
 * AXI interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN32 register field. */
#define DMA_SYSBUS_MODE_BLEN32_LSB	  4
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN32 register field. */
#define DMA_SYSBUS_MODE_BLEN32_MSB	  4
/* The width in bits of the DMA_SYSBUS_MODE_BLEN32 register field. */
#define DMA_SYSBUS_MODE_BLEN32_WIDTH	  1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN32 register field value. */
#define DMA_SYSBUS_MODE_BLEN32_SET_MSK	  0x00000010
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN32 register field value. */
#define DMA_SYSBUS_MODE_BLEN32_CLR_MSK	  0xffffffef
/* The reset value of the DMA_SYSBUS_MODE_BLEN32 register field. */
#define DMA_SYSBUS_MODE_BLEN32_RESET	  0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN32 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN32_GET(value) (((value)&0x00000010) >> 4)
/* Produces a DMA_SYSBUS_MODE_BLEN32 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN32_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : BLEN64
 *
 * AXI Burst Length 64.
 *
 * When this bit is set to 1, the AXI master can select a burst length of 64 on the
 * AXI interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN64 register field. */
#define DMA_SYSBUS_MODE_BLEN64_LSB	  5
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN64 register field. */
#define DMA_SYSBUS_MODE_BLEN64_MSB	  5
/* The width in bits of the DMA_SYSBUS_MODE_BLEN64 register field. */
#define DMA_SYSBUS_MODE_BLEN64_WIDTH	  1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN64 register field value. */
#define DMA_SYSBUS_MODE_BLEN64_SET_MSK	  0x00000020
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN64 register field value. */
#define DMA_SYSBUS_MODE_BLEN64_CLR_MSK	  0xffffffdf
/* The reset value of the DMA_SYSBUS_MODE_BLEN64 register field. */
#define DMA_SYSBUS_MODE_BLEN64_RESET	  0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN64 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN64_GET(value) (((value)&0x00000020) >> 5)
/* Produces a DMA_SYSBUS_MODE_BLEN64 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN64_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : BLEN128
 *
 * AXI Burst Length 128.
 *
 * When this bit is set to 1, the AXI master can select a burst length of 128 on
 * the AXI interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN128 register field. */
#define DMA_SYSBUS_MODE_BLEN128_LSB	   6
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN128 register field. */
#define DMA_SYSBUS_MODE_BLEN128_MSB	   6
/* The width in bits of the DMA_SYSBUS_MODE_BLEN128 register field. */
#define DMA_SYSBUS_MODE_BLEN128_WIDTH	   1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN128 register field value. */
#define DMA_SYSBUS_MODE_BLEN128_SET_MSK	   0x00000040
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN128 register field value. */
#define DMA_SYSBUS_MODE_BLEN128_CLR_MSK	   0xffffffbf
/* The reset value of the DMA_SYSBUS_MODE_BLEN128 register field. */
#define DMA_SYSBUS_MODE_BLEN128_RESET	   0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN128 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN128_GET(value) (((value)&0x00000040) >> 6)
/* Produces a DMA_SYSBUS_MODE_BLEN128 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN128_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : BLEN256
 *
 * AXI Burst Length 256.
 *
 * When this bit is set to 1, the AXI master can select a burst length of 256 on
 * the AXI interface.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_BLEN256 register field. */
#define DMA_SYSBUS_MODE_BLEN256_LSB	   7
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_BLEN256 register field. */
#define DMA_SYSBUS_MODE_BLEN256_MSB	   7
/* The width in bits of the DMA_SYSBUS_MODE_BLEN256 register field. */
#define DMA_SYSBUS_MODE_BLEN256_WIDTH	   1
/* The mask used to set the DMA_SYSBUS_MODE_BLEN256 register field value. */
#define DMA_SYSBUS_MODE_BLEN256_SET_MSK	   0x00000080
/* The mask used to clear the DMA_SYSBUS_MODE_BLEN256 register field value. */
#define DMA_SYSBUS_MODE_BLEN256_CLR_MSK	   0xffffff7f
/* The reset value of the DMA_SYSBUS_MODE_BLEN256 register field. */
#define DMA_SYSBUS_MODE_BLEN256_RESET	   0x0
/* Extracts the DMA_SYSBUS_MODE_BLEN256 field value from a register. */
#define DMA_SYSBUS_MODE_BLEN256_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_SYSBUS_MODE_BLEN256 register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_BLEN256_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : Reserved_9_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_RESERVED_9_8 register field. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_LSB	8
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_RESERVED_9_8 register field. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_MSB	9
/* The width in bits of the DMA_SYSBUS_MODE_RESERVED_9_8 register field. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_WIDTH	2
/* The mask used to set the DMA_SYSBUS_MODE_RESERVED_9_8 register field value. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_SET_MSK	0x00000300
/* The mask used to clear the DMA_SYSBUS_MODE_RESERVED_9_8 register field value. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_CLR_MSK	0xfffffcff
/* The reset value of the DMA_SYSBUS_MODE_RESERVED_9_8 register field. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_RESET	0x0
/* Extracts the DMA_SYSBUS_MODE_RESERVED_9_8 field value from a register. */
#define DMA_SYSBUS_MODE_RESERVED_9_8_GET(value) (((value)&0x00000300) >> 8)
/* Produces a DMA_SYSBUS_MODE_RESERVED_9_8 register field value suitable for setting the register.
 */
#define DMA_SYSBUS_MODE_RESERVED_9_8_SET(value) (((value) << 8) & 0x00000300)

/*
 * Field : AALE
 *
 * Automatic AXI LPI enable.
 *
 * When set to 1, enables the AXI master to enter into LPI state when there is no
 * activity in DWC_xgmac for number of system clock cycles programmed in the LPIEI
 * field of AXI_LPI_Entry_Interval register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_AALE register field. */
#define DMA_SYSBUS_MODE_AALE_LSB	10
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_AALE register field. */
#define DMA_SYSBUS_MODE_AALE_MSB	10
/* The width in bits of the DMA_SYSBUS_MODE_AALE register field. */
#define DMA_SYSBUS_MODE_AALE_WIDTH	1
/* The mask used to set the DMA_SYSBUS_MODE_AALE register field value. */
#define DMA_SYSBUS_MODE_AALE_SET_MSK	0x00000400
/* The mask used to clear the DMA_SYSBUS_MODE_AALE register field value. */
#define DMA_SYSBUS_MODE_AALE_CLR_MSK	0xfffffbff
/* The reset value of the DMA_SYSBUS_MODE_AALE register field. */
#define DMA_SYSBUS_MODE_AALE_RESET	0x0
/* Extracts the DMA_SYSBUS_MODE_AALE field value from a register. */
#define DMA_SYSBUS_MODE_AALE_GET(value) (((value)&0x00000400) >> 10)
/* Produces a DMA_SYSBUS_MODE_AALE register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_AALE_SET(value) (((value) << 10) & 0x00000400)

/*
 * Field : EAME
 *
 * Enhanced Address Mode Enable.
 *
 * When this bit is set to 1, the DMA master enables the enhanced address mode
 * (40-bit or 48-bit addressing mode). In this mode, the DMA engine uses either the
 * 40- or 48-bit address, depending on the configuration.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_EAME register field. */
#define DMA_SYSBUS_MODE_EAME_LSB	11
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_EAME register field. */
#define DMA_SYSBUS_MODE_EAME_MSB	11
/* The width in bits of the DMA_SYSBUS_MODE_EAME register field. */
#define DMA_SYSBUS_MODE_EAME_WIDTH	1
/* The mask used to set the DMA_SYSBUS_MODE_EAME register field value. */
#define DMA_SYSBUS_MODE_EAME_SET_MSK	0x00000800
/* The mask used to clear the DMA_SYSBUS_MODE_EAME register field value. */
#define DMA_SYSBUS_MODE_EAME_CLR_MSK	0xfffff7ff
/* The reset value of the DMA_SYSBUS_MODE_EAME register field. */
#define DMA_SYSBUS_MODE_EAME_RESET	0x0
/* Extracts the DMA_SYSBUS_MODE_EAME field value from a register. */
#define DMA_SYSBUS_MODE_EAME_GET(value) (((value)&0x00000800) >> 11)
/* Produces a DMA_SYSBUS_MODE_EAME register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_EAME_SET(value) (((value) << 11) & 0x00000800)

/*
 * Field : AAL
 *
 * Address-Aligned Beats.
 *
 * When this bit is set to 1, the AXI master performs address-aligned burst
 * transfers on Read and Write channels.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_AAL register field. */
#define DMA_SYSBUS_MODE_AAL_LSB	       12
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_AAL register field. */
#define DMA_SYSBUS_MODE_AAL_MSB	       12
/* The width in bits of the DMA_SYSBUS_MODE_AAL register field. */
#define DMA_SYSBUS_MODE_AAL_WIDTH      1
/* The mask used to set the DMA_SYSBUS_MODE_AAL register field value. */
#define DMA_SYSBUS_MODE_AAL_SET_MSK    0x00001000
/* The mask used to clear the DMA_SYSBUS_MODE_AAL register field value. */
#define DMA_SYSBUS_MODE_AAL_CLR_MSK    0xffffefff
/* The reset value of the DMA_SYSBUS_MODE_AAL register field. */
#define DMA_SYSBUS_MODE_AAL_RESET      0x0
/* Extracts the DMA_SYSBUS_MODE_AAL field value from a register. */
#define DMA_SYSBUS_MODE_AAL_GET(value) (((value)&0x00001000) >> 12)
/* Produces a DMA_SYSBUS_MODE_AAL register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_AAL_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : ONEKBBE
 *
 * 1 KB Boundary Crossing Enable for the AXI Master.
 *
 * * 1: The burst transfers performed by the AXI master do not cross 1 KB boundary.
 *
 * * 0: The burst transfers performed by the AXI master do not cross 4 KB boundary.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_ONEKBBE register field. */
#define DMA_SYSBUS_MODE_ONEKBBE_LSB	   13
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_ONEKBBE register field. */
#define DMA_SYSBUS_MODE_ONEKBBE_MSB	   13
/* The width in bits of the DMA_SYSBUS_MODE_ONEKBBE register field. */
#define DMA_SYSBUS_MODE_ONEKBBE_WIDTH	   1
/* The mask used to set the DMA_SYSBUS_MODE_ONEKBBE register field value. */
#define DMA_SYSBUS_MODE_ONEKBBE_SET_MSK	   0x00002000
/* The mask used to clear the DMA_SYSBUS_MODE_ONEKBBE register field value. */
#define DMA_SYSBUS_MODE_ONEKBBE_CLR_MSK	   0xffffdfff
/* The reset value of the DMA_SYSBUS_MODE_ONEKBBE register field. */
#define DMA_SYSBUS_MODE_ONEKBBE_RESET	   0x0
/* Extracts the DMA_SYSBUS_MODE_ONEKBBE field value from a register. */
#define DMA_SYSBUS_MODE_ONEKBBE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a DMA_SYSBUS_MODE_ONEKBBE register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_ONEKBBE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : LPI_XIT_PKT
 *
 * Unlock on Magic Packet or Remote Wake-Up Packet.
 *
 * * 1: Enables the AXI master to come out of the LPI mode only when the magic
 *   packet or remote wake-up packet is received.
 *
 * * 0: Enables the AXI master to come out of the LPI mode when any packet is
 *   received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_LPI_XIT_PKT register field. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_LSB	       14
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_LPI_XIT_PKT register field. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_MSB	       14
/* The width in bits of the DMA_SYSBUS_MODE_LPI_XIT_PKT register field. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_WIDTH      1
/* The mask used to set the DMA_SYSBUS_MODE_LPI_XIT_PKT register field value. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_SET_MSK    0x00004000
/* The mask used to clear the DMA_SYSBUS_MODE_LPI_XIT_PKT register field value. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_CLR_MSK    0xffffbfff
/* The reset value of the DMA_SYSBUS_MODE_LPI_XIT_PKT register field. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_RESET      0x0
/* Extracts the DMA_SYSBUS_MODE_LPI_XIT_PKT field value from a register. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_GET(value) (((value)&0x00004000) >> 14)
/* Produces a DMA_SYSBUS_MODE_LPI_XIT_PKT register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_LPI_XIT_PKT_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : EN_LPI
 *
 * Enable Low Power Interface (LPI).
 *
 * * 1: Enables the LPI mode supported by the AXI interface and accepts the LPI
 *   request from the AXI System Clock controller.
 *
 * * 0: Disables the LPI mode and always denies the LPI request from the AXI System
 *   Clock controller.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_EN_LPI register field. */
#define DMA_SYSBUS_MODE_EN_LPI_LSB	  15
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_EN_LPI register field. */
#define DMA_SYSBUS_MODE_EN_LPI_MSB	  15
/* The width in bits of the DMA_SYSBUS_MODE_EN_LPI register field. */
#define DMA_SYSBUS_MODE_EN_LPI_WIDTH	  1
/* The mask used to set the DMA_SYSBUS_MODE_EN_LPI register field value. */
#define DMA_SYSBUS_MODE_EN_LPI_SET_MSK	  0x00008000
/* The mask used to clear the DMA_SYSBUS_MODE_EN_LPI register field value. */
#define DMA_SYSBUS_MODE_EN_LPI_CLR_MSK	  0xffff7fff
/* The reset value of the DMA_SYSBUS_MODE_EN_LPI register field. */
#define DMA_SYSBUS_MODE_EN_LPI_RESET	  0x0
/* Extracts the DMA_SYSBUS_MODE_EN_LPI field value from a register. */
#define DMA_SYSBUS_MODE_EN_LPI_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_SYSBUS_MODE_EN_LPI register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_EN_LPI_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : RD_OSR_LMT
 *
 * AXI Maximum Read Outstanding Request Limit.
 *
 * This value limits the maximum outstanding request on the AXI read interface.
 * Maximum outstanding requests = RD_OSR_LMT + 1
 *
 * Note:
 *
 * * Bit 21 is reserved and RO if AXI Maximum Outstanding Read Requests selected
 *   are less than 64
 *
 * * Bit 20 is reserved and RO if AXI Maximum Outstanding Read Requests selected
 *   are less than 32
 *
 * * Bit 19 is reserved and RO if AXI Maximum Outstanding Read Requests selected
 *   are less than 16
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_RD_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_LSB	      16
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_RD_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_MSB	      20
/* The width in bits of the DMA_SYSBUS_MODE_RD_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_WIDTH      5
/* The mask used to set the DMA_SYSBUS_MODE_RD_OSR_LMT register field value. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_SET_MSK    0x001f0000
/* The mask used to clear the DMA_SYSBUS_MODE_RD_OSR_LMT register field value. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_CLR_MSK    0xffe0ffff
/* The reset value of the DMA_SYSBUS_MODE_RD_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_RESET      0x1
/* Extracts the DMA_SYSBUS_MODE_RD_OSR_LMT field value from a register. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_GET(value) (((value)&0x001f0000) >> 16)
/* Produces a DMA_SYSBUS_MODE_RD_OSR_LMT register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_RD_OSR_LMT_SET(value) (((value) << 16) & 0x001f0000)

/*
 * Field : Reserved_23_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_RESERVED_23_22 register field. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_LSB	  21
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_RESERVED_23_22 register field. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_MSB	  23
/* The width in bits of the DMA_SYSBUS_MODE_RESERVED_23_22 register field. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_WIDTH	  3
/* The mask used to set the DMA_SYSBUS_MODE_RESERVED_23_22 register field value. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_SET_MSK	  0x00e00000
/* The mask used to clear the DMA_SYSBUS_MODE_RESERVED_23_22 register field value. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_CLR_MSK	  0xff1fffff
/* The reset value of the DMA_SYSBUS_MODE_RESERVED_23_22 register field. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_RESET	  0x0
/* Extracts the DMA_SYSBUS_MODE_RESERVED_23_22 field value from a register. */
#define DMA_SYSBUS_MODE_RESERVED_23_22_GET(value) (((value)&0x00e00000) >> 21)
/* Produces a DMA_SYSBUS_MODE_RESERVED_23_22 register field value suitable for setting the register.
 */
#define DMA_SYSBUS_MODE_RESERVED_23_22_SET(value) (((value) << 21) & 0x00e00000)

/*
 * Field : WR_OSR_LMT
 *
 * AXI Maximum Write Outstanding Request Limit.
 *
 * This value limits the maximum outstanding request on the AXI write interface.
 * Maximum outstanding requests = WR_OSR_LMT + 1
 *
 * Note:
 *
 * * Bit 29 is reserved and RO if AXI Maximum Outstanding Write Requests selected
 *   are less than 64
 *
 * * Bit 28 is reserved and RO if AXI Maximum Outstanding Write Requests selected
 *   are less than 32
 *
 * * Bit 27 is reserved and RO if AXI Maximum Outstanding Write Requests selected
 *   are less than 16
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_WR_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_LSB	      24
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_WR_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_MSB	      28
/* The width in bits of the DMA_SYSBUS_MODE_WR_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_WIDTH      5
/* The mask used to set the DMA_SYSBUS_MODE_WR_OSR_LMT register field value. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_SET_MSK    0x1f000000
/* The mask used to clear the DMA_SYSBUS_MODE_WR_OSR_LMT register field value. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_CLR_MSK    0xe0ffffff
/* The reset value of the DMA_SYSBUS_MODE_WR_OSR_LMT register field. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_RESET      0x1
/* Extracts the DMA_SYSBUS_MODE_WR_OSR_LMT field value from a register. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_GET(value) (((value)&0x1f000000) >> 24)
/* Produces a DMA_SYSBUS_MODE_WR_OSR_LMT register field value suitable for setting the register. */
#define DMA_SYSBUS_MODE_WR_OSR_LMT_SET(value) (((value) << 24) & 0x1f000000)

/*
 * Field : Reserved_31_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_SYSBUS_MODE_RESERVED_31_30 register field. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_LSB	  29
/* The Most Significant Bit (MSB) position of the DMA_SYSBUS_MODE_RESERVED_31_30 register field. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_MSB	  31
/* The width in bits of the DMA_SYSBUS_MODE_RESERVED_31_30 register field. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_WIDTH	  3
/* The mask used to set the DMA_SYSBUS_MODE_RESERVED_31_30 register field value. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_SET_MSK	  0xe0000000
/* The mask used to clear the DMA_SYSBUS_MODE_RESERVED_31_30 register field value. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_CLR_MSK	  0x1fffffff
/* The reset value of the DMA_SYSBUS_MODE_RESERVED_31_30 register field. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_RESET	  0x0
/* Extracts the DMA_SYSBUS_MODE_RESERVED_31_30 field value from a register. */
#define DMA_SYSBUS_MODE_RESERVED_31_30_GET(value) (((value)&0xe0000000) >> 29)
/* Produces a DMA_SYSBUS_MODE_RESERVED_31_30 register field value suitable for setting the register.
 */
#define DMA_SYSBUS_MODE_RESERVED_31_30_SET(value) (((value) << 29) & 0xe0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_SYSBUS_MODE.
 */
struct DMA_SYSBUS_MODE_s {
	volatile uint32_t UNDEF : 1;		    /* DMA_SYSBUS_MODE_UNDEF */
	volatile uint32_t BLEN4 : 1;		    /* DMA_SYSBUS_MODE_BLEN4 */
	volatile uint32_t BLEN8 : 1;		    /* DMA_SYSBUS_MODE_BLEN8 */
	volatile uint32_t BLEN16 : 1;		    /* DMA_SYSBUS_MODE_BLEN16 */
	volatile uint32_t BLEN32 : 1;		    /* DMA_SYSBUS_MODE_BLEN32 */
	volatile uint32_t BLEN64 : 1;		    /* DMA_SYSBUS_MODE_BLEN64 */
	volatile uint32_t BLEN128 : 1;		    /* DMA_SYSBUS_MODE_BLEN128 */
	volatile uint32_t BLEN256 : 1;		    /* DMA_SYSBUS_MODE_BLEN256 */
	const volatile uint32_t Reserved_9_8 : 2;   /* DMA_SYSBUS_MODE_RESERVED_9_8 */
	volatile uint32_t AALE : 1;		    /* DMA_SYSBUS_MODE_AALE */
	volatile uint32_t EAME : 1;		    /* DMA_SYSBUS_MODE_EAME */
	volatile uint32_t AAL : 1;		    /* DMA_SYSBUS_MODE_AAL */
	volatile uint32_t ONEKBBE : 1;		    /* DMA_SYSBUS_MODE_ONEKBBE */
	volatile uint32_t LPI_XIT_PKT : 1;	    /* DMA_SYSBUS_MODE_LPI_XIT_PKT */
	volatile uint32_t EN_LPI : 1;		    /* DMA_SYSBUS_MODE_EN_LPI */
	volatile uint32_t RD_OSR_LMT : 5;	    /* DMA_SYSBUS_MODE_RD_OSR_LMT */
	const volatile uint32_t Reserved_23_22 : 3; /* DMA_SYSBUS_MODE_RESERVED_23_22 */
	volatile uint32_t WR_OSR_LMT : 5;	    /* DMA_SYSBUS_MODE_WR_OSR_LMT */
	const volatile uint32_t Reserved_31_30 : 3; /* DMA_SYSBUS_MODE_RESERVED_31_30 */
};

/* The typedef declaration for register DMA_SYSBUS_MODE. */
typedef struct DMA_SYSBUS_MODE_s DMA_SYSBUS_MODE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_SYSBUS_MODE register. */
#define DMA_SYSBUS_MODE_RESET 0x01010000
/* The byte offset of the DMA_SYSBUS_MODE register from the beginning of the component. */
#define DMA_SYSBUS_MODE_OFST  0x4

/*
 * Register : DMA_Interrupt_Status
 *
 * The application reads this Interrupt Status register during interrupt service
 * routine or polling to determine the interrupt status of DMA channels, MTL
 * queues, and the MAC.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:----------------------------------------------------------
 *  [0]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC0IS
 *  [1]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC1IS
 *  [2]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC2IS
 *  [3]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC3IS
 *  [4]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC4IS
 *  [5]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC5IS
 *  [6]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC6IS
 *  [7]     | R      | 0x0   | DMA_INTERRUPT_STATUS_DC7IS
 *  [15:8]  | R      | 0x0   | DMA_INTERRUPT_STATUS_DC15TC8IS
 *  [16]    | R      | 0x0   | DMA_INTERRUPT_STATUS_MTLIS
 *  [17]    | R      | 0x0   | DMA_INTERRUPT_STATUS_MACIS
 *  [31:18] | R      | 0x0   | DMA_INTERRUPT_STATUS_RESERVED_31_18
 *
 */
/*
 * Field : DC0IS
 *
 * DMA Channel 0 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 0. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 0 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC0IS register field. */
#define DMA_INTERRUPT_STATUS_DC0IS_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC0IS register field. */
#define DMA_INTERRUPT_STATUS_DC0IS_MSB	      0
/* The width in bits of the DMA_INTERRUPT_STATUS_DC0IS register field. */
#define DMA_INTERRUPT_STATUS_DC0IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC0IS register field value. */
#define DMA_INTERRUPT_STATUS_DC0IS_SET_MSK    0x00000001
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC0IS register field value. */
#define DMA_INTERRUPT_STATUS_DC0IS_CLR_MSK    0xfffffffe
/* The reset value of the DMA_INTERRUPT_STATUS_DC0IS register field. */
#define DMA_INTERRUPT_STATUS_DC0IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC0IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC0IS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_INTERRUPT_STATUS_DC0IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC0IS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : DC1IS
 *
 * DMA Channel 1 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 1. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 1 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC1IS register field. */
#define DMA_INTERRUPT_STATUS_DC1IS_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC1IS register field. */
#define DMA_INTERRUPT_STATUS_DC1IS_MSB	      1
/* The width in bits of the DMA_INTERRUPT_STATUS_DC1IS register field. */
#define DMA_INTERRUPT_STATUS_DC1IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC1IS register field value. */
#define DMA_INTERRUPT_STATUS_DC1IS_SET_MSK    0x00000002
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC1IS register field value. */
#define DMA_INTERRUPT_STATUS_DC1IS_CLR_MSK    0xfffffffd
/* The reset value of the DMA_INTERRUPT_STATUS_DC1IS register field. */
#define DMA_INTERRUPT_STATUS_DC1IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC1IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC1IS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_INTERRUPT_STATUS_DC1IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC1IS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : DC2IS
 *
 * DMA Channel 2 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 2. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 2 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC2IS register field. */
#define DMA_INTERRUPT_STATUS_DC2IS_LSB	      2
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC2IS register field. */
#define DMA_INTERRUPT_STATUS_DC2IS_MSB	      2
/* The width in bits of the DMA_INTERRUPT_STATUS_DC2IS register field. */
#define DMA_INTERRUPT_STATUS_DC2IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC2IS register field value. */
#define DMA_INTERRUPT_STATUS_DC2IS_SET_MSK    0x00000004
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC2IS register field value. */
#define DMA_INTERRUPT_STATUS_DC2IS_CLR_MSK    0xfffffffb
/* The reset value of the DMA_INTERRUPT_STATUS_DC2IS register field. */
#define DMA_INTERRUPT_STATUS_DC2IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC2IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC2IS_GET(value) (((value)&0x00000004) >> 2)
/* Produces a DMA_INTERRUPT_STATUS_DC2IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC2IS_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : DC3IS
 *
 * DMA Channel 3 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 3. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 3 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC3IS register field. */
#define DMA_INTERRUPT_STATUS_DC3IS_LSB	      3
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC3IS register field. */
#define DMA_INTERRUPT_STATUS_DC3IS_MSB	      3
/* The width in bits of the DMA_INTERRUPT_STATUS_DC3IS register field. */
#define DMA_INTERRUPT_STATUS_DC3IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC3IS register field value. */
#define DMA_INTERRUPT_STATUS_DC3IS_SET_MSK    0x00000008
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC3IS register field value. */
#define DMA_INTERRUPT_STATUS_DC3IS_CLR_MSK    0xfffffff7
/* The reset value of the DMA_INTERRUPT_STATUS_DC3IS register field. */
#define DMA_INTERRUPT_STATUS_DC3IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC3IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC3IS_GET(value) (((value)&0x00000008) >> 3)
/* Produces a DMA_INTERRUPT_STATUS_DC3IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC3IS_SET(value) (((value) << 3) & 0x00000008)

/*
 * Field : DC4IS
 *
 * DMA Channel 4 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 4. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 4 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC4IS register field. */
#define DMA_INTERRUPT_STATUS_DC4IS_LSB	      4
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC4IS register field. */
#define DMA_INTERRUPT_STATUS_DC4IS_MSB	      4
/* The width in bits of the DMA_INTERRUPT_STATUS_DC4IS register field. */
#define DMA_INTERRUPT_STATUS_DC4IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC4IS register field value. */
#define DMA_INTERRUPT_STATUS_DC4IS_SET_MSK    0x00000010
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC4IS register field value. */
#define DMA_INTERRUPT_STATUS_DC4IS_CLR_MSK    0xffffffef
/* The reset value of the DMA_INTERRUPT_STATUS_DC4IS register field. */
#define DMA_INTERRUPT_STATUS_DC4IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC4IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC4IS_GET(value) (((value)&0x00000010) >> 4)
/* Produces a DMA_INTERRUPT_STATUS_DC4IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC4IS_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : DC5IS
 *
 * DMA Channel 5 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 5. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 5 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC5IS register field. */
#define DMA_INTERRUPT_STATUS_DC5IS_LSB	      5
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC5IS register field. */
#define DMA_INTERRUPT_STATUS_DC5IS_MSB	      5
/* The width in bits of the DMA_INTERRUPT_STATUS_DC5IS register field. */
#define DMA_INTERRUPT_STATUS_DC5IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC5IS register field value. */
#define DMA_INTERRUPT_STATUS_DC5IS_SET_MSK    0x00000020
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC5IS register field value. */
#define DMA_INTERRUPT_STATUS_DC5IS_CLR_MSK    0xffffffdf
/* The reset value of the DMA_INTERRUPT_STATUS_DC5IS register field. */
#define DMA_INTERRUPT_STATUS_DC5IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC5IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC5IS_GET(value) (((value)&0x00000020) >> 5)
/* Produces a DMA_INTERRUPT_STATUS_DC5IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC5IS_SET(value) (((value) << 5) & 0x00000020)

/*
 * Field : DC6IS
 *
 * DMA Channel 6 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 6. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 6 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC6IS register field. */
#define DMA_INTERRUPT_STATUS_DC6IS_LSB	      6
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC6IS register field. */
#define DMA_INTERRUPT_STATUS_DC6IS_MSB	      6
/* The width in bits of the DMA_INTERRUPT_STATUS_DC6IS register field. */
#define DMA_INTERRUPT_STATUS_DC6IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC6IS register field value. */
#define DMA_INTERRUPT_STATUS_DC6IS_SET_MSK    0x00000040
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC6IS register field value. */
#define DMA_INTERRUPT_STATUS_DC6IS_CLR_MSK    0xffffffbf
/* The reset value of the DMA_INTERRUPT_STATUS_DC6IS register field. */
#define DMA_INTERRUPT_STATUS_DC6IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC6IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC6IS_GET(value) (((value)&0x00000040) >> 6)
/* Produces a DMA_INTERRUPT_STATUS_DC6IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC6IS_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : DC7IS
 *
 * DMA Channel 7 Interrupt Status.
 *
 * This bit indicates an interrupt event in DMA Channel 7. To reset this bit to
 * 1'b0, the software must read the corresponding register in DMA Channel 7 to get
 * the exact cause of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC7IS register field. */
#define DMA_INTERRUPT_STATUS_DC7IS_LSB	      7
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC7IS register field. */
#define DMA_INTERRUPT_STATUS_DC7IS_MSB	      7
/* The width in bits of the DMA_INTERRUPT_STATUS_DC7IS register field. */
#define DMA_INTERRUPT_STATUS_DC7IS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_DC7IS register field value. */
#define DMA_INTERRUPT_STATUS_DC7IS_SET_MSK    0x00000080
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC7IS register field value. */
#define DMA_INTERRUPT_STATUS_DC7IS_CLR_MSK    0xffffff7f
/* The reset value of the DMA_INTERRUPT_STATUS_DC7IS register field. */
#define DMA_INTERRUPT_STATUS_DC7IS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC7IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC7IS_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_INTERRUPT_STATUS_DC7IS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_DC7IS_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : DC15TC8IS
 *
 * DMA Channel 15 Interrupt Status to DMA Channel 8 Interrupt Status.
 *
 * To reset a bit to 1'b0, the software must read the Channel Status register in
 * the corresponding DMA Channel (15 to 8) to get the exact cause of the interrupt
 * and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_DC15TC8IS register field. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_LSB	  8
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_DC15TC8IS register field. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_MSB	  15
/* The width in bits of the DMA_INTERRUPT_STATUS_DC15TC8IS register field. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_WIDTH	  8
/* The mask used to set the DMA_INTERRUPT_STATUS_DC15TC8IS register field value. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_SET_MSK	  0x0000ff00
/* The mask used to clear the DMA_INTERRUPT_STATUS_DC15TC8IS register field value. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_CLR_MSK	  0xffff00ff
/* The reset value of the DMA_INTERRUPT_STATUS_DC15TC8IS register field. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_RESET	  0x0
/* Extracts the DMA_INTERRUPT_STATUS_DC15TC8IS field value from a register. */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_GET(value) (((value)&0x0000ff00) >> 8)
/* Produces a DMA_INTERRUPT_STATUS_DC15TC8IS register field value suitable for setting the register.
 */
#define DMA_INTERRUPT_STATUS_DC15TC8IS_SET(value) (((value) << 8) & 0x0000ff00)

/*
 * Field : MTLIS
 *
 * MTL Interrupt Status.
 *
 * This bit indicates an interrupt event in the MTL. To reset this bit to 1'b0, the
 * software must read the corresponding register in the MTL to get the exact cause
 * of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_MTLIS register field. */
#define DMA_INTERRUPT_STATUS_MTLIS_LSB	      16
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_MTLIS register field. */
#define DMA_INTERRUPT_STATUS_MTLIS_MSB	      16
/* The width in bits of the DMA_INTERRUPT_STATUS_MTLIS register field. */
#define DMA_INTERRUPT_STATUS_MTLIS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_MTLIS register field value. */
#define DMA_INTERRUPT_STATUS_MTLIS_SET_MSK    0x00010000
/* The mask used to clear the DMA_INTERRUPT_STATUS_MTLIS register field value. */
#define DMA_INTERRUPT_STATUS_MTLIS_CLR_MSK    0xfffeffff
/* The reset value of the DMA_INTERRUPT_STATUS_MTLIS register field. */
#define DMA_INTERRUPT_STATUS_MTLIS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_MTLIS field value from a register. */
#define DMA_INTERRUPT_STATUS_MTLIS_GET(value) (((value)&0x00010000) >> 16)
/* Produces a DMA_INTERRUPT_STATUS_MTLIS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_MTLIS_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : MACIS
 *
 * MAC Interrupt Status.
 *
 * This bit indicates an interrupt event in the MAC. To reset this bit to 1'b0, the
 * software must read the corresponding register in the MAC to get the exact cause
 * of the interrupt and clear its source.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_MACIS register field. */
#define DMA_INTERRUPT_STATUS_MACIS_LSB	      17
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_MACIS register field. */
#define DMA_INTERRUPT_STATUS_MACIS_MSB	      17
/* The width in bits of the DMA_INTERRUPT_STATUS_MACIS register field. */
#define DMA_INTERRUPT_STATUS_MACIS_WIDTH      1
/* The mask used to set the DMA_INTERRUPT_STATUS_MACIS register field value. */
#define DMA_INTERRUPT_STATUS_MACIS_SET_MSK    0x00020000
/* The mask used to clear the DMA_INTERRUPT_STATUS_MACIS register field value. */
#define DMA_INTERRUPT_STATUS_MACIS_CLR_MSK    0xfffdffff
/* The reset value of the DMA_INTERRUPT_STATUS_MACIS register field. */
#define DMA_INTERRUPT_STATUS_MACIS_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_MACIS field value from a register. */
#define DMA_INTERRUPT_STATUS_MACIS_GET(value) (((value)&0x00020000) >> 17)
/* Produces a DMA_INTERRUPT_STATUS_MACIS register field value suitable for setting the register. */
#define DMA_INTERRUPT_STATUS_MACIS_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : Reserved_31_18
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_INTERRUPT_STATUS_RESERVED_31_18 register
 * field. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_LSB	       18
/* The Most Significant Bit (MSB) position of the DMA_INTERRUPT_STATUS_RESERVED_31_18 register
 * field. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_MSB	       31
/* The width in bits of the DMA_INTERRUPT_STATUS_RESERVED_31_18 register field. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_WIDTH      14
/* The mask used to set the DMA_INTERRUPT_STATUS_RESERVED_31_18 register field value. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_SET_MSK    0xfffc0000
/* The mask used to clear the DMA_INTERRUPT_STATUS_RESERVED_31_18 register field value. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_CLR_MSK    0x0003ffff
/* The reset value of the DMA_INTERRUPT_STATUS_RESERVED_31_18 register field. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_RESET      0x0
/* Extracts the DMA_INTERRUPT_STATUS_RESERVED_31_18 field value from a register. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_GET(value) (((value)&0xfffc0000) >> 18)
/* Produces a DMA_INTERRUPT_STATUS_RESERVED_31_18 register field value suitable for setting the
 * register. */
#define DMA_INTERRUPT_STATUS_RESERVED_31_18_SET(value) (((value) << 18) & 0xfffc0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_INTERRUPT_STATUS.
 */
struct DMA_INTERRUPT_STATUS_s {
	const volatile uint32_t DC0IS : 1;	     /* DMA_INTERRUPT_STATUS_DC0IS */
	const volatile uint32_t DC1IS : 1;	     /* DMA_INTERRUPT_STATUS_DC1IS */
	const volatile uint32_t DC2IS : 1;	     /* DMA_INTERRUPT_STATUS_DC2IS */
	const volatile uint32_t DC3IS : 1;	     /* DMA_INTERRUPT_STATUS_DC3IS */
	const volatile uint32_t DC4IS : 1;	     /* DMA_INTERRUPT_STATUS_DC4IS */
	const volatile uint32_t DC5IS : 1;	     /* DMA_INTERRUPT_STATUS_DC5IS */
	const volatile uint32_t DC6IS : 1;	     /* DMA_INTERRUPT_STATUS_DC6IS */
	const volatile uint32_t DC7IS : 1;	     /* DMA_INTERRUPT_STATUS_DC7IS */
	const volatile uint32_t DC15TC8IS : 8;	     /* DMA_INTERRUPT_STATUS_DC15TC8IS */
	const volatile uint32_t MTLIS : 1;	     /* DMA_INTERRUPT_STATUS_MTLIS */
	const volatile uint32_t MACIS : 1;	     /* DMA_INTERRUPT_STATUS_MACIS */
	const volatile uint32_t Reserved_31_18 : 14; /* DMA_INTERRUPT_STATUS_RESERVED_31_18 */
};

/* The typedef declaration for register DMA_INTERRUPT_STATUS. */
typedef struct DMA_INTERRUPT_STATUS_s DMA_INTERRUPT_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_INTERRUPT_STATUS register. */
#define DMA_INTERRUPT_STATUS_RESET 0x00000000
/* The byte offset of the DMA_INTERRUPT_STATUS register from the beginning of the component. */
#define DMA_INTERRUPT_STATUS_OFST  0x8

/*
 * Register : AXI_Tx_AR_ACE_Control
 *
 * This register is used to control the AXI4 Cache Coherency Signals for read
 * transactions by all the Transmit DMA channels. The following signals of the AXI4
 * interface are driven with different values as programmed for corresponding type
 * (descriptor, buffer1, buffer2) of access.
 *
 * * arcache_m_o[3:0]
 *
 * * ardomain_m_o[1:0]
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [3:0]   | RW     | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_TDRC
 *  [5:4]   | RW     | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_TDRD
 *  [7:6]   | R      | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6
 *  [11:8]  | RW     | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_TEC
 *  [13:12] | RW     | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_TED
 *  [15:14] | R      | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14
 *  [19:16] | RW     | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_THC
 *  [21:20] | RW     | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_THD
 *  [31:22] | R      | 0x0   | DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22
 *
 */
/*
 * Field : TDRC
 *
 * Transmit DMA Read Descriptor Cache Control.
 *
 * This field is used to drive arcache_o[3:0] signal when Transmit DMA engines
 * access the Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_LSB	  0
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_MSB	  3
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_WIDTH	  4
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_SET_MSK	  0x0000000f
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_CLR_MSK	  0xfffffff0
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_RESET	  0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_TDRC field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_TDRC register field value suitable for setting the register.
 */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRC_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : TDRD
 *
 * Transmit DMA Read Descriptor Domain Control.
 *
 * This field is used to drive ardomain_o[1:0] signal when Transmit DMA engines
 * access the Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_LSB	  4
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_MSB	  5
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_WIDTH	  2
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_SET_MSK	  0x00000030
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_CLR_MSK	  0xffffffcf
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_RESET	  0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_TDRD field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_GET(value) (((value)&0x00000030) >> 4)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_TDRD register field value suitable for setting the register.
 */
#define DMA_AXI_TX_AR_ACE_CONTROL_TDRD_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register
 * field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_LSB	  6
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register
 * field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_MSB	  7
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_WIDTH	  2
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_SET_MSK	  0x000000c0
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_CLR_MSK	  0xffffff3f
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_RESET	  0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 register field value suitable for setting the
 * register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : TEC
 *
 * Transmit DMA Extended Packet Buffer or TSO Payload Cache Control.
 *
 * When TSO is not enabled, this field is used to drive arcache o[3:0] signal when
 * Transmit DMA is accessing the extended buffers (when packet is distributed
 * across multiple buffers).
 *
 * When TSO is enabled, this field is used to drive arcache_o[3:0] signal when the
 * Transmit DMA is accessing the TSO payload data.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TEC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_LSB	 8
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TEC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_MSB	 11
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_TEC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_WIDTH	 4
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_TEC register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_SET_MSK	 0x00000f00
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_TEC register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_CLR_MSK	 0xfffff0ff
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_TEC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_RESET	 0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_TEC field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_TEC register field value suitable for setting the register.
 */
#define DMA_AXI_TX_AR_ACE_CONTROL_TEC_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : TED
 *
 * Transmit DMA Extended Packet Buffer or TSO Payload Domain Control.
 *
 * When TSO is not enabled, this field is used to drive ardomain_o[1:0] signal when
 * Transmit DMA is accessing the extended buffers (when packet is distributed
 * across multiple buffers).
 *
 * When TSO is enabled, this field is used to drive ardomain_o[1:0] signal when the
 * Transmit DMA is accessing the TSO payload data.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TED register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_LSB	 12
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_TED register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_MSB	 13
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_TED register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_WIDTH	 2
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_TED register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_SET_MSK	 0x00003000
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_TED register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_CLR_MSK	 0xffffcfff
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_TED register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_RESET	 0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_TED field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_GET(value) (((value)&0x00003000) >> 12)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_TED register field value suitable for setting the register.
 */
#define DMA_AXI_TX_AR_ACE_CONTROL_TED_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register
 * field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_LSB	    14
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register
 * field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_MSB	    15
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_WIDTH	    2
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_SET_MSK    0x0000c000
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_CLR_MSK    0xffff3fff
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_RESET	    0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 register field value suitable for setting the
 * register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : THC
 *
 * Transmit DMA First Packet Buffer or TSO Header Cache Control.
 *
 * When TSO is not enabled, this field is used to drive arcache_o[3:0] signal when
 * Transmit DMA is accessing First Buffer of the Packet (First valid buffer with FD
 * being set in the TDES3 of the Descriptor).
 *
 * When TSO is enabled, this field is used to drive arcache_o[3:0] signal when the
 * Transmit DMA is accessing the TSO Header data.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_THC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_LSB	 16
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_THC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_MSB	 19
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_THC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_WIDTH	 4
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_THC register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_SET_MSK	 0x000f0000
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_THC register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_CLR_MSK	 0xfff0ffff
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_THC register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_RESET	 0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_THC field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_THC register field value suitable for setting the register.
 */
#define DMA_AXI_TX_AR_ACE_CONTROL_THC_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : THD
 *
 * Transmit DMA First Packet Buffer or TSO Header Domain Control.
 *
 * When TSO is not enabled, this field is used to drive ardomain_o[1:0] signal when
 * Transmit DMA is accessing First Buffer of the Packet (First valid buffer with FD
 * being set in the TDES3 of the Descriptor).
 *
 * When TSO is enabled, this field is used to drive ardomain_o[1:0] signal when the
 * Transmit DMA is accessing the TSO Header data.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_THD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_LSB	 20
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_THD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_MSB	 21
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_THD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_WIDTH	 2
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_THD register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_SET_MSK	 0x00300000
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_THD register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_CLR_MSK	 0xffcfffff
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_THD register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_RESET	 0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_THD field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_GET(value) (((value)&0x00300000) >> 20)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_THD register field value suitable for setting the register.
 */
#define DMA_AXI_TX_AR_ACE_CONTROL_THD_SET(value) (((value) << 20) & 0x00300000)

/*
 * Field : Reserved_31_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register
 * field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_LSB	    22
/* The Most Significant Bit (MSB) position of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register
 * field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_MSB	    31
/* The width in bits of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_WIDTH	    10
/* The mask used to set the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_SET_MSK    0xffc00000
/* The mask used to clear the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register field value. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_CLR_MSK    0x003fffff
/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register field. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_RESET	    0x0
/* Extracts the DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 field value from a register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_GET(value) (((value)&0xffc00000) >> 22)
/* Produces a DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 register field value suitable for setting the
 * register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22_SET(value) (((value) << 22) & 0xffc00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_AXI_TX_AR_ACE_CONTROL.
 */
struct DMA_AXI_TX_AR_ACE_CONTROL_s {
	volatile uint32_t TDRC : 4;		     /* DMA_AXI_TX_AR_ACE_CONTROL_TDRC */
	volatile uint32_t TDRD : 2;		     /* DMA_AXI_TX_AR_ACE_CONTROL_TDRD */
	const volatile uint32_t Reserved_7_6 : 2;    /* DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_7_6 */
	volatile uint32_t TEC : 4;		     /* DMA_AXI_TX_AR_ACE_CONTROL_TEC */
	volatile uint32_t TED : 2;		     /* DMA_AXI_TX_AR_ACE_CONTROL_TED */
	const volatile uint32_t Reserved_15_14 : 2;  /* DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_15_14 */
	volatile uint32_t THC : 4;		     /* DMA_AXI_TX_AR_ACE_CONTROL_THC */
	volatile uint32_t THD : 2;		     /* DMA_AXI_TX_AR_ACE_CONTROL_THD */
	const volatile uint32_t Reserved_31_22 : 10; /* DMA_AXI_TX_AR_ACE_CONTROL_RESERVED_31_22 */
};

/* The typedef declaration for register DMA_AXI_TX_AR_ACE_CONTROL. */
typedef struct DMA_AXI_TX_AR_ACE_CONTROL_s DMA_AXI_TX_AR_ACE_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_AXI_TX_AR_ACE_CONTROL register. */
#define DMA_AXI_TX_AR_ACE_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_AXI_TX_AR_ACE_CONTROL register from the beginning of the component. */
#define DMA_AXI_TX_AR_ACE_CONTROL_OFST	0x10

/*
 * Register : AXI_Rx_AW_ACE_Control
 *
 * This register is used to control the Cache Coherency Signals of the AXI4-ACE
 * Lite on the Receive DMA. The programmable controllability is supported on the
 * following signals of the AXI Write channel.
 *
 * * awcache_m_o[3:0]
 *
 * * awdomain_m_o[1:0]
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [3:0]   | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RDWC
 *  [5:4]   | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RDWD
 *  [7:6]   | R      | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6
 *  [11:8]  | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RPC
 *  [13:12] | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RPD
 *  [15:14] | R      | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14
 *  [19:16] | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RHC
 *  [21:20] | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RHD
 *  [23:22] | R      | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22
 *  [27:24] | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RDC
 *  [29:28] | RW     | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RDD
 *  [31:30] | R      | 0x0   | DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30
 *
 */
/*
 * Field : RDWC
 *
 * Receive DMA Write Descriptor Cache Control.
 *
 * This field is used to drive awcache_o[3:0] signal when Receive DMA access the
 * Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_LSB	  0
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_MSB	  3
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_WIDTH	  4
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_SET_MSK	  0x0000000f
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_CLR_MSK	  0xfffffff0
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_RESET	  0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RDWC field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RDWC register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWC_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : RDWD
 *
 * Receive DMA Write Descriptor Domain Control.
 *
 * This field is used to drive awdomain_o[1:0] signal when Receive DMA access the
 * Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_LSB	  4
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_MSB	  5
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_WIDTH	  2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_SET_MSK	  0x00000030
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_CLR_MSK	  0xffffffcf
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_RESET	  0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RDWD field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_GET(value) (((value)&0x00000030) >> 4)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RDWD register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDWD_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_LSB	  6
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_MSB	  7
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_WIDTH	  2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_SET_MSK	  0x000000c0
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_CLR_MSK	  0xffffff3f
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_RESET	  0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 register field value suitable for setting the
 * register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : RPC
 *
 * Receive DMA Payload Cache Control.
 *
 * This field is used to drive awcache_o[3:0] signal when Receive DMA is accessing
 * the Payload Buffer when Header and payload are separated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RPC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_LSB	 8
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RPC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_MSB	 11
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RPC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_WIDTH	 4
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RPC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_SET_MSK	 0x00000f00
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RPC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_CLR_MSK	 0xfffff0ff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RPC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_RESET	 0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RPC field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RPC register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPC_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : RPD
 *
 * Receive DMA Payload Domain Control.
 *
 * This field is used to drive awdomain_o[1:0] signal when Receive DMA is accessing
 * the Payload Buffer when Header and payload are separated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RPD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_LSB	 12
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RPD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_MSB	 13
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RPD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_WIDTH	 2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RPD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_SET_MSK	 0x00003000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RPD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_CLR_MSK	 0xffffcfff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RPD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_RESET	 0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RPD field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_GET(value) (((value)&0x00003000) >> 12)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RPD register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RPD_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_LSB	    14
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_MSB	    15
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_WIDTH	    2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_SET_MSK    0x0000c000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_CLR_MSK    0xffff3fff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_RESET	    0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 register field value suitable for setting the
 * register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : RHC
 *
 * Receive DMA Header Cache Control.
 *
 * This field is used to drive awcache_o[3:0] and signal when Receive DMA is
 * accessing the header Buffer when Header and payload are separated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RHC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_LSB	 16
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RHC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_MSB	 19
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RHC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_WIDTH	 4
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RHC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_SET_MSK	 0x000f0000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RHC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_CLR_MSK	 0xfff0ffff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RHC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_RESET	 0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RHC field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RHC register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHC_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : RHD
 *
 * Receive DMA Header Domain Control.
 *
 * This field is used to drive awdomain_o[1:0] and signal when Receive DMA is
 * accessing the header Buffer when Header and payload are separated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RHD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_LSB	 20
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RHD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_MSB	 21
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RHD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_WIDTH	 2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RHD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_SET_MSK	 0x00300000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RHD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_CLR_MSK	 0xffcfffff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RHD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_RESET	 0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RHD field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_GET(value) (((value)&0x00300000) >> 20)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RHD register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RHD_SET(value) (((value) << 20) & 0x00300000)

/*
 * Field : Reserved_23_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_LSB	    22
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_MSB	    23
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_WIDTH	    2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_SET_MSK    0x00c00000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_CLR_MSK    0xff3fffff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_RESET	    0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_GET(value) (((value)&0x00c00000) >> 22)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 register field value suitable for setting the
 * register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22_SET(value) (((value) << 22) & 0x00c00000)

/*
 * Field : RDC
 *
 * Receive DMA Buffer Cache Control.
 *
 * This field is used to drive awcache_o[3:0] signal when Receive DMA is accessing
 * the Buffer when Header and payload are not separated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_LSB	 24
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_MSB	 27
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RDC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_WIDTH	 4
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RDC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_SET_MSK	 0x0f000000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RDC register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_CLR_MSK	 0xf0ffffff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RDC register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_RESET	 0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RDC field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_GET(value) (((value)&0x0f000000) >> 24)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RDC register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDC_SET(value) (((value) << 24) & 0x0f000000)

/*
 * Field : RDD
 *
 * Receive DMA Buffer Domain Control.
 *
 * This field is used to drive the awdomain_o[1:0] signal when Receive DMA is
 * accessing the Buffer when Header and payload are not separated.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_LSB	 28
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RDD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_MSB	 29
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RDD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_WIDTH	 2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RDD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_SET_MSK	 0x30000000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RDD register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_CLR_MSK	 0xcfffffff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RDD register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_RESET	 0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RDD field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_GET(value) (((value)&0x30000000) >> 28)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RDD register field value suitable for setting the register.
 */
#define DMA_AXI_RX_AW_ACE_CONTROL_RDD_SET(value) (((value) << 28) & 0x30000000)

/*
 * Field : Reserved_31_30
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_LSB	    30
/* The Most Significant Bit (MSB) position of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register
 * field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_MSB	    31
/* The width in bits of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_WIDTH	    2
/* The mask used to set the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_SET_MSK    0xc0000000
/* The mask used to clear the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register field value. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_CLR_MSK    0x3fffffff
/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register field. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_RESET	    0x0
/* Extracts the DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 field value from a register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 register field value suitable for setting the
 * register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_AXI_RX_AW_ACE_CONTROL.
 */
struct DMA_AXI_RX_AW_ACE_CONTROL_s {
	volatile uint32_t RDWC : 4;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RDWC */
	volatile uint32_t RDWD : 2;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RDWD */
	const volatile uint32_t Reserved_7_6 : 2;   /* DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_7_6 */
	volatile uint32_t RPC : 4;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RPC */
	volatile uint32_t RPD : 2;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RPD */
	const volatile uint32_t Reserved_15_14 : 2; /* DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_15_14 */
	volatile uint32_t RHC : 4;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RHC */
	volatile uint32_t RHD : 2;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RHD */
	const volatile uint32_t Reserved_23_22 : 2; /* DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_23_22 */
	volatile uint32_t RDC : 4;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RDC */
	volatile uint32_t RDD : 2;		    /* DMA_AXI_RX_AW_ACE_CONTROL_RDD */
	const volatile uint32_t Reserved_31_30 : 2; /* DMA_AXI_RX_AW_ACE_CONTROL_RESERVED_31_30 */
};

/* The typedef declaration for register DMA_AXI_RX_AW_ACE_CONTROL. */
typedef struct DMA_AXI_RX_AW_ACE_CONTROL_s DMA_AXI_RX_AW_ACE_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_AXI_RX_AW_ACE_CONTROL register. */
#define DMA_AXI_RX_AW_ACE_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_AXI_RX_AW_ACE_CONTROL register from the beginning of the component. */
#define DMA_AXI_RX_AW_ACE_CONTROL_OFST	0x18

/*
 * Register : AXI_TxRx_AWAR_ACE_Control
 *
 * This register is used to control the AXI4 Cache Coherency Signals for Descriptor
 * write transactions by all the TxDMA channels and Descriptor read transactions by
 * all the RxDMA channels. It also controls the values to be driven on awprot_m_o
 * and arprot_m_o.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------
 *  [3:0]   | RW     | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC
 *  [5:4]   | RW     | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD
 *  [7:6]   | R      | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6
 *  [11:8]  | RW     | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC
 *  [13:12] | RW     | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD
 *  [15:14] | R      | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14
 *  [18:16] | RW     | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP
 *  [19]    | R      | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19
 *  [22:20] | RW     | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP
 *  [31:23] | R      | 0x0   | DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23
 *
 */
/*
 * Field : TDWC
 *
 * Transmit DMA Write Descriptor Cache control.
 *
 * This field is used to drive awcache_o[3:0] signal when Transmit DMA is writing
 * the Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register
 * field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_MSB	      3
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_WIDTH      4
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_SET_MSK    0x0000000f
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_CLR_MSK    0xfffffff0
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_RESET      0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC register field value suitable for setting the
 * register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : TDWD
 *
 * Transmit DMA Write Descriptor Domain control.
 *
 * This field is used to drive awdomain_o[1:0] signal when Transmit DMA is writing
 * the Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register
 * field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_LSB	      4
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_MSB	      5
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_WIDTH      2
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_SET_MSK    0x00000030
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_CLR_MSK    0xffffffcf
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_RESET      0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_GET(value) (((value)&0x00000030) >> 4)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD register field value suitable for setting the
 * register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_LSB	      6
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_MSB	      7
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_WIDTH      2
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_SET_MSK    0x000000c0
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_CLR_MSK    0xffffff3f
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_RESET      0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 register field value suitable for setting
 * the register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : RDRC
 *
 * Receive DMA Read Descriptor Cache control.
 *
 * This field is used to drive arcache_o[3:0] signal when Receive DMA engine is
 * reading the Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register
 * field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_MSB	      11
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_WIDTH      4
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_SET_MSK    0x00000f00
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_CLR_MSK    0xfffff0ff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_RESET      0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC register field value suitable for setting the
 * register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : RDRD
 *
 * Receive DMA Read Descriptor Domain control.
 *
 * This field is used to drive ardomain_o[1:0] signal when Receive DMA engine is
 * reading the Descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register
 * field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_LSB	      12
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_MSB	      13
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_WIDTH      2
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_SET_MSK    0x00003000
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_CLR_MSK    0xffffcfff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_RESET      0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_GET(value) (((value)&0x00003000) >> 12)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD register field value suitable for setting the
 * register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_LSB	14
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_MSB	15
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_WIDTH	2
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_SET_MSK	0x0000c000
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_CLR_MSK	0xffff3fff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_RESET	0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 register field value suitable for setting
 * the register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : RDP
 *
 * DMA Read Protection control.
 *
 * This field is used to drive the arprot_m_o[2:0] during all read requests.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_LSB	     16
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_MSB	     18
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_WIDTH	     3
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_SET_MSK    0x00070000
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_CLR_MSK    0xfff8ffff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_RESET	     0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_GET(value) (((value)&0x00070000) >> 16)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP register field value suitable for setting the
 * register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : Reserved_19
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_LSB	     19
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 register
 * field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_MSB	     19
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_WIDTH	     1
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_SET_MSK    0x00080000
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_CLR_MSK    0xfff7ffff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_RESET	     0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_GET(value) (((value)&0x00080000) >> 19)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 register field value suitable for setting
 * the register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19_SET(value) (((value) << 19) & 0x00080000)

/*
 * Field : WRP
 *
 * DMA Write Protection control.
 *
 * This field is used to drive the awprot_m_o[2:0] during all write Requests.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_LSB	     20
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field.
 */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_MSB	     22
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_WIDTH	     3
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_SET_MSK    0x00700000
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_CLR_MSK    0xff8fffff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_RESET	     0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_GET(value) (((value)&0x00700000) >> 20)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP register field value suitable for setting the
 * register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP_SET(value) (((value) << 20) & 0x00700000)

/*
 * Field : Reserved_31_23
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_LSB	23
/* The Most Significant Bit (MSB) position of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23
 * register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_MSB	31
/* The width in bits of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_WIDTH	9
/* The mask used to set the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_SET_MSK	0xff800000
/* The mask used to clear the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 register field value. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_CLR_MSK	0x007fffff
/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 register field. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_RESET	0x0
/* Extracts the DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 field value from a register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_GET(value) (((value)&0xff800000) >> 23)
/* Produces a DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 register field value suitable for setting
 * the register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23_SET(value) (((value) << 23) & 0xff800000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_AXI_TXRX_AWAR_ACE_CONTROL.
 */
struct DMA_AXI_TXRX_AWAR_ACE_CONTROL_s {
	volatile uint32_t TDWC : 4;		  /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWC */
	volatile uint32_t TDWD : 2;		  /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_TDWD */
	const volatile uint32_t Reserved_7_6 : 2; /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_7_6 */
	volatile uint32_t RDRC : 4;		  /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRC */
	volatile uint32_t RDRD : 2;		  /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDRD */
	const volatile uint32_t
		Reserved_15_14 : 2;		 /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_15_14 */
	volatile uint32_t RDP : 3;		 /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RDP */
	const volatile uint32_t Reserved_19 : 1; /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_19 */
	volatile uint32_t WRP : 3;		 /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_WRP */
	const volatile uint32_t
		Reserved_31_23 : 9; /* DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESERVED_31_23 */
};

/* The typedef declaration for register DMA_AXI_TXRX_AWAR_ACE_CONTROL. */
typedef struct DMA_AXI_TXRX_AWAR_ACE_CONTROL_s DMA_AXI_TXRX_AWAR_ACE_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_AXI_TXRX_AWAR_ACE_CONTROL register. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_AXI_TXRX_AWAR_ACE_CONTROL register from the beginning of the
 * component. */
#define DMA_AXI_TXRX_AWAR_ACE_CONTROL_OFST  0x1c

/*
 * Register : DMA_Debug_Status0
 *
 * The Debug Status 0 register gives the Receive and Transmit process status for
 * DMA Channel 0 - Channel 2 for debugging purpose.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------
 *  [0]     | R      | 0x0   | DMA_DEBUG_STATUS0_AXWHSTS
 *  [1]     | R      | 0x0   | DMA_DEBUG_STATUS0_AXRHSTS
 *  [7:2]   | R      | 0x0   | DMA_DEBUG_STATUS0_RESERVED_7_2
 *  [11:8]  | R      | 0x0   | DMA_DEBUG_STATUS0_RPS0
 *  [15:12] | R      | 0x0   | DMA_DEBUG_STATUS0_TPS0
 *  [19:16] | R      | 0x0   | DMA_DEBUG_STATUS0_RPS1
 *  [23:20] | R      | 0x0   | DMA_DEBUG_STATUS0_TPS1
 *  [27:24] | R      | 0x0   | DMA_DEBUG_STATUS0_RPS2
 *  [31:28] | R      | 0x0   | DMA_DEBUG_STATUS0_TPS2
 *
 */
/*
 * Field : AXWHSTS
 *
 * AXI Master Write Channel Status.
 *
 * When high, this bit indicates that the write channel of the AXI master is
 * active, and it is transferring data.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_AXWHSTS register field. */
#define DMA_DEBUG_STATUS0_AXWHSTS_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_AXWHSTS register field. */
#define DMA_DEBUG_STATUS0_AXWHSTS_MSB	     0
/* The width in bits of the DMA_DEBUG_STATUS0_AXWHSTS register field. */
#define DMA_DEBUG_STATUS0_AXWHSTS_WIDTH	     1
/* The mask used to set the DMA_DEBUG_STATUS0_AXWHSTS register field value. */
#define DMA_DEBUG_STATUS0_AXWHSTS_SET_MSK    0x00000001
/* The mask used to clear the DMA_DEBUG_STATUS0_AXWHSTS register field value. */
#define DMA_DEBUG_STATUS0_AXWHSTS_CLR_MSK    0xfffffffe
/* The reset value of the DMA_DEBUG_STATUS0_AXWHSTS register field. */
#define DMA_DEBUG_STATUS0_AXWHSTS_RESET	     0x0
/* Extracts the DMA_DEBUG_STATUS0_AXWHSTS field value from a register. */
#define DMA_DEBUG_STATUS0_AXWHSTS_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_DEBUG_STATUS0_AXWHSTS register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_AXWHSTS_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : AXRHSTS
 *
 * AXI Master Read Channel Status.
 *
 * When high, this bit indicates that the read channel of the AXI master is active,
 * and it is transferring the data.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_AXRHSTS register field. */
#define DMA_DEBUG_STATUS0_AXRHSTS_LSB	     1
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_AXRHSTS register field. */
#define DMA_DEBUG_STATUS0_AXRHSTS_MSB	     1
/* The width in bits of the DMA_DEBUG_STATUS0_AXRHSTS register field. */
#define DMA_DEBUG_STATUS0_AXRHSTS_WIDTH	     1
/* The mask used to set the DMA_DEBUG_STATUS0_AXRHSTS register field value. */
#define DMA_DEBUG_STATUS0_AXRHSTS_SET_MSK    0x00000002
/* The mask used to clear the DMA_DEBUG_STATUS0_AXRHSTS register field value. */
#define DMA_DEBUG_STATUS0_AXRHSTS_CLR_MSK    0xfffffffd
/* The reset value of the DMA_DEBUG_STATUS0_AXRHSTS register field. */
#define DMA_DEBUG_STATUS0_AXRHSTS_RESET	     0x0
/* Extracts the DMA_DEBUG_STATUS0_AXRHSTS field value from a register. */
#define DMA_DEBUG_STATUS0_AXRHSTS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_DEBUG_STATUS0_AXRHSTS register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_AXRHSTS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_7_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_RESERVED_7_2 register field. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_LSB	  2
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_RESERVED_7_2 register field. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_MSB	  7
/* The width in bits of the DMA_DEBUG_STATUS0_RESERVED_7_2 register field. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_WIDTH	  6
/* The mask used to set the DMA_DEBUG_STATUS0_RESERVED_7_2 register field value. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_SET_MSK	  0x000000fc
/* The mask used to clear the DMA_DEBUG_STATUS0_RESERVED_7_2 register field value. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_CLR_MSK	  0xffffff03
/* The reset value of the DMA_DEBUG_STATUS0_RESERVED_7_2 register field. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_RESERVED_7_2 field value from a register. */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_GET(value) (((value)&0x000000fc) >> 2)
/* Produces a DMA_DEBUG_STATUS0_RESERVED_7_2 register field value suitable for setting the register.
 */
#define DMA_DEBUG_STATUS0_RESERVED_7_2_SET(value) (((value) << 2) & 0x000000fc)

/*
 * Field : RPS0
 *
 * DMA Channel 0 Receive Process State.
 *
 * This field indicates the Rx DMA FSM state for Channel 0:
 *
 * * 4'b0000: Stopped (Reset or Stop Receive Command issued)
 *
 * * 4'b0001: Running (Fetching Rx Transfer Descriptor)
 *
 * * 4'b0010: Reserved for future use
 *
 * * 4'b0011: Running (Waiting for Rx packet)
 *
 * * 4'b0100: Suspended (Rx Descriptor Unavailable)
 *
 * * 4'b0101: Running (Closing the Rx Descriptor)
 *
 * * 4'b0110: Timestamp write state
 *
 * * 4'b0111: Running (Transferring the received packet data from the Rx buffer to
 *   the system memory)
 *
 * This field does not generate an interrupt.
 *
 * The MSB of this field always returns 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_RPS0 register field. */
#define DMA_DEBUG_STATUS0_RPS0_LSB	  8
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_RPS0 register field. */
#define DMA_DEBUG_STATUS0_RPS0_MSB	  11
/* The width in bits of the DMA_DEBUG_STATUS0_RPS0 register field. */
#define DMA_DEBUG_STATUS0_RPS0_WIDTH	  4
/* The mask used to set the DMA_DEBUG_STATUS0_RPS0 register field value. */
#define DMA_DEBUG_STATUS0_RPS0_SET_MSK	  0x00000f00
/* The mask used to clear the DMA_DEBUG_STATUS0_RPS0 register field value. */
#define DMA_DEBUG_STATUS0_RPS0_CLR_MSK	  0xfffff0ff
/* The reset value of the DMA_DEBUG_STATUS0_RPS0 register field. */
#define DMA_DEBUG_STATUS0_RPS0_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_RPS0 field value from a register. */
#define DMA_DEBUG_STATUS0_RPS0_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_DEBUG_STATUS0_RPS0 register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_RPS0_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : TPS0
 *
 * DMA Channel 0 Transmit Process State.
 *
 * This field indicates the Tx DMA FSM state for Channel 0:
 *
 * * 4'b0000: Stopped (Reset or Stop Transmit Command issued)
 *
 * * 4'b0001: Running (Fetching Tx Transfer Descriptor)
 *
 * * 4'b0010: Running (Waiting for status)
 *
 * * 4'b0011: Running (Reading Data from system memory buffer and queuing it to the
 *   Tx buffer (Tx FIFO))
 *
 * * 4'b0100: Timestamp write state
 *
 * * 4'b0101: Reserved for future use
 *
 * * 4'b0110: Suspended (Tx Descriptor Unavailable or Tx Buffer Underflow)
 *
 * * 4'b0111: Running (Closing Tx Descriptor)
 *
 * This field does not generate an interrupt.
 *
 * The MSB of this field always returns 0.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_TPS0 register field. */
#define DMA_DEBUG_STATUS0_TPS0_LSB	  12
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_TPS0 register field. */
#define DMA_DEBUG_STATUS0_TPS0_MSB	  15
/* The width in bits of the DMA_DEBUG_STATUS0_TPS0 register field. */
#define DMA_DEBUG_STATUS0_TPS0_WIDTH	  4
/* The mask used to set the DMA_DEBUG_STATUS0_TPS0 register field value. */
#define DMA_DEBUG_STATUS0_TPS0_SET_MSK	  0x0000f000
/* The mask used to clear the DMA_DEBUG_STATUS0_TPS0 register field value. */
#define DMA_DEBUG_STATUS0_TPS0_CLR_MSK	  0xffff0fff
/* The reset value of the DMA_DEBUG_STATUS0_TPS0 register field. */
#define DMA_DEBUG_STATUS0_TPS0_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_TPS0 field value from a register. */
#define DMA_DEBUG_STATUS0_TPS0_GET(value) (((value)&0x0000f000) >> 12)
/* Produces a DMA_DEBUG_STATUS0_TPS0 register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_TPS0_SET(value) (((value) << 12) & 0x0000f000)

/*
 * Field : RPS1
 *
 * DMA Channel 1 Receive Process State.
 *
 * This field indicates the Rx DMA FSM state for Channel 1. This field is similar
 * to the RPS0 field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_RPS1 register field. */
#define DMA_DEBUG_STATUS0_RPS1_LSB	  16
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_RPS1 register field. */
#define DMA_DEBUG_STATUS0_RPS1_MSB	  19
/* The width in bits of the DMA_DEBUG_STATUS0_RPS1 register field. */
#define DMA_DEBUG_STATUS0_RPS1_WIDTH	  4
/* The mask used to set the DMA_DEBUG_STATUS0_RPS1 register field value. */
#define DMA_DEBUG_STATUS0_RPS1_SET_MSK	  0x000f0000
/* The mask used to clear the DMA_DEBUG_STATUS0_RPS1 register field value. */
#define DMA_DEBUG_STATUS0_RPS1_CLR_MSK	  0xfff0ffff
/* The reset value of the DMA_DEBUG_STATUS0_RPS1 register field. */
#define DMA_DEBUG_STATUS0_RPS1_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_RPS1 field value from a register. */
#define DMA_DEBUG_STATUS0_RPS1_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a DMA_DEBUG_STATUS0_RPS1 register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_RPS1_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : TPS1
 *
 * DMA Channel 1 Transmit Process State.
 *
 * This field indicates the Tx DMA FSM state for Channel 1. This field is similar
 * to the TPS0 field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_TPS1 register field. */
#define DMA_DEBUG_STATUS0_TPS1_LSB	  20
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_TPS1 register field. */
#define DMA_DEBUG_STATUS0_TPS1_MSB	  23
/* The width in bits of the DMA_DEBUG_STATUS0_TPS1 register field. */
#define DMA_DEBUG_STATUS0_TPS1_WIDTH	  4
/* The mask used to set the DMA_DEBUG_STATUS0_TPS1 register field value. */
#define DMA_DEBUG_STATUS0_TPS1_SET_MSK	  0x00f00000
/* The mask used to clear the DMA_DEBUG_STATUS0_TPS1 register field value. */
#define DMA_DEBUG_STATUS0_TPS1_CLR_MSK	  0xff0fffff
/* The reset value of the DMA_DEBUG_STATUS0_TPS1 register field. */
#define DMA_DEBUG_STATUS0_TPS1_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_TPS1 field value from a register. */
#define DMA_DEBUG_STATUS0_TPS1_GET(value) (((value)&0x00f00000) >> 20)
/* Produces a DMA_DEBUG_STATUS0_TPS1 register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_TPS1_SET(value) (((value) << 20) & 0x00f00000)

/*
 * Field : RPS2
 *
 * DMA Channel 2 Receive Process State.
 *
 * This field indicates the Rx DMA FSM state for Channel 2. This field is similar
 * to the RPS0 field
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_RPS2 register field. */
#define DMA_DEBUG_STATUS0_RPS2_LSB	  24
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_RPS2 register field. */
#define DMA_DEBUG_STATUS0_RPS2_MSB	  27
/* The width in bits of the DMA_DEBUG_STATUS0_RPS2 register field. */
#define DMA_DEBUG_STATUS0_RPS2_WIDTH	  4
/* The mask used to set the DMA_DEBUG_STATUS0_RPS2 register field value. */
#define DMA_DEBUG_STATUS0_RPS2_SET_MSK	  0x0f000000
/* The mask used to clear the DMA_DEBUG_STATUS0_RPS2 register field value. */
#define DMA_DEBUG_STATUS0_RPS2_CLR_MSK	  0xf0ffffff
/* The reset value of the DMA_DEBUG_STATUS0_RPS2 register field. */
#define DMA_DEBUG_STATUS0_RPS2_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_RPS2 field value from a register. */
#define DMA_DEBUG_STATUS0_RPS2_GET(value) (((value)&0x0f000000) >> 24)
/* Produces a DMA_DEBUG_STATUS0_RPS2 register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_RPS2_SET(value) (((value) << 24) & 0x0f000000)

/*
 * Field : TPS2
 *
 * DMA Channel 2 Transmit Process State.
 *
 * This field indicates the Tx DMA FSM state for Channel 2. This field is similar
 * to the TPS0 field.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS0_TPS2 register field. */
#define DMA_DEBUG_STATUS0_TPS2_LSB	  28
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS0_TPS2 register field. */
#define DMA_DEBUG_STATUS0_TPS2_MSB	  31
/* The width in bits of the DMA_DEBUG_STATUS0_TPS2 register field. */
#define DMA_DEBUG_STATUS0_TPS2_WIDTH	  4
/* The mask used to set the DMA_DEBUG_STATUS0_TPS2 register field value. */
#define DMA_DEBUG_STATUS0_TPS2_SET_MSK	  0xf0000000
/* The mask used to clear the DMA_DEBUG_STATUS0_TPS2 register field value. */
#define DMA_DEBUG_STATUS0_TPS2_CLR_MSK	  0x0fffffff
/* The reset value of the DMA_DEBUG_STATUS0_TPS2 register field. */
#define DMA_DEBUG_STATUS0_TPS2_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS0_TPS2 field value from a register. */
#define DMA_DEBUG_STATUS0_TPS2_GET(value) (((value)&0xf0000000) >> 28)
/* Produces a DMA_DEBUG_STATUS0_TPS2 register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS0_TPS2_SET(value) (((value) << 28) & 0xf0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_DEBUG_STATUS0.
 */
struct DMA_DEBUG_STATUS0_s {
	const volatile uint32_t AXWHSTS : 1;	  /* DMA_DEBUG_STATUS0_AXWHSTS */
	const volatile uint32_t AXRHSTS : 1;	  /* DMA_DEBUG_STATUS0_AXRHSTS */
	const volatile uint32_t Reserved_7_2 : 6; /* DMA_DEBUG_STATUS0_RESERVED_7_2 */
	const volatile uint32_t RPS0 : 4;	  /* DMA_DEBUG_STATUS0_RPS0 */
	const volatile uint32_t TPS0 : 4;	  /* DMA_DEBUG_STATUS0_TPS0 */
	const volatile uint32_t RPS1 : 4;	  /* DMA_DEBUG_STATUS0_RPS1 */
	const volatile uint32_t TPS1 : 4;	  /* DMA_DEBUG_STATUS0_TPS1 */
	const volatile uint32_t RPS2 : 4;	  /* DMA_DEBUG_STATUS0_RPS2 */
	const volatile uint32_t TPS2 : 4;	  /* DMA_DEBUG_STATUS0_TPS2 */
};

/* The typedef declaration for register DMA_DEBUG_STATUS0. */
typedef struct DMA_DEBUG_STATUS0_s DMA_DEBUG_STATUS0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_DEBUG_STATUS0 register. */
#define DMA_DEBUG_STATUS0_RESET 0x00000000
/* The byte offset of the DMA_DEBUG_STATUS0 register from the beginning of the component. */
#define DMA_DEBUG_STATUS0_OFST	0x20

/*
 * Register : DMA_Debug_Status1
 *
 * The Debug Status1 register gives the per Transmit DMA active status.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [7:0]  | R      | 0x0   | DMA_DEBUG_STATUS1_TDAS
 *  [31:8] | R      | 0x0   | DMA_DEBUG_STATUS1_RESERVED_31_X
 *
 */
/*
 * Field : TDAS
 *
 * Transmit DMA Active Status.
 *
 * When the bit is set to 1, the corresponding Transmit DMA FSMs are not idle, that
 * is, actively processing the descriptors or packet data.
 *
 * When the bit is set to 0, the corresponding Transmit DMA FSMs are in idle state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS1_TDAS register field. */
#define DMA_DEBUG_STATUS1_TDAS_LSB	  0
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS1_TDAS register field. */
#define DMA_DEBUG_STATUS1_TDAS_MSB	  7
/* The width in bits of the DMA_DEBUG_STATUS1_TDAS register field. */
#define DMA_DEBUG_STATUS1_TDAS_WIDTH	  8
/* The mask used to set the DMA_DEBUG_STATUS1_TDAS register field value. */
#define DMA_DEBUG_STATUS1_TDAS_SET_MSK	  0x000000ff
/* The mask used to clear the DMA_DEBUG_STATUS1_TDAS register field value. */
#define DMA_DEBUG_STATUS1_TDAS_CLR_MSK	  0xffffff00
/* The reset value of the DMA_DEBUG_STATUS1_TDAS register field. */
#define DMA_DEBUG_STATUS1_TDAS_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS1_TDAS field value from a register. */
#define DMA_DEBUG_STATUS1_TDAS_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_DEBUG_STATUS1_TDAS register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS1_TDAS_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_x
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS1_RESERVED_31_X register field.
 */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_LSB	   8
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS1_RESERVED_31_X register field. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_MSB	   31
/* The width in bits of the DMA_DEBUG_STATUS1_RESERVED_31_X register field. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_WIDTH	   24
/* The mask used to set the DMA_DEBUG_STATUS1_RESERVED_31_X register field value. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_SET_MSK	   0xffffff00
/* The mask used to clear the DMA_DEBUG_STATUS1_RESERVED_31_X register field value. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_CLR_MSK	   0x000000ff
/* The reset value of the DMA_DEBUG_STATUS1_RESERVED_31_X register field. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_RESET	   0x0
/* Extracts the DMA_DEBUG_STATUS1_RESERVED_31_X field value from a register. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_DEBUG_STATUS1_RESERVED_31_X register field value suitable for setting the
 * register. */
#define DMA_DEBUG_STATUS1_RESERVED_31_X_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_DEBUG_STATUS1.
 */
struct DMA_DEBUG_STATUS1_s {
	const volatile uint32_t TDAS : 8;	    /* DMA_DEBUG_STATUS1_TDAS */
	const volatile uint32_t Reserved_31_x : 24; /* DMA_DEBUG_STATUS1_RESERVED_31_X */
};

/* The typedef declaration for register DMA_DEBUG_STATUS1. */
typedef struct DMA_DEBUG_STATUS1_s DMA_DEBUG_STATUS1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_DEBUG_STATUS1 register. */
#define DMA_DEBUG_STATUS1_RESET 0x00000000
/* The byte offset of the DMA_DEBUG_STATUS1 register from the beginning of the component. */
#define DMA_DEBUG_STATUS1_OFST	0x24

/*
 * Register : DMA_Debug_Status3
 *
 * The Debug Status3 register gives the per Receive DMA active status.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:------------------------------------------------------
 *  [7:0]  | R      | 0x0   | DMA_DEBUG_STATUS3_RDAS
 *  [31:8] | R      | 0x0   | DMA_DEBUG_STATUS3_RESERVED_31_X
 *
 */
/*
 * Field : RDAS
 *
 * Receive DMA Active Status.
 *
 * When the bit is set to 1, the corresponding Receive DMA FSMs are not idle, that
 * is, actively processing the descriptors or packet data.
 *
 * When the bit is set to 0, the corresponding Receive DMA FSMs are in idle state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS3_RDAS register field. */
#define DMA_DEBUG_STATUS3_RDAS_LSB	  0
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS3_RDAS register field. */
#define DMA_DEBUG_STATUS3_RDAS_MSB	  7
/* The width in bits of the DMA_DEBUG_STATUS3_RDAS register field. */
#define DMA_DEBUG_STATUS3_RDAS_WIDTH	  8
/* The mask used to set the DMA_DEBUG_STATUS3_RDAS register field value. */
#define DMA_DEBUG_STATUS3_RDAS_SET_MSK	  0x000000ff
/* The mask used to clear the DMA_DEBUG_STATUS3_RDAS register field value. */
#define DMA_DEBUG_STATUS3_RDAS_CLR_MSK	  0xffffff00
/* The reset value of the DMA_DEBUG_STATUS3_RDAS register field. */
#define DMA_DEBUG_STATUS3_RDAS_RESET	  0x0
/* Extracts the DMA_DEBUG_STATUS3_RDAS field value from a register. */
#define DMA_DEBUG_STATUS3_RDAS_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_DEBUG_STATUS3_RDAS register field value suitable for setting the register. */
#define DMA_DEBUG_STATUS3_RDAS_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_x
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_DEBUG_STATUS3_RESERVED_31_X register field.
 */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_LSB	   8
/* The Most Significant Bit (MSB) position of the DMA_DEBUG_STATUS3_RESERVED_31_X register field. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_MSB	   31
/* The width in bits of the DMA_DEBUG_STATUS3_RESERVED_31_X register field. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_WIDTH	   24
/* The mask used to set the DMA_DEBUG_STATUS3_RESERVED_31_X register field value. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_SET_MSK	   0xffffff00
/* The mask used to clear the DMA_DEBUG_STATUS3_RESERVED_31_X register field value. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_CLR_MSK	   0x000000ff
/* The reset value of the DMA_DEBUG_STATUS3_RESERVED_31_X register field. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_RESET	   0x0
/* Extracts the DMA_DEBUG_STATUS3_RESERVED_31_X field value from a register. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_DEBUG_STATUS3_RESERVED_31_X register field value suitable for setting the
 * register. */
#define DMA_DEBUG_STATUS3_RESERVED_31_X_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_DEBUG_STATUS3.
 */
struct DMA_DEBUG_STATUS3_s {
	const volatile uint32_t RDAS : 8;	    /* DMA_DEBUG_STATUS3_RDAS */
	const volatile uint32_t Reserved_31_x : 24; /* DMA_DEBUG_STATUS3_RESERVED_31_X */
};

/* The typedef declaration for register DMA_DEBUG_STATUS3. */
typedef struct DMA_DEBUG_STATUS3_s DMA_DEBUG_STATUS3_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_DEBUG_STATUS3 register. */
#define DMA_DEBUG_STATUS3_RESET 0x00000000
/* The byte offset of the DMA_DEBUG_STATUS3 register from the beginning of the component. */
#define DMA_DEBUG_STATUS3_OFST	0x2c

/*
 * Register : DMA_Tx_EDMA_Control
 *
 * The DMA_Tx_EDMA_Control register controls the sequence of all TxDMA operations
 * with the DMA engine.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------
 *  [1:0]   | RW     | 0x0   | DMA_TX_EDMA_CONTROL_TDPS
 *  [29:2]  | R      | 0x0   | DMA_TX_EDMA_CONTROL_RESERVED_29_Y
 *  [31:30] | RW     | 0x0   | DMA_TX_EDMA_CONTROL_TEDM
 *
 */
/*
 * Field : TDPS
 *
 * Tx Descriptor Pre-fetch threshold Size.
 *
 * This field controls the threshold in the Descriptor cache after which the DMA
 * starts pre-fetching the TxDMA descriptors. The DMA engine for all TxDMA channels
 * initiate requests for the descriptor fetches as soon as the number of
 * descriptors in the cache memory for that DMA channel, falls below or equal to
 * the programmed threshold (each descriptor is 16 bytes).
 *
 * * 3'b000: Threshold of 0 descriptors. Descriptor pre-fetch is triggered only
 *   when cache is empty.
 *
 * * 3'b001: Threshold is 4 descriptors. Descriptor pre-fetch is triggered when 4
 *   descriptors are left in the cache.
 *
 * * 3'b010: Threshold is 8 descriptors. Descriptor pre-fetch is triggered when 8
 *   descriptors are left in the cache.
 *
 * * 3'b011: Threshold is 12 descriptors. Descriptor pre-fetch is triggered when 12
 *   descriptors are left in the cache.
 *
 * * 3'b100: Threshold is 16 descriptors. Descriptor pre-fetch is triggered when 16
 *   descriptors are left in the cache.
 *
 * * 3'b101: Threshold is 24 descriptors. Descriptor pre-fetch is triggered when 24
 *   descriptors are left in the cache.
 *
 * * 3'b110 - 3'b111: Reserved.
 *
 * Note1:  Bit 2 is reserved and RO when "Maximum Outstanding Read Burst Requests
 * for each Tx DMA Channel" is less than or equal to 8, that is TDPS value of 100
 * and 101 is not valid.
 *
 * Note2:  When "Maximum Outstanding Read Burst Requests for each Tx DMA Channel"
 * selected is 32 or 64, the above encoding represent Descriptor pre-fetch is
 * triggered when 2 times or 4 times the number of descriptors left in the cache.
 * For example, when "Maximum Outstanding Read Burst Requests for each Tx DMA
 * Channel" is 32 value of 3'b101 specifies that descriptor pre-fetch is triggered
 * when 48 (=2*24) descriptors are left in the cache.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TX_EDMA_CONTROL_TDPS register field. */
#define DMA_TX_EDMA_CONTROL_TDPS_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_TX_EDMA_CONTROL_TDPS register field. */
#define DMA_TX_EDMA_CONTROL_TDPS_MSB	    1
/* The width in bits of the DMA_TX_EDMA_CONTROL_TDPS register field. */
#define DMA_TX_EDMA_CONTROL_TDPS_WIDTH	    2
/* The mask used to set the DMA_TX_EDMA_CONTROL_TDPS register field value. */
#define DMA_TX_EDMA_CONTROL_TDPS_SET_MSK    0x00000003
/* The mask used to clear the DMA_TX_EDMA_CONTROL_TDPS register field value. */
#define DMA_TX_EDMA_CONTROL_TDPS_CLR_MSK    0xfffffffc
/* The reset value of the DMA_TX_EDMA_CONTROL_TDPS register field. */
#define DMA_TX_EDMA_CONTROL_TDPS_RESET	    0x0
/* Extracts the DMA_TX_EDMA_CONTROL_TDPS field value from a register. */
#define DMA_TX_EDMA_CONTROL_TDPS_GET(value) (((value)&0x00000003) >> 0)
/* Produces a DMA_TX_EDMA_CONTROL_TDPS register field value suitable for setting the register. */
#define DMA_TX_EDMA_CONTROL_TDPS_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : Reserved_29_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field.
 */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_LSB	     2
/* The Most Significant Bit (MSB) position of the DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field.
 */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_MSB	     29
/* The width in bits of the DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field. */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_WIDTH	     28
/* The mask used to set the DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field value. */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_SET_MSK    0x3ffffffc
/* The mask used to clear the DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field value. */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_CLR_MSK    0xc0000003
/* The reset value of the DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field. */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_RESET	     0x0
/* Extracts the DMA_TX_EDMA_CONTROL_RESERVED_29_Y field value from a register. */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_GET(value) (((value)&0x3ffffffc) >> 2)
/* Produces a DMA_TX_EDMA_CONTROL_RESERVED_29_Y register field value suitable for setting the
 * register. */
#define DMA_TX_EDMA_CONTROL_RESERVED_29_Y_SET(value) (((value) << 2) & 0x3ffffffc)

/*
 * Field : TEDM
 *
 * Tx DMA Mode.
 *
 * This field controls the sequence of descriptor and data transfers in the DMA
 * engine for all TxDMA channels is as follows:
 *
 * * 2'b00: Default mode of DMA, in which all transfers are independently triggered
 *   and can occur in parallel. This gives you the best performance. Use the other
 *   modes only for debug purposes.
 *
 * * 2'b01: The value of TDPS field is ignored and only one Descriptor is fetched
 *   at a time from the System Memory. The next descriptor is fetched only after
 *   the current descriptor is accepted by Data Transfer Engine. The Data transfer,
 *   Descriptor close and the next descriptor fetch can still occur in parallel.
 *
 * * 2'b10: The value of TDPS field is ignored and only one Descriptor is fetched
 *   at a time from the System Memory. The next descriptor is fetched only after
 *   the data transfer corresponding to current descriptor is completed. The
 *   Descriptor close and the next descriptor fetch can still happen in parallel.
 *
 * * 2'b11: All operations are sequential. Descriptor is fetched, data transfer is
 *   completed, descriptor is closed and then only the next descriptor is fetched.
 *   The value of TDPS is ignored in this mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TX_EDMA_CONTROL_TEDM register field. */
#define DMA_TX_EDMA_CONTROL_TEDM_LSB	    30
/* The Most Significant Bit (MSB) position of the DMA_TX_EDMA_CONTROL_TEDM register field. */
#define DMA_TX_EDMA_CONTROL_TEDM_MSB	    31
/* The width in bits of the DMA_TX_EDMA_CONTROL_TEDM register field. */
#define DMA_TX_EDMA_CONTROL_TEDM_WIDTH	    2
/* The mask used to set the DMA_TX_EDMA_CONTROL_TEDM register field value. */
#define DMA_TX_EDMA_CONTROL_TEDM_SET_MSK    0xc0000000
/* The mask used to clear the DMA_TX_EDMA_CONTROL_TEDM register field value. */
#define DMA_TX_EDMA_CONTROL_TEDM_CLR_MSK    0x3fffffff
/* The reset value of the DMA_TX_EDMA_CONTROL_TEDM register field. */
#define DMA_TX_EDMA_CONTROL_TEDM_RESET	    0x0
/* Extracts the DMA_TX_EDMA_CONTROL_TEDM field value from a register. */
#define DMA_TX_EDMA_CONTROL_TEDM_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a DMA_TX_EDMA_CONTROL_TEDM register field value suitable for setting the register. */
#define DMA_TX_EDMA_CONTROL_TEDM_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_TX_EDMA_CONTROL.
 */
struct DMA_TX_EDMA_CONTROL_s {
	volatile uint32_t TDPS : 2;		    /* DMA_TX_EDMA_CONTROL_TDPS */
	const volatile uint32_t Reserved_29_y : 28; /* DMA_TX_EDMA_CONTROL_RESERVED_29_Y */
	volatile uint32_t TEDM : 2;		    /* DMA_TX_EDMA_CONTROL_TEDM */
};

/* The typedef declaration for register DMA_TX_EDMA_CONTROL. */
typedef struct DMA_TX_EDMA_CONTROL_s DMA_TX_EDMA_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_TX_EDMA_CONTROL register. */
#define DMA_TX_EDMA_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_TX_EDMA_CONTROL register from the beginning of the component. */
#define DMA_TX_EDMA_CONTROL_OFST  0x40

/*
 * Register : DMA_Rx_EDMA_Control
 *
 * The DMA_Rx_EDMA_Control register controls the sequence of all RxDMA operations
 * with the DMA engine.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------
 *  [1:0]   | RW     | 0x0   | DMA_RX_EDMA_CONTROL_RDPS
 *  [29:2]  | R      | 0x0   | DMA_RX_EDMA_CONTROL_RESERVED_29_Y
 *  [31:30] | RW     | 0x0   | DMA_RX_EDMA_CONTROL_REDM
 *
 */
/*
 * Field : RDPS
 *
 * Rx Descriptor Pre-Fetch Threshold Size.
 *
 * This field controls the threshold in the Descriptor cache after which the DMA
 * starts pre-fetching the RxDMA descriptors. The DMA engine for all RxDMA channels
 * initiate requests for the descriptor fetches as soon as the number of
 * descriptors in the cache memory for that DMA channel, falls lower than or equal
 * to the programmed threshold (each descriptor is 16 bytes).
 *
 * * 3'b000: Threshold of 0 descriptors. Descriptor pre-fetch is triggered only
 *   when cache is empty.
 *
 * * 3'b001: Threshold is 4 descriptors. Descriptor pre-fetch is triggered when 4
 *   descriptors are left in the cache.
 *
 * * 3'b010: Threshold is 8 descriptors. Descriptor pre-fetch is triggered when 8
 *   descriptors are left in the cache.
 *
 * * 3'b011: Threshold is 12 descriptors. Descriptor pre-fetch is triggered when 12
 *   descriptors are left in the cache.
 *
 * * 3'b100: Threshold is 16 descriptors. Descriptor pre-fetch is triggered when 16
 *   descriptors are left in the cache.
 *
 * * 3'b101: Threshold is 24 descriptors. Descriptor pre-fetch is triggered when 24
 *   descriptors are left in the cache.
 *
 * * 3'b110-3'b111: Reserved.
 *
 * Note1:  Bit 2 is reserved and RO when "Maximum Outstanding Write Burst Requests
 * for each Rx DMA Channel" is less than or equal to 8, that is RDPS value of 100
 * and 101 is not valid.
 *
 * Note2:  When "Maximum Outstanding Write Burst Requests for each Rx DMA Channel"
 * selected is 32 or 64, the above encoding represent Descriptor pre-fetch is
 * triggered when 2 times or 4 times the number of descriptors left in the cache.
 * For example, when "Maximum Outstanding Write Burst Requests for each Rx DMA
 * Channel" is 32 value of 3'b101 specifies that descriptor pre-fetch is triggered
 * when 48 (=2*24) descriptors are left in the cache.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_RX_EDMA_CONTROL_RDPS register field. */
#define DMA_RX_EDMA_CONTROL_RDPS_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_RX_EDMA_CONTROL_RDPS register field. */
#define DMA_RX_EDMA_CONTROL_RDPS_MSB	    1
/* The width in bits of the DMA_RX_EDMA_CONTROL_RDPS register field. */
#define DMA_RX_EDMA_CONTROL_RDPS_WIDTH	    2
/* The mask used to set the DMA_RX_EDMA_CONTROL_RDPS register field value. */
#define DMA_RX_EDMA_CONTROL_RDPS_SET_MSK    0x00000003
/* The mask used to clear the DMA_RX_EDMA_CONTROL_RDPS register field value. */
#define DMA_RX_EDMA_CONTROL_RDPS_CLR_MSK    0xfffffffc
/* The reset value of the DMA_RX_EDMA_CONTROL_RDPS register field. */
#define DMA_RX_EDMA_CONTROL_RDPS_RESET	    0x0
/* Extracts the DMA_RX_EDMA_CONTROL_RDPS field value from a register. */
#define DMA_RX_EDMA_CONTROL_RDPS_GET(value) (((value)&0x00000003) >> 0)
/* Produces a DMA_RX_EDMA_CONTROL_RDPS register field value suitable for setting the register. */
#define DMA_RX_EDMA_CONTROL_RDPS_SET(value) (((value) << 0) & 0x00000003)

/*
 * Field : Reserved_29_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field.
 */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_LSB	     2
/* The Most Significant Bit (MSB) position of the DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field.
 */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_MSB	     29
/* The width in bits of the DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field. */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_WIDTH	     28
/* The mask used to set the DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field value. */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_SET_MSK    0x3ffffffc
/* The mask used to clear the DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field value. */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_CLR_MSK    0xc0000003
/* The reset value of the DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field. */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_RESET	     0x0
/* Extracts the DMA_RX_EDMA_CONTROL_RESERVED_29_Y field value from a register. */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_GET(value) (((value)&0x3ffffffc) >> 2)
/* Produces a DMA_RX_EDMA_CONTROL_RESERVED_29_Y register field value suitable for setting the
 * register. */
#define DMA_RX_EDMA_CONTROL_RESERVED_29_Y_SET(value) (((value) << 2) & 0x3ffffffc)

/*
 * Field : REDM
 *
 * Rx DMA Mode.
 *
 * This field controls the sequence of descriptor and data transfers in the DMA
 * engine for all RxDMA channels:
 *
 * * 2'b00: Default mode of DMA as explained in section 2.4.8 in which all
 *   transfers are independently triggered and can occur in parallel. This gives
 *   you the best performance. Use the other modes only for debug purposes.
 *
 * * 2'b01: The value of RDPS field is ignored and only 1 Descriptor is fetched at
 *   a time from the System Memory. The next descriptor is fetched only after the
 *   current descriptor is accepted by Data Transfer Engine. The Data transfer,
 *   Descriptor close and the next descriptor fetch can still happen in parallel.
 *
 * * 2'b10: The value of RDPS field is ignored and only 1 Descriptor is fetched at
 *   a time from the System Memory. The next descriptor is fetched only after the
 *   data transfer corresponding to current descriptor is completed. The Descriptor
 *   close and the next descriptor fetch can still happen in parallel.
 *
 * * 2'b11: All operations are sequential. Descriptor is fetched, data transfer is
 *   completed, descriptor is closed; then the next descriptor is fetched. The
 *   value of RDPS is ignored in this mode.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_RX_EDMA_CONTROL_REDM register field. */
#define DMA_RX_EDMA_CONTROL_REDM_LSB	    30
/* The Most Significant Bit (MSB) position of the DMA_RX_EDMA_CONTROL_REDM register field. */
#define DMA_RX_EDMA_CONTROL_REDM_MSB	    31
/* The width in bits of the DMA_RX_EDMA_CONTROL_REDM register field. */
#define DMA_RX_EDMA_CONTROL_REDM_WIDTH	    2
/* The mask used to set the DMA_RX_EDMA_CONTROL_REDM register field value. */
#define DMA_RX_EDMA_CONTROL_REDM_SET_MSK    0xc0000000
/* The mask used to clear the DMA_RX_EDMA_CONTROL_REDM register field value. */
#define DMA_RX_EDMA_CONTROL_REDM_CLR_MSK    0x3fffffff
/* The reset value of the DMA_RX_EDMA_CONTROL_REDM register field. */
#define DMA_RX_EDMA_CONTROL_REDM_RESET	    0x0
/* Extracts the DMA_RX_EDMA_CONTROL_REDM field value from a register. */
#define DMA_RX_EDMA_CONTROL_REDM_GET(value) (((value)&0xc0000000) >> 30)
/* Produces a DMA_RX_EDMA_CONTROL_REDM register field value suitable for setting the register. */
#define DMA_RX_EDMA_CONTROL_REDM_SET(value) (((value) << 30) & 0xc0000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_RX_EDMA_CONTROL.
 */
struct DMA_RX_EDMA_CONTROL_s {
	volatile uint32_t RDPS : 2;		    /* DMA_RX_EDMA_CONTROL_RDPS */
	const volatile uint32_t Reserved_29_y : 28; /* DMA_RX_EDMA_CONTROL_RESERVED_29_Y */
	volatile uint32_t REDM : 2;		    /* DMA_RX_EDMA_CONTROL_REDM */
};

/* The typedef declaration for register DMA_RX_EDMA_CONTROL. */
typedef struct DMA_RX_EDMA_CONTROL_s DMA_RX_EDMA_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_RX_EDMA_CONTROL register. */
#define DMA_RX_EDMA_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_RX_EDMA_CONTROL register from the beginning of the component. */
#define DMA_RX_EDMA_CONTROL_OFST  0x44

/*
 * Register : AXI_LPI_Entry_Interval
 *
 * This register is used to control the AXI LPI entry interval.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------
 *  [3:0]  | RW     | 0x0   | DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI
 *  [31:4] | R      | 0x0   | DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4
 *
 */
/*
 * Field : LPIEI
 *
 * LPI Entry Interval
 *
 * This field contains the number of system clock cycles, multiplied by 256, to
 * wait for an activity in DWC_xgmac to enter into the AXI low-power state, 0
 * indicates 256 clock cycles.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field.
 */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field.
 */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_MSB	    3
/* The width in bits of the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_WIDTH	    4
/* The mask used to set the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field value. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_SET_MSK    0x0000000f
/* The mask used to clear the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field value. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_CLR_MSK    0xfffffff0
/* The reset value of the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_RESET	    0x0
/* Extracts the DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI field value from a register. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_GET(value) (((value)&0x0000000f) >> 0)
/* Produces a DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI register field value suitable for setting the
 * register. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_SET(value) (((value) << 0) & 0x0000000f)

/*
 * Field : Reserved_31_4
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register
 * field. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_LSB	    4
/* The Most Significant Bit (MSB) position of the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register
 * field. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_MSB	    31
/* The width in bits of the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register field. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_WIDTH	    28
/* The mask used to set the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register field value. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_SET_MSK    0xfffffff0
/* The mask used to clear the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register field value. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_CLR_MSK    0x0000000f
/* The reset value of the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register field. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_RESET	    0x0
/* Extracts the DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 field value from a register. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_GET(value) (((value)&0xfffffff0) >> 4)
/* Produces a DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 register field value suitable for setting the
 * register. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4_SET(value) (((value) << 4) & 0xfffffff0)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_AXI_LPI_ENTRY_INTERVAL.
 */
struct DMA_AXI_LPI_ENTRY_INTERVAL_s {
	volatile uint32_t LPIEI : 4;		    /* DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI */
	const volatile uint32_t Reserved_31_4 : 28; /* DMA_AXI_LPI_ENTRY_INTERVAL_RESERVED_31_4 */
};

/* The typedef declaration for register DMA_AXI_LPI_ENTRY_INTERVAL. */
typedef struct DMA_AXI_LPI_ENTRY_INTERVAL_s DMA_AXI_LPI_ENTRY_INTERVAL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_AXI_LPI_ENTRY_INTERVAL register. */
#define DMA_AXI_LPI_ENTRY_INTERVAL_RESET 0x00000000
/* The byte offset of the DMA_AXI_LPI_ENTRY_INTERVAL register from the beginning of the component.
 */
#define DMA_AXI_LPI_ENTRY_INTERVAL_OFST	 0x50

/*
 * Register : DMA_TBS_CTRL0
 *
 * This register is used to control the TBS0 attributes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [0]    | RW     | 0x0   | DMA_TBS_CTRL0_FTOV
 *  [3:1]  | R      | 0x0   | DMA_TBS_CTRL0_RESERVED_3_1
 *  [6:4]  | RW     | 0x0   | DMA_TBS_CTRL0_FGOS
 *  [7]    | R      | 0x0   | DMA_TBS_CTRL0_RESERVED_7
 *  [31:8] | RW     | 0x0   | DMA_TBS_CTRL0_FTOS
 *
 */
/*
 * Field : FTOV
 *
 * Fetch Time Offset 0 Valid
 *
 * When set indicates the FTOS field is valid. When not set, indicates the Fetch
 * Offset is not valid and the DMA engine can fetch the frames from host memory
 * without any time restrictions.
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:-----------------------------
 *  DMA_TBS_CTRL0_FTOV_E_INVALID | 0x0   | Fetch Time Offset is invalid
 *  DMA_TBS_CTRL0_FTOV_E_VALID   | 0x1   | Fetch Time Offset is valid
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field DMA_TBS_CTRL0_FTOV
 *
 * Fetch Time Offset is invalid
 */
#define DMA_TBS_CTRL0_FTOV_E_INVALID 0x0
/*
 * Enumerated value for register field DMA_TBS_CTRL0_FTOV
 *
 * Fetch Time Offset is valid
 */
#define DMA_TBS_CTRL0_FTOV_E_VALID   0x1

/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL0_FTOV register field. */
#define DMA_TBS_CTRL0_FTOV_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL0_FTOV register field. */
#define DMA_TBS_CTRL0_FTOV_MSB	      0
/* The width in bits of the DMA_TBS_CTRL0_FTOV register field. */
#define DMA_TBS_CTRL0_FTOV_WIDTH      1
/* The mask used to set the DMA_TBS_CTRL0_FTOV register field value. */
#define DMA_TBS_CTRL0_FTOV_SET_MSK    0x00000001
/* The mask used to clear the DMA_TBS_CTRL0_FTOV register field value. */
#define DMA_TBS_CTRL0_FTOV_CLR_MSK    0xfffffffe
/* The reset value of the DMA_TBS_CTRL0_FTOV register field. */
#define DMA_TBS_CTRL0_FTOV_RESET      0x0
/* Extracts the DMA_TBS_CTRL0_FTOV field value from a register. */
#define DMA_TBS_CTRL0_FTOV_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_TBS_CTRL0_FTOV register field value suitable for setting the register. */
#define DMA_TBS_CTRL0_FTOV_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL0_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL0_RESERVED_3_1_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL0_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL0_RESERVED_3_1_MSB	      3
/* The width in bits of the DMA_TBS_CTRL0_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL0_RESERVED_3_1_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL0_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL0_RESERVED_3_1_SET_MSK    0x0000000e
/* The mask used to clear the DMA_TBS_CTRL0_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL0_RESERVED_3_1_CLR_MSK    0xfffffff1
/* The reset value of the DMA_TBS_CTRL0_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL0_RESERVED_3_1_RESET      0x0
/* Extracts the DMA_TBS_CTRL0_RESERVED_3_1 field value from a register. */
#define DMA_TBS_CTRL0_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_TBS_CTRL0_RESERVED_3_1 register field value suitable for setting the register. */
#define DMA_TBS_CTRL0_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : FGOS
 *
 * Fetch GSN Offset 0
 *
 * The number of GSN slots that must be deducted from the Launch GSN to compute the
 * Fetch GSN. Value valid only when FTOV is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL0_FGOS register field. */
#define DMA_TBS_CTRL0_FGOS_LSB	      4
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL0_FGOS register field. */
#define DMA_TBS_CTRL0_FGOS_MSB	      6
/* The width in bits of the DMA_TBS_CTRL0_FGOS register field. */
#define DMA_TBS_CTRL0_FGOS_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL0_FGOS register field value. */
#define DMA_TBS_CTRL0_FGOS_SET_MSK    0x00000070
/* The mask used to clear the DMA_TBS_CTRL0_FGOS register field value. */
#define DMA_TBS_CTRL0_FGOS_CLR_MSK    0xffffff8f
/* The reset value of the DMA_TBS_CTRL0_FGOS register field. */
#define DMA_TBS_CTRL0_FGOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL0_FGOS field value from a register. */
#define DMA_TBS_CTRL0_FGOS_GET(value) (((value)&0x00000070) >> 4)
/* Produces a DMA_TBS_CTRL0_FGOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL0_FGOS_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL0_RESERVED_7 register field. */
#define DMA_TBS_CTRL0_RESERVED_7_LSB	    7
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL0_RESERVED_7 register field. */
#define DMA_TBS_CTRL0_RESERVED_7_MSB	    7
/* The width in bits of the DMA_TBS_CTRL0_RESERVED_7 register field. */
#define DMA_TBS_CTRL0_RESERVED_7_WIDTH	    1
/* The mask used to set the DMA_TBS_CTRL0_RESERVED_7 register field value. */
#define DMA_TBS_CTRL0_RESERVED_7_SET_MSK    0x00000080
/* The mask used to clear the DMA_TBS_CTRL0_RESERVED_7 register field value. */
#define DMA_TBS_CTRL0_RESERVED_7_CLR_MSK    0xffffff7f
/* The reset value of the DMA_TBS_CTRL0_RESERVED_7 register field. */
#define DMA_TBS_CTRL0_RESERVED_7_RESET	    0x0
/* Extracts the DMA_TBS_CTRL0_RESERVED_7 field value from a register. */
#define DMA_TBS_CTRL0_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_TBS_CTRL0_RESERVED_7 register field value suitable for setting the register. */
#define DMA_TBS_CTRL0_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : FTOS
 *
 * Fetch Time Offset 0
 *
 * * The value in units of 256 ns must be deducted from the Launch time to compute
 *   the Fetch Time.
 *
 * * Max value: 999,999,999 ns. Also, this must be smaller than CTR-1 value when
 *   ESTM mode is set, as this value is a modulo CTR value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL0_FTOS register field. */
#define DMA_TBS_CTRL0_FTOS_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL0_FTOS register field. */
#define DMA_TBS_CTRL0_FTOS_MSB	      31
/* The width in bits of the DMA_TBS_CTRL0_FTOS register field. */
#define DMA_TBS_CTRL0_FTOS_WIDTH      24
/* The mask used to set the DMA_TBS_CTRL0_FTOS register field value. */
#define DMA_TBS_CTRL0_FTOS_SET_MSK    0xffffff00
/* The mask used to clear the DMA_TBS_CTRL0_FTOS register field value. */
#define DMA_TBS_CTRL0_FTOS_CLR_MSK    0x000000ff
/* The reset value of the DMA_TBS_CTRL0_FTOS register field. */
#define DMA_TBS_CTRL0_FTOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL0_FTOS field value from a register. */
#define DMA_TBS_CTRL0_FTOS_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_TBS_CTRL0_FTOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL0_FTOS_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_TBS_CTRL0.
 */
struct DMA_TBS_CTRL0_s {
	volatile uint32_t FTOV : 1;		  /* DMA_TBS_CTRL0_FTOV */
	const volatile uint32_t Reserved_3_1 : 3; /* DMA_TBS_CTRL0_RESERVED_3_1 */
	volatile uint32_t FGOS : 3;		  /* DMA_TBS_CTRL0_FGOS */
	const volatile uint32_t Reserved_7 : 1;	  /* DMA_TBS_CTRL0_RESERVED_7 */
	volatile uint32_t FTOS : 24;		  /* DMA_TBS_CTRL0_FTOS */
};

/* The typedef declaration for register DMA_TBS_CTRL0. */
typedef struct DMA_TBS_CTRL0_s DMA_TBS_CTRL0_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_TBS_CTRL0 register. */
#define DMA_TBS_CTRL0_RESET 0x00000000
/* The byte offset of the DMA_TBS_CTRL0 register from the beginning of the component. */
#define DMA_TBS_CTRL0_OFST  0x54

/*
 * Register : DMA_TBS_CTRL1
 *
 * This register is used to control the TBS1 attributes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [0]    | RW     | 0x0   | DMA_TBS_CTRL1_FTOV
 *  [3:1]  | R      | 0x0   | DMA_TBS_CTRL1_RESERVED_3_1
 *  [6:4]  | RW     | 0x0   | DMA_TBS_CTRL1_FGOS
 *  [7]    | R      | 0x0   | DMA_TBS_CTRL1_RESERVED_7
 *  [31:8] | RW     | 0x0   | DMA_TBS_CTRL1_FTOS
 *
 */
/*
 * Field : FTOV
 *
 * Fetch Time Offset 1 Valid
 *
 * When set indicates the FTOS field is valid. When not set, indicates the Fetch
 * Offset is not valid and the DMA engine can fetch the frames from host memory
 * without any time restrictions.
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:-----------------------------
 *  DMA_TBS_CTRL1_FTOV_E_INVALID | 0x0   | Fetch Time Offset is invalid
 *  DMA_TBS_CTRL1_FTOV_E_VALID   | 0x1   | Fetch Time Offset is valid
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field DMA_TBS_CTRL1_FTOV
 *
 * Fetch Time Offset is invalid
 */
#define DMA_TBS_CTRL1_FTOV_E_INVALID 0x0
/*
 * Enumerated value for register field DMA_TBS_CTRL1_FTOV
 *
 * Fetch Time Offset is valid
 */
#define DMA_TBS_CTRL1_FTOV_E_VALID   0x1

/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL1_FTOV register field. */
#define DMA_TBS_CTRL1_FTOV_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL1_FTOV register field. */
#define DMA_TBS_CTRL1_FTOV_MSB	      0
/* The width in bits of the DMA_TBS_CTRL1_FTOV register field. */
#define DMA_TBS_CTRL1_FTOV_WIDTH      1
/* The mask used to set the DMA_TBS_CTRL1_FTOV register field value. */
#define DMA_TBS_CTRL1_FTOV_SET_MSK    0x00000001
/* The mask used to clear the DMA_TBS_CTRL1_FTOV register field value. */
#define DMA_TBS_CTRL1_FTOV_CLR_MSK    0xfffffffe
/* The reset value of the DMA_TBS_CTRL1_FTOV register field. */
#define DMA_TBS_CTRL1_FTOV_RESET      0x0
/* Extracts the DMA_TBS_CTRL1_FTOV field value from a register. */
#define DMA_TBS_CTRL1_FTOV_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_TBS_CTRL1_FTOV register field value suitable for setting the register. */
#define DMA_TBS_CTRL1_FTOV_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL1_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL1_RESERVED_3_1_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL1_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL1_RESERVED_3_1_MSB	      3
/* The width in bits of the DMA_TBS_CTRL1_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL1_RESERVED_3_1_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL1_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL1_RESERVED_3_1_SET_MSK    0x0000000e
/* The mask used to clear the DMA_TBS_CTRL1_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL1_RESERVED_3_1_CLR_MSK    0xfffffff1
/* The reset value of the DMA_TBS_CTRL1_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL1_RESERVED_3_1_RESET      0x0
/* Extracts the DMA_TBS_CTRL1_RESERVED_3_1 field value from a register. */
#define DMA_TBS_CTRL1_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_TBS_CTRL1_RESERVED_3_1 register field value suitable for setting the register. */
#define DMA_TBS_CTRL1_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : FGOS
 *
 * Fetch GSN Offset 1
 *
 * The number of GSN slots that must be deducted from the Launch GSN to compute the
 * Fetch GSN. Value valid only when FTOV is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL1_FGOS register field. */
#define DMA_TBS_CTRL1_FGOS_LSB	      4
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL1_FGOS register field. */
#define DMA_TBS_CTRL1_FGOS_MSB	      6
/* The width in bits of the DMA_TBS_CTRL1_FGOS register field. */
#define DMA_TBS_CTRL1_FGOS_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL1_FGOS register field value. */
#define DMA_TBS_CTRL1_FGOS_SET_MSK    0x00000070
/* The mask used to clear the DMA_TBS_CTRL1_FGOS register field value. */
#define DMA_TBS_CTRL1_FGOS_CLR_MSK    0xffffff8f
/* The reset value of the DMA_TBS_CTRL1_FGOS register field. */
#define DMA_TBS_CTRL1_FGOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL1_FGOS field value from a register. */
#define DMA_TBS_CTRL1_FGOS_GET(value) (((value)&0x00000070) >> 4)
/* Produces a DMA_TBS_CTRL1_FGOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL1_FGOS_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL1_RESERVED_7 register field. */
#define DMA_TBS_CTRL1_RESERVED_7_LSB	    7
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL1_RESERVED_7 register field. */
#define DMA_TBS_CTRL1_RESERVED_7_MSB	    7
/* The width in bits of the DMA_TBS_CTRL1_RESERVED_7 register field. */
#define DMA_TBS_CTRL1_RESERVED_7_WIDTH	    1
/* The mask used to set the DMA_TBS_CTRL1_RESERVED_7 register field value. */
#define DMA_TBS_CTRL1_RESERVED_7_SET_MSK    0x00000080
/* The mask used to clear the DMA_TBS_CTRL1_RESERVED_7 register field value. */
#define DMA_TBS_CTRL1_RESERVED_7_CLR_MSK    0xffffff7f
/* The reset value of the DMA_TBS_CTRL1_RESERVED_7 register field. */
#define DMA_TBS_CTRL1_RESERVED_7_RESET	    0x0
/* Extracts the DMA_TBS_CTRL1_RESERVED_7 field value from a register. */
#define DMA_TBS_CTRL1_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_TBS_CTRL1_RESERVED_7 register field value suitable for setting the register. */
#define DMA_TBS_CTRL1_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : FTOS
 *
 * Fetch Time Offset 1
 *
 * * The value in units of 256 ns, that must be deducted from the Launch time to
 *   compute the Fetch Time.
 *
 * * Max value: 999,999,999 ns. Also, this must be smaller than CTR-1 value when
 *   ESTM mode is set, as this value is a modulo CTR value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL1_FTOS register field. */
#define DMA_TBS_CTRL1_FTOS_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL1_FTOS register field. */
#define DMA_TBS_CTRL1_FTOS_MSB	      31
/* The width in bits of the DMA_TBS_CTRL1_FTOS register field. */
#define DMA_TBS_CTRL1_FTOS_WIDTH      24
/* The mask used to set the DMA_TBS_CTRL1_FTOS register field value. */
#define DMA_TBS_CTRL1_FTOS_SET_MSK    0xffffff00
/* The mask used to clear the DMA_TBS_CTRL1_FTOS register field value. */
#define DMA_TBS_CTRL1_FTOS_CLR_MSK    0x000000ff
/* The reset value of the DMA_TBS_CTRL1_FTOS register field. */
#define DMA_TBS_CTRL1_FTOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL1_FTOS field value from a register. */
#define DMA_TBS_CTRL1_FTOS_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_TBS_CTRL1_FTOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL1_FTOS_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_TBS_CTRL1.
 */
struct DMA_TBS_CTRL1_s {
	volatile uint32_t FTOV : 1;		  /* DMA_TBS_CTRL1_FTOV */
	const volatile uint32_t Reserved_3_1 : 3; /* DMA_TBS_CTRL1_RESERVED_3_1 */
	volatile uint32_t FGOS : 3;		  /* DMA_TBS_CTRL1_FGOS */
	const volatile uint32_t Reserved_7 : 1;	  /* DMA_TBS_CTRL1_RESERVED_7 */
	volatile uint32_t FTOS : 24;		  /* DMA_TBS_CTRL1_FTOS */
};

/* The typedef declaration for register DMA_TBS_CTRL1. */
typedef struct DMA_TBS_CTRL1_s DMA_TBS_CTRL1_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_TBS_CTRL1 register. */
#define DMA_TBS_CTRL1_RESET 0x00000000
/* The byte offset of the DMA_TBS_CTRL1 register from the beginning of the component. */
#define DMA_TBS_CTRL1_OFST  0x58

/*
 * Register : DMA_TBS_CTRL2
 *
 * This register is used to control the TBS2 attributes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [0]    | RW     | 0x0   | DMA_TBS_CTRL2_FTOV
 *  [3:1]  | R      | 0x0   | DMA_TBS_CTRL2_RESERVED_3_1
 *  [6:4]  | RW     | 0x0   | DMA_TBS_CTRL2_FGOS
 *  [7]    | R      | 0x0   | DMA_TBS_CTRL2_RESERVED_7
 *  [31:8] | RW     | 0x0   | DMA_TBS_CTRL2_FTOS
 *
 */
/*
 * Field : FTOV
 *
 * Fetch Time Offset 2 Valid
 *
 * When set indicates the FTOS field is valid. When not set, indicates the Fetch
 * Offset is not valid and the DMA engine can fetch the frames from host memory
 * without any time restrictions.
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:-----------------------------
 *  DMA_TBS_CTRL2_FTOV_E_INVALID | 0x0   | Fetch Time Offset is invalid
 *  DMA_TBS_CTRL2_FTOV_E_VALID   | 0x1   | Fetch Time Offset is valid
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field DMA_TBS_CTRL2_FTOV
 *
 * Fetch Time Offset is invalid
 */
#define DMA_TBS_CTRL2_FTOV_E_INVALID 0x0
/*
 * Enumerated value for register field DMA_TBS_CTRL2_FTOV
 *
 * Fetch Time Offset is valid
 */
#define DMA_TBS_CTRL2_FTOV_E_VALID   0x1

/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL2_FTOV register field. */
#define DMA_TBS_CTRL2_FTOV_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL2_FTOV register field. */
#define DMA_TBS_CTRL2_FTOV_MSB	      0
/* The width in bits of the DMA_TBS_CTRL2_FTOV register field. */
#define DMA_TBS_CTRL2_FTOV_WIDTH      1
/* The mask used to set the DMA_TBS_CTRL2_FTOV register field value. */
#define DMA_TBS_CTRL2_FTOV_SET_MSK    0x00000001
/* The mask used to clear the DMA_TBS_CTRL2_FTOV register field value. */
#define DMA_TBS_CTRL2_FTOV_CLR_MSK    0xfffffffe
/* The reset value of the DMA_TBS_CTRL2_FTOV register field. */
#define DMA_TBS_CTRL2_FTOV_RESET      0x0
/* Extracts the DMA_TBS_CTRL2_FTOV field value from a register. */
#define DMA_TBS_CTRL2_FTOV_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_TBS_CTRL2_FTOV register field value suitable for setting the register. */
#define DMA_TBS_CTRL2_FTOV_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL2_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL2_RESERVED_3_1_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL2_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL2_RESERVED_3_1_MSB	      3
/* The width in bits of the DMA_TBS_CTRL2_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL2_RESERVED_3_1_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL2_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL2_RESERVED_3_1_SET_MSK    0x0000000e
/* The mask used to clear the DMA_TBS_CTRL2_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL2_RESERVED_3_1_CLR_MSK    0xfffffff1
/* The reset value of the DMA_TBS_CTRL2_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL2_RESERVED_3_1_RESET      0x0
/* Extracts the DMA_TBS_CTRL2_RESERVED_3_1 field value from a register. */
#define DMA_TBS_CTRL2_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_TBS_CTRL2_RESERVED_3_1 register field value suitable for setting the register. */
#define DMA_TBS_CTRL2_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : FGOS
 *
 * Fetch GSN Offset 2
 *
 * The number of GSN slots that must be deducted from the Launch GSN to compute the
 * Fetch GSN. Value valid only when FTOV is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL2_FGOS register field. */
#define DMA_TBS_CTRL2_FGOS_LSB	      4
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL2_FGOS register field. */
#define DMA_TBS_CTRL2_FGOS_MSB	      6
/* The width in bits of the DMA_TBS_CTRL2_FGOS register field. */
#define DMA_TBS_CTRL2_FGOS_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL2_FGOS register field value. */
#define DMA_TBS_CTRL2_FGOS_SET_MSK    0x00000070
/* The mask used to clear the DMA_TBS_CTRL2_FGOS register field value. */
#define DMA_TBS_CTRL2_FGOS_CLR_MSK    0xffffff8f
/* The reset value of the DMA_TBS_CTRL2_FGOS register field. */
#define DMA_TBS_CTRL2_FGOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL2_FGOS field value from a register. */
#define DMA_TBS_CTRL2_FGOS_GET(value) (((value)&0x00000070) >> 4)
/* Produces a DMA_TBS_CTRL2_FGOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL2_FGOS_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL2_RESERVED_7 register field. */
#define DMA_TBS_CTRL2_RESERVED_7_LSB	    7
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL2_RESERVED_7 register field. */
#define DMA_TBS_CTRL2_RESERVED_7_MSB	    7
/* The width in bits of the DMA_TBS_CTRL2_RESERVED_7 register field. */
#define DMA_TBS_CTRL2_RESERVED_7_WIDTH	    1
/* The mask used to set the DMA_TBS_CTRL2_RESERVED_7 register field value. */
#define DMA_TBS_CTRL2_RESERVED_7_SET_MSK    0x00000080
/* The mask used to clear the DMA_TBS_CTRL2_RESERVED_7 register field value. */
#define DMA_TBS_CTRL2_RESERVED_7_CLR_MSK    0xffffff7f
/* The reset value of the DMA_TBS_CTRL2_RESERVED_7 register field. */
#define DMA_TBS_CTRL2_RESERVED_7_RESET	    0x0
/* Extracts the DMA_TBS_CTRL2_RESERVED_7 field value from a register. */
#define DMA_TBS_CTRL2_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_TBS_CTRL2_RESERVED_7 register field value suitable for setting the register. */
#define DMA_TBS_CTRL2_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : FTOS
 *
 * Fetch Time Offset 2
 *
 * The value in units of 256 ns, that must be deducted from the Launch time to
 * compute the Fetch Time.
 *
 * Max value: 999,999,999 ns. This must be smaller than CTR-1 value when ESTM mode
 * is set, as this value is a modulo CTR value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL2_FTOS register field. */
#define DMA_TBS_CTRL2_FTOS_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL2_FTOS register field. */
#define DMA_TBS_CTRL2_FTOS_MSB	      31
/* The width in bits of the DMA_TBS_CTRL2_FTOS register field. */
#define DMA_TBS_CTRL2_FTOS_WIDTH      24
/* The mask used to set the DMA_TBS_CTRL2_FTOS register field value. */
#define DMA_TBS_CTRL2_FTOS_SET_MSK    0xffffff00
/* The mask used to clear the DMA_TBS_CTRL2_FTOS register field value. */
#define DMA_TBS_CTRL2_FTOS_CLR_MSK    0x000000ff
/* The reset value of the DMA_TBS_CTRL2_FTOS register field. */
#define DMA_TBS_CTRL2_FTOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL2_FTOS field value from a register. */
#define DMA_TBS_CTRL2_FTOS_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_TBS_CTRL2_FTOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL2_FTOS_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_TBS_CTRL2.
 */
struct DMA_TBS_CTRL2_s {
	volatile uint32_t FTOV : 1;		  /* DMA_TBS_CTRL2_FTOV */
	const volatile uint32_t Reserved_3_1 : 3; /* DMA_TBS_CTRL2_RESERVED_3_1 */
	volatile uint32_t FGOS : 3;		  /* DMA_TBS_CTRL2_FGOS */
	const volatile uint32_t Reserved_7 : 1;	  /* DMA_TBS_CTRL2_RESERVED_7 */
	volatile uint32_t FTOS : 24;		  /* DMA_TBS_CTRL2_FTOS */
};

/* The typedef declaration for register DMA_TBS_CTRL2. */
typedef struct DMA_TBS_CTRL2_s DMA_TBS_CTRL2_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_TBS_CTRL2 register. */
#define DMA_TBS_CTRL2_RESET 0x00000000
/* The byte offset of the DMA_TBS_CTRL2 register from the beginning of the component. */
#define DMA_TBS_CTRL2_OFST  0x5c

/*
 * Register : DMA_TBS_CTRL3
 *
 * This register is used to control the TBS3 attributes.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------
 *  [0]    | RW     | 0x0   | DMA_TBS_CTRL3_FTOV
 *  [3:1]  | R      | 0x0   | DMA_TBS_CTRL3_RESERVED_3_1
 *  [6:4]  | RW     | 0x0   | DMA_TBS_CTRL3_FGOS
 *  [7]    | R      | 0x0   | DMA_TBS_CTRL3_RESERVED_7
 *  [31:8] | RW     | 0x0   | DMA_TBS_CTRL3_FTOS
 *
 */
/*
 * Field : FTOV
 *
 * Fetch Time Offset 3 Valid
 *
 * When set indicates the FTOS field is valid. When not set, indicates the Fetch
 * Offset is not valid and the DMA engine can fetch the frames from host memory
 * without any time restrictions.
 *
 * Field Enumeration Values:
 *
 *  Enum                                               | Value | Description
 * :---------------------------------------------------|:------|:-----------------------------
 *  DMA_TBS_CTRL3_FTOV_E_INVALID | 0x0   | Fetch Time Offset is invalid
 *  DMA_TBS_CTRL3_FTOV_E_VALID   | 0x1   | Fetch Time Offset is valid
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field DMA_TBS_CTRL3_FTOV
 *
 * Fetch Time Offset is invalid
 */
#define DMA_TBS_CTRL3_FTOV_E_INVALID 0x0
/*
 * Enumerated value for register field DMA_TBS_CTRL3_FTOV
 *
 * Fetch Time Offset is valid
 */
#define DMA_TBS_CTRL3_FTOV_E_VALID   0x1

/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL3_FTOV register field. */
#define DMA_TBS_CTRL3_FTOV_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL3_FTOV register field. */
#define DMA_TBS_CTRL3_FTOV_MSB	      0
/* The width in bits of the DMA_TBS_CTRL3_FTOV register field. */
#define DMA_TBS_CTRL3_FTOV_WIDTH      1
/* The mask used to set the DMA_TBS_CTRL3_FTOV register field value. */
#define DMA_TBS_CTRL3_FTOV_SET_MSK    0x00000001
/* The mask used to clear the DMA_TBS_CTRL3_FTOV register field value. */
#define DMA_TBS_CTRL3_FTOV_CLR_MSK    0xfffffffe
/* The reset value of the DMA_TBS_CTRL3_FTOV register field. */
#define DMA_TBS_CTRL3_FTOV_RESET      0x0
/* Extracts the DMA_TBS_CTRL3_FTOV field value from a register. */
#define DMA_TBS_CTRL3_FTOV_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_TBS_CTRL3_FTOV register field value suitable for setting the register. */
#define DMA_TBS_CTRL3_FTOV_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL3_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL3_RESERVED_3_1_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL3_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL3_RESERVED_3_1_MSB	      3
/* The width in bits of the DMA_TBS_CTRL3_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL3_RESERVED_3_1_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL3_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL3_RESERVED_3_1_SET_MSK    0x0000000e
/* The mask used to clear the DMA_TBS_CTRL3_RESERVED_3_1 register field value. */
#define DMA_TBS_CTRL3_RESERVED_3_1_CLR_MSK    0xfffffff1
/* The reset value of the DMA_TBS_CTRL3_RESERVED_3_1 register field. */
#define DMA_TBS_CTRL3_RESERVED_3_1_RESET      0x0
/* Extracts the DMA_TBS_CTRL3_RESERVED_3_1 field value from a register. */
#define DMA_TBS_CTRL3_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_TBS_CTRL3_RESERVED_3_1 register field value suitable for setting the register. */
#define DMA_TBS_CTRL3_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : FGOS
 *
 * Fetch GSN Offset 3
 *
 * The number GSN slots that must be deducted from the Launch GSN to compute the
 * Fetch GSN. Value valid only when FTOV is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL3_FGOS register field. */
#define DMA_TBS_CTRL3_FGOS_LSB	      4
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL3_FGOS register field. */
#define DMA_TBS_CTRL3_FGOS_MSB	      6
/* The width in bits of the DMA_TBS_CTRL3_FGOS register field. */
#define DMA_TBS_CTRL3_FGOS_WIDTH      3
/* The mask used to set the DMA_TBS_CTRL3_FGOS register field value. */
#define DMA_TBS_CTRL3_FGOS_SET_MSK    0x00000070
/* The mask used to clear the DMA_TBS_CTRL3_FGOS register field value. */
#define DMA_TBS_CTRL3_FGOS_CLR_MSK    0xffffff8f
/* The reset value of the DMA_TBS_CTRL3_FGOS register field. */
#define DMA_TBS_CTRL3_FGOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL3_FGOS field value from a register. */
#define DMA_TBS_CTRL3_FGOS_GET(value) (((value)&0x00000070) >> 4)
/* Produces a DMA_TBS_CTRL3_FGOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL3_FGOS_SET(value) (((value) << 4) & 0x00000070)

/*
 * Field : Reserved_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL3_RESERVED_7 register field. */
#define DMA_TBS_CTRL3_RESERVED_7_LSB	    7
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL3_RESERVED_7 register field. */
#define DMA_TBS_CTRL3_RESERVED_7_MSB	    7
/* The width in bits of the DMA_TBS_CTRL3_RESERVED_7 register field. */
#define DMA_TBS_CTRL3_RESERVED_7_WIDTH	    1
/* The mask used to set the DMA_TBS_CTRL3_RESERVED_7 register field value. */
#define DMA_TBS_CTRL3_RESERVED_7_SET_MSK    0x00000080
/* The mask used to clear the DMA_TBS_CTRL3_RESERVED_7 register field value. */
#define DMA_TBS_CTRL3_RESERVED_7_CLR_MSK    0xffffff7f
/* The reset value of the DMA_TBS_CTRL3_RESERVED_7 register field. */
#define DMA_TBS_CTRL3_RESERVED_7_RESET	    0x0
/* Extracts the DMA_TBS_CTRL3_RESERVED_7 field value from a register. */
#define DMA_TBS_CTRL3_RESERVED_7_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_TBS_CTRL3_RESERVED_7 register field value suitable for setting the register. */
#define DMA_TBS_CTRL3_RESERVED_7_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : FTOS
 *
 * Fetch Time Offset 3
 *
 * The value in units of 256 ns, that has to be deducted from the Launch time to
 * compute the Fetch Time.
 *
 * Max value: 999,999,999 ns. Also, this must be smaller than CTR-1 value when ESTM
 * mode is set, as this value is a modulo CTR value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_TBS_CTRL3_FTOS register field. */
#define DMA_TBS_CTRL3_FTOS_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_TBS_CTRL3_FTOS register field. */
#define DMA_TBS_CTRL3_FTOS_MSB	      31
/* The width in bits of the DMA_TBS_CTRL3_FTOS register field. */
#define DMA_TBS_CTRL3_FTOS_WIDTH      24
/* The mask used to set the DMA_TBS_CTRL3_FTOS register field value. */
#define DMA_TBS_CTRL3_FTOS_SET_MSK    0xffffff00
/* The mask used to clear the DMA_TBS_CTRL3_FTOS register field value. */
#define DMA_TBS_CTRL3_FTOS_CLR_MSK    0x000000ff
/* The reset value of the DMA_TBS_CTRL3_FTOS register field. */
#define DMA_TBS_CTRL3_FTOS_RESET      0x0
/* Extracts the DMA_TBS_CTRL3_FTOS field value from a register. */
#define DMA_TBS_CTRL3_FTOS_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_TBS_CTRL3_FTOS register field value suitable for setting the register. */
#define DMA_TBS_CTRL3_FTOS_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_TBS_CTRL3.
 */
struct DMA_TBS_CTRL3_s {
	volatile uint32_t FTOV : 1;		  /* DMA_TBS_CTRL3_FTOV */
	const volatile uint32_t Reserved_3_1 : 3; /* DMA_TBS_CTRL3_RESERVED_3_1 */
	volatile uint32_t FGOS : 3;		  /* DMA_TBS_CTRL3_FGOS */
	const volatile uint32_t Reserved_7 : 1;	  /* DMA_TBS_CTRL3_RESERVED_7 */
	volatile uint32_t FTOS : 24;		  /* DMA_TBS_CTRL3_FTOS */
};

/* The typedef declaration for register DMA_TBS_CTRL3. */
typedef struct DMA_TBS_CTRL3_s DMA_TBS_CTRL3_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_TBS_CTRL3 register. */
#define DMA_TBS_CTRL3_RESET 0x00000000
/* The byte offset of the DMA_TBS_CTRL3 register from the beginning of the component. */
#define DMA_TBS_CTRL3_OFST  0x60

/*
 * Register : DMA_CH_Ind_Ctrl
 *
 * This register is used to program Indirect Access DMA configuration registers
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_CH_IND_CTRL_OB
 *  [1]     | RW     | 0x0   | DMA_CH_IND_CTRL_CT
 *  [3:2]   | R      | 0x0   | DMA_CH_IND_CTRL_RESERVED_3_2
 *  [5:4]   | RW     | 0x0   | DMA_CH_IND_CTRL_AUTO
 *  [7:6]   | R      | 0x0   | DMA_CH_IND_CTRL_RESERVED_7_6
 *  [11:8]  | RW     | 0x0   | DMA_CH_IND_CTRL_AOFF
 *  [15:12] | R      | 0x0   | DMA_CH_IND_CTRL_RESERVED_15_12
 *  [19:16] | RW     | 0x0   | DMA_CH_IND_CTRL_MSEL
 *  [31:20] | R      | 0x0   | DMA_CH_IND_CTRL_RESERVED_31_20
 *
 */
/*
 * Field : OB
 *
 * Operation Busy
 *
 * This bit is set along with a read or write command for initiating the indirect
 * access to DMA_<MSEL>_<AOFF> register. This bit is reset when the read or write
 * command to DMA_<MSEL>_<AOFF> register is complete. The next indirect register
 * access can be initiated only after this bit is reset. During a write operation,
 * the bit is reset only after the data has been written into the DMA_<MSEL>_<AOFF>
 * register. During a read operation, the data must be read from the
 * DMA_CH_Ind_Data register, only after this bit is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_OB register field. */
#define DMA_CH_IND_CTRL_OB_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_OB register field. */
#define DMA_CH_IND_CTRL_OB_MSB	      0
/* The width in bits of the DMA_CH_IND_CTRL_OB register field. */
#define DMA_CH_IND_CTRL_OB_WIDTH      1
/* The mask used to set the DMA_CH_IND_CTRL_OB register field value. */
#define DMA_CH_IND_CTRL_OB_SET_MSK    0x00000001
/* The mask used to clear the DMA_CH_IND_CTRL_OB register field value. */
#define DMA_CH_IND_CTRL_OB_CLR_MSK    0xfffffffe
/* The reset value of the DMA_CH_IND_CTRL_OB register field. */
#define DMA_CH_IND_CTRL_OB_RESET      0x0
/* Extracts the DMA_CH_IND_CTRL_OB field value from a register. */
#define DMA_CH_IND_CTRL_OB_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_CH_IND_CTRL_OB register field value suitable for setting the register. */
#define DMA_CH_IND_CTRL_OB_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : CT
 *
 * Command Type
 *
 * This bit indicates if the current register access is a read or a write
 * operation.
 *
 * * 1: Indicates a read operation.
 *
 * * 0: Indicates a write operation.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_CT register field. */
#define DMA_CH_IND_CTRL_CT_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_CT register field. */
#define DMA_CH_IND_CTRL_CT_MSB	      1
/* The width in bits of the DMA_CH_IND_CTRL_CT register field. */
#define DMA_CH_IND_CTRL_CT_WIDTH      1
/* The mask used to set the DMA_CH_IND_CTRL_CT register field value. */
#define DMA_CH_IND_CTRL_CT_SET_MSK    0x00000002
/* The mask used to clear the DMA_CH_IND_CTRL_CT register field value. */
#define DMA_CH_IND_CTRL_CT_CLR_MSK    0xfffffffd
/* The reset value of the DMA_CH_IND_CTRL_CT register field. */
#define DMA_CH_IND_CTRL_CT_RESET      0x0
/* Extracts the DMA_CH_IND_CTRL_CT field value from a register. */
#define DMA_CH_IND_CTRL_CT_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_CH_IND_CTRL_CT register field value suitable for setting the register. */
#define DMA_CH_IND_CTRL_CT_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_3_2
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_RESERVED_3_2 register field. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_LSB	2
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_RESERVED_3_2 register field. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_MSB	3
/* The width in bits of the DMA_CH_IND_CTRL_RESERVED_3_2 register field. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_WIDTH	2
/* The mask used to set the DMA_CH_IND_CTRL_RESERVED_3_2 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_SET_MSK	0x0000000c
/* The mask used to clear the DMA_CH_IND_CTRL_RESERVED_3_2 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_CLR_MSK	0xfffffff3
/* The reset value of the DMA_CH_IND_CTRL_RESERVED_3_2 register field. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_RESET	0x0
/* Extracts the DMA_CH_IND_CTRL_RESERVED_3_2 field value from a register. */
#define DMA_CH_IND_CTRL_RESERVED_3_2_GET(value) (((value)&0x0000000c) >> 2)
/* Produces a DMA_CH_IND_CTRL_RESERVED_3_2 register field value suitable for setting the register.
 */
#define DMA_CH_IND_CTRL_RESERVED_3_2_SET(value) (((value) << 2) & 0x0000000c)

/*
 * Field : AUTO
 *
 * Auto Increment
 *
 * * 00: No auto increment
 *
 * * 01: Auto increment MSEL only
 *
 * * 10: Auto increment AOFF only
 *
 * * 11: No auto increment
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_AUTO register field. */
#define DMA_CH_IND_CTRL_AUTO_LSB	4
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_AUTO register field. */
#define DMA_CH_IND_CTRL_AUTO_MSB	5
/* The width in bits of the DMA_CH_IND_CTRL_AUTO register field. */
#define DMA_CH_IND_CTRL_AUTO_WIDTH	2
/* The mask used to set the DMA_CH_IND_CTRL_AUTO register field value. */
#define DMA_CH_IND_CTRL_AUTO_SET_MSK	0x00000030
/* The mask used to clear the DMA_CH_IND_CTRL_AUTO register field value. */
#define DMA_CH_IND_CTRL_AUTO_CLR_MSK	0xffffffcf
/* The reset value of the DMA_CH_IND_CTRL_AUTO register field. */
#define DMA_CH_IND_CTRL_AUTO_RESET	0x0
/* Extracts the DMA_CH_IND_CTRL_AUTO field value from a register. */
#define DMA_CH_IND_CTRL_AUTO_GET(value) (((value)&0x00000030) >> 4)
/* Produces a DMA_CH_IND_CTRL_AUTO register field value suitable for setting the register. */
#define DMA_CH_IND_CTRL_AUTO_SET(value) (((value) << 4) & 0x00000030)

/*
 * Field : Reserved_7_6
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_RESERVED_7_6 register field. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_LSB	6
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_RESERVED_7_6 register field. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_MSB	7
/* The width in bits of the DMA_CH_IND_CTRL_RESERVED_7_6 register field. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_WIDTH	2
/* The mask used to set the DMA_CH_IND_CTRL_RESERVED_7_6 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_SET_MSK	0x000000c0
/* The mask used to clear the DMA_CH_IND_CTRL_RESERVED_7_6 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_CLR_MSK	0xffffff3f
/* The reset value of the DMA_CH_IND_CTRL_RESERVED_7_6 register field. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_RESET	0x0
/* Extracts the DMA_CH_IND_CTRL_RESERVED_7_6 field value from a register. */
#define DMA_CH_IND_CTRL_RESERVED_7_6_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a DMA_CH_IND_CTRL_RESERVED_7_6 register field value suitable for setting the register.
 */
#define DMA_CH_IND_CTRL_RESERVED_7_6_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : AOFF
 *
 * Address Offset
 *
 * This field selects the offset address of per DMA Channel registers specified by
 * MSEL field.
 *
 * * 0000: CH0
 *
 * * 0001: CH1
 *
 * * ----
 *
 * * 1111 : CH15
 *
 * AOFF field is used in the indirect access of the DMA_<MSEL>_<AOFF>
 *
 * This field must be set along with initiation of read/write to the
 * DMA_<MSEL>_<AOFF> register and must not be changed until the OB is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_AOFF register field. */
#define DMA_CH_IND_CTRL_AOFF_LSB	8
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_AOFF register field. */
#define DMA_CH_IND_CTRL_AOFF_MSB	11
/* The width in bits of the DMA_CH_IND_CTRL_AOFF register field. */
#define DMA_CH_IND_CTRL_AOFF_WIDTH	4
/* The mask used to set the DMA_CH_IND_CTRL_AOFF register field value. */
#define DMA_CH_IND_CTRL_AOFF_SET_MSK	0x00000f00
/* The mask used to clear the DMA_CH_IND_CTRL_AOFF register field value. */
#define DMA_CH_IND_CTRL_AOFF_CLR_MSK	0xfffff0ff
/* The reset value of the DMA_CH_IND_CTRL_AOFF register field. */
#define DMA_CH_IND_CTRL_AOFF_RESET	0x0
/* Extracts the DMA_CH_IND_CTRL_AOFF field value from a register. */
#define DMA_CH_IND_CTRL_AOFF_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_CH_IND_CTRL_AOFF register field value suitable for setting the register. */
#define DMA_CH_IND_CTRL_AOFF_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : Reserved_15_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_RESERVED_15_12 register field. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_LSB	  12
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_RESERVED_15_12 register field. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_MSB	  15
/* The width in bits of the DMA_CH_IND_CTRL_RESERVED_15_12 register field. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_WIDTH	  4
/* The mask used to set the DMA_CH_IND_CTRL_RESERVED_15_12 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_SET_MSK	  0x0000f000
/* The mask used to clear the DMA_CH_IND_CTRL_RESERVED_15_12 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_CLR_MSK	  0xffff0fff
/* The reset value of the DMA_CH_IND_CTRL_RESERVED_15_12 register field. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_RESET	  0x0
/* Extracts the DMA_CH_IND_CTRL_RESERVED_15_12 field value from a register. */
#define DMA_CH_IND_CTRL_RESERVED_15_12_GET(value) (((value)&0x0000f000) >> 12)
/* Produces a DMA_CH_IND_CTRL_RESERVED_15_12 register field value suitable for setting the register.
 */
#define DMA_CH_IND_CTRL_RESERVED_15_12_SET(value) (((value) << 12) & 0x0000f000)

/*
 * Field : MSEL
 *
 * Mode Select
 *
 * This field selects a group of identical registers.
 *
 * * 0000: DMA_CH(#i)_TxExtCfg registers
 *
 * * 0001-1111: reserved for future use
 *
 * MSEL field is used in the indirect access of the DMA_<MSEL>_<AOFF>
 *
 * This field must be set along with initiation of read/write to the
 * DMA_<MSEL>_<AOFF> register and must not be changed until the OB is reset.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_MSEL register field. */
#define DMA_CH_IND_CTRL_MSEL_LSB	16
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_MSEL register field. */
#define DMA_CH_IND_CTRL_MSEL_MSB	19
/* The width in bits of the DMA_CH_IND_CTRL_MSEL register field. */
#define DMA_CH_IND_CTRL_MSEL_WIDTH	4
/* The mask used to set the DMA_CH_IND_CTRL_MSEL register field value. */
#define DMA_CH_IND_CTRL_MSEL_SET_MSK	0x000f0000
/* The mask used to clear the DMA_CH_IND_CTRL_MSEL register field value. */
#define DMA_CH_IND_CTRL_MSEL_CLR_MSK	0xfff0ffff
/* The reset value of the DMA_CH_IND_CTRL_MSEL register field. */
#define DMA_CH_IND_CTRL_MSEL_RESET	0x0
/* Extracts the DMA_CH_IND_CTRL_MSEL field value from a register. */
#define DMA_CH_IND_CTRL_MSEL_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a DMA_CH_IND_CTRL_MSEL register field value suitable for setting the register. */
#define DMA_CH_IND_CTRL_MSEL_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : Reserved_31_20
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_CTRL_RESERVED_31_20 register field. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_LSB	  20
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_CTRL_RESERVED_31_20 register field. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_MSB	  31
/* The width in bits of the DMA_CH_IND_CTRL_RESERVED_31_20 register field. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_WIDTH	  12
/* The mask used to set the DMA_CH_IND_CTRL_RESERVED_31_20 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_SET_MSK	  0xfff00000
/* The mask used to clear the DMA_CH_IND_CTRL_RESERVED_31_20 register field value. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_CLR_MSK	  0x000fffff
/* The reset value of the DMA_CH_IND_CTRL_RESERVED_31_20 register field. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_RESET	  0x0
/* Extracts the DMA_CH_IND_CTRL_RESERVED_31_20 field value from a register. */
#define DMA_CH_IND_CTRL_RESERVED_31_20_GET(value) (((value)&0xfff00000) >> 20)
/* Produces a DMA_CH_IND_CTRL_RESERVED_31_20 register field value suitable for setting the register.
 */
#define DMA_CH_IND_CTRL_RESERVED_31_20_SET(value) (((value) << 20) & 0xfff00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CH_IND_CTRL.
 */
struct DMA_CH_IND_CTRL_s {
	volatile uint32_t OB : 1;		     /* DMA_CH_IND_CTRL_OB */
	volatile uint32_t CT : 1;		     /* DMA_CH_IND_CTRL_CT */
	const volatile uint32_t Reserved_3_2 : 2;    /* DMA_CH_IND_CTRL_RESERVED_3_2 */
	volatile uint32_t AUTO : 2;		     /* DMA_CH_IND_CTRL_AUTO */
	const volatile uint32_t Reserved_7_6 : 2;    /* DMA_CH_IND_CTRL_RESERVED_7_6 */
	volatile uint32_t AOFF : 4;		     /* DMA_CH_IND_CTRL_AOFF */
	const volatile uint32_t Reserved_15_12 : 4;  /* DMA_CH_IND_CTRL_RESERVED_15_12 */
	volatile uint32_t MSEL : 4;		     /* DMA_CH_IND_CTRL_MSEL */
	const volatile uint32_t Reserved_31_20 : 12; /* DMA_CH_IND_CTRL_RESERVED_31_20 */
};

/* The typedef declaration for register DMA_CH_IND_CTRL. */
typedef struct DMA_CH_IND_CTRL_s DMA_CH_IND_CTRL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CH_IND_CTRL register. */
#define DMA_CH_IND_CTRL_RESET 0x00000000
/* The byte offset of the DMA_CH_IND_CTRL register from the beginning of the component. */
#define DMA_CH_IND_CTRL_OFST  0x80

/*
 * Register : DMA_CH_Ind_Data
 *
 * This register holds the read/write data for Indirect Access of the registers
 * indicated by DMA_<MSEL>_<AOFF>. During the read access, this field contains
 * valid read data only after the OB bit is reset. During the write access, this
 * field must be valid prior setting the OB bit in the DMA_CH_Ind_Data register.
 * Once auto increment is set, application is allowed to write without setting OB
 * bit of DMA_CH_Ind_Ctrl register.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:----------------------------------------------------
 *  [6:0]  | RW     | 0x0   | DMA_CH_IND_DATA_WT
 *  [31:7] | R      | 0x0   | DMA_CH_IND_DATA_RESERVED_31_7
 *
 */
/*
 * Field : WT
 *
 * Weights
 *
 * This field contains the weights of the corresponding Tx DMA used for Weighted
 * Round Robin Arbitration of Tx DMA Data Reads. The maximum value is 0x64.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_DATA_WT register field. */
#define DMA_CH_IND_DATA_WT_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_DATA_WT register field. */
#define DMA_CH_IND_DATA_WT_MSB	      6
/* The width in bits of the DMA_CH_IND_DATA_WT register field. */
#define DMA_CH_IND_DATA_WT_WIDTH      7
/* The mask used to set the DMA_CH_IND_DATA_WT register field value. */
#define DMA_CH_IND_DATA_WT_SET_MSK    0x0000007f
/* The mask used to clear the DMA_CH_IND_DATA_WT register field value. */
#define DMA_CH_IND_DATA_WT_CLR_MSK    0xffffff80
/* The reset value of the DMA_CH_IND_DATA_WT register field. */
#define DMA_CH_IND_DATA_WT_RESET      0x0
/* Extracts the DMA_CH_IND_DATA_WT field value from a register. */
#define DMA_CH_IND_DATA_WT_GET(value) (((value)&0x0000007f) >> 0)
/* Produces a DMA_CH_IND_DATA_WT register field value suitable for setting the register. */
#define DMA_CH_IND_DATA_WT_SET(value) (((value) << 0) & 0x0000007f)

/*
 * Field : Reserved_31_7
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CH_IND_DATA_RESERVED_31_7 register field. */
#define DMA_CH_IND_DATA_RESERVED_31_7_LSB	 7
/* The Most Significant Bit (MSB) position of the DMA_CH_IND_DATA_RESERVED_31_7 register field. */
#define DMA_CH_IND_DATA_RESERVED_31_7_MSB	 31
/* The width in bits of the DMA_CH_IND_DATA_RESERVED_31_7 register field. */
#define DMA_CH_IND_DATA_RESERVED_31_7_WIDTH	 25
/* The mask used to set the DMA_CH_IND_DATA_RESERVED_31_7 register field value. */
#define DMA_CH_IND_DATA_RESERVED_31_7_SET_MSK	 0xffffff80
/* The mask used to clear the DMA_CH_IND_DATA_RESERVED_31_7 register field value. */
#define DMA_CH_IND_DATA_RESERVED_31_7_CLR_MSK	 0x0000007f
/* The reset value of the DMA_CH_IND_DATA_RESERVED_31_7 register field. */
#define DMA_CH_IND_DATA_RESERVED_31_7_RESET	 0x0
/* Extracts the DMA_CH_IND_DATA_RESERVED_31_7 field value from a register. */
#define DMA_CH_IND_DATA_RESERVED_31_7_GET(value) (((value)&0xffffff80) >> 7)
/* Produces a DMA_CH_IND_DATA_RESERVED_31_7 register field value suitable for setting the register.
 */
#define DMA_CH_IND_DATA_RESERVED_31_7_SET(value) (((value) << 7) & 0xffffff80)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CH_IND_DATA.
 */
struct DMA_CH_IND_DATA_s {
	volatile uint32_t WT : 7;		    /* DMA_CH_IND_DATA_WT */
	const volatile uint32_t Reserved_31_7 : 25; /* DMA_CH_IND_DATA_RESERVED_31_7 */
};

/* The typedef declaration for register DMA_CH_IND_DATA. */
typedef struct DMA_CH_IND_DATA_s DMA_CH_IND_DATA_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CH_IND_DATA register. */
#define DMA_CH_IND_DATA_RESET 0x00000000
/* The byte offset of the DMA_CH_IND_DATA register from the beginning of the component. */
#define DMA_CH_IND_DATA_OFST  0x84

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register group DMA.
 */
struct DMA_s {
	volatile DMA_MODE_t DMA_Mode;				    /* DMA_MODE */
	volatile DMA_SYSBUS_MODE_t DMA_SysBus_Mode;		    /* DMA_SYSBUS_MODE */
	volatile DMA_INTERRUPT_STATUS_t DMA_Interrupt_Status;	    /* DMA_INTERRUPT_STATUS */
	volatile uint32_t _pad_0xc_0xf;				    /* *UNDEFINED* */
	volatile DMA_AXI_TX_AR_ACE_CONTROL_t AXI_Tx_AR_ACE_Control; /* DMA_AXI_TX_AR_ACE_CONTROL */
	volatile uint32_t _pad_0x14_0x17;			    /* *UNDEFINED* */
	volatile DMA_AXI_RX_AW_ACE_CONTROL_t AXI_Rx_AW_ACE_Control; /* DMA_AXI_RX_AW_ACE_CONTROL */
	volatile DMA_AXI_TXRX_AWAR_ACE_CONTROL_t
		AXI_TxRx_AWAR_ACE_Control;		    /* DMA_AXI_TXRX_AWAR_ACE_CONTROL */
	volatile DMA_DEBUG_STATUS0_t DMA_Debug_Status0;	    /* DMA_DEBUG_STATUS0 */
	volatile DMA_DEBUG_STATUS1_t DMA_Debug_Status1;	    /* DMA_DEBUG_STATUS1 */
	volatile uint32_t _pad_0x28_0x2b;		    /* *UNDEFINED* */
	volatile DMA_DEBUG_STATUS3_t DMA_Debug_Status3;	    /* DMA_DEBUG_STATUS3 */
	volatile uint32_t _pad_0x30_0x3f[4];		    /* *UNDEFINED* */
	volatile DMA_TX_EDMA_CONTROL_t DMA_Tx_EDMA_Control; /* DMA_TX_EDMA_CONTROL */
	volatile DMA_RX_EDMA_CONTROL_t DMA_Rx_EDMA_Control; /* DMA_RX_EDMA_CONTROL */
	volatile uint32_t _pad_0x48_0x4f[2];		    /* *UNDEFINED* */
	volatile DMA_AXI_LPI_ENTRY_INTERVAL_t
		AXI_LPI_Entry_Interval;		    /* DMA_AXI_LPI_ENTRY_INTERVAL */
	volatile DMA_TBS_CTRL0_t DMA_TBS_CTRL0;	    /* DMA_TBS_CTRL0 */
	volatile DMA_TBS_CTRL1_t DMA_TBS_CTRL1;	    /* DMA_TBS_CTRL1 */
	volatile DMA_TBS_CTRL2_t DMA_TBS_CTRL2;	    /* DMA_TBS_CTRL2 */
	volatile DMA_TBS_CTRL3_t DMA_TBS_CTRL3;	    /* DMA_TBS_CTRL3 */
	volatile uint32_t _pad_0x64_0x7f[7];	    /* *UNDEFINED* */
	volatile DMA_CH_IND_CTRL_t DMA_CH_Ind_Ctrl; /* DMA_CH_IND_CTRL */
	volatile DMA_CH_IND_DATA_t DMA_CH_Ind_Data; /* DMA_CH_IND_DATA */
	volatile uint32_t _pad_0x88_0x100[30];	    /* *UNDEFINED* */
};

/* The typedef declaration for register group DMA. */
typedef struct DMA_s DMA_t;
/* The struct declaration for the raw register contents of register group DMA. */
struct DMA_raw_s {
	volatile uint32_t DMA_Mode;		     /* DMA_MODE */
	volatile uint32_t DMA_SysBus_Mode;	     /* DMA_SYSBUS_MODE */
	volatile uint32_t DMA_Interrupt_Status;	     /* DMA_INTERRUPT_STATUS */
	volatile uint32_t _pad_0xc_0xf;		     /* *UNDEFINED* */
	volatile uint32_t AXI_Tx_AR_ACE_Control;     /* DMA_AXI_TX_AR_ACE_CONTROL */
	volatile uint32_t _pad_0x14_0x17;	     /* *UNDEFINED* */
	volatile uint32_t AXI_Rx_AW_ACE_Control;     /* DMA_AXI_RX_AW_ACE_CONTROL */
	volatile uint32_t AXI_TxRx_AWAR_ACE_Control; /* DMA_AXI_TXRX_AWAR_ACE_CONTROL */
	volatile uint32_t DMA_Debug_Status0;	     /* DMA_DEBUG_STATUS0 */
	volatile uint32_t DMA_Debug_Status1;	     /* DMA_DEBUG_STATUS1 */
	volatile uint32_t _pad_0x28_0x2b;	     /* *UNDEFINED* */
	volatile uint32_t DMA_Debug_Status3;	     /* DMA_DEBUG_STATUS3 */
	volatile uint32_t _pad_0x30_0x3f[4];	     /* *UNDEFINED* */
	volatile uint32_t DMA_Tx_EDMA_Control;	     /* DMA_TX_EDMA_CONTROL */
	volatile uint32_t DMA_Rx_EDMA_Control;	     /* DMA_RX_EDMA_CONTROL */
	volatile uint32_t _pad_0x48_0x4f[2];	     /* *UNDEFINED* */
	volatile uint32_t AXI_LPI_Entry_Interval;    /* DMA_AXI_LPI_ENTRY_INTERVAL */
	volatile uint32_t DMA_TBS_CTRL0;	     /* DMA_TBS_CTRL0 */
	volatile uint32_t DMA_TBS_CTRL1;	     /* DMA_TBS_CTRL1 */
	volatile uint32_t DMA_TBS_CTRL2;	     /* DMA_TBS_CTRL2 */
	volatile uint32_t DMA_TBS_CTRL3;	     /* DMA_TBS_CTRL3 */
	volatile uint32_t _pad_0x64_0x7f[7];	     /* *UNDEFINED* */
	volatile uint32_t DMA_CH_Ind_Ctrl;	     /* DMA_CH_IND_CTRL */
	volatile uint32_t DMA_CH_Ind_Data;	     /* DMA_CH_IND_DATA */
	volatile uint32_t _pad_0x88_0x100[30];	     /* *UNDEFINED* */
};

/* The typedef declaration for the raw register contents of register group DMA. */
typedef struct DMA_raw_s DMA_raw_t;
#endif /* __ASSEMBLY__ */

/*
 * Component : DMA_CH0
 * DMA Channel (#i) Registers.
 *
 */
/*
 * Register : DMA_CH0_Control
 *
 * The DMA Channelx Control register specifies the MSS value for segmentation,
 * length to skip between two descriptors, and also the features such as header
 * splitting and 8xPBL mode.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------
 *  [13:0]  | RW     | 0x0   | DMA_CHx_CONTROL_MSS
 *  [15:14] | R      | 0x0   | DMA_CHx_CONTROL_RESERVED_15_14
 *  [16]    | RW     | 0x0   | DMA_CHx_CONTROL_PBLX8
 *  [17]    | R      | 0x0   | DMA_CHx_CONTROL_RESERVED_17
 *  [20:18] | RW     | 0x0   | DMA_CHx_CONTROL_DSL
 *  [23:21] | R      | 0x0   | DMA_CHx_CONTROL_RESERVED_23_21
 *  [24]    | RW     | 0x0   | DMA_CHx_CONTROL_SPH
 *  [31:25] | R      | 0x0   | DMA_CHx_CONTROL_RESERVED_31_25
 *
 */
/*
 * Field : MSS
 *
 * Maximum Segment Size.
 *
 * This field specifies the maximum segment size that must be used while segmenting
 * the Transmit packet. This field is valid only if the TSE bit of
 * DMA_CH0_Tx_Control register is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_MSS register field. */
#define DMA_CHx_CONTROL_MSS_LSB	       0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_MSS register field. */
#define DMA_CHx_CONTROL_MSS_MSB	       13
/* The width in bits of the DMA_CHx_CONTROL_MSS register field. */
#define DMA_CHx_CONTROL_MSS_WIDTH      14
/* The mask used to set the DMA_CHx_CONTROL_MSS register field value. */
#define DMA_CHx_CONTROL_MSS_SET_MSK    0x00003fff
/* The mask used to clear the DMA_CHx_CONTROL_MSS register field value. */
#define DMA_CHx_CONTROL_MSS_CLR_MSK    0xffffc000
/* The reset value of the DMA_CHx_CONTROL_MSS register field. */
#define DMA_CHx_CONTROL_MSS_RESET      0x0
/* Extracts the DMA_CHx_CONTROL_MSS field value from a register. */
#define DMA_CHx_CONTROL_MSS_GET(value) (((value)&0x00003fff) >> 0)
/* Produces a DMA_CHx_CONTROL_MSS register field value suitable for setting the register. */
#define DMA_CHx_CONTROL_MSS_SET(value) (((value) << 0) & 0x00003fff)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_RESERVED_15_14 register field. */
#define DMA_CHx_CONTROL_RESERVED_15_14_LSB	  14
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_RESERVED_15_14 register field. */
#define DMA_CHx_CONTROL_RESERVED_15_14_MSB	  15
/* The width in bits of the DMA_CHx_CONTROL_RESERVED_15_14 register field. */
#define DMA_CHx_CONTROL_RESERVED_15_14_WIDTH	  2
/* The mask used to set the DMA_CHx_CONTROL_RESERVED_15_14 register field value. */
#define DMA_CHx_CONTROL_RESERVED_15_14_SET_MSK	  0x0000c000
/* The mask used to clear the DMA_CHx_CONTROL_RESERVED_15_14 register field value. */
#define DMA_CHx_CONTROL_RESERVED_15_14_CLR_MSK	  0xffff3fff
/* The reset value of the DMA_CHx_CONTROL_RESERVED_15_14 register field. */
#define DMA_CHx_CONTROL_RESERVED_15_14_RESET	  0x0
/* Extracts the DMA_CHx_CONTROL_RESERVED_15_14 field value from a register. */
#define DMA_CHx_CONTROL_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a DMA_CHx_CONTROL_RESERVED_15_14 register field value suitable for setting the register.
 */
#define DMA_CHx_CONTROL_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : PBLx8
 *
 * 8xPBL mode.
 *
 * When this bit is set, the PBL value programmed in Bits[21:16] in
 * DMA_CH0_Tx_Control is multiplied eight times. Therefore, the DMA transfers the
 * data in 8, 16, 32, 64, 128, and 256 beats depending on the PBL value.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_PBLX8 register field. */
#define DMA_CHx_CONTROL_PBLX8_LSB	 16
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_PBLX8 register field. */
#define DMA_CHx_CONTROL_PBLX8_MSB	 16
/* The width in bits of the DMA_CHx_CONTROL_PBLX8 register field. */
#define DMA_CHx_CONTROL_PBLX8_WIDTH	 1
/* The mask used to set the DMA_CHx_CONTROL_PBLX8 register field value. */
#define DMA_CHx_CONTROL_PBLX8_SET_MSK	 0x00010000
/* The mask used to clear the DMA_CHx_CONTROL_PBLX8 register field value. */
#define DMA_CHx_CONTROL_PBLX8_CLR_MSK	 0xfffeffff
/* The reset value of the DMA_CHx_CONTROL_PBLX8 register field. */
#define DMA_CHx_CONTROL_PBLX8_RESET	 0x0
/* Extracts the DMA_CHx_CONTROL_PBLX8 field value from a register. */
#define DMA_CHx_CONTROL_PBLX8_GET(value) (((value)&0x00010000) >> 16)
/* Produces a DMA_CHx_CONTROL_PBLX8 register field value suitable for setting the register. */
#define DMA_CHx_CONTROL_PBLX8_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : Reserved_17
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_RESERVED_17 register field. */
#define DMA_CHx_CONTROL_RESERVED_17_LSB	       17
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_RESERVED_17 register field. */
#define DMA_CHx_CONTROL_RESERVED_17_MSB	       17
/* The width in bits of the DMA_CHx_CONTROL_RESERVED_17 register field. */
#define DMA_CHx_CONTROL_RESERVED_17_WIDTH      1
/* The mask used to set the DMA_CHx_CONTROL_RESERVED_17 register field value. */
#define DMA_CHx_CONTROL_RESERVED_17_SET_MSK    0x00020000
/* The mask used to clear the DMA_CHx_CONTROL_RESERVED_17 register field value. */
#define DMA_CHx_CONTROL_RESERVED_17_CLR_MSK    0xfffdffff
/* The reset value of the DMA_CHx_CONTROL_RESERVED_17 register field. */
#define DMA_CHx_CONTROL_RESERVED_17_RESET      0x0
/* Extracts the DMA_CHx_CONTROL_RESERVED_17 field value from a register. */
#define DMA_CHx_CONTROL_RESERVED_17_GET(value) (((value)&0x00020000) >> 17)
/* Produces a DMA_CHx_CONTROL_RESERVED_17 register field value suitable for setting the register. */
#define DMA_CHx_CONTROL_RESERVED_17_SET(value) (((value) << 17) & 0x00020000)

/*
 * Field : DSL
 *
 * Descriptor Skip Length.
 *
 * This bit specifies the Word, Dword, or Lword number (depending on the 32-bit,
 * 64-bit, or 128-bit bus) to skip between two descriptors. The address skipping
 * starts from the end of the current descriptor to the start of the next
 * descriptor.
 *
 * When the DSL value is equal to zero, the DMA takes the descriptor list as
 * contiguous.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_DSL register field. */
#define DMA_CHx_CONTROL_DSL_LSB	       18
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_DSL register field. */
#define DMA_CHx_CONTROL_DSL_MSB	       20
/* The width in bits of the DMA_CHx_CONTROL_DSL register field. */
#define DMA_CHx_CONTROL_DSL_WIDTH      3
/* The mask used to set the DMA_CHx_CONTROL_DSL register field value. */
#define DMA_CHx_CONTROL_DSL_SET_MSK    0x001c0000
/* The mask used to clear the DMA_CHx_CONTROL_DSL register field value. */
#define DMA_CHx_CONTROL_DSL_CLR_MSK    0xffe3ffff
/* The reset value of the DMA_CHx_CONTROL_DSL register field. */
#define DMA_CHx_CONTROL_DSL_RESET      0x0
/* Extracts the DMA_CHx_CONTROL_DSL field value from a register. */
#define DMA_CHx_CONTROL_DSL_GET(value) (((value)&0x001c0000) >> 18)
/* Produces a DMA_CHx_CONTROL_DSL register field value suitable for setting the register. */
#define DMA_CHx_CONTROL_DSL_SET(value) (((value) << 18) & 0x001c0000)

/*
 * Field : Reserved_23_21
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_RESERVED_23_21 register field. */
#define DMA_CHx_CONTROL_RESERVED_23_21_LSB	  21
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_RESERVED_23_21 register field. */
#define DMA_CHx_CONTROL_RESERVED_23_21_MSB	  23
/* The width in bits of the DMA_CHx_CONTROL_RESERVED_23_21 register field. */
#define DMA_CHx_CONTROL_RESERVED_23_21_WIDTH	  3
/* The mask used to set the DMA_CHx_CONTROL_RESERVED_23_21 register field value. */
#define DMA_CHx_CONTROL_RESERVED_23_21_SET_MSK	  0x00e00000
/* The mask used to clear the DMA_CHx_CONTROL_RESERVED_23_21 register field value. */
#define DMA_CHx_CONTROL_RESERVED_23_21_CLR_MSK	  0xff1fffff
/* The reset value of the DMA_CHx_CONTROL_RESERVED_23_21 register field. */
#define DMA_CHx_CONTROL_RESERVED_23_21_RESET	  0x0
/* Extracts the DMA_CHx_CONTROL_RESERVED_23_21 field value from a register. */
#define DMA_CHx_CONTROL_RESERVED_23_21_GET(value) (((value)&0x00e00000) >> 21)
/* Produces a DMA_CHx_CONTROL_RESERVED_23_21 register field value suitable for setting the register.
 */
#define DMA_CHx_CONTROL_RESERVED_23_21_SET(value) (((value) << 21) & 0x00e00000)

/*
 * Field : SPH
 *
 * Header-Payload Split.
 *
 * When this bit is set, the DMA splits the header and payload in the Receive path.
 * The DMA writes the header to the Buffer Address1. The DMA writes the payload to
 * the buffer to which the Buffer Address2 is pointing.
 *
 * The software must ensure that the header fits into the Receive buffers. If the
 * header length exceeds the receive buffer size, the DMA does not split the header
 * and payload.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_SPH register field. */
#define DMA_CHx_CONTROL_SPH_LSB	       24
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_SPH register field. */
#define DMA_CHx_CONTROL_SPH_MSB	       24
/* The width in bits of the DMA_CHx_CONTROL_SPH register field. */
#define DMA_CHx_CONTROL_SPH_WIDTH      1
/* The mask used to set the DMA_CHx_CONTROL_SPH register field value. */
#define DMA_CHx_CONTROL_SPH_SET_MSK    0x01000000
/* The mask used to clear the DMA_CHx_CONTROL_SPH register field value. */
#define DMA_CHx_CONTROL_SPH_CLR_MSK    0xfeffffff
/* The reset value of the DMA_CHx_CONTROL_SPH register field. */
#define DMA_CHx_CONTROL_SPH_RESET      0x0
/* Extracts the DMA_CHx_CONTROL_SPH field value from a register. */
#define DMA_CHx_CONTROL_SPH_GET(value) (((value)&0x01000000) >> 24)
/* Produces a DMA_CHx_CONTROL_SPH register field value suitable for setting the register. */
#define DMA_CHx_CONTROL_SPH_SET(value) (((value) << 24) & 0x01000000)

/*
 * Field : Reserved_31_25
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CONTROL_RESERVED_31_25 register field. */
#define DMA_CHx_CONTROL_RESERVED_31_25_LSB	  25
/* The Most Significant Bit (MSB) position of the DMA_CHx_CONTROL_RESERVED_31_25 register field. */
#define DMA_CHx_CONTROL_RESERVED_31_25_MSB	  31
/* The width in bits of the DMA_CHx_CONTROL_RESERVED_31_25 register field. */
#define DMA_CHx_CONTROL_RESERVED_31_25_WIDTH	  7
/* The mask used to set the DMA_CHx_CONTROL_RESERVED_31_25 register field value. */
#define DMA_CHx_CONTROL_RESERVED_31_25_SET_MSK	  0xfe000000
/* The mask used to clear the DMA_CHx_CONTROL_RESERVED_31_25 register field value. */
#define DMA_CHx_CONTROL_RESERVED_31_25_CLR_MSK	  0x01ffffff
/* The reset value of the DMA_CHx_CONTROL_RESERVED_31_25 register field. */
#define DMA_CHx_CONTROL_RESERVED_31_25_RESET	  0x0
/* Extracts the DMA_CHx_CONTROL_RESERVED_31_25 field value from a register. */
#define DMA_CHx_CONTROL_RESERVED_31_25_GET(value) (((value)&0xfe000000) >> 25)
/* Produces a DMA_CHx_CONTROL_RESERVED_31_25 register field value suitable for setting the register.
 */
#define DMA_CHx_CONTROL_RESERVED_31_25_SET(value) (((value) << 25) & 0xfe000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CONTROL.
 */
struct DMA_CHx_CONTROL_s {
	volatile uint32_t MSS : 14;		    /* DMA_CHx_CONTROL_MSS */
	const volatile uint32_t Reserved_15_14 : 2; /* DMA_CHx_CONTROL_RESERVED_15_14 */
	volatile uint32_t PBLx8 : 1;		    /* DMA_CHx_CONTROL_PBLX8 */
	const volatile uint32_t Reserved_17 : 1;    /* DMA_CHx_CONTROL_RESERVED_17 */
	volatile uint32_t DSL : 3;		    /* DMA_CHx_CONTROL_DSL */
	const volatile uint32_t Reserved_23_21 : 3; /* DMA_CHx_CONTROL_RESERVED_23_21 */
	volatile uint32_t SPH : 1;		    /* DMA_CHx_CONTROL_SPH */
	const volatile uint32_t Reserved_31_25 : 7; /* DMA_CHx_CONTROL_RESERVED_31_25 */
};

/* The typedef declaration for register DMA_CHx_CONTROL. */
typedef struct DMA_CHx_CONTROL_s DMA_CHx_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CONTROL register. */
#define DMA_CHx_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_CHx_CONTROL register from the beginning of the component. */
#define DMA_CHx_CONTROL_OFST  0x0

/*
 * Register : DMA_CH0_Tx_Control
 *
 * The DMA Channelx Transmit Control register controls the Tx features such as PBL,
 * TCP segmentation, and Tx Channel weights.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_CHx_TX_CONTROL_ST
 *  [3:1]   | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_3_1
 *  [4]     | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_OSP
 *  [11:5]  | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_11_5
 *  [12]    | RW     | 0x0   | DMA_CHx_TX_CONTROL_TSE
 *  [14:13] | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_14_13
 *  [15]    | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_IPBL
 *  [21:16] | RW     | 0x0   | DMA_CHx_TX_CONTROL_TXPBL
 *  [23:22] | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_23_22
 *  [27:24] | RW     | 0x0   | DMA_CHx_TX_CONTROL_TQOS
 *  [28]    | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_EDSE
 *  [30:29] | RW     | 0x0   | DMA_CHx_TX_CONTROL_TFSEL
 *  [31]    | R      | 0x0   | DMA_CHx_TX_CONTROL_RESERVED_31
 *
 */
/*
 * Field : ST
 *
 * Start or Stop Transmission Command.
 *
 * When this bit is set, transmission is placed in the Running state. The DMA
 * checks the Transmit list at the current position for a packet to be transmitted.
 *
 * The DMA tries to acquire descriptor from either of the following positions:
 *
 * * The current position in the list
 *
 * This is the base address of the Transmit list set by the
 * DMA_CH0_TxDesc_List_LAddress register.
 *
 * * The position at which the transmission was previously stopped
 *
 * If the DMA does not own the current descriptor, the transmission enters the
 * Suspended state and the TBU bit of the DMA_CH0_Status register is set. The Start
 * Transmission command is effective only when the transmission is stopped. If the
 * command is issued before setting the DMA_CH0_TxDesc_List_LAddress register, the
 * DMA behavior is unpredictable.
 *
 * When this bit is reset, the transmission process is placed in the Stopped state
 * after completing the transmission of the current packet. The Next Descriptor
 * position in the Transmit list is saved, and it becomes the current position when
 * the transmission is restarted. To change the list address, program
 * DMA_CH0_TxDesc_List_Address register with a new value when this bit is reset.
 * The new value is considered when this bit is set again. The stop transmission
 * command is effective only when the transmission of the current packet is
 * complete or the transmission is in the Suspended state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_ST register field. */
#define DMA_CHx_TX_CONTROL_ST_LSB	 0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_ST register field. */
#define DMA_CHx_TX_CONTROL_ST_MSB	 0
/* The width in bits of the DMA_CHx_TX_CONTROL_ST register field. */
#define DMA_CHx_TX_CONTROL_ST_WIDTH	 1
/* The mask used to set the DMA_CHx_TX_CONTROL_ST register field value. */
#define DMA_CHx_TX_CONTROL_ST_SET_MSK	 0x00000001
/* The mask used to clear the DMA_CHx_TX_CONTROL_ST register field value. */
#define DMA_CHx_TX_CONTROL_ST_CLR_MSK	 0xfffffffe
/* The reset value of the DMA_CHx_TX_CONTROL_ST register field. */
#define DMA_CHx_TX_CONTROL_ST_RESET	 0x0
/* Extracts the DMA_CHx_TX_CONTROL_ST field value from a register. */
#define DMA_CHx_TX_CONTROL_ST_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_CHx_TX_CONTROL_ST register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL_ST_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_3_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_3_1 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_LSB	   1
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_3_1 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_MSB	   3
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_3_1 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_WIDTH	   3
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_3_1 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_SET_MSK	   0x0000000e
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_3_1 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_CLR_MSK	   0xfffffff1
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_3_1 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_RESET	   0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_3_1 field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_3_1 register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_3_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : Reserved_OSP
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_OSP register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_LSB	   4
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_OSP register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_MSB	   4
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_OSP register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_WIDTH	   1
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_OSP register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_SET_MSK	   0x00000010
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_OSP register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_CLR_MSK	   0xffffffef
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_OSP register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_RESET	   0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_OSP field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_GET(value) (((value)&0x00000010) >> 4)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_OSP register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_OSP_SET(value) (((value) << 4) & 0x00000010)

/*
 * Field : Reserved_11_5
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_11_5 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_LSB	    5
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_11_5 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_MSB	    11
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_11_5 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_WIDTH	    7
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_11_5 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_SET_MSK    0x00000fe0
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_11_5 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_CLR_MSK    0xfffff01f
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_11_5 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_11_5 field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_GET(value) (((value)&0x00000fe0) >> 5)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_11_5 register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_11_5_SET(value) (((value) << 5) & 0x00000fe0)

/*
 * Field : TSE
 *
 * TCP Segmentation Enabled.
 *
 * When this bit is set, the DMA performs the TCP segmentation for packets in
 * Channel 0. The TCP segmentation is done only for those packets for which the TSE
 * bit (TDES0[19]) is set in the Tx Normal descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_TSE register field. */
#define DMA_CHx_TX_CONTROL_TSE_LSB	  12
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_TSE register field. */
#define DMA_CHx_TX_CONTROL_TSE_MSB	  12
/* The width in bits of the DMA_CHx_TX_CONTROL_TSE register field. */
#define DMA_CHx_TX_CONTROL_TSE_WIDTH	  1
/* The mask used to set the DMA_CHx_TX_CONTROL_TSE register field value. */
#define DMA_CHx_TX_CONTROL_TSE_SET_MSK	  0x00001000
/* The mask used to clear the DMA_CHx_TX_CONTROL_TSE register field value. */
#define DMA_CHx_TX_CONTROL_TSE_CLR_MSK	  0xffffefff
/* The reset value of the DMA_CHx_TX_CONTROL_TSE register field. */
#define DMA_CHx_TX_CONTROL_TSE_RESET	  0x0
/* Extracts the DMA_CHx_TX_CONTROL_TSE field value from a register. */
#define DMA_CHx_TX_CONTROL_TSE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a DMA_CHx_TX_CONTROL_TSE register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL_TSE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : Reserved_14_13
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_14_13 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_LSB	     13
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_14_13 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_MSB	     14
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_14_13 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_WIDTH	     2
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_14_13 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_SET_MSK    0x00006000
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_14_13 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_CLR_MSK    0xffff9fff
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_14_13 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_RESET	     0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_14_13 field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_GET(value) (((value)&0x00006000) >> 13)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_14_13 register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_14_13_SET(value) (((value) << 13) & 0x00006000)

/*
 * Field : Reserved_IPBL
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_IPBL register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_LSB	    15
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_IPBL register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_MSB	    15
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_IPBL register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_WIDTH	    1
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_IPBL register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_SET_MSK    0x00008000
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_IPBL register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_CLR_MSK    0xffff7fff
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_IPBL register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_IPBL field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_IPBL register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_IPBL_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : TxPBL
 *
 * Transmit Programmable Burst Length.
 *
 * These bits indicate the maximum number of beats to be transferred in one DMA
 * data transfer. This is the maximum value that is used in a single block Read or
 * Write. The DMA always attempts to burst as specified in PBL each time it starts
 * a burst transfer on the application bus. You can program PBL with any of the
 * following values: 1, 2, 4, 8, 16, or 32. Any other value results in undefined
 * behavior.
 *
 * To transfer more than 32 beats, perform the following steps:
 *
 * * Set the PBLx8 mode in DMA_CH0_Control register.
 *
 * * Set the PBL.
 *
 * Note-1: This PBL is for the internal DMA engine. The AXI Interface block can
 * split this PBL requests from DMA engine into multiple AXI requests based on the
 * programmed values in DMA_SysBus_Mode register.
 *
 * Note-2: The maximum limit is equal to half of the Tx Queue depth (Queue Depth =
 * Queue Size / Datawidth)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_TXPBL register field. */
#define DMA_CHx_TX_CONTROL_TXPBL_LSB	    16
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_TXPBL register field. */
#define DMA_CHx_TX_CONTROL_TXPBL_MSB	    21
/* The width in bits of the DMA_CHx_TX_CONTROL_TXPBL register field. */
#define DMA_CHx_TX_CONTROL_TXPBL_WIDTH	    6
/* The mask used to set the DMA_CHx_TX_CONTROL_TXPBL register field value. */
#define DMA_CHx_TX_CONTROL_TXPBL_SET_MSK    0x003f0000
/* The mask used to clear the DMA_CHx_TX_CONTROL_TXPBL register field value. */
#define DMA_CHx_TX_CONTROL_TXPBL_CLR_MSK    0xffc0ffff
/* The reset value of the DMA_CHx_TX_CONTROL_TXPBL register field. */
#define DMA_CHx_TX_CONTROL_TXPBL_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL_TXPBL field value from a register. */
#define DMA_CHx_TX_CONTROL_TXPBL_GET(value) (((value)&0x003f0000) >> 16)
/* Produces a DMA_CHx_TX_CONTROL_TXPBL register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL_TXPBL_SET(value) (((value) << 16) & 0x003f0000)

/*
 * Field : Reserved_23_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_23_22 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_LSB	     22
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_23_22 register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_MSB	     23
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_23_22 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_WIDTH	     2
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_23_22 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_SET_MSK    0x00c00000
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_23_22 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_CLR_MSK    0xff3fffff
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_23_22 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_RESET	     0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_23_22 field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_GET(value) (((value)&0x00c00000) >> 22)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_23_22 register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_23_22_SET(value) (((value) << 22) & 0x00c00000)

/*
 * Field : TQOS
 *
 * Transmit QOS.
 *
 * This field is used to drive arqos_m_o[3:0] or awqos_m_o[3:0] output signals for
 * all transactions of DMA Tx Channelx.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_TQOS register field. */
#define DMA_CHx_TX_CONTROL_TQOS_LSB	   24
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_TQOS register field. */
#define DMA_CHx_TX_CONTROL_TQOS_MSB	   27
/* The width in bits of the DMA_CHx_TX_CONTROL_TQOS register field. */
#define DMA_CHx_TX_CONTROL_TQOS_WIDTH	   4
/* The mask used to set the DMA_CHx_TX_CONTROL_TQOS register field value. */
#define DMA_CHx_TX_CONTROL_TQOS_SET_MSK	   0x0f000000
/* The mask used to clear the DMA_CHx_TX_CONTROL_TQOS register field value. */
#define DMA_CHx_TX_CONTROL_TQOS_CLR_MSK	   0xf0ffffff
/* The reset value of the DMA_CHx_TX_CONTROL_TQOS register field. */
#define DMA_CHx_TX_CONTROL_TQOS_RESET	   0x0
/* Extracts the DMA_CHx_TX_CONTROL_TQOS field value from a register. */
#define DMA_CHx_TX_CONTROL_TQOS_GET(value) (((value)&0x0f000000) >> 24)
/* Produces a DMA_CHx_TX_CONTROL_TQOS register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL_TQOS_SET(value) (((value) << 24) & 0x0f000000)

/*
 * Field : Reserved_EDSE
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_EDSE register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_LSB	    28
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_EDSE register field.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_MSB	    28
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_EDSE register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_WIDTH	    1
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_EDSE register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_SET_MSK    0x10000000
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_EDSE register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_CLR_MSK    0xefffffff
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_EDSE register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_EDSE field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_GET(value) (((value)&0x10000000) >> 28)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_EDSE register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL_RESERVED_EDSE_SET(value) (((value) << 28) & 0x10000000)

/*
 * Field : TFSEL
 *
 * TBS Fetch Time Select.
 *
 * Select bits for one of the four DMA_TBS_CTRL register fields (FTOS,FGSN,FTOV)
 * for the channel.
 *
 * Note: If Configured Transmit DMA channels are less or equal to 4 then this field
 * is reserved and one to one DMA_TBS_CTRL(#i) register mapping is
 *
 * used for each Channel. Example: DMA_TBS_CTRL0 is used for Channel 0,
 * DMA_TBS_CTRL1 is used for Channel 1, and so on.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                               | Value | Description
 * :-------------------------------------------------------------------|:------|:------------
 *  DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL0 | 0x0   |
 *  DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL1 | 0x1   |
 *  DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL2 | 0x2   |
 *  DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL3 | 0x3   |
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field DMA_CHx_TX_CONTROL_TFSEL
 *
 */
#define DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL0 0x0
/*
 * Enumerated value for register field DMA_CHx_TX_CONTROL_TFSEL
 *
 */
#define DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL1 0x1
/*
 * Enumerated value for register field DMA_CHx_TX_CONTROL_TFSEL
 *
 */
#define DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL2 0x2
/*
 * Enumerated value for register field DMA_CHx_TX_CONTROL_TFSEL
 *
 */
#define DMA_CHx_TX_CONTROL_TFSEL_E_DMA_TBS_CTRL3 0x3

/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_TFSEL register field. */
#define DMA_CHx_TX_CONTROL_TFSEL_LSB	    29
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_TFSEL register field. */
#define DMA_CHx_TX_CONTROL_TFSEL_MSB	    30
/* The width in bits of the DMA_CHx_TX_CONTROL_TFSEL register field. */
#define DMA_CHx_TX_CONTROL_TFSEL_WIDTH	    2
/* The mask used to set the DMA_CHx_TX_CONTROL_TFSEL register field value. */
#define DMA_CHx_TX_CONTROL_TFSEL_SET_MSK    0x60000000
/* The mask used to clear the DMA_CHx_TX_CONTROL_TFSEL register field value. */
#define DMA_CHx_TX_CONTROL_TFSEL_CLR_MSK    0x9fffffff
/* The reset value of the DMA_CHx_TX_CONTROL_TFSEL register field. */
#define DMA_CHx_TX_CONTROL_TFSEL_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL_TFSEL field value from a register. */
#define DMA_CHx_TX_CONTROL_TFSEL_GET(value) (((value)&0x60000000) >> 29)
/* Produces a DMA_CHx_TX_CONTROL_TFSEL register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL_TFSEL_SET(value) (((value) << 29) & 0x60000000)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL_RESERVED_31 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_LSB	  31
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL_RESERVED_31 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_MSB	  31
/* The width in bits of the DMA_CHx_TX_CONTROL_RESERVED_31 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_WIDTH	  1
/* The mask used to set the DMA_CHx_TX_CONTROL_RESERVED_31 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_SET_MSK	  0x80000000
/* The mask used to clear the DMA_CHx_TX_CONTROL_RESERVED_31 register field value. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_CLR_MSK	  0x7fffffff
/* The reset value of the DMA_CHx_TX_CONTROL_RESERVED_31 register field. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_RESET	  0x0
/* Extracts the DMA_CHx_TX_CONTROL_RESERVED_31 field value from a register. */
#define DMA_CHx_TX_CONTROL_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a DMA_CHx_TX_CONTROL_RESERVED_31 register field value suitable for setting the register.
 */
#define DMA_CHx_TX_CONTROL_RESERVED_31_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TX_CONTROL.
 */
struct DMA_CHx_TX_CONTROL_s {
	volatile uint32_t ST : 1;		    /* DMA_CHx_TX_CONTROL_ST */
	const volatile uint32_t Reserved_3_1 : 3;   /* DMA_CHx_TX_CONTROL_RESERVED_3_1 */
	const volatile uint32_t Reserved_OSP : 1;   /* DMA_CHx_TX_CONTROL_RESERVED_OSP */
	const volatile uint32_t Reserved_11_5 : 7;  /* DMA_CHx_TX_CONTROL_RESERVED_11_5 */
	volatile uint32_t TSE : 1;		    /* DMA_CHx_TX_CONTROL_TSE */
	const volatile uint32_t Reserved_14_13 : 2; /* DMA_CHx_TX_CONTROL_RESERVED_14_13 */
	const volatile uint32_t Reserved_IPBL : 1;  /* DMA_CHx_TX_CONTROL_RESERVED_IPBL */
	volatile uint32_t TxPBL : 6;		    /* DMA_CHx_TX_CONTROL_TXPBL */
	const volatile uint32_t Reserved_23_22 : 2; /* DMA_CHx_TX_CONTROL_RESERVED_23_22 */
	volatile uint32_t TQOS : 4;		    /* DMA_CHx_TX_CONTROL_TQOS */
	const volatile uint32_t Reserved_EDSE : 1;  /* DMA_CHx_TX_CONTROL_RESERVED_EDSE */
	volatile uint32_t TFSEL : 2;		    /* DMA_CHx_TX_CONTROL_TFSEL */
	const volatile uint32_t Reserved_31 : 1;    /* DMA_CHx_TX_CONTROL_RESERVED_31 */
};

/* The typedef declaration for register DMA_CHx_TX_CONTROL. */
typedef struct DMA_CHx_TX_CONTROL_s DMA_CHx_TX_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TX_CONTROL register. */
#define DMA_CHx_TX_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_CHx_TX_CONTROL register from the beginning of the component. */
#define DMA_CHx_TX_CONTROL_OFST	 0x4

/*
 * Register : DMA_CH0_Rx_Control
 *
 * The DMA Channelx Receive Control register controls the Rx features such as PBL,
 * buffer size, and extended status.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_CHx_RX_CONTROL_SR
 *  [3:1]   | R      | 0x0   | DMA_CHx_RX_CONTROL_RESERVED_X_1
 *  [14:4]  | RW     | 0x0   | DMA_CHx_RX_CONTROL_RBSZ
 *  [15]    | R      | 0x0   | DMA_CHx_RX_CONTROL_RESERVED_15
 *  [21:16] | RW     | 0x0   | DMA_CHx_RX_CONTROL_RXPBL
 *  [23:22] | R      | 0x0   | DMA_CHx_RX_CONTROL_RESERVED_23_22
 *  [27:24] | RW     | 0x0   | DMA_CHx_RX_CONTROL_RQOS
 *  [30:28] | R      | 0x0   | DMA_CHx_RX_CONTROL_RESERVED_30_28
 *  [31]    | RW     | 0x0   | DMA_CHx_RX_CONTROL_RPF
 *
 */
/*
 * Field : SR
 *
 * Start or Stop Receive.
 *
 * * 1: DMA tries to acquire the descriptor from the Receive list and processes the
 *   incoming packets.
 *
 * The DMA tries to acquire descriptor from either of the following positions:
 *
 * * - The current position in the list
 *
 * This is the address set by the DMA_CH0_RxDesc_List_LAddress register.
 *
 * * - The position at which the Rx process was previously stopped
 *
 * If the DMA does not own the current descriptor, the reception is suspended and
 * the RBU bit of the DMA_CH0_Status register is set. The Start Receive command is
 * effective only when the reception is stopped. If the command is issued before
 * setting the DMA_CH0_RxDesc_List_LAddress register, the DMA behavior is
 * unpredictable.
 *
 * * 0: Rx DMA operation is stopped after the transfer of the current packet. The
 *   next descriptor position in the Receive list is saved, and it becomes the
 *   current position after the Rx process is restarted. The Stop Receive command
 *   is effective only when the Rx process is in the Running (waiting for Rx
 *   packet) or Suspended state. Similarly, Start Receive command is effective only
 *   when the Receive process is in the Stopped state. So, read the RD*S fields in
 *   the corresponding channel's DMA_CH0_Debug Status register before writing the
 *   SR bit (Start or Stop Receive) in DMA_CH0_RX_Control register. Additionally,
 *   when RSE and AIE bits of DMA_CH0_Interrupt_Enable register are set, an
 *   interrupt is generated when the Rx DMA is stopped.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_SR register field. */
#define DMA_CHx_RX_CONTROL_SR_LSB	 0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_SR register field. */
#define DMA_CHx_RX_CONTROL_SR_MSB	 0
/* The width in bits of the DMA_CHx_RX_CONTROL_SR register field. */
#define DMA_CHx_RX_CONTROL_SR_WIDTH	 1
/* The mask used to set the DMA_CHx_RX_CONTROL_SR register field value. */
#define DMA_CHx_RX_CONTROL_SR_SET_MSK	 0x00000001
/* The mask used to clear the DMA_CHx_RX_CONTROL_SR register field value. */
#define DMA_CHx_RX_CONTROL_SR_CLR_MSK	 0xfffffffe
/* The reset value of the DMA_CHx_RX_CONTROL_SR register field. */
#define DMA_CHx_RX_CONTROL_SR_RESET	 0x0
/* Extracts the DMA_CHx_RX_CONTROL_SR field value from a register. */
#define DMA_CHx_RX_CONTROL_SR_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_CHx_RX_CONTROL_SR register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL_SR_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : Reserved_x_1
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RESERVED_X_1 register field.
 */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_LSB	   1
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RESERVED_X_1 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_MSB	   3
/* The width in bits of the DMA_CHx_RX_CONTROL_RESERVED_X_1 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_WIDTH	   3
/* The mask used to set the DMA_CHx_RX_CONTROL_RESERVED_X_1 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_SET_MSK	   0x0000000e
/* The mask used to clear the DMA_CHx_RX_CONTROL_RESERVED_X_1 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_CLR_MSK	   0xfffffff1
/* The reset value of the DMA_CHx_RX_CONTROL_RESERVED_X_1 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_RESET	   0x0
/* Extracts the DMA_CHx_RX_CONTROL_RESERVED_X_1 field value from a register. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_GET(value) (((value)&0x0000000e) >> 1)
/* Produces a DMA_CHx_RX_CONTROL_RESERVED_X_1 register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_CONTROL_RESERVED_X_1_SET(value) (((value) << 1) & 0x0000000e)

/*
 * Field : RBSZ
 *
 * Receive Buffer size.
 *
 * This field indicates the size of the Rx buffers specified in bytes allocated by
 * the software to store the packets the Rx DMA transfers to the host memory. The
 * maximum buffer size is limited to 16K bytes. The buffer size is applicable to
 * payload buffers when split headers are enabled.
 *
 * Note-1:  The buffer size must be a multiple of 8 or 16 depending on the bus
 * widths (64 or 128 respectively). This is required even if the value of buffer
 * address pointer is not aligned to bus width. If the buffer size is not a
 * multiple of 8 or 16, it might result into undefined behavior.
 *
 * The LSB bits (2:0, or 3:0) for 64-bit or 128-bit bus width are ignored and the
 * DMA internally takes the LSB bits as all-zero. Therefore, these LSB bits are
 * read-only (RO). Therefore, the maximum values that can be programmed into this
 * field are 0x3FF8 (16376) and 0x3FF0 (16368) in 64-bit and 128-bit
 * configurations, respectively.
 *
 * Note-2:  It is recommended to program a minimum size of 256 bytes for better
 * performance.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RBSZ register field. */
#define DMA_CHx_RX_CONTROL_RBSZ_LSB	   4
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RBSZ register field. */
#define DMA_CHx_RX_CONTROL_RBSZ_MSB	   14
/* The width in bits of the DMA_CHx_RX_CONTROL_RBSZ register field. */
#define DMA_CHx_RX_CONTROL_RBSZ_WIDTH	   11
/* The mask used to set the DMA_CHx_RX_CONTROL_RBSZ register field value. */
#define DMA_CHx_RX_CONTROL_RBSZ_SET_MSK	   0x00007ff0
/* The mask used to clear the DMA_CHx_RX_CONTROL_RBSZ register field value. */
#define DMA_CHx_RX_CONTROL_RBSZ_CLR_MSK	   0xffff800f
/* The reset value of the DMA_CHx_RX_CONTROL_RBSZ register field. */
#define DMA_CHx_RX_CONTROL_RBSZ_RESET	   0x0
/* Extracts the DMA_CHx_RX_CONTROL_RBSZ field value from a register. */
#define DMA_CHx_RX_CONTROL_RBSZ_GET(value) (((value)&0x00007ff0) >> 4)
/* Produces a DMA_CHx_RX_CONTROL_RBSZ register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL_RBSZ_SET(value) (((value) << 4) & 0x00007ff0)

/*
 * Field : Reserved_15
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RESERVED_15 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_LSB	  15
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RESERVED_15 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_MSB	  15
/* The width in bits of the DMA_CHx_RX_CONTROL_RESERVED_15 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_WIDTH	  1
/* The mask used to set the DMA_CHx_RX_CONTROL_RESERVED_15 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_SET_MSK	  0x00008000
/* The mask used to clear the DMA_CHx_RX_CONTROL_RESERVED_15 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_CLR_MSK	  0xffff7fff
/* The reset value of the DMA_CHx_RX_CONTROL_RESERVED_15 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_RESET	  0x0
/* Extracts the DMA_CHx_RX_CONTROL_RESERVED_15 field value from a register. */
#define DMA_CHx_RX_CONTROL_RESERVED_15_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_CHx_RX_CONTROL_RESERVED_15 register field value suitable for setting the register.
 */
#define DMA_CHx_RX_CONTROL_RESERVED_15_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : RxPBL
 *
 * Receive Programmable Burst Length.
 *
 * These bits indicate the maximum number of beats to be transferred in one DMA
 * data transfer. This is the maximum value that is used in a single block Read or
 * Write. The DMA always attempts to burst as specified in PBL each time it starts
 * a burst transfer on the application bus. You can program PBL with any of the
 * following values: 1, 2, 4, 8, 16, or 32. Any other value results in undefined
 * behavior. It is recommended to use higher values (8 and higher) for better
 * performance. A value of 0 might result in undefined behavior.
 *
 * To transfer more than 32 beats, perform the following steps:
 *
 * * Set the PBLx8 mode in the DMA_CH0_Control register.
 *
 * * Set the PBL.
 *
 * Note-1: This PBL is for the internal DMA engine. The AXI Interface block can
 * split this PBL requests from DMA engine into multiple AXI requests based on the
 * programmed values in DMA_SysBus_Mode register.
 *
 * Note-2: The maximum limit is equal to half of the Rx Queue Depth (Queue Depth =
 * Queue Size / Datawidth in bytes). For example, in 64-bit configuration, there
 * are 8 bytes per location. So, when Rx Queue Size is 256 bytes, the Rx Queue
 * Depth = 256/8 = 32. The RxPBL must be programmed <= total no. of locations in Rx
 * Queue/2, so RxPBL must be programmed less than 32.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RXPBL register field. */
#define DMA_CHx_RX_CONTROL_RXPBL_LSB	    16
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RXPBL register field. */
#define DMA_CHx_RX_CONTROL_RXPBL_MSB	    21
/* The width in bits of the DMA_CHx_RX_CONTROL_RXPBL register field. */
#define DMA_CHx_RX_CONTROL_RXPBL_WIDTH	    6
/* The mask used to set the DMA_CHx_RX_CONTROL_RXPBL register field value. */
#define DMA_CHx_RX_CONTROL_RXPBL_SET_MSK    0x003f0000
/* The mask used to clear the DMA_CHx_RX_CONTROL_RXPBL register field value. */
#define DMA_CHx_RX_CONTROL_RXPBL_CLR_MSK    0xffc0ffff
/* The reset value of the DMA_CHx_RX_CONTROL_RXPBL register field. */
#define DMA_CHx_RX_CONTROL_RXPBL_RESET	    0x0
/* Extracts the DMA_CHx_RX_CONTROL_RXPBL field value from a register. */
#define DMA_CHx_RX_CONTROL_RXPBL_GET(value) (((value)&0x003f0000) >> 16)
/* Produces a DMA_CHx_RX_CONTROL_RXPBL register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL_RXPBL_SET(value) (((value) << 16) & 0x003f0000)

/*
 * Field : Reserved_23_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RESERVED_23_22 register field.
 */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_LSB	     22
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RESERVED_23_22 register field.
 */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_MSB	     23
/* The width in bits of the DMA_CHx_RX_CONTROL_RESERVED_23_22 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_WIDTH	     2
/* The mask used to set the DMA_CHx_RX_CONTROL_RESERVED_23_22 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_SET_MSK    0x00c00000
/* The mask used to clear the DMA_CHx_RX_CONTROL_RESERVED_23_22 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_CLR_MSK    0xff3fffff
/* The reset value of the DMA_CHx_RX_CONTROL_RESERVED_23_22 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_RESET	     0x0
/* Extracts the DMA_CHx_RX_CONTROL_RESERVED_23_22 field value from a register. */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_GET(value) (((value)&0x00c00000) >> 22)
/* Produces a DMA_CHx_RX_CONTROL_RESERVED_23_22 register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_CONTROL_RESERVED_23_22_SET(value) (((value) << 22) & 0x00c00000)

/*
 * Field : RQOS
 *
 * Receive QOS.
 *
 * This field is used to drive arqos_m_o[3:0] or awqos_m_o[3:0] output signals for
 * all transactions of DMA Rx Channelx.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RQOS register field. */
#define DMA_CHx_RX_CONTROL_RQOS_LSB	   24
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RQOS register field. */
#define DMA_CHx_RX_CONTROL_RQOS_MSB	   27
/* The width in bits of the DMA_CHx_RX_CONTROL_RQOS register field. */
#define DMA_CHx_RX_CONTROL_RQOS_WIDTH	   4
/* The mask used to set the DMA_CHx_RX_CONTROL_RQOS register field value. */
#define DMA_CHx_RX_CONTROL_RQOS_SET_MSK	   0x0f000000
/* The mask used to clear the DMA_CHx_RX_CONTROL_RQOS register field value. */
#define DMA_CHx_RX_CONTROL_RQOS_CLR_MSK	   0xf0ffffff
/* The reset value of the DMA_CHx_RX_CONTROL_RQOS register field. */
#define DMA_CHx_RX_CONTROL_RQOS_RESET	   0x0
/* Extracts the DMA_CHx_RX_CONTROL_RQOS field value from a register. */
#define DMA_CHx_RX_CONTROL_RQOS_GET(value) (((value)&0x0f000000) >> 24)
/* Produces a DMA_CHx_RX_CONTROL_RQOS register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL_RQOS_SET(value) (((value) << 24) & 0x0f000000)

/*
 * Field : Reserved_30_28
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RESERVED_30_28 register field.
 */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_LSB	     28
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RESERVED_30_28 register field.
 */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_MSB	     30
/* The width in bits of the DMA_CHx_RX_CONTROL_RESERVED_30_28 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_WIDTH	     3
/* The mask used to set the DMA_CHx_RX_CONTROL_RESERVED_30_28 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_SET_MSK    0x70000000
/* The mask used to clear the DMA_CHx_RX_CONTROL_RESERVED_30_28 register field value. */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_CLR_MSK    0x8fffffff
/* The reset value of the DMA_CHx_RX_CONTROL_RESERVED_30_28 register field. */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_RESET	     0x0
/* Extracts the DMA_CHx_RX_CONTROL_RESERVED_30_28 field value from a register. */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_GET(value) (((value)&0x70000000) >> 28)
/* Produces a DMA_CHx_RX_CONTROL_RESERVED_30_28 register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_CONTROL_RESERVED_30_28_SET(value) (((value) << 28) & 0x70000000)

/*
 * Field : RPF
 *
 * Rx DMA Channelx Packet Flush.
 *
 * When this bit is set to 1, then DWC_xgmac automatically flushes the packet from
 * the Rx Queues destined to this DMA Rx Channel, when it is stopped. When this bit
 * remains set and the DMA is re-started by the software driver the packets
 * residing in the Rx Queues that were received when the DMA is stopped, still gets
 * flushed out. The packets received by the MAC only after the DMA is re-started is
 * routed to the RxDMA. The flushing is done on the Read side of the Rx Queue.
 *
 * When this bit is set to 0, DWC_xgmac does not flush the packet in the Rx Queue
 * destined to this RxDMA Channel when it is STOP state. This might cause head-of-
 * line blocking in the corresponding RxQueue.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL_RPF register field. */
#define DMA_CHx_RX_CONTROL_RPF_LSB	  31
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL_RPF register field. */
#define DMA_CHx_RX_CONTROL_RPF_MSB	  31
/* The width in bits of the DMA_CHx_RX_CONTROL_RPF register field. */
#define DMA_CHx_RX_CONTROL_RPF_WIDTH	  1
/* The mask used to set the DMA_CHx_RX_CONTROL_RPF register field value. */
#define DMA_CHx_RX_CONTROL_RPF_SET_MSK	  0x80000000
/* The mask used to clear the DMA_CHx_RX_CONTROL_RPF register field value. */
#define DMA_CHx_RX_CONTROL_RPF_CLR_MSK	  0x7fffffff
/* The reset value of the DMA_CHx_RX_CONTROL_RPF register field. */
#define DMA_CHx_RX_CONTROL_RPF_RESET	  0x0
/* Extracts the DMA_CHx_RX_CONTROL_RPF field value from a register. */
#define DMA_CHx_RX_CONTROL_RPF_GET(value) (((value)&0x80000000) >> 31)
/* Produces a DMA_CHx_RX_CONTROL_RPF register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL_RPF_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RX_CONTROL.
 */
struct DMA_CHx_RX_CONTROL_s {
	volatile uint32_t SR : 1;		    /* DMA_CHx_RX_CONTROL_SR */
	const volatile uint32_t Reserved_x_1 : 3;   /* DMA_CHx_RX_CONTROL_RESERVED_X_1 */
	volatile uint32_t RBSZ : 11;		    /* DMA_CHx_RX_CONTROL_RBSZ */
	const volatile uint32_t Reserved_15 : 1;    /* DMA_CHx_RX_CONTROL_RESERVED_15 */
	volatile uint32_t RxPBL : 6;		    /* DMA_CHx_RX_CONTROL_RXPBL */
	const volatile uint32_t Reserved_23_22 : 2; /* DMA_CHx_RX_CONTROL_RESERVED_23_22 */
	volatile uint32_t RQOS : 4;		    /* DMA_CHx_RX_CONTROL_RQOS */
	const volatile uint32_t Reserved_30_28 : 3; /* DMA_CHx_RX_CONTROL_RESERVED_30_28 */
	volatile uint32_t RPF : 1;		    /* DMA_CHx_RX_CONTROL_RPF */
};

/* The typedef declaration for register DMA_CHx_RX_CONTROL. */
typedef struct DMA_CHx_RX_CONTROL_s DMA_CHx_RX_CONTROL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RX_CONTROL register. */
#define DMA_CHx_RX_CONTROL_RESET 0x00000000
/* The byte offset of the DMA_CHx_RX_CONTROL register from the beginning of the component. */
#define DMA_CHx_RX_CONTROL_OFST	 0x8

/*
 * Register : DMA_CH0_Slot_Function_Control_Status
 *
 * This register contains the control bits for slot function and its status for
 * Transmit path.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC
 *  [1]     | RW     | 0x0   | DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC
 *  [15:2]  | R      | 0x0   | DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2
 *  [19:16] | R      | 0x0   | DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN
 *  [31:20] | R      | 0x0   | DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20
 *
 */
/*
 * Field : ESC
 *
 * Enable Slot Comparison
 *
 * When set, this bit enables the checking of the slot numbers programmed in the Tx
 * descriptor with the current reference given in the RSN field. The DMA fetches
 * the data from the corresponding buffer only when the slot number is
 *
 * * equal to the reference slot number or
 *
 * * ahead of the reference slot number by one slot.
 *
 * When reset, this bit disables the checking of the slot numbers. The DMA fetches
 * the data immediately after the descriptor is processed.
 *
 * Note:  Do not enable TSO along with TBS/Audio Video Bridging Slot number check.
 * The TSO involves transmission of multiple segments for a single packet received
 * from application and the slot number check is applicable for fetching only the
 * first segment/fragment. So, it might be difficult for the software to specify
 * slot number for subsequent packets.
 *
 * Field Enumeration Values:
 *
 *  Enum                                                                         | Value |
 * Description
 * :-----------------------------------------------------------------------------|:------|:----------------------------
 *  DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_E_DISABLE | 0x0   | Slot Comparison is disabled
 *  DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_E_ENABLE  | 0x1   | Slot Comparison is enabled
 *
 * Field Access Macros:
 *
 */
/*
 * Enumerated value for register field DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC
 *
 * Slot Comparison is disabled
 */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_E_DISABLE 0x0
/*
 * Enumerated value for register field DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC
 *
 * Slot Comparison is enabled
 */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_E_ENABLE  0x1

/* The Least Significant Bit (LSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register
 * field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register
 * field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_MSB	    0
/* The width in bits of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_WIDTH	    1
/* The mask used to set the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register field value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_SET_MSK    0x00000001
/* The mask used to clear the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register field value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_CLR_MSK    0xfffffffe
/* The reset value of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_RESET	    0x0
/* Extracts the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC field value from a register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC register field value suitable for setting the
 * register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : ASC
 *
 * Advance Slot Check
 *
 * When set, this bit enables the DMA to fetch the data from the buffer when the
 * slot number (SLOTNUM) programmed in the Tx descriptor is
 *
 * * Equal to the reference slot number given in the RSN field or
 *
 * * Ahead of the reference slot number by upto two slots.
 *
 * This bit is applicable only when the ESC bit is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register
 * field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_LSB	    1
/* The Most Significant Bit (MSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register
 * field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_MSB	    1
/* The width in bits of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_WIDTH	    1
/* The mask used to set the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register field value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_SET_MSK    0x00000002
/* The mask used to clear the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register field value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_CLR_MSK    0xfffffffd
/* The reset value of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_RESET	    0x0
/* Extracts the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC field value from a register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC register field value suitable for setting the
 * register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : Reserved_15_2
 *
 * Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_LSB	      2
/* The Most Significant Bit (MSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2
 * register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_MSB	      15
/* The width in bits of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_WIDTH      14
/* The mask used to set the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 register field value.
 */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_SET_MSK    0x0000fffc
/* The mask used to clear the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 register field
 * value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_CLR_MSK    0xffff0003
/* The reset value of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_RESET      0x0
/* Extracts the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 field value from a register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_GET(value) (((value)&0x0000fffc) >> 2)
/* Produces a DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 register field value suitable for
 * setting the register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2_SET(value) (((value) << 2) & 0x0000fffc)

/*
 * Field : RSN
 *
 * Reference Slot Number
 *
 * This field gives the current value of the reference slot number in the DMA. It
 * is used for slot comparison.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register
 * field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_LSB	    16
/* The Most Significant Bit (MSB) position of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register
 * field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_MSB	    19
/* The width in bits of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_WIDTH	    4
/* The mask used to set the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register field value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_SET_MSK    0x000f0000
/* The mask used to clear the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register field value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_CLR_MSK    0xfff0ffff
/* The reset value of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_RESET	    0x0
/* Extracts the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN field value from a register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_GET(value) (((value)&0x000f0000) >> 16)
/* Produces a DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN register field value suitable for setting the
 * register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN_SET(value) (((value) << 16) & 0x000f0000)

/*
 * Field : Reserved_31_20
 *
 * Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_LSB	       20
/* The Most Significant Bit (MSB) position of the
 * DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_MSB	       31
/* The width in bits of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_WIDTH      12
/* The mask used to set the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field
 * value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_SET_MSK    0xfff00000
/* The mask used to clear the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field
 * value. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_CLR_MSK    0x000fffff
/* The reset value of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_RESET      0x0
/* Extracts the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 field value from a register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_GET(value) (((value)&0xfff00000) >> 20)
/* Produces a DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 register field value suitable for
 * setting the register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20_SET(value)                             \
	(((value) << 20) & 0xfff00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS.
 */
struct DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_s {
	volatile uint32_t ESC : 1; /* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ESC */
	volatile uint32_t ASC : 1; /* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_ASC */
	const volatile uint32_t
		Reserved_15_2 : 14;	 /* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_15_2 */
	const volatile uint32_t RSN : 4; /* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RSN */
	const volatile uint32_t
		Reserved_31_20 : 12; /* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESERVED_31_20 */
};

/* The typedef declaration for register DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS. */
typedef struct DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_s DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS register. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_RESET 0x00000000
/* The byte offset of the DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS register from the beginning of the
 * component. */
#define DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_OFST  0xc

/*
 * Register : DMA_CH0_TxDesc_List_HAddress
 *
 * The Channelx Tx Descriptor List HAddress register has the higher 8 or 16 bits of
 * the start address of the Transmit descriptor list. This register is present only
 * when DWC_xgmac is configured for 40-bit or 48-bit addressing mode.
 *
 * You can write to this register only when the Tx DMA has stopped, that is, the ST
 * bit is set to zero in DMA_CH0_Tx_Control register. When stopped, this register
 * can be written with a new descriptor list address. When you set the ST bit to 1,
 * the DMA takes the newly-programmed descriptor base address. If this register is
 * not changed when the ST bit is set to 0, the DMA takes the descriptor address
 * where it was stopped earlier. This register must be programmed with desired
 * higher address before programming the DMA_CH0_TxDesc_List_LAddress register.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [7:0]  | RW     | 0x0   | DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA
 *  [31:8] | R      | 0x0   | DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y
 *
 */
/*
 * Field : TDESHA
 *
 * Start of Transmit List.
 *
 * This field contains the most-significant 8 or 16 bits of the 40 or 48-bit base
 * address of the first descriptor in the Transmit descriptor list.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register
 * field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_LSB	       0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register
 * field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_MSB	       7
/* The width in bits of the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_WIDTH      8
/* The mask used to set the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register field value. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_SET_MSK    0x000000ff
/* The mask used to clear the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register field value. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_CLR_MSK    0xffffff00
/* The reset value of the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_RESET      0x0
/* Extracts the DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA field value from a register. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA register field value suitable for setting the
 * register. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y
 * register field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y
 * register field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_MSB	      31
/* The width in bits of the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y register field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_WIDTH      24
/* The mask used to set the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y register field value. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_SET_MSK    0xffffff00
/* The mask used to clear the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y register field value. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_CLR_MSK    0x000000ff
/* The reset value of the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y register field. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_RESET      0x0
/* Extracts the DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y field value from a register. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y register field value suitable for setting
 * the register. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TXDESC_LIST_HADDRESS.
 */
struct DMA_CHx_TXDESC_LIST_HADDRESS_s {
	volatile uint32_t TDESHA : 8;		    /* DMA_CHx_TXDESC_LIST_HADDRESS_TDESHA */
	const volatile uint32_t Reserved_31_y : 24; /* DMA_CHx_TXDESC_LIST_HADDRESS_RESERVED_31_Y */
};

/* The typedef declaration for register DMA_CHx_TXDESC_LIST_HADDRESS. */
typedef struct DMA_CHx_TXDESC_LIST_HADDRESS_s DMA_CHx_TXDESC_LIST_HADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TXDESC_LIST_HADDRESS register. */
#define DMA_CHx_TXDESC_LIST_HADDRESS_RESET 0x00000000
/* The byte offset of the DMA_CHx_TXDESC_LIST_HADDRESS register from the beginning of the component.
 */
#define DMA_CHx_TXDESC_LIST_HADDRESS_OFST  0x10

/*
 * Register : DMA_CH0_TxDesc_List_LAddress
 *
 * The Channelx Tx Descriptor List LAddress register has the lower 32 bits of the
 * start address of the Transmit descriptor list. The descriptor lists reside in
 * the physical memory space of the application and must be Dword, or Lword-aligned
 * (for 64-bit or 128-bit data bus). The DMA internally converts it to bus width
 * aligned address by making the corresponding LSB to low.
 *
 * You can write to this register only when the Tx DMA has stopped, that is, the ST
 * bit is set to zero in DMA_CH0_Tx_Control register. When stopped, this register
 * can be written with a new descriptor list address. When you set the ST bit to 1,
 * the DMA takes the newly-programmed descriptor base address. If this register is
 * not changed when the ST bit is set to 0, the DMA takes the descriptor address
 * where it was stopped earlier.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [2:0]  | R      | 0x0   | DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0
 *  [31:3] | RW     | 0x0   | DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA
 *
 */
/*
 * Field : Reserved_x_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0
 * register field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 register
 * field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_MSB	     2
/* The width in bits of the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 register field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_WIDTH	     3
/* The mask used to set the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 register field value. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_SET_MSK    0x00000007
/* The mask used to clear the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 register field value. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_CLR_MSK    0xfffffff8
/* The reset value of the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 register field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_RESET	     0x0
/* Extracts the DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 field value from a register. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_GET(value) (((value)&0x00000007) >> 0)
/* Produces a DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 register field value suitable for setting
 * the register. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : TDESLA
 *
 * Start of Transmit List.
 *
 * This field contains the base address of the first descriptor in the Transmit
 * descriptor list. The DMA ignores the LSB bits (2:0 or 3:0) for 64-bit or 128-bit
 * bus width and internally takes these bits as all-zero. Therefore, these LSB bits
 * are read-only (RO).
 *
 * The width of this field depends on the configuration:
 *
 * * 31:3 for 64-bit configuration
 *
 * * 31:4 for 128-bit configuration
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register
 * field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_LSB	       3
/* The Most Significant Bit (MSB) position of the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register
 * field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_MSB	       31
/* The width in bits of the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_WIDTH      29
/* The mask used to set the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register field value. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_SET_MSK    0xfffffff8
/* The mask used to clear the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register field value. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_CLR_MSK    0x00000007
/* The reset value of the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register field. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_RESET      0x0
/* Extracts the DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA field value from a register. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_GET(value) (((value)&0xfffffff8) >> 3)
/* Produces a DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA register field value suitable for setting the
 * register. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA_SET(value) (((value) << 3) & 0xfffffff8)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TXDESC_LIST_LADDRESS.
 */
struct DMA_CHx_TXDESC_LIST_LADDRESS_s {
	const volatile uint32_t Reserved_x_0 : 3; /* DMA_CHx_TXDESC_LIST_LADDRESS_RESERVED_X_0 */
	volatile uint32_t TDESLA : 29;		  /* DMA_CHx_TXDESC_LIST_LADDRESS_TDESLA */
};

/* The typedef declaration for register DMA_CHx_TXDESC_LIST_LADDRESS. */
typedef struct DMA_CHx_TXDESC_LIST_LADDRESS_s DMA_CHx_TXDESC_LIST_LADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TXDESC_LIST_LADDRESS register. */
#define DMA_CHx_TXDESC_LIST_LADDRESS_RESET 0x00000000
/* The byte offset of the DMA_CHx_TXDESC_LIST_LADDRESS register from the beginning of the component.
 */
#define DMA_CHx_TXDESC_LIST_LADDRESS_OFST  0x14

/*
 * Register : DMA_CH0_RxDesc_List_HAddress
 *
 * The Channelx Rx Descriptor List HAddress register has the higher 8 or 16 bits of
 * the start address of the Receive descriptor list. This register is present only
 * when DWC_xgmac is configured for 40-bit or 48-bit addressing mode.
 *
 * You can write to this register only when the Rx DMA has stopped, that is, the SR
 * bit is set to zero in DMA_CH0_Rx_Control register. When stopped, this register
 * can be written with a new descriptor list address. When you set the SR bit to 1,
 * the DMA takes the newly-programmed descriptor base address. If this register is
 * not changed when the SR bit is set to 0, the DMA takes the descriptor address
 * where it was stopped earlier. This register must be programmed with desired
 * higher address before programming the DMA_CH0_RxDesc_List_LAddress register.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [7:0]  | RW     | 0x0   | DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA
 *  [31:8] | R      | 0x0   | DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y
 *
 */
/*
 * Field : RDESHA
 *
 * Start of Receive List.
 *
 * This field contains the most-significant 8 or 16 bits of the 40- or 48-bit base
 * address of the first descriptor in the Receive Descriptor list.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register
 * field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_LSB	       0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register
 * field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_MSB	       7
/* The width in bits of the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_WIDTH      8
/* The mask used to set the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register field value. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_SET_MSK    0x000000ff
/* The mask used to clear the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register field value. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_CLR_MSK    0xffffff00
/* The reset value of the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_RESET      0x0
/* Extracts the DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA field value from a register. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA register field value suitable for setting the
 * register. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y
 * register field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y
 * register field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_MSB	      31
/* The width in bits of the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y register field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_WIDTH      24
/* The mask used to set the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y register field value. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_SET_MSK    0xffffff00
/* The mask used to clear the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y register field value. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_CLR_MSK    0x000000ff
/* The reset value of the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y register field. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_RESET      0x0
/* Extracts the DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y field value from a register. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y register field value suitable for setting
 * the register. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RXDESC_LIST_HADDRESS.
 */
struct DMA_CHx_RXDESC_LIST_HADDRESS_s {
	volatile uint32_t RDESHA : 8;		    /* DMA_CHx_RXDESC_LIST_HADDRESS_RDESHA */
	const volatile uint32_t Reserved_31_y : 24; /* DMA_CHx_RXDESC_LIST_HADDRESS_RESERVED_31_Y */
};

/* The typedef declaration for register DMA_CHx_RXDESC_LIST_HADDRESS. */
typedef struct DMA_CHx_RXDESC_LIST_HADDRESS_s DMA_CHx_RXDESC_LIST_HADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RXDESC_LIST_HADDRESS register. */
#define DMA_CHx_RXDESC_LIST_HADDRESS_RESET 0x00000000
/* The byte offset of the DMA_CHx_RXDESC_LIST_HADDRESS register from the beginning of the component.
 */
#define DMA_CHx_RXDESC_LIST_HADDRESS_OFST  0x18

/*
 * Register : DMA_CH0_RxDesc_List_LAddress
 *
 * The Channelx Rx Descriptor List LAddress register has the lower 32 bits of the
 * start address of the Receive descriptor list.
 *
 * This register points to the start of the Receive Descriptor List. The descriptor
 * lists reside in the physical memory space of the application and must be Dword
 * or Lword-aligned (for 64-bit or 128-bit data bus). The DMA internally converts
 * it to bus width aligned address by making the corresponding LS bits low. Writing
 * to this register is permitted only when reception is stopped. When stopped, this
 * register must be written to before the receive Start command is given. You can
 * write to this register only when Rx DMA has stopped, that is, SR bit is set to
 * zero in DMA_CH0_Rx_Control register. When stopped, this register can be written
 * with a new descriptor list address.
 *
 * When you set the SR bit to 1, the DMA takes the newly programmed descriptor base
 * address.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [2:0]  | R      | 0x0   | DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0
 *  [31:3] | RW     | 0x0   | DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA
 *
 */
/*
 * Field : Reserved_x_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0
 * register field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 register
 * field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_MSB	     2
/* The width in bits of the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 register field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_WIDTH	     3
/* The mask used to set the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 register field value. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_SET_MSK    0x00000007
/* The mask used to clear the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 register field value. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_CLR_MSK    0xfffffff8
/* The reset value of the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 register field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_RESET	     0x0
/* Extracts the DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 field value from a register. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_GET(value) (((value)&0x00000007) >> 0)
/* Produces a DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 register field value suitable for setting
 * the register. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : RDESLA
 *
 * Start of Receive List.
 *
 * This field contains the base address of the first descriptor in the Rx
 * Descriptor list. The DMA ignores the LSB bits (2:0 or 3:0) for 64-bit or 128-bit
 * bus width and internally takes these bits as all-zero. Therefore, these LSB bits
 * are read-only (RO).
 *
 * The width of this field depends on the configuration:
 *
 * * 31:3 for 64-bit configuration
 *
 * * 31:4 for 128-bit configuration
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register
 * field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_LSB	       3
/* The Most Significant Bit (MSB) position of the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register
 * field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_MSB	       31
/* The width in bits of the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_WIDTH      29
/* The mask used to set the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register field value. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_SET_MSK    0xfffffff8
/* The mask used to clear the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register field value. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_CLR_MSK    0x00000007
/* The reset value of the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register field. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_RESET      0x0
/* Extracts the DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA field value from a register. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_GET(value) (((value)&0xfffffff8) >> 3)
/* Produces a DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA register field value suitable for setting the
 * register. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA_SET(value) (((value) << 3) & 0xfffffff8)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RXDESC_LIST_LADDRESS.
 */
struct DMA_CHx_RXDESC_LIST_LADDRESS_s {
	const volatile uint32_t Reserved_x_0 : 3; /* DMA_CHx_RXDESC_LIST_LADDRESS_RESERVED_X_0 */
	volatile uint32_t RDESLA : 29;		  /* DMA_CHx_RXDESC_LIST_LADDRESS_RDESLA */
};

/* The typedef declaration for register DMA_CHx_RXDESC_LIST_LADDRESS. */
typedef struct DMA_CHx_RXDESC_LIST_LADDRESS_s DMA_CHx_RXDESC_LIST_LADDRESS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RXDESC_LIST_LADDRESS register. */
#define DMA_CHx_RXDESC_LIST_LADDRESS_RESET 0x00000000
/* The byte offset of the DMA_CHx_RXDESC_LIST_LADDRESS register from the beginning of the component.
 */
#define DMA_CHx_RXDESC_LIST_LADDRESS_OFST  0x1c

/*
 * Register : DMA_CH0_TxDesc_Tail_LPointer
 *
 * The Channelx Tx Descriptor Tail LPointer register has the 32 bits end address of
 * the Transmit descriptor list.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [2:0]  | R      | 0x0   | DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0
 *  [31:3] | RW     | 0x0   | DMA_CHx_TXDESC_TAIL_LPOINTER_TDT
 *
 */
/*
 * Field : Reserved_x_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0
 * register field. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 register
 * field. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_MSB	     2
/* The width in bits of the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 register field. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_WIDTH	     3
/* The mask used to set the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 register field value. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_SET_MSK    0x00000007
/* The mask used to clear the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 register field value. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_CLR_MSK    0xfffffff8
/* The reset value of the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 register field. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_RESET	     0x0
/* Extracts the DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 field value from a register. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_GET(value) (((value)&0x00000007) >> 0)
/* Produces a DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 register field value suitable for setting
 * the register. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : TDT
 *
 * Transmit Descriptor Tail Pointer.
 *
 * This field contains the tail pointer for the Tx descriptor ring. The software
 * writes the tail pointer to add more descriptors to the Tx channel. DWC_xgmac
 * tries to transmit all packets referenced by the descriptors between the head and
 * the tail pointer registers.
 *
 * The width of this field depends on the configuration:
 *
 * * 31:3 for 64-bit configuration
 *
 * * 31:4 for 128-bit configuration
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field.
 */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_LSB	    3
/* The Most Significant Bit (MSB) position of the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field.
 */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_MSB	    31
/* The width in bits of the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_WIDTH	    29
/* The mask used to set the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field value. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_SET_MSK    0xfffffff8
/* The mask used to clear the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field value. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_CLR_MSK    0x00000007
/* The reset value of the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_RESET	    0x0
/* Extracts the DMA_CHx_TXDESC_TAIL_LPOINTER_TDT field value from a register. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_GET(value) (((value)&0xfffffff8) >> 3)
/* Produces a DMA_CHx_TXDESC_TAIL_LPOINTER_TDT register field value suitable for setting the
 * register. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_TDT_SET(value) (((value) << 3) & 0xfffffff8)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TXDESC_TAIL_LPOINTER.
 */
struct DMA_CHx_TXDESC_TAIL_LPOINTER_s {
	const volatile uint32_t Reserved_x_0 : 3; /* DMA_CHx_TXDESC_TAIL_LPOINTER_RESERVED_X_0 */
	volatile uint32_t TDT : 29;		  /* DMA_CHx_TXDESC_TAIL_LPOINTER_TDT */
};

/* The typedef declaration for register DMA_CHx_TXDESC_TAIL_LPOINTER. */
typedef struct DMA_CHx_TXDESC_TAIL_LPOINTER_s DMA_CHx_TXDESC_TAIL_LPOINTER_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TXDESC_TAIL_LPOINTER register. */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_RESET 0x00000000
/* The byte offset of the DMA_CHx_TXDESC_TAIL_LPOINTER register from the beginning of the component.
 */
#define DMA_CHx_TXDESC_TAIL_LPOINTER_OFST  0x24

/*
 * Register : DMA_CH0_RxDesc_Tail_LPointer
 *
 * The Channelx Rx Descriptor Tail LPointer register has the 32 bits end address of
 * the Receive descriptor list.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:--------------------------------------------------------------------
 *  [2:0]  | R      | 0x0   | DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0
 *  [31:3] | RW     | 0x0   | DMA_CHx_RXDESC_TAIL_LPOINTER_RDT
 *
 */
/*
 * Field : Reserved_x_0
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0
 * register field. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 register
 * field. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_MSB	     2
/* The width in bits of the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 register field. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_WIDTH	     3
/* The mask used to set the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 register field value. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_SET_MSK    0x00000007
/* The mask used to clear the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 register field value. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_CLR_MSK    0xfffffff8
/* The reset value of the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 register field. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_RESET	     0x0
/* Extracts the DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 field value from a register. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_GET(value) (((value)&0x00000007) >> 0)
/* Produces a DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 register field value suitable for setting
 * the register. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : RDT
 *
 * Receive Descriptor Tail Pointer.
 *
 * This field contains the tail pointer for the Rx descriptor ring. The software
 * writes the tail pointer to add more descriptors to the Rx channel. DWC_xgmac
 * tries to write all the received packets to the descriptors referenced between
 * the head and the tail pointer registers.
 *
 * The width of this field depends on the configuration:
 *
 * * 31:3 for 64-bit configuration
 *
 * * 31:4 for 128-bit configuration
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field.
 */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_LSB	    3
/* The Most Significant Bit (MSB) position of the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field.
 */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_MSB	    31
/* The width in bits of the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_WIDTH	    29
/* The mask used to set the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field value. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_SET_MSK    0xfffffff8
/* The mask used to clear the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field value. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_CLR_MSK    0x00000007
/* The reset value of the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_RESET	    0x0
/* Extracts the DMA_CHx_RXDESC_TAIL_LPOINTER_RDT field value from a register. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_GET(value) (((value)&0xfffffff8) >> 3)
/* Produces a DMA_CHx_RXDESC_TAIL_LPOINTER_RDT register field value suitable for setting the
 * register. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RDT_SET(value) (((value) << 3) & 0xfffffff8)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RXDESC_TAIL_LPOINTER.
 */
struct DMA_CHx_RXDESC_TAIL_LPOINTER_s {
	const volatile uint32_t Reserved_x_0 : 3; /* DMA_CHx_RXDESC_TAIL_LPOINTER_RESERVED_X_0 */
	volatile uint32_t RDT : 29;		  /* DMA_CHx_RXDESC_TAIL_LPOINTER_RDT */
};

/* The typedef declaration for register DMA_CHx_RXDESC_TAIL_LPOINTER. */
typedef struct DMA_CHx_RXDESC_TAIL_LPOINTER_s DMA_CHx_RXDESC_TAIL_LPOINTER_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RXDESC_TAIL_LPOINTER register. */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_RESET 0x00000000
/* The byte offset of the DMA_CHx_RXDESC_TAIL_LPOINTER register from the beginning of the component.
 */
#define DMA_CHx_RXDESC_TAIL_LPOINTER_OFST  0x2c

/*
 * Register : DMA_CH0_Tx_Control2
 *
 * The Tx_Control2 register contains programmable control to Outstanding read
 * requests per DMA and the length of the Transmit descriptor ring.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | DMA_CHx_TX_CONTROL2_TDRL
 *  [23:16] | R      | 0x0   | DMA_CHx_TX_CONTROL2_RESERVED_23_12
 *  [25:24] | RW     | 0x0   | DMA_CHx_TX_CONTROL2_ORRQ
 *  [31:26] | R      | 0x0   | DMA_CHx_TX_CONTROL2_RESERVED_31_Y
 *
 */
/*
 * Field : TDRL
 *
 * Transmit Descriptor Ring Length.
 *
 * This field sets the maximum number of Tx descriptors in the circular descriptor
 * ring. The maximum number of descriptors is limited to 16384 descriptors.
 *
 * * 0 implies ring length of 1 descriptor.
 *
 * * 0xFFFF implies a ring length of 65536 descriptors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL2_TDRL register field. */
#define DMA_CHx_TX_CONTROL2_TDRL_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL2_TDRL register field. */
#define DMA_CHx_TX_CONTROL2_TDRL_MSB	    15
/* The width in bits of the DMA_CHx_TX_CONTROL2_TDRL register field. */
#define DMA_CHx_TX_CONTROL2_TDRL_WIDTH	    16
/* The mask used to set the DMA_CHx_TX_CONTROL2_TDRL register field value. */
#define DMA_CHx_TX_CONTROL2_TDRL_SET_MSK    0x0000ffff
/* The mask used to clear the DMA_CHx_TX_CONTROL2_TDRL register field value. */
#define DMA_CHx_TX_CONTROL2_TDRL_CLR_MSK    0xffff0000
/* The reset value of the DMA_CHx_TX_CONTROL2_TDRL register field. */
#define DMA_CHx_TX_CONTROL2_TDRL_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL2_TDRL field value from a register. */
#define DMA_CHx_TX_CONTROL2_TDRL_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a DMA_CHx_TX_CONTROL2_TDRL register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL2_TDRL_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_23_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL2_RESERVED_23_12 register
 * field. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_LSB	      16
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL2_RESERVED_23_12 register field.
 */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_MSB	      23
/* The width in bits of the DMA_CHx_TX_CONTROL2_RESERVED_23_12 register field. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_WIDTH      8
/* The mask used to set the DMA_CHx_TX_CONTROL2_RESERVED_23_12 register field value. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_SET_MSK    0x00ff0000
/* The mask used to clear the DMA_CHx_TX_CONTROL2_RESERVED_23_12 register field value. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_CLR_MSK    0xff00ffff
/* The reset value of the DMA_CHx_TX_CONTROL2_RESERVED_23_12 register field. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_RESET      0x0
/* Extracts the DMA_CHx_TX_CONTROL2_RESERVED_23_12 field value from a register. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_GET(value) (((value)&0x00ff0000) >> 16)
/* Produces a DMA_CHx_TX_CONTROL2_RESERVED_23_12 register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL2_RESERVED_23_12_SET(value) (((value) << 16) & 0x00ff0000)

/*
 * Field : ORRQ
 *
 * Read Outstanding Requests
 *
 * When set to a value greater than zero, acts as the maximum number of Read
 * outstanding requests that can be serviced per DMA.
 *
 * When Maximum Outstanding Read Burst Requests for each Transmit DMA Channel is
 *
 * * 64: Upto Bit 30 is Reserved
 *
 * * 32: Upto Bit 29 is Reserved
 *
 * * 16: Upto Bit 28 is Reserved
 *
 * * 8: Upto Bit 27 is Reserved
 *
 * * 4: Upto Bit 26 is Reserved
 *
 * * 2: Upto Bit 25 is Reserved
 *
 * When set to 0, backward compatibility is maintained.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL2_ORRQ register field. */
#define DMA_CHx_TX_CONTROL2_ORRQ_LSB	    24
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL2_ORRQ register field. */
#define DMA_CHx_TX_CONTROL2_ORRQ_MSB	    25
/* The width in bits of the DMA_CHx_TX_CONTROL2_ORRQ register field. */
#define DMA_CHx_TX_CONTROL2_ORRQ_WIDTH	    2
/* The mask used to set the DMA_CHx_TX_CONTROL2_ORRQ register field value. */
#define DMA_CHx_TX_CONTROL2_ORRQ_SET_MSK    0x03000000
/* The mask used to clear the DMA_CHx_TX_CONTROL2_ORRQ register field value. */
#define DMA_CHx_TX_CONTROL2_ORRQ_CLR_MSK    0xfcffffff
/* The reset value of the DMA_CHx_TX_CONTROL2_ORRQ register field. */
#define DMA_CHx_TX_CONTROL2_ORRQ_RESET	    0x0
/* Extracts the DMA_CHx_TX_CONTROL2_ORRQ field value from a register. */
#define DMA_CHx_TX_CONTROL2_ORRQ_GET(value) (((value)&0x03000000) >> 24)
/* Produces a DMA_CHx_TX_CONTROL2_ORRQ register field value suitable for setting the register. */
#define DMA_CHx_TX_CONTROL2_ORRQ_SET(value) (((value) << 24) & 0x03000000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field.
 */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_LSB	     26
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field.
 */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_MSB	     31
/* The width in bits of the DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field. */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_WIDTH	     6
/* The mask used to set the DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field value. */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_SET_MSK    0xfc000000
/* The mask used to clear the DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field value. */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_CLR_MSK    0x03ffffff
/* The reset value of the DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field. */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_RESET	     0x0
/* Extracts the DMA_CHx_TX_CONTROL2_RESERVED_31_Y field value from a register. */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_GET(value) (((value)&0xfc000000) >> 26)
/* Produces a DMA_CHx_TX_CONTROL2_RESERVED_31_Y register field value suitable for setting the
 * register. */
#define DMA_CHx_TX_CONTROL2_RESERVED_31_Y_SET(value) (((value) << 26) & 0xfc000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TX_CONTROL2.
 */
struct DMA_CHx_TX_CONTROL2_s {
	volatile uint32_t TDRL : 16;		    /* DMA_CHx_TX_CONTROL2_TDRL */
	const volatile uint32_t Reserved_23_12 : 8; /* DMA_CHx_TX_CONTROL2_RESERVED_23_12 */
	volatile uint32_t ORRQ : 2;		    /* DMA_CHx_TX_CONTROL2_ORRQ */
	const volatile uint32_t Reserved_31_y : 6;  /* DMA_CHx_TX_CONTROL2_RESERVED_31_Y */
};

/* The typedef declaration for register DMA_CHx_TX_CONTROL2. */
typedef struct DMA_CHx_TX_CONTROL2_s DMA_CHx_TX_CONTROL2_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TX_CONTROL2 register. */
#define DMA_CHx_TX_CONTROL2_RESET 0x00000000
/* The byte offset of the DMA_CHx_TX_CONTROL2 register from the beginning of the component. */
#define DMA_CHx_TX_CONTROL2_OFST  0x30

/*
 * Register : DMA_CH0_Rx_Control2
 *
 * The Channelx Rx Control2 register contains programmable control to Outstanding
 * Write requests and the length of the Receive descriptor circular ring.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------
 *  [15:0]  | RW     | 0x0   | DMA_CHx_RX_CONTROL2_RDRL
 *  [16]    | R      | 0x0   | DMA_CHx_RX_CONTROL2_RESERVED_X_16
 *  [23:17] | RW     | 0x0   | DMA_CHx_RX_CONTROL2_ARBS
 *  [25:24] | RW     | 0x0   | DMA_CHx_RX_CONTROL2_OWRQ
 *  [31:26] | R      | 0x0   | DMA_CHx_RX_CONTROL2_RESERVED_31_Y
 *
 */
/*
 * Field : RDRL
 *
 * Receive Descriptor Ring Length.
 *
 * This field sets the maximum number of Rx descriptors in the circular descriptor
 * ring. The maximum number of descriptors is limited to 16384 descriptors.
 *
 * * 0 implies ring length of 1 descriptor.
 *
 * * 0xFFFF implies a ring length of 65536 descriptors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL2_RDRL register field. */
#define DMA_CHx_RX_CONTROL2_RDRL_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL2_RDRL register field. */
#define DMA_CHx_RX_CONTROL2_RDRL_MSB	    15
/* The width in bits of the DMA_CHx_RX_CONTROL2_RDRL register field. */
#define DMA_CHx_RX_CONTROL2_RDRL_WIDTH	    16
/* The mask used to set the DMA_CHx_RX_CONTROL2_RDRL register field value. */
#define DMA_CHx_RX_CONTROL2_RDRL_SET_MSK    0x0000ffff
/* The mask used to clear the DMA_CHx_RX_CONTROL2_RDRL register field value. */
#define DMA_CHx_RX_CONTROL2_RDRL_CLR_MSK    0xffff0000
/* The reset value of the DMA_CHx_RX_CONTROL2_RDRL register field. */
#define DMA_CHx_RX_CONTROL2_RDRL_RESET	    0x0
/* Extracts the DMA_CHx_RX_CONTROL2_RDRL field value from a register. */
#define DMA_CHx_RX_CONTROL2_RDRL_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a DMA_CHx_RX_CONTROL2_RDRL register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL2_RDRL_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_x_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field.
 */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_LSB	     16
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field.
 */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_MSB	     16
/* The width in bits of the DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field. */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_WIDTH	     1
/* The mask used to set the DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field value. */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_SET_MSK    0x00010000
/* The mask used to clear the DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field value. */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_CLR_MSK    0xfffeffff
/* The reset value of the DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field. */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_RESET	     0x0
/* Extracts the DMA_CHx_RX_CONTROL2_RESERVED_X_16 field value from a register. */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_GET(value) (((value)&0x00010000) >> 16)
/* Produces a DMA_CHx_RX_CONTROL2_RESERVED_X_16 register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_CONTROL2_RESERVED_X_16_SET(value) (((value) << 16) & 0x00010000)

/*
 * Field : ARBS
 *
 * Alternate Receive Buffer Size
 *
 * Indicates size in bytes for Buffer 1 when ARBS is programmed to a non-zero value
 * (when split header feature is not enabled). When split header feature is
 * enabled, ARBS indicates the buffer size for header data. The maximum alternate
 * buffer is limited to 1016 or 1008-bytes depending on the data bus widths (64-bit
 * or 128-bit respectively). When ARBS=0, Rx Buffer1 and Rx Buffer2 sizes are based
 * on RBSZ field of DMA_CH(#i)_Rx_Control. Width of ARBS field is 7 or 6-bits
 * depending on the data bus widths (64-bit or 128-bit respectively)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL2_ARBS register field. */
#define DMA_CHx_RX_CONTROL2_ARBS_LSB	    17
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL2_ARBS register field. */
#define DMA_CHx_RX_CONTROL2_ARBS_MSB	    23
/* The width in bits of the DMA_CHx_RX_CONTROL2_ARBS register field. */
#define DMA_CHx_RX_CONTROL2_ARBS_WIDTH	    7
/* The mask used to set the DMA_CHx_RX_CONTROL2_ARBS register field value. */
#define DMA_CHx_RX_CONTROL2_ARBS_SET_MSK    0x00fe0000
/* The mask used to clear the DMA_CHx_RX_CONTROL2_ARBS register field value. */
#define DMA_CHx_RX_CONTROL2_ARBS_CLR_MSK    0xff01ffff
/* The reset value of the DMA_CHx_RX_CONTROL2_ARBS register field. */
#define DMA_CHx_RX_CONTROL2_ARBS_RESET	    0x0
/* Extracts the DMA_CHx_RX_CONTROL2_ARBS field value from a register. */
#define DMA_CHx_RX_CONTROL2_ARBS_GET(value) (((value)&0x00fe0000) >> 17)
/* Produces a DMA_CHx_RX_CONTROL2_ARBS register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL2_ARBS_SET(value) (((value) << 17) & 0x00fe0000)

/*
 * Field : OWRQ
 *
 * Write Outstanding Requests
 *
 * When set to a value greater than zero, acts as maximum number of Write
 * outstanding requests that can be serviced per DMA.
 *
 * When Maximum Outstanding Write Burst Requests for each Receive DMA Channel is
 *
 * * 64: Upto Bit 30 is Reserved
 *
 * * 32: Upto Bit 29 is Reserved
 *
 * * 16: Upto Bit 28 is Reserved
 *
 * * 8: Upto Bit 27 is Reserved
 *
 * * 4: Upto Bit 26 is Reserved
 *
 * * 2: Upto Bit 25 is Reserved
 *
 * When set to 0, backward compatibility is maintained.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL2_OWRQ register field. */
#define DMA_CHx_RX_CONTROL2_OWRQ_LSB	    24
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL2_OWRQ register field. */
#define DMA_CHx_RX_CONTROL2_OWRQ_MSB	    25
/* The width in bits of the DMA_CHx_RX_CONTROL2_OWRQ register field. */
#define DMA_CHx_RX_CONTROL2_OWRQ_WIDTH	    2
/* The mask used to set the DMA_CHx_RX_CONTROL2_OWRQ register field value. */
#define DMA_CHx_RX_CONTROL2_OWRQ_SET_MSK    0x03000000
/* The mask used to clear the DMA_CHx_RX_CONTROL2_OWRQ register field value. */
#define DMA_CHx_RX_CONTROL2_OWRQ_CLR_MSK    0xfcffffff
/* The reset value of the DMA_CHx_RX_CONTROL2_OWRQ register field. */
#define DMA_CHx_RX_CONTROL2_OWRQ_RESET	    0x0
/* Extracts the DMA_CHx_RX_CONTROL2_OWRQ field value from a register. */
#define DMA_CHx_RX_CONTROL2_OWRQ_GET(value) (((value)&0x03000000) >> 24)
/* Produces a DMA_CHx_RX_CONTROL2_OWRQ register field value suitable for setting the register. */
#define DMA_CHx_RX_CONTROL2_OWRQ_SET(value) (((value) << 24) & 0x03000000)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field.
 */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_LSB	     26
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field.
 */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_MSB	     31
/* The width in bits of the DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field. */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_WIDTH	     6
/* The mask used to set the DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field value. */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_SET_MSK    0xfc000000
/* The mask used to clear the DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field value. */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_CLR_MSK    0x03ffffff
/* The reset value of the DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field. */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_RESET	     0x0
/* Extracts the DMA_CHx_RX_CONTROL2_RESERVED_31_Y field value from a register. */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_GET(value) (((value)&0xfc000000) >> 26)
/* Produces a DMA_CHx_RX_CONTROL2_RESERVED_31_Y register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_CONTROL2_RESERVED_31_Y_SET(value) (((value) << 26) & 0xfc000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RX_CONTROL2.
 */
struct DMA_CHx_RX_CONTROL2_s {
	volatile uint32_t RDRL : 16;		   /* DMA_CHx_RX_CONTROL2_RDRL */
	const volatile uint32_t Reserved_x_16 : 1; /* DMA_CHx_RX_CONTROL2_RESERVED_X_16 */
	volatile uint32_t ARBS : 7;		   /* DMA_CHx_RX_CONTROL2_ARBS */
	volatile uint32_t OWRQ : 2;		   /* DMA_CHx_RX_CONTROL2_OWRQ */
	const volatile uint32_t Reserved_31_y : 6; /* DMA_CHx_RX_CONTROL2_RESERVED_31_Y */
};

/* The typedef declaration for register DMA_CHx_RX_CONTROL2. */
typedef struct DMA_CHx_RX_CONTROL2_s DMA_CHx_RX_CONTROL2_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RX_CONTROL2 register. */
#define DMA_CHx_RX_CONTROL2_RESET 0x00000000
/* The byte offset of the DMA_CHx_RX_CONTROL2 register from the beginning of the component. */
#define DMA_CHx_RX_CONTROL2_OFST  0x34

/*
 * Register : DMA_CH0_Interrupt_Enable
 *
 * The Channelx Interrupt Enable register enables the interrupts reported by the
 * Status register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:------------------------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_TIE
 *  [1]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_TXSE
 *  [2]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_TBUE
 *  [5:3]   | R      | 0x0   | DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3
 *  [6]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_RIE
 *  [7]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_RBUE
 *  [8]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_RSE
 *  [9]     | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_DDEE
 *  [11:10] | R      | 0x0   | DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10
 *  [12]    | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_FBEE
 *  [13]    | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_CDEE
 *  [14]    | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_AIE
 *  [15]    | RW     | 0x0   | DMA_CHx_INTERRUPT_ENABLE_NIE
 *  [31:16] | R      | 0x0   | DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16
 *
 */
/*
 * Field : TIE
 *
 * Transmit Interrupt Enable.
 *
 * When this bit is set along with the NIE bit, the Transmit Interrupt is enabled.
 * When this bit is reset, the Transmit Interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_TIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_LSB	0
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_TIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_MSB	0
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_TIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_WIDTH	1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_TIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_SET_MSK	0x00000001
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_TIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_CLR_MSK	0xfffffffe
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_TIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_RESET	0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_TIE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_TIE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_TIE_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TXSE
 *
 * Transmit Stopped Enable.
 *
 * When this bit is set along with the AIE bit, the Transmission Stopped interrupt
 * is enabled. When this bit is reset, the Transmission Stopped interrupt is
 * disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_TXSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_LSB	 1
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_TXSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_MSB	 1
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_TXSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_WIDTH	 1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_TXSE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_SET_MSK	 0x00000002
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_TXSE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_CLR_MSK	 0xfffffffd
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_TXSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_TXSE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_TXSE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_TXSE_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TBUE
 *
 * Transmit Buffer Unavailable Enable.
 *
 * When this bit is set along with the NIE bit, the Transmit Buffer Unavailable
 * interrupt is enabled. When this bit is reset, the Transmit Buffer Unavailable
 * interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_TBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_LSB	 2
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_TBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_MSB	 2
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_TBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_WIDTH	 1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_TBUE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_SET_MSK	 0x00000004
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_TBUE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_CLR_MSK	 0xfffffffb
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_TBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_TBUE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_GET(value) (((value)&0x00000004) >> 2)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_TBUE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_TBUE_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_5_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register
 * field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_LSB	 3
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register
 * field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_MSB	 5
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_WIDTH	 3
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_SET_MSK	 0x00000038
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_CLR_MSK	 0xffffffc7
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_GET(value) (((value)&0x00000038) >> 3)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 register field value suitable for setting the
 * register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3_SET(value) (((value) << 3) & 0x00000038)

/*
 * Field : RIE
 *
 * Receive Interrupt Enable.
 *
 * When this bit is set along with the NIE bit, the Receive Interrupt is enabled.
 * When this bit is reset, the Receive Interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_RIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_LSB	6
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_RIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_MSB	6
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_RIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_WIDTH	1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_RIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_SET_MSK	0x00000040
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_RIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_CLR_MSK	0xffffffbf
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_RIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_RESET	0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_RIE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_GET(value) (((value)&0x00000040) >> 6)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_RIE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_RIE_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : RBUE
 *
 * Receive Buffer Unavailable Enable.
 *
 * When this bit is set along with the AIE bit, the Receive Buffer Unavailable
 * interrupt is enabled. When this bit is reset, the Receive Buffer Unavailable
 * interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_RBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_LSB	 7
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_RBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_MSB	 7
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_RBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_WIDTH	 1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_RBUE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_SET_MSK	 0x00000080
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_RBUE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_CLR_MSK	 0xffffff7f
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_RBUE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_RBUE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_RBUE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_RBUE_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : RSE
 *
 * Receive Stopped Enable.
 *
 * When this bit is set along with the AIE bit, the Receive Stopped Interrupt is
 * enabled. When this bit is reset, the Receive Stopped interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_RSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_LSB	8
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_RSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_MSB	8
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_RSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_WIDTH	1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_RSE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_SET_MSK	0x00000100
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_RSE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_CLR_MSK	0xfffffeff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_RSE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_RESET	0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_RSE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_GET(value) (((value)&0x00000100) >> 8)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_RSE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_RSE_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : DDEE
 *
 * Descriptor Definition Error Enable.
 *
 * When this bit is set along with the AIE bit, the Descriptor Definition error
 * interrupt is enabled. When this bit is reset, the Descriptor Definition Error
 * error interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_DDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_LSB	 9
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_DDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_MSB	 9
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_DDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_WIDTH	 1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_DDEE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_SET_MSK	 0x00000200
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_DDEE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_CLR_MSK	 0xfffffdff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_DDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_DDEE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_DDEE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_DDEE_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : Reserved_11_10
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register
 * field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_LSB	   10
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register
 * field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_MSB	   11
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_WIDTH	   2
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_SET_MSK	   0x00000c00
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_CLR_MSK	   0xfffff3ff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_RESET	   0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_GET(value) (((value)&0x00000c00) >> 10)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 register field value suitable for setting the
 * register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10_SET(value) (((value) << 10) & 0x00000c00)

/*
 * Field : FBEE
 *
 * Fatal Bus Error Enable.
 *
 * When this bit is set along with the AIE bit, the Fatal Bus error interrupt is
 * enabled. When this bit is reset, the Fatal Bus Error error interrupt is
 * disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_FBEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_LSB	 12
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_FBEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_MSB	 12
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_FBEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_WIDTH	 1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_FBEE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_SET_MSK	 0x00001000
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_FBEE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_CLR_MSK	 0xffffefff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_FBEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_FBEE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_FBEE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_FBEE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : CDEE
 *
 * Context Descriptor Error Enable.
 *
 * When this bit is set along with the AIE bit, the Context Descriptor error
 * interrupt is enabled. When this bit is reset, the Context Descriptor error
 * interrupt is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_CDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_LSB	 13
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_CDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_MSB	 13
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_CDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_WIDTH	 1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_CDEE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_SET_MSK	 0x00002000
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_CDEE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_CLR_MSK	 0xffffdfff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_CDEE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_RESET	 0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_CDEE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_CDEE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_CDEE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : AIE
 *
 * Abnormal Interrupt Summary Enable.
 *
 * When this bit is set, the abnormal interrupt summary is enabled. This bit
 * enables the following interrupts in the DMA_CH0_Status register:
 *
 * * Bit 1: Transmit Process Stopped
 *
 * * Bit 7: Rx Buffer Unavailable
 *
 * * Bit 8: Receive Process Stopped
 *
 * * Bit 9: Descriptor Definition Error
 *
 * * Bit 12: Fatal Bus Error
 *
 * * Bit 13: Context Descriptor Error
 *
 * When this bit is reset, the abnormal interrupt summary is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_AIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_LSB	14
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_AIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_MSB	14
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_AIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_WIDTH	1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_AIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_SET_MSK	0x00004000
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_AIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_CLR_MSK	0xffffbfff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_AIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_RESET	0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_AIE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_GET(value) (((value)&0x00004000) >> 14)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_AIE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_AIE_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : NIE
 *
 * Normal Interrupt Summary Enable.
 *
 * When this bit is set, the normal interrupt summary is enabled. This bit enables
 * the following interrupts in the DMA_CH0_Status register:
 *
 * * Bit 0: Transmit Interrupt
 *
 * * Bit 2: Transmit Buffer Unavailable
 *
 * * Bit 6: Receive Interrupt
 *
 * When this bit is reset, the normal interrupt summary is disabled.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_NIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_LSB	15
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_NIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_MSB	15
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_NIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_WIDTH	1
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_NIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_SET_MSK	0x00008000
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_NIE register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_CLR_MSK	0xffff7fff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_NIE register field. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_RESET	0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_NIE field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_NIE register field value suitable for setting the register.
 */
#define DMA_CHx_INTERRUPT_ENABLE_NIE_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register
 * field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_LSB	   16
/* The Most Significant Bit (MSB) position of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register
 * field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_MSB	   31
/* The width in bits of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_WIDTH	   16
/* The mask used to set the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_SET_MSK	   0xffff0000
/* The mask used to clear the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register field value. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_CLR_MSK	   0x0000ffff
/* The reset value of the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register field. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_RESET	   0x0
/* Extracts the DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 field value from a register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 register field value suitable for setting the
 * register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_INTERRUPT_ENABLE.
 */
struct DMA_CHx_INTERRUPT_ENABLE_s {
	volatile uint32_t TIE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_TIE */
	volatile uint32_t TXSE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_TXSE */
	volatile uint32_t TBUE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_TBUE */
	const volatile uint32_t Reserved_5_3 : 3;    /* DMA_CHx_INTERRUPT_ENABLE_RESERVED_5_3 */
	volatile uint32_t RIE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_RIE */
	volatile uint32_t RBUE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_RBUE */
	volatile uint32_t RSE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_RSE */
	volatile uint32_t DDEE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_DDEE */
	const volatile uint32_t Reserved_11_10 : 2;  /* DMA_CHx_INTERRUPT_ENABLE_RESERVED_11_10 */
	volatile uint32_t FBEE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_FBEE */
	volatile uint32_t CDEE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_CDEE */
	volatile uint32_t AIE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_AIE */
	volatile uint32_t NIE : 1;		     /* DMA_CHx_INTERRUPT_ENABLE_NIE */
	const volatile uint32_t Reserved_31_16 : 16; /* DMA_CHx_INTERRUPT_ENABLE_RESERVED_31_16 */
};

/* The typedef declaration for register DMA_CHx_INTERRUPT_ENABLE. */
typedef struct DMA_CHx_INTERRUPT_ENABLE_s DMA_CHx_INTERRUPT_ENABLE_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_INTERRUPT_ENABLE register. */
#define DMA_CHx_INTERRUPT_ENABLE_RESET 0x00000000
/* The byte offset of the DMA_CHx_INTERRUPT_ENABLE register from the beginning of the component. */
#define DMA_CHx_INTERRUPT_ENABLE_OFST  0x38

/*
 * Register : DMA_CH0_Rx_Interrupt_Watchdog_Timer
 *
 * The Receive Interrupt Watchdog Timer register indicates the watchdog timeout for
 * Receive Interrupt (RI) from the DMA. This can in terms of number of clock cycles
 * (RWT field) or number of transferred bytes or number of packets received (RBCT)
 * based on the value of programmable bit PSEL. When either of these fields are
 * written with a non-zero value, the interrupt timer is enabled when a packet
 * transfer is completed for which RI is not generated. The timers are cleared when
 * the RI is generated by that RxDMA channel.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------------------
 *  [7:0]   | RW     | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT
 *  [11:8]  | R      | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8
 *  [13:12] | RW     | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU
 *  [15:14] | R      | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14
 *  [25:16] | RW     | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT
 *  [30:26] | R      | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26
 *  [31]    | RW     | 0x0   | DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL
 *
 */
/*
 * Field : RWT
 *
 * Receive Interrupt Watchdog Timer Count.
 *
 * This bit indicates the number of system clock cycles, multiplied by factor
 * indicated in RWTU field, for which the watchdog timer is set.
 *
 * The watchdog timer is triggered with the programmed value after the Rx DMA
 * completes the transfer of a packet for which the RI bit is not set in the
 * DMA_CH0_Status register, because the Interrupt Enable bit in the corresponding
 * descriptor RDES3[30] is reset.
 *
 * When the watchdog timer runs out, the RI bit is set and the timer is stopped.
 * The watchdog timer is reset when the RI bit is set high because of automatic
 * setting of RI as per the Interrupt Enable bit RDES3[30] of any received packet.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_LSB	   0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_MSB	   7
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_WIDTH	   8
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_SET_MSK	   0x000000ff
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_CLR_MSK	   0xffffff00
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_RESET	   0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_11_8
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8
 * register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_LSB	     8
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8
 * register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_MSB	     11
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_WIDTH	     4
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 register field value.
 */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_SET_MSK    0x00000f00
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 register field
 * value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_CLR_MSK    0xfffff0ff
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_RESET	     0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 register field value suitable for
 * setting the register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : RWTU
 *
 * Receive Interrupt Watchdog Timer Count Units.
 *
 * This fields indicates the number of system clock cycles corresponding to one
 * unit in RWT field.
 *
 * * 2'b00: 256
 *
 * * 2'b01: 512
 *
 * * 2'b10: 1024
 *
 * * 2'b11: 2048
 *
 * For example, when RWT=2 and RWTU=1, the watchdog timer is set for 2*512=1024
 * system clock cycles.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_LSB	    12
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_MSB	    13
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_WIDTH	    2
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_SET_MSK    0x00003000
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_CLR_MSK    0xffffcfff
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_RESET	    0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_GET(value) (((value)&0x00003000) >> 12)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU_SET(value) (((value) << 12) & 0x00003000)

/*
 * Field : Reserved_15_14
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_LSB	      14
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14
 * register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_MSB	      15
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_WIDTH      2
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 register field value.
 */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_SET_MSK    0x0000c000
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 register field
 * value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_CLR_MSK    0xffff3fff
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_RESET      0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_GET(value) (((value)&0x0000c000) >> 14)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 register field value suitable for
 * setting the register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14_SET(value) (((value) << 14) & 0x0000c000)

/*
 * Field : RBCT
 *
 * Receive Byte Count Threshold.
 *
 * This fields indicates the number of received bytes multiplied by 1KB, for which
 * the watchdog timer is set.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_LSB	    16
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_MSB	    25
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_WIDTH	    10
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_SET_MSK    0x03ff0000
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_CLR_MSK    0xfc00ffff
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_RESET	    0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_GET(value) (((value)&0x03ff0000) >> 16)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT_SET(value) (((value) << 16) & 0x03ff0000)

/*
 * Field : Reserved_30_26
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the
 * DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_LSB	      26
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26
 * register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_MSB	      30
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_WIDTH      5
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 register field value.
 */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_SET_MSK    0x7c000000
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 register field
 * value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_CLR_MSK    0x83ffffff
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_RESET      0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_GET(value) (((value)&0x7c000000) >> 26)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 register field value suitable for
 * setting the register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26_SET(value) (((value) << 26) & 0x7c000000)

/*
 * Field : PSEL
 *
 * Packet Count Interrupt Select.
 *
 * This fields indicates if RBCT field acts in Received Byte Counter mode or
 * Received Packet Counter mode.
 *
 * * 1: RBCT field is used to generate interrupt based on number of packets
 *   received.
 *
 * * 0: RBCT field is used to generate interrupt based on number of bytes received.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_LSB	    31
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register
 * field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_MSB	    31
/* The width in bits of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_WIDTH	    1
/* The mask used to set the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_SET_MSK    0x80000000
/* The mask used to clear the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register field value. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_CLR_MSK    0x7fffffff
/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register field. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_RESET	    0x0
/* Extracts the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL field value from a register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_GET(value) (((value)&0x80000000) >> 31)
/* Produces a DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL register field value suitable for setting the
 * register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER.
 */
struct DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_s {
	volatile uint32_t RWT : 8; /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWT */
	const volatile uint32_t
		Reserved_11_8 : 4;  /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_11_8 */
	volatile uint32_t RWTU : 2; /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RWTU */
	const volatile uint32_t
		Reserved_15_14 : 2;  /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_15_14 */
	volatile uint32_t RBCT : 10; /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RBCT */
	const volatile uint32_t
		Reserved_30_26 : 5; /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESERVED_30_26 */
	volatile uint32_t PSEL : 1; /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_PSEL */
};

/* The typedef declaration for register DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER. */
typedef struct DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_s DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER register. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_RESET 0x00000000
/* The byte offset of the DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER register from the beginning of the
 * component. */
#define DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_OFST  0x3c

/*
 * Register : DMA_CH0_Current_App_TxDesc_L
 *
 * The Channelx Current Application Transmit Descriptor High register has the lower
 * 32 bits of the current address of the Transmit descriptor read by the DMA. The
 * upper 32 address bits of the Current Transmit Descriptor are equal to the value
 * written in the DMA_CH0_TxDesc_List_HAddress. Therefore, the upper address bits
 * are not given in the register map.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR
 *
 */
/*
 * Field : CURTDESAPTR
 *
 * Application Transmit Descriptor Address Pointer.
 *
 * This gives the address of the Descriptor currently processed by the Normal TxDMA
 * Engine.
 *
 * In DMA, it gives the address of the next descriptor that is going to be fetched
 * from system memory.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register
 * field. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register
 * field. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_MSB	    31
/* The width in bits of the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register field. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_WIDTH	    32
/* The mask used to set the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register field value. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_SET_MSK    0xffffffff
/* The mask used to clear the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register field value. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_CLR_MSK    0x00000000
/* The reset value of the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register field. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_RESET	    0x0
/* Extracts the DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR field value from a register. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR register field value suitable for setting the
 * register. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CURRENT_APP_TXDESC_L.
 */
struct DMA_CHx_CURRENT_APP_TXDESC_L_s {
	const volatile uint32_t CURTDESAPTR : 32; /* DMA_CHx_CURRENT_APP_TXDESC_L_CURTDESAPTR */
};

/* The typedef declaration for register DMA_CHx_CURRENT_APP_TXDESC_L. */
typedef struct DMA_CHx_CURRENT_APP_TXDESC_L_s DMA_CHx_CURRENT_APP_TXDESC_L_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CURRENT_APP_TXDESC_L register. */
#define DMA_CHx_CURRENT_APP_TXDESC_L_RESET 0x00000000
/* The byte offset of the DMA_CHx_CURRENT_APP_TXDESC_L register from the beginning of the component.
 */
#define DMA_CHx_CURRENT_APP_TXDESC_L_OFST  0x44

/*
 * Register : DMA_CH0_Current_App_RxDesc_L
 *
 * The Channelx Current Application Receive Descriptor Low register has the lower
 * 32 bits of the current address of the Receive descriptor read by the DMA. The
 * upper 32 address bits of the Current Receive Descriptor are equal to the value
 * written in the DMA_CH0_RxDesc_List_HAddress. Therefore, the upper address bits
 * are not given in the register map.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR
 *
 */
/*
 * Field : CURRDESAPTR
 *
 * Application Receive Descriptor Address Pointer.
 *
 * This gives the address of the Descriptor currently processed by the Normal RxDMA
 * Engine.
 *
 * In DMA, it gives the address of the next descriptor that is going to be fetched
 * from system memory.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register
 * field. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_LSB	    0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register
 * field. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_MSB	    31
/* The width in bits of the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register field. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_WIDTH	    32
/* The mask used to set the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register field value. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_SET_MSK    0xffffffff
/* The mask used to clear the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register field value. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_CLR_MSK    0x00000000
/* The reset value of the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register field. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_RESET	    0x0
/* Extracts the DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR field value from a register. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR register field value suitable for setting the
 * register. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CURRENT_APP_RXDESC_L.
 */
struct DMA_CHx_CURRENT_APP_RXDESC_L_s {
	const volatile uint32_t CURRDESAPTR : 32; /* DMA_CHx_CURRENT_APP_RXDESC_L_CURRDESAPTR */
};

/* The typedef declaration for register DMA_CHx_CURRENT_APP_RXDESC_L. */
typedef struct DMA_CHx_CURRENT_APP_RXDESC_L_s DMA_CHx_CURRENT_APP_RXDESC_L_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CURRENT_APP_RXDESC_L register. */
#define DMA_CHx_CURRENT_APP_RXDESC_L_RESET 0x00000000
/* The byte offset of the DMA_CHx_CURRENT_APP_RXDESC_L register from the beginning of the component.
 */
#define DMA_CHx_CURRENT_APP_RXDESC_L_OFST  0x4c

/*
 * Register : DMA_CH0_Current_App_TxBuffer_H
 *
 * The Channelx Current Application Transmit Buffer Address High register has the
 * higher 8 or 16 bits of the current address of the Transmit buffer address read
 * by the DMA. This register is present only when DWC_xgmac is configured for
 * 40-bit or 48-bit addressing mode.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------------
 *  [7:0]  | R      | 0x0   | DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH
 *  [31:8] | R      | 0x0   | DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y
 *
 */
/*
 * Field : CURTBUFAPTRH
 *
 * Application Receive Buffer Address Pointer.
 *
 * This field is set to the value of the address of the first memory block
 * allocated by software (the address in TDESC) and DMA transferred data from that
 * memory block in normal DMA.
 *
 * This field is set to the value of the last address DMA put request on AXI
 * interface in DMA.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH
 * register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_LSB	       0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH
 * register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_MSB	       7
/* The width in bits of the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_WIDTH      8
/* The mask used to set the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH register field value. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_SET_MSK    0x000000ff
/* The mask used to clear the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH register field value. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_CLR_MSK    0xffffff00
/* The reset value of the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_RESET      0x0
/* Extracts the DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH field value from a register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH register field value suitable for setting
 * the register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y
 * register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_LSB	8
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y
 * register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_MSB	31
/* The width in bits of the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_WIDTH	24
/* The mask used to set the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y register field value. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_SET_MSK	0xffffff00
/* The mask used to clear the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y register field value. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_CLR_MSK	0x000000ff
/* The reset value of the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_RESET	0x0
/* Extracts the DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y field value from a register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y register field value suitable for setting
 * the register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CURRENT_APP_TXBUFFER_H.
 */
struct DMA_CHx_CURRENT_APP_TXBUFFER_H_s {
	const volatile uint32_t CURTBUFAPTRH : 8; /* DMA_CHx_CURRENT_APP_TXBUFFER_H_CURTBUFAPTRH */
	const volatile uint32_t
		Reserved_31_y : 24; /* DMA_CHx_CURRENT_APP_TXBUFFER_H_RESERVED_31_Y */
};

/* The typedef declaration for register DMA_CHx_CURRENT_APP_TXBUFFER_H. */
typedef struct DMA_CHx_CURRENT_APP_TXBUFFER_H_s DMA_CHx_CURRENT_APP_TXBUFFER_H_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CURRENT_APP_TXBUFFER_H register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_RESET 0x00000000
/* The byte offset of the DMA_CHx_CURRENT_APP_TXBUFFER_H register from the beginning of the
 * component. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_H_OFST  0x50

/*
 * Register : DMA_CH0_Current_App_TxBuffer_L
 *
 * The Channelx Current Application Transmit Buffer Address Low register has the
 * lower 32 bits of the current address of the Transmit buffer address read by the
 * DMA.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR
 *
 */
/*
 * Field : CURTBUFAPTR
 *
 * Application Transmit Buffer Address Pointer.
 *
 * This field is set to the value of the address of the first of memory block
 * allocated by software (the address in TDESC) and DMA transferred data from that
 * memory block in normal DMA.
 *
 * This field is set to the value of the last address DMA put request on AXI
 * interface in DMA.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR
 * register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR
 * register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_MSB	      31
/* The width in bits of the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_WIDTH      32
/* The mask used to set the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR register field value. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_SET_MSK    0xffffffff
/* The mask used to clear the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR register field value. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_CLR_MSK    0x00000000
/* The reset value of the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR register field. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_RESET      0x0
/* Extracts the DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR field value from a register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR register field value suitable for setting
 * the register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CURRENT_APP_TXBUFFER_L.
 */
struct DMA_CHx_CURRENT_APP_TXBUFFER_L_s {
	const volatile uint32_t CURTBUFAPTR : 32; /* DMA_CHx_CURRENT_APP_TXBUFFER_L_CURTBUFAPTR */
};

/* The typedef declaration for register DMA_CHx_CURRENT_APP_TXBUFFER_L. */
typedef struct DMA_CHx_CURRENT_APP_TXBUFFER_L_s DMA_CHx_CURRENT_APP_TXBUFFER_L_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CURRENT_APP_TXBUFFER_L register. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_RESET 0x00000000
/* The byte offset of the DMA_CHx_CURRENT_APP_TXBUFFER_L register from the beginning of the
 * component. */
#define DMA_CHx_CURRENT_APP_TXBUFFER_L_OFST  0x54

/*
 * Register : DMA_CH0_Current_App_RxBuffer_H
 *
 * The Channelx Current Application Receive Buffer Address High register has the
 * higher 8 or 16 bits of the current address of the Receive buffer address read by
 * the DMA. This register is present only when DWC_xgmac is configured for 40-bit
 * or 48-bit addressing mode.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:-----------------------------------------------------------------------
 *  [7:0]  | R      | 0x0   | DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH
 *  [31:8] | R      | 0x0   | DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y
 *
 */
/*
 * Field : CURRBUFAPTRH
 *
 * Application Receive Buffer Address Pointer.
 *
 * This field is set to the value of the address of the first of memory block
 * allocated by software (the address in RDESC) and DMA transferred data from that
 * memory block in normal DMA.
 *
 * This field is set to the value of the last address DMA put request on AXI
 * interface in DMA.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH
 * register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_LSB	       0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH
 * register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_MSB	       7
/* The width in bits of the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_WIDTH      8
/* The mask used to set the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH register field value. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_SET_MSK    0x000000ff
/* The mask used to clear the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH register field value. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_CLR_MSK    0xffffff00
/* The reset value of the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_RESET      0x0
/* Extracts the DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH field value from a register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_GET(value) (((value)&0x000000ff) >> 0)
/* Produces a DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH register field value suitable for setting
 * the register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH_SET(value) (((value) << 0) & 0x000000ff)

/*
 * Field : Reserved_31_y
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y
 * register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_LSB	8
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y
 * register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_MSB	31
/* The width in bits of the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_WIDTH	24
/* The mask used to set the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y register field value. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_SET_MSK	0xffffff00
/* The mask used to clear the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y register field value. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_CLR_MSK	0x000000ff
/* The reset value of the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_RESET	0x0
/* Extracts the DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y field value from a register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_GET(value) (((value)&0xffffff00) >> 8)
/* Produces a DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y register field value suitable for setting
 * the register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y_SET(value) (((value) << 8) & 0xffffff00)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CURRENT_APP_RXBUFFER_H.
 */
struct DMA_CHx_CURRENT_APP_RXBUFFER_H_s {
	const volatile uint32_t CURRBUFAPTRH : 8; /* DMA_CHx_CURRENT_APP_RXBUFFER_H_CURRBUFAPTRH */
	const volatile uint32_t
		Reserved_31_y : 24; /* DMA_CHx_CURRENT_APP_RXBUFFER_H_RESERVED_31_Y */
};

/* The typedef declaration for register DMA_CHx_CURRENT_APP_RXBUFFER_H. */
typedef struct DMA_CHx_CURRENT_APP_RXBUFFER_H_s DMA_CHx_CURRENT_APP_RXBUFFER_H_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CURRENT_APP_RXBUFFER_H register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_RESET 0x00000000
/* The byte offset of the DMA_CHx_CURRENT_APP_RXBUFFER_H register from the beginning of the
 * component. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_H_OFST  0x58

/*
 * Register : DMA_CH0_Current_App_RxBuffer_L
 *
 * The Channelx Current Application Receive Buffer Address Low register has the
 * lower 32 bits of the current address of the Receive buffer address read by the
 * DMA.
 *
 * Register Layout
 *
 *  Bits   | Access | Reset | Description
 * :-------|:-------|:------|:---------------------------------------------------------------------
 *  [31:0] | R      | 0x0   | DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR
 *
 */
/*
 * Field : CURRBUFAPTR
 *
 * Application Receive Buffer Address Pointer.
 *
 * This field is set to the value of the address of the first of memory block
 * allocated by software (the address in TDESC) and DMA transferred data from that
 * memory block in normal DMA.
 *
 * This field is set to the value of the last address DMA put request on AXI
 * interface in DMA.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR
 * register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_LSB	      0
/* The Most Significant Bit (MSB) position of the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR
 * register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_MSB	      31
/* The width in bits of the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_WIDTH      32
/* The mask used to set the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR register field value. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_SET_MSK    0xffffffff
/* The mask used to clear the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR register field value. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_CLR_MSK    0x00000000
/* The reset value of the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR register field. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_RESET      0x0
/* Extracts the DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR field value from a register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_GET(value) (((value)&0xffffffff) >> 0)
/* Produces a DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR register field value suitable for setting
 * the register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR_SET(value) (((value) << 0) & 0xffffffff)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_CURRENT_APP_RXBUFFER_L.
 */
struct DMA_CHx_CURRENT_APP_RXBUFFER_L_s {
	const volatile uint32_t CURRBUFAPTR : 32; /* DMA_CHx_CURRENT_APP_RXBUFFER_L_CURRBUFAPTR */
};

/* The typedef declaration for register DMA_CHx_CURRENT_APP_RXBUFFER_L. */
typedef struct DMA_CHx_CURRENT_APP_RXBUFFER_L_s DMA_CHx_CURRENT_APP_RXBUFFER_L_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_CURRENT_APP_RXBUFFER_L register. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_RESET 0x00000000
/* The byte offset of the DMA_CHx_CURRENT_APP_RXBUFFER_L register from the beginning of the
 * component. */
#define DMA_CHx_CURRENT_APP_RXBUFFER_L_OFST  0x5c

/*
 * Register : DMA_CH0_Status
 *
 * The software driver (application) reads the Status register during interrupt
 * service routine or polling to determine the status of the DMA.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------
 *  [0]     | RW     | 0x0   | DMA_CHx_STATUS_TI
 *  [1]     | RW     | 0x0   | DMA_CHx_STATUS_TPS
 *  [2]     | RW     | 0x0   | DMA_CHx_STATUS_TBU
 *  [5:3]   | R      | 0x0   | DMA_CHx_STATUS_RESERVED_5_3
 *  [6]     | RW     | 0x0   | DMA_CHx_STATUS_RI
 *  [7]     | RW     | 0x0   | DMA_CHx_STATUS_RBU
 *  [8]     | RW     | 0x0   | DMA_CHx_STATUS_RPS
 *  [9]     | RW     | 0x0   | DMA_CHx_STATUS_DDE
 *  [11:10] | R      | 0x0   | DMA_CHx_STATUS_RESERVED_11_10
 *  [12]    | RW     | 0x0   | DMA_CHx_STATUS_FBE
 *  [13]    | RW     | 0x0   | DMA_CHx_STATUS_CDE
 *  [14]    | RW     | 0x0   | DMA_CHx_STATUS_AIS
 *  [15]    | RW     | 0x0   | DMA_CHx_STATUS_NIS
 *  [18:16] | RW     | 0x0   | DMA_CHx_STATUS_TEB
 *  [21:19] | RW     | 0x0   | DMA_CHx_STATUS_REB
 *  [31:22] | R      | 0x0   | DMA_CHx_STATUS_RESERVED_31_22
 *
 */
/*
 * Field : TI
 *
 * Transmit Interrupt.
 *
 * This bit indicates that the packet transmission is complete. When transmission
 * is complete, Bit 31 of TDES1 is reset in the first descriptor, and the specific
 * packet status information is updated in the descriptor.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_TI register field. */
#define DMA_CHx_STATUS_TI_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_TI register field. */
#define DMA_CHx_STATUS_TI_MSB	     0
/* The width in bits of the DMA_CHx_STATUS_TI register field. */
#define DMA_CHx_STATUS_TI_WIDTH	     1
/* The mask used to set the DMA_CHx_STATUS_TI register field value. */
#define DMA_CHx_STATUS_TI_SET_MSK    0x00000001
/* The mask used to clear the DMA_CHx_STATUS_TI register field value. */
#define DMA_CHx_STATUS_TI_CLR_MSK    0xfffffffe
/* The reset value of the DMA_CHx_STATUS_TI register field. */
#define DMA_CHx_STATUS_TI_RESET	     0x0
/* Extracts the DMA_CHx_STATUS_TI field value from a register. */
#define DMA_CHx_STATUS_TI_GET(value) (((value)&0x00000001) >> 0)
/* Produces a DMA_CHx_STATUS_TI register field value suitable for setting the register. */
#define DMA_CHx_STATUS_TI_SET(value) (((value) << 0) & 0x00000001)

/*
 * Field : TPS
 *
 * Transmit Process Stopped.
 *
 * This bit is set when the transmission is stopped.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_TPS register field. */
#define DMA_CHx_STATUS_TPS_LSB	      1
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_TPS register field. */
#define DMA_CHx_STATUS_TPS_MSB	      1
/* The width in bits of the DMA_CHx_STATUS_TPS register field. */
#define DMA_CHx_STATUS_TPS_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_TPS register field value. */
#define DMA_CHx_STATUS_TPS_SET_MSK    0x00000002
/* The mask used to clear the DMA_CHx_STATUS_TPS register field value. */
#define DMA_CHx_STATUS_TPS_CLR_MSK    0xfffffffd
/* The reset value of the DMA_CHx_STATUS_TPS register field. */
#define DMA_CHx_STATUS_TPS_RESET      0x0
/* Extracts the DMA_CHx_STATUS_TPS field value from a register. */
#define DMA_CHx_STATUS_TPS_GET(value) (((value)&0x00000002) >> 1)
/* Produces a DMA_CHx_STATUS_TPS register field value suitable for setting the register. */
#define DMA_CHx_STATUS_TPS_SET(value) (((value) << 1) & 0x00000002)

/*
 * Field : TBU
 *
 * Transmit Buffer Unavailable.
 *
 * This bit indicates that the application owns the next descriptor in the Transmit
 * list, and the DMA cannot acquire it. Transmission is suspended. The TPS0 field
 * of the DMA_Debug_Status0 register explains the Transmit Process state
 * transitions.
 *
 * To resume the transmission, the application must do the following:
 *
 * * Change the ownership of the descriptor by setting Bit 31 of TDES0.
 *
 * * Issue a Transmit Poll Demand command by performing a write to the Transmit
 *   Descriptor Tail Pointer register.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_TBU register field. */
#define DMA_CHx_STATUS_TBU_LSB	      2
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_TBU register field. */
#define DMA_CHx_STATUS_TBU_MSB	      2
/* The width in bits of the DMA_CHx_STATUS_TBU register field. */
#define DMA_CHx_STATUS_TBU_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_TBU register field value. */
#define DMA_CHx_STATUS_TBU_SET_MSK    0x00000004
/* The mask used to clear the DMA_CHx_STATUS_TBU register field value. */
#define DMA_CHx_STATUS_TBU_CLR_MSK    0xfffffffb
/* The reset value of the DMA_CHx_STATUS_TBU register field. */
#define DMA_CHx_STATUS_TBU_RESET      0x0
/* Extracts the DMA_CHx_STATUS_TBU field value from a register. */
#define DMA_CHx_STATUS_TBU_GET(value) (((value)&0x00000004) >> 2)
/* Produces a DMA_CHx_STATUS_TBU register field value suitable for setting the register. */
#define DMA_CHx_STATUS_TBU_SET(value) (((value) << 2) & 0x00000004)

/*
 * Field : Reserved_5_3
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_RESERVED_5_3 register field. */
#define DMA_CHx_STATUS_RESERVED_5_3_LSB	       3
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_RESERVED_5_3 register field. */
#define DMA_CHx_STATUS_RESERVED_5_3_MSB	       5
/* The width in bits of the DMA_CHx_STATUS_RESERVED_5_3 register field. */
#define DMA_CHx_STATUS_RESERVED_5_3_WIDTH      3
/* The mask used to set the DMA_CHx_STATUS_RESERVED_5_3 register field value. */
#define DMA_CHx_STATUS_RESERVED_5_3_SET_MSK    0x00000038
/* The mask used to clear the DMA_CHx_STATUS_RESERVED_5_3 register field value. */
#define DMA_CHx_STATUS_RESERVED_5_3_CLR_MSK    0xffffffc7
/* The reset value of the DMA_CHx_STATUS_RESERVED_5_3 register field. */
#define DMA_CHx_STATUS_RESERVED_5_3_RESET      0x0
/* Extracts the DMA_CHx_STATUS_RESERVED_5_3 field value from a register. */
#define DMA_CHx_STATUS_RESERVED_5_3_GET(value) (((value)&0x00000038) >> 3)
/* Produces a DMA_CHx_STATUS_RESERVED_5_3 register field value suitable for setting the register. */
#define DMA_CHx_STATUS_RESERVED_5_3_SET(value) (((value) << 3) & 0x00000038)

/*
 * Field : RI
 *
 * Receive Interrupt.
 *
 * This bit indicates that the packet reception is complete. When packet reception
 * is complete, Bit 31 of RDES1 is reset in the last descriptor, and the specific
 * packet status information is updated in the descriptor.
 *
 * The reception remains in the Running state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_RI register field. */
#define DMA_CHx_STATUS_RI_LSB	     6
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_RI register field. */
#define DMA_CHx_STATUS_RI_MSB	     6
/* The width in bits of the DMA_CHx_STATUS_RI register field. */
#define DMA_CHx_STATUS_RI_WIDTH	     1
/* The mask used to set the DMA_CHx_STATUS_RI register field value. */
#define DMA_CHx_STATUS_RI_SET_MSK    0x00000040
/* The mask used to clear the DMA_CHx_STATUS_RI register field value. */
#define DMA_CHx_STATUS_RI_CLR_MSK    0xffffffbf
/* The reset value of the DMA_CHx_STATUS_RI register field. */
#define DMA_CHx_STATUS_RI_RESET	     0x0
/* Extracts the DMA_CHx_STATUS_RI field value from a register. */
#define DMA_CHx_STATUS_RI_GET(value) (((value)&0x00000040) >> 6)
/* Produces a DMA_CHx_STATUS_RI register field value suitable for setting the register. */
#define DMA_CHx_STATUS_RI_SET(value) (((value) << 6) & 0x00000040)

/*
 * Field : RBU
 *
 * Receive Buffer Unavailable.
 *
 * This bit indicates that the application owns the next descriptor in the Receive
 * list, and the DMA cannot acquire it. The Rx process is suspended. To resume the
 * Rx process, the application must change the ownership of the descriptor and
 * advance the DMA_CH0_RxDesc_Tail_LPointer register. If this is not done, the
 * RxDMA remains in SUSPEND state and results in overflow of the corresponding
 * RxQueue.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_RBU register field. */
#define DMA_CHx_STATUS_RBU_LSB	      7
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_RBU register field. */
#define DMA_CHx_STATUS_RBU_MSB	      7
/* The width in bits of the DMA_CHx_STATUS_RBU register field. */
#define DMA_CHx_STATUS_RBU_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_RBU register field value. */
#define DMA_CHx_STATUS_RBU_SET_MSK    0x00000080
/* The mask used to clear the DMA_CHx_STATUS_RBU register field value. */
#define DMA_CHx_STATUS_RBU_CLR_MSK    0xffffff7f
/* The reset value of the DMA_CHx_STATUS_RBU register field. */
#define DMA_CHx_STATUS_RBU_RESET      0x0
/* Extracts the DMA_CHx_STATUS_RBU field value from a register. */
#define DMA_CHx_STATUS_RBU_GET(value) (((value)&0x00000080) >> 7)
/* Produces a DMA_CHx_STATUS_RBU register field value suitable for setting the register. */
#define DMA_CHx_STATUS_RBU_SET(value) (((value) << 7) & 0x00000080)

/*
 * Field : RPS
 *
 * Receive Process Stopped.
 *
 * This bit is asserted when the Rx process enters the Stopped state.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_RPS register field. */
#define DMA_CHx_STATUS_RPS_LSB	      8
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_RPS register field. */
#define DMA_CHx_STATUS_RPS_MSB	      8
/* The width in bits of the DMA_CHx_STATUS_RPS register field. */
#define DMA_CHx_STATUS_RPS_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_RPS register field value. */
#define DMA_CHx_STATUS_RPS_SET_MSK    0x00000100
/* The mask used to clear the DMA_CHx_STATUS_RPS register field value. */
#define DMA_CHx_STATUS_RPS_CLR_MSK    0xfffffeff
/* The reset value of the DMA_CHx_STATUS_RPS register field. */
#define DMA_CHx_STATUS_RPS_RESET      0x0
/* Extracts the DMA_CHx_STATUS_RPS field value from a register. */
#define DMA_CHx_STATUS_RPS_GET(value) (((value)&0x00000100) >> 8)
/* Produces a DMA_CHx_STATUS_RPS register field value suitable for setting the register. */
#define DMA_CHx_STATUS_RPS_SET(value) (((value) << 8) & 0x00000100)

/*
 * Field : DDE
 *
 * Descriptor Definition Error.
 *
 * This bit indicates that a Descriptor Definition error occurred. When this bit is
 * set, the corresponding DMA channel engine suspends Descriptor Fetch.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_DDE register field. */
#define DMA_CHx_STATUS_DDE_LSB	      9
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_DDE register field. */
#define DMA_CHx_STATUS_DDE_MSB	      9
/* The width in bits of the DMA_CHx_STATUS_DDE register field. */
#define DMA_CHx_STATUS_DDE_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_DDE register field value. */
#define DMA_CHx_STATUS_DDE_SET_MSK    0x00000200
/* The mask used to clear the DMA_CHx_STATUS_DDE register field value. */
#define DMA_CHx_STATUS_DDE_CLR_MSK    0xfffffdff
/* The reset value of the DMA_CHx_STATUS_DDE register field. */
#define DMA_CHx_STATUS_DDE_RESET      0x0
/* Extracts the DMA_CHx_STATUS_DDE field value from a register. */
#define DMA_CHx_STATUS_DDE_GET(value) (((value)&0x00000200) >> 9)
/* Produces a DMA_CHx_STATUS_DDE register field value suitable for setting the register. */
#define DMA_CHx_STATUS_DDE_SET(value) (((value) << 9) & 0x00000200)

/*
 * Field : Reserved_11_10
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_RESERVED_11_10 register field. */
#define DMA_CHx_STATUS_RESERVED_11_10_LSB	 10
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_RESERVED_11_10 register field. */
#define DMA_CHx_STATUS_RESERVED_11_10_MSB	 11
/* The width in bits of the DMA_CHx_STATUS_RESERVED_11_10 register field. */
#define DMA_CHx_STATUS_RESERVED_11_10_WIDTH	 2
/* The mask used to set the DMA_CHx_STATUS_RESERVED_11_10 register field value. */
#define DMA_CHx_STATUS_RESERVED_11_10_SET_MSK	 0x00000c00
/* The mask used to clear the DMA_CHx_STATUS_RESERVED_11_10 register field value. */
#define DMA_CHx_STATUS_RESERVED_11_10_CLR_MSK	 0xfffff3ff
/* The reset value of the DMA_CHx_STATUS_RESERVED_11_10 register field. */
#define DMA_CHx_STATUS_RESERVED_11_10_RESET	 0x0
/* Extracts the DMA_CHx_STATUS_RESERVED_11_10 field value from a register. */
#define DMA_CHx_STATUS_RESERVED_11_10_GET(value) (((value)&0x00000c00) >> 10)
/* Produces a DMA_CHx_STATUS_RESERVED_11_10 register field value suitable for setting the register.
 */
#define DMA_CHx_STATUS_RESERVED_11_10_SET(value) (((value) << 10) & 0x00000c00)

/*
 * Field : FBE
 *
 * Fatal Bus Error.
 *
 * This bit indicates that a bus error occurred (as described in the EB field).
 * When this bit is set, the corresponding DMA channel engine disables all bus
 * accesses.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_FBE register field. */
#define DMA_CHx_STATUS_FBE_LSB	      12
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_FBE register field. */
#define DMA_CHx_STATUS_FBE_MSB	      12
/* The width in bits of the DMA_CHx_STATUS_FBE register field. */
#define DMA_CHx_STATUS_FBE_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_FBE register field value. */
#define DMA_CHx_STATUS_FBE_SET_MSK    0x00001000
/* The mask used to clear the DMA_CHx_STATUS_FBE register field value. */
#define DMA_CHx_STATUS_FBE_CLR_MSK    0xffffefff
/* The reset value of the DMA_CHx_STATUS_FBE register field. */
#define DMA_CHx_STATUS_FBE_RESET      0x0
/* Extracts the DMA_CHx_STATUS_FBE field value from a register. */
#define DMA_CHx_STATUS_FBE_GET(value) (((value)&0x00001000) >> 12)
/* Produces a DMA_CHx_STATUS_FBE register field value suitable for setting the register. */
#define DMA_CHx_STATUS_FBE_SET(value) (((value) << 12) & 0x00001000)

/*
 * Field : CDE
 *
 * Context Descriptor Error.
 *
 * This bit indicates that the DMA Tx engine received a context descriptor in the
 * middle of a packet (in an intermediate descriptor), and the DMA Tx engine
 * ignored it.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_CDE register field. */
#define DMA_CHx_STATUS_CDE_LSB	      13
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_CDE register field. */
#define DMA_CHx_STATUS_CDE_MSB	      13
/* The width in bits of the DMA_CHx_STATUS_CDE register field. */
#define DMA_CHx_STATUS_CDE_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_CDE register field value. */
#define DMA_CHx_STATUS_CDE_SET_MSK    0x00002000
/* The mask used to clear the DMA_CHx_STATUS_CDE register field value. */
#define DMA_CHx_STATUS_CDE_CLR_MSK    0xffffdfff
/* The reset value of the DMA_CHx_STATUS_CDE register field. */
#define DMA_CHx_STATUS_CDE_RESET      0x0
/* Extracts the DMA_CHx_STATUS_CDE field value from a register. */
#define DMA_CHx_STATUS_CDE_GET(value) (((value)&0x00002000) >> 13)
/* Produces a DMA_CHx_STATUS_CDE register field value suitable for setting the register. */
#define DMA_CHx_STATUS_CDE_SET(value) (((value) << 13) & 0x00002000)

/*
 * Field : AIS
 *
 * Abnormal Interrupt Summary.
 *
 * Abnormal Interrupt Summary bit value is the logical OR of the following when the
 * corresponding interrupt bits are enabled in the DMA_CH0_Interrupt_Enable
 * register:
 *
 * * Bit 1: Transmit Process Stopped
 *
 * * Bit 7: Receive Buffer Unavailable
 *
 * * Bit 8: Receive Process Stopped
 *
 * * Bit 9: Descriptor Definition Error
 *
 * * Bit 12: Fatal Bus Error
 *
 * * Bit 13: Context Descriptor Error
 *
 * Only unmasked bits affect the Abnormal Interrupt Summary bit.
 *
 * This is a sticky bit. You must clear this bit (by writing 1 to this bit) each
 * time a corresponding bit, which causes AIS to be set, is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_AIS register field. */
#define DMA_CHx_STATUS_AIS_LSB	      14
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_AIS register field. */
#define DMA_CHx_STATUS_AIS_MSB	      14
/* The width in bits of the DMA_CHx_STATUS_AIS register field. */
#define DMA_CHx_STATUS_AIS_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_AIS register field value. */
#define DMA_CHx_STATUS_AIS_SET_MSK    0x00004000
/* The mask used to clear the DMA_CHx_STATUS_AIS register field value. */
#define DMA_CHx_STATUS_AIS_CLR_MSK    0xffffbfff
/* The reset value of the DMA_CHx_STATUS_AIS register field. */
#define DMA_CHx_STATUS_AIS_RESET      0x0
/* Extracts the DMA_CHx_STATUS_AIS field value from a register. */
#define DMA_CHx_STATUS_AIS_GET(value) (((value)&0x00004000) >> 14)
/* Produces a DMA_CHx_STATUS_AIS register field value suitable for setting the register. */
#define DMA_CHx_STATUS_AIS_SET(value) (((value) << 14) & 0x00004000)

/*
 * Field : NIS
 *
 * Normal Interrupt Summary.
 *
 * Normal Interrupt Summary bit value is the logical OR of the following bits when
 * the corresponding interrupt bits are enabled in the DMA_CH0_Interrupt_Enable
 * register:
 *
 * * Bit 0: Transmit Interrupt
 *
 * * Bit 2: Transmit Buffer Unavailable
 *
 * * Bit 6: Receive Interrupt
 *
 * Only unmasked bits (interrupts for which interrupt enable is set in
 * DMA_CH0_Interrupt_Enable register) affect the Normal Interrupt Summary bit.
 *
 * This is a sticky bit. You must clear this bit (by writing 1 to this bit) each
 * time a corresponding bit which causes NIS to be set is cleared.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_NIS register field. */
#define DMA_CHx_STATUS_NIS_LSB	      15
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_NIS register field. */
#define DMA_CHx_STATUS_NIS_MSB	      15
/* The width in bits of the DMA_CHx_STATUS_NIS register field. */
#define DMA_CHx_STATUS_NIS_WIDTH      1
/* The mask used to set the DMA_CHx_STATUS_NIS register field value. */
#define DMA_CHx_STATUS_NIS_SET_MSK    0x00008000
/* The mask used to clear the DMA_CHx_STATUS_NIS register field value. */
#define DMA_CHx_STATUS_NIS_CLR_MSK    0xffff7fff
/* The reset value of the DMA_CHx_STATUS_NIS register field. */
#define DMA_CHx_STATUS_NIS_RESET      0x0
/* Extracts the DMA_CHx_STATUS_NIS field value from a register. */
#define DMA_CHx_STATUS_NIS_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_CHx_STATUS_NIS register field value suitable for setting the register. */
#define DMA_CHx_STATUS_NIS_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : TEB
 *
 * Tx DMA Error Bits.
 *
 * This field indicates the type of error that caused a Bus Error. For example,
 * error response on the AXI interface.
 *
 * Bit 18
 *
 * * 1'b1: Error during data transfer by the Tx DMA
 *
 * * 1'b0: No Error during data transfer by the Tx DMA
 *
 * Bit 17
 *
 * * 1'b1: Error during descriptor access
 *
 * * 1'b0: Error during data buffer access
 *
 * Bit 16
 *
 * * 1'b1: Error during read transfer
 *
 * * 1'b0: Error during write transfer
 *
 * This field is valid only when the FBE bit is set. This field does not generate
 * an interrupt.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_TEB register field. */
#define DMA_CHx_STATUS_TEB_LSB	      16
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_TEB register field. */
#define DMA_CHx_STATUS_TEB_MSB	      18
/* The width in bits of the DMA_CHx_STATUS_TEB register field. */
#define DMA_CHx_STATUS_TEB_WIDTH      3
/* The mask used to set the DMA_CHx_STATUS_TEB register field value. */
#define DMA_CHx_STATUS_TEB_SET_MSK    0x00070000
/* The mask used to clear the DMA_CHx_STATUS_TEB register field value. */
#define DMA_CHx_STATUS_TEB_CLR_MSK    0xfff8ffff
/* The reset value of the DMA_CHx_STATUS_TEB register field. */
#define DMA_CHx_STATUS_TEB_RESET      0x0
/* Extracts the DMA_CHx_STATUS_TEB field value from a register. */
#define DMA_CHx_STATUS_TEB_GET(value) (((value)&0x00070000) >> 16)
/* Produces a DMA_CHx_STATUS_TEB register field value suitable for setting the register. */
#define DMA_CHx_STATUS_TEB_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : REB
 *
 * Rx DMA Error Bits.
 *
 * This field indicates the type of error that caused a Bus Error. For example,
 * error response on the AXI interface.
 *
 * Bit 21
 *
 * * 1'b1: Error during data transfer by the Rx DMA
 *
 * * 1'b0: No error during data transfer by the Rx DMA
 *
 * Bit 20
 *
 * * 1'b1: Error during descriptor access
 *
 * * 1'b0: Error during data buffer access
 *
 * Bit 19
 *
 * * 1'b1: Error during read transfer
 *
 * * 1'b0: Error during write transfer
 *
 * This field is valid only when the FBE bit is set. This field does not generate
 * an interrupt.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_REB register field. */
#define DMA_CHx_STATUS_REB_LSB	      19
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_REB register field. */
#define DMA_CHx_STATUS_REB_MSB	      21
/* The width in bits of the DMA_CHx_STATUS_REB register field. */
#define DMA_CHx_STATUS_REB_WIDTH      3
/* The mask used to set the DMA_CHx_STATUS_REB register field value. */
#define DMA_CHx_STATUS_REB_SET_MSK    0x00380000
/* The mask used to clear the DMA_CHx_STATUS_REB register field value. */
#define DMA_CHx_STATUS_REB_CLR_MSK    0xffc7ffff
/* The reset value of the DMA_CHx_STATUS_REB register field. */
#define DMA_CHx_STATUS_REB_RESET      0x0
/* Extracts the DMA_CHx_STATUS_REB field value from a register. */
#define DMA_CHx_STATUS_REB_GET(value) (((value)&0x00380000) >> 19)
/* Produces a DMA_CHx_STATUS_REB register field value suitable for setting the register. */
#define DMA_CHx_STATUS_REB_SET(value) (((value) << 19) & 0x00380000)

/*
 * Field : Reserved_31_22
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_STATUS_RESERVED_31_22 register field. */
#define DMA_CHx_STATUS_RESERVED_31_22_LSB	 22
/* The Most Significant Bit (MSB) position of the DMA_CHx_STATUS_RESERVED_31_22 register field. */
#define DMA_CHx_STATUS_RESERVED_31_22_MSB	 31
/* The width in bits of the DMA_CHx_STATUS_RESERVED_31_22 register field. */
#define DMA_CHx_STATUS_RESERVED_31_22_WIDTH	 10
/* The mask used to set the DMA_CHx_STATUS_RESERVED_31_22 register field value. */
#define DMA_CHx_STATUS_RESERVED_31_22_SET_MSK	 0xffc00000
/* The mask used to clear the DMA_CHx_STATUS_RESERVED_31_22 register field value. */
#define DMA_CHx_STATUS_RESERVED_31_22_CLR_MSK	 0x003fffff
/* The reset value of the DMA_CHx_STATUS_RESERVED_31_22 register field. */
#define DMA_CHx_STATUS_RESERVED_31_22_RESET	 0x0
/* Extracts the DMA_CHx_STATUS_RESERVED_31_22 field value from a register. */
#define DMA_CHx_STATUS_RESERVED_31_22_GET(value) (((value)&0xffc00000) >> 22)
/* Produces a DMA_CHx_STATUS_RESERVED_31_22 register field value suitable for setting the register.
 */
#define DMA_CHx_STATUS_RESERVED_31_22_SET(value) (((value) << 22) & 0xffc00000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_STATUS.
 */
struct DMA_CHx_STATUS_s {
	volatile uint32_t TI : 1;		     /* DMA_CHx_STATUS_TI */
	volatile uint32_t TPS : 1;		     /* DMA_CHx_STATUS_TPS */
	volatile uint32_t TBU : 1;		     /* DMA_CHx_STATUS_TBU */
	const volatile uint32_t Reserved_5_3 : 3;    /* DMA_CHx_STATUS_RESERVED_5_3 */
	volatile uint32_t RI : 1;		     /* DMA_CHx_STATUS_RI */
	volatile uint32_t RBU : 1;		     /* DMA_CHx_STATUS_RBU */
	volatile uint32_t RPS : 1;		     /* DMA_CHx_STATUS_RPS */
	volatile uint32_t DDE : 1;		     /* DMA_CHx_STATUS_DDE */
	const volatile uint32_t Reserved_11_10 : 2;  /* DMA_CHx_STATUS_RESERVED_11_10 */
	volatile uint32_t FBE : 1;		     /* DMA_CHx_STATUS_FBE */
	volatile uint32_t CDE : 1;		     /* DMA_CHx_STATUS_CDE */
	volatile uint32_t AIS : 1;		     /* DMA_CHx_STATUS_AIS */
	volatile uint32_t NIS : 1;		     /* DMA_CHx_STATUS_NIS */
	volatile uint32_t TEB : 3;		     /* DMA_CHx_STATUS_TEB */
	volatile uint32_t REB : 3;		     /* DMA_CHx_STATUS_REB */
	const volatile uint32_t Reserved_31_22 : 10; /* DMA_CHx_STATUS_RESERVED_31_22 */
};

/* The typedef declaration for register DMA_CHx_STATUS. */
typedef struct DMA_CHx_STATUS_s DMA_CHx_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_STATUS register. */
#define DMA_CHx_STATUS_RESET 0x00000000
/* The byte offset of the DMA_CHx_STATUS register from the beginning of the component. */
#define DMA_CHx_STATUS_OFST  0x60

/*
 * Register : DMA_CH0_Debug_Status
 *
 * DMA Channe0 Debug Status register
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------
 *  [2:0]   | R      | 0x0   | DMA_CHx_DEBUG_STATUS_TDFS
 *  [5:3]   | R      | 0x0   | DMA_CHx_DEBUG_STATUS_TDXS
 *  [7:6]   | R      | 0x0   | DMA_CHx_DEBUG_STATUS_TDRS
 *  [11:8]  | R      | 0x0   | DMA_CHx_DEBUG_STATUS_TDTS
 *  [14:12] | R      | 0x0   | DMA_CHx_DEBUG_STATUS_TDWS
 *  [15]    | R      | 0x0   | DMA_CHx_DEBUG_STATUS_RESERVED_15
 *  [18:16] | R      | 0x0   | DMA_CHx_DEBUG_STATUS_RDFS
 *  [27:19] | R      | 0x0   | DMA_CHx_DEBUG_STATUS_RDTS
 *  [30:28] | R      | 0x0   | DMA_CHx_DEBUG_STATUS_RDWS
 *  [31]    | R      | 0x0   | DMA_CHx_DEBUG_STATUS_RESERVED_31
 *
 */
/*
 * Field : TDFS
 *
 * TxDMA Descriptor Fetch FSM State
 *
 * * 'x0: STOP/IDLE State
 *
 * * 'x1: Requesting for Descriptor Read state
 *
 * * 'x2: Reading the Descriptor & writing into Descriptor Cache state
 *
 * * 'x3: SUSPEND state
 *
 * * 'x4: ERROR state
 *
 * * 'x5: Waiting for Descriptor data transfer complete after OWN bit error
 *
 * * 'x6: Start Read descriptor with OWN bit not set again
 *
 * * 'x7: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_TDFS register field. */
#define DMA_CHx_DEBUG_STATUS_TDFS_LSB	     0
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_TDFS register field. */
#define DMA_CHx_DEBUG_STATUS_TDFS_MSB	     2
/* The width in bits of the DMA_CHx_DEBUG_STATUS_TDFS register field. */
#define DMA_CHx_DEBUG_STATUS_TDFS_WIDTH	     3
/* The mask used to set the DMA_CHx_DEBUG_STATUS_TDFS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDFS_SET_MSK    0x00000007
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_TDFS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDFS_CLR_MSK    0xfffffff8
/* The reset value of the DMA_CHx_DEBUG_STATUS_TDFS register field. */
#define DMA_CHx_DEBUG_STATUS_TDFS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_TDFS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_TDFS_GET(value) (((value)&0x00000007) >> 0)
/* Produces a DMA_CHx_DEBUG_STATUS_TDFS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_TDFS_SET(value) (((value) << 0) & 0x00000007)

/*
 * Field : TDXS
 *
 * TxDMA Data Transfer FSM State
 *
 * * 'x0: IDLE state
 *
 * * 'x1: Control word writing state
 *
 * * 'x2: Data transferring state
 *
 * * 'x3: Descriptor Writing Back state
 *
 * * 'x4: Writing Timestamp correction field state (Reserved if Data Width is
 *   greater than 64)
 *
 * * 'x5-'x7: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_TDXS register field. */
#define DMA_CHx_DEBUG_STATUS_TDXS_LSB	     3
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_TDXS register field. */
#define DMA_CHx_DEBUG_STATUS_TDXS_MSB	     5
/* The width in bits of the DMA_CHx_DEBUG_STATUS_TDXS register field. */
#define DMA_CHx_DEBUG_STATUS_TDXS_WIDTH	     3
/* The mask used to set the DMA_CHx_DEBUG_STATUS_TDXS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDXS_SET_MSK    0x00000038
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_TDXS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDXS_CLR_MSK    0xffffffc7
/* The reset value of the DMA_CHx_DEBUG_STATUS_TDXS register field. */
#define DMA_CHx_DEBUG_STATUS_TDXS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_TDXS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_TDXS_GET(value) (((value)&0x00000038) >> 3)
/* Produces a DMA_CHx_DEBUG_STATUS_TDXS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_TDXS_SET(value) (((value) << 3) & 0x00000038)

/*
 * Field : TDRS
 *
 * TxDMA Data Request FSM State
 *
 * * 'x0: IDLE state
 *
 * * 'x1: Checking Tx FIFO space state
 *
 * * 'x2: AXI or TSO cache request state
 *
 * * 'x3: Internal Request information updating state
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_TDRS register field. */
#define DMA_CHx_DEBUG_STATUS_TDRS_LSB	     6
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_TDRS register field. */
#define DMA_CHx_DEBUG_STATUS_TDRS_MSB	     7
/* The width in bits of the DMA_CHx_DEBUG_STATUS_TDRS register field. */
#define DMA_CHx_DEBUG_STATUS_TDRS_WIDTH	     2
/* The mask used to set the DMA_CHx_DEBUG_STATUS_TDRS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDRS_SET_MSK    0x000000c0
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_TDRS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDRS_CLR_MSK    0xffffff3f
/* The reset value of the DMA_CHx_DEBUG_STATUS_TDRS register field. */
#define DMA_CHx_DEBUG_STATUS_TDRS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_TDRS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_TDRS_GET(value) (((value)&0x000000c0) >> 6)
/* Produces a DMA_CHx_DEBUG_STATUS_TDRS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_TDRS_SET(value) (((value) << 6) & 0x000000c0)

/*
 * Field : TDTS
 *
 * TxDMA Data Transfer Control Module FSM State
 *
 * * 'x0: STOP state
 *
 * * 'x1: IDLE state
 *
 * * 'x2: Buffer Reading request
 *
 * * 'x3: Internal normal control word writing
 *
 * * 'x4: ERROR state
 *
 * * 'x5: Internal context control word writing
 *
 * * 'x6: Internal Timestamp correction updating
 *
 * * 'x7: TSO header Reading request
 *
 * * 'x8: TSO payload Reading request
 *
 * * 'x9: Writing pended TSO header descriptor
 *
 * * 'xA: Waiting for TSO memory writing complete
 *
 * * 'xB: TSO header cache Reading request
 *
 * * 'xC-'xF: TDT in reset, or Some unknown error (should not be here)
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_TDTS register field. */
#define DMA_CHx_DEBUG_STATUS_TDTS_LSB	     8
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_TDTS register field. */
#define DMA_CHx_DEBUG_STATUS_TDTS_MSB	     11
/* The width in bits of the DMA_CHx_DEBUG_STATUS_TDTS register field. */
#define DMA_CHx_DEBUG_STATUS_TDTS_WIDTH	     4
/* The mask used to set the DMA_CHx_DEBUG_STATUS_TDTS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDTS_SET_MSK    0x00000f00
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_TDTS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDTS_CLR_MSK    0xfffff0ff
/* The reset value of the DMA_CHx_DEBUG_STATUS_TDTS register field. */
#define DMA_CHx_DEBUG_STATUS_TDTS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_TDTS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_TDTS_GET(value) (((value)&0x00000f00) >> 8)
/* Produces a DMA_CHx_DEBUG_STATUS_TDTS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_TDTS_SET(value) (((value) << 8) & 0x00000f00)

/*
 * Field : TDWS
 *
 * TxDMA Descriptor Write FSM state
 *
 * * 'x0: STOP/IDLE state
 *
 * * 'x1: Request to Arbiter for Descriptor Write state
 *
 * * 'x2: Descriptor Write Transfer state
 *
 * * 'x3: Waiting for AXI Write Response state
 *
 * * 'x4: ERROR state
 *
 * * 'x5-'x7: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_TDWS register field. */
#define DMA_CHx_DEBUG_STATUS_TDWS_LSB	     12
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_TDWS register field. */
#define DMA_CHx_DEBUG_STATUS_TDWS_MSB	     14
/* The width in bits of the DMA_CHx_DEBUG_STATUS_TDWS register field. */
#define DMA_CHx_DEBUG_STATUS_TDWS_WIDTH	     3
/* The mask used to set the DMA_CHx_DEBUG_STATUS_TDWS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDWS_SET_MSK    0x00007000
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_TDWS register field value. */
#define DMA_CHx_DEBUG_STATUS_TDWS_CLR_MSK    0xffff8fff
/* The reset value of the DMA_CHx_DEBUG_STATUS_TDWS register field. */
#define DMA_CHx_DEBUG_STATUS_TDWS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_TDWS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_TDWS_GET(value) (((value)&0x00007000) >> 12)
/* Produces a DMA_CHx_DEBUG_STATUS_TDWS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_TDWS_SET(value) (((value) << 12) & 0x00007000)

/*
 * Field : Reserved_15
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_RESERVED_15 register field.
 */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_LSB	    15
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_RESERVED_15 register field.
 */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_MSB	    15
/* The width in bits of the DMA_CHx_DEBUG_STATUS_RESERVED_15 register field. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_WIDTH	    1
/* The mask used to set the DMA_CHx_DEBUG_STATUS_RESERVED_15 register field value. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_SET_MSK    0x00008000
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_RESERVED_15 register field value. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_CLR_MSK    0xffff7fff
/* The reset value of the DMA_CHx_DEBUG_STATUS_RESERVED_15 register field. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_RESET	    0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_RESERVED_15 field value from a register. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_CHx_DEBUG_STATUS_RESERVED_15 register field value suitable for setting the
 * register. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_15_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : RDFS
 *
 * RxDMA Descriptor Fetch FSM State
 *
 * * 'x0: STOP/IDLE State
 *
 * * 'x1: Requesting for Descriptor Read
 *
 * * 'x2: Reading the Descriptor & writing into Descriptor Cache
 *
 * * 'x3: SUSPEND state
 *
 * * 'x4: ERROR state
 *
 * * 'x5: Waiting for Descriptor data transfer complete after OWN bit error
 *
 * * 'x6: Start Read descriptor with OWN bit not set again
 *
 * * 'x7: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_RDFS register field. */
#define DMA_CHx_DEBUG_STATUS_RDFS_LSB	     16
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_RDFS register field. */
#define DMA_CHx_DEBUG_STATUS_RDFS_MSB	     18
/* The width in bits of the DMA_CHx_DEBUG_STATUS_RDFS register field. */
#define DMA_CHx_DEBUG_STATUS_RDFS_WIDTH	     3
/* The mask used to set the DMA_CHx_DEBUG_STATUS_RDFS register field value. */
#define DMA_CHx_DEBUG_STATUS_RDFS_SET_MSK    0x00070000
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_RDFS register field value. */
#define DMA_CHx_DEBUG_STATUS_RDFS_CLR_MSK    0xfff8ffff
/* The reset value of the DMA_CHx_DEBUG_STATUS_RDFS register field. */
#define DMA_CHx_DEBUG_STATUS_RDFS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_RDFS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_RDFS_GET(value) (((value)&0x00070000) >> 16)
/* Produces a DMA_CHx_DEBUG_STATUS_RDFS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_RDFS_SET(value) (((value) << 16) & 0x00070000)

/*
 * Field : RDTS
 *
 * RxDMA Data Transfer FSM State
 *
 * * 'x0: STOP state
 *
 * * 'x1: waiting for the New Descriptor from RDF state
 *
 * * 'x2: Waiting for Packet Header Status from ARI state
 *
 * * 'x3: Waiting for new intermediate Descriptor from RDF state
 *
 * * 'x4: Waiting for Watermark on ARI state
 *
 * * 'x5: Request for Data Transfer on AXI state
 *
 * * 'x6: Write Data Transfer on AXI state
 *
 * * 'x7: Write Dummy Data after receiving AXI Error state
 *
 * * 'x8: Waiting for previous descriptor to closed by RDW state
 *
 * * 'x9: Error state
 *
 * * 'xA-'xF: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_RDTS register field. */
#define DMA_CHx_DEBUG_STATUS_RDTS_LSB	     19
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_RDTS register field. */
#define DMA_CHx_DEBUG_STATUS_RDTS_MSB	     27
/* The width in bits of the DMA_CHx_DEBUG_STATUS_RDTS register field. */
#define DMA_CHx_DEBUG_STATUS_RDTS_WIDTH	     9
/* The mask used to set the DMA_CHx_DEBUG_STATUS_RDTS register field value. */
#define DMA_CHx_DEBUG_STATUS_RDTS_SET_MSK    0x0ff80000
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_RDTS register field value. */
#define DMA_CHx_DEBUG_STATUS_RDTS_CLR_MSK    0xf007ffff
/* The reset value of the DMA_CHx_DEBUG_STATUS_RDTS register field. */
#define DMA_CHx_DEBUG_STATUS_RDTS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_RDTS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_RDTS_GET(value) (((value)&0x0ff80000) >> 19)
/* Produces a DMA_CHx_DEBUG_STATUS_RDTS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_RDTS_SET(value) (((value) << 19) & 0x0ff80000)

/*
 * Field : RDWS
 *
 * RxDMA Descriptor Write FSM state
 *
 * * 'x0: STOP/IDLE state
 *
 * * 'x1: Request to Arbiter for Descriptor Write state
 *
 * * 'x2: Descriptor Write Transfer state
 *
 * * 'x3: Waiting for AXI Write Response state
 *
 * * 'x4: ERROR state
 *
 * * 'x5-'x7: Reserved
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_RDWS register field. */
#define DMA_CHx_DEBUG_STATUS_RDWS_LSB	     28
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_RDWS register field. */
#define DMA_CHx_DEBUG_STATUS_RDWS_MSB	     30
/* The width in bits of the DMA_CHx_DEBUG_STATUS_RDWS register field. */
#define DMA_CHx_DEBUG_STATUS_RDWS_WIDTH	     3
/* The mask used to set the DMA_CHx_DEBUG_STATUS_RDWS register field value. */
#define DMA_CHx_DEBUG_STATUS_RDWS_SET_MSK    0x70000000
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_RDWS register field value. */
#define DMA_CHx_DEBUG_STATUS_RDWS_CLR_MSK    0x8fffffff
/* The reset value of the DMA_CHx_DEBUG_STATUS_RDWS register field. */
#define DMA_CHx_DEBUG_STATUS_RDWS_RESET	     0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_RDWS field value from a register. */
#define DMA_CHx_DEBUG_STATUS_RDWS_GET(value) (((value)&0x70000000) >> 28)
/* Produces a DMA_CHx_DEBUG_STATUS_RDWS register field value suitable for setting the register. */
#define DMA_CHx_DEBUG_STATUS_RDWS_SET(value) (((value) << 28) & 0x70000000)

/*
 * Field : Reserved_31
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DEBUG_STATUS_RESERVED_31 register field.
 */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_LSB	    31
/* The Most Significant Bit (MSB) position of the DMA_CHx_DEBUG_STATUS_RESERVED_31 register field.
 */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_MSB	    31
/* The width in bits of the DMA_CHx_DEBUG_STATUS_RESERVED_31 register field. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_WIDTH	    1
/* The mask used to set the DMA_CHx_DEBUG_STATUS_RESERVED_31 register field value. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_SET_MSK    0x80000000
/* The mask used to clear the DMA_CHx_DEBUG_STATUS_RESERVED_31 register field value. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_CLR_MSK    0x7fffffff
/* The reset value of the DMA_CHx_DEBUG_STATUS_RESERVED_31 register field. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_RESET	    0x0
/* Extracts the DMA_CHx_DEBUG_STATUS_RESERVED_31 field value from a register. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_GET(value) (((value)&0x80000000) >> 31)
/* Produces a DMA_CHx_DEBUG_STATUS_RESERVED_31 register field value suitable for setting the
 * register. */
#define DMA_CHx_DEBUG_STATUS_RESERVED_31_SET(value) (((value) << 31) & 0x80000000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_DEBUG_STATUS.
 */
struct DMA_CHx_DEBUG_STATUS_s {
	const volatile uint32_t TDFS : 3;	 /* DMA_CHx_DEBUG_STATUS_TDFS */
	const volatile uint32_t TDXS : 3;	 /* DMA_CHx_DEBUG_STATUS_TDXS */
	const volatile uint32_t TDRS : 2;	 /* DMA_CHx_DEBUG_STATUS_TDRS */
	const volatile uint32_t TDTS : 4;	 /* DMA_CHx_DEBUG_STATUS_TDTS */
	const volatile uint32_t TDWS : 3;	 /* DMA_CHx_DEBUG_STATUS_TDWS */
	const volatile uint32_t Reserved_15 : 1; /* DMA_CHx_DEBUG_STATUS_RESERVED_15 */
	const volatile uint32_t RDFS : 3;	 /* DMA_CHx_DEBUG_STATUS_RDFS */
	const volatile uint32_t RDTS : 9;	 /* DMA_CHx_DEBUG_STATUS_RDTS */
	const volatile uint32_t RDWS : 3;	 /* DMA_CHx_DEBUG_STATUS_RDWS */
	const volatile uint32_t Reserved_31 : 1; /* DMA_CHx_DEBUG_STATUS_RESERVED_31 */
};

/* The typedef declaration for register DMA_CHx_DEBUG_STATUS. */
typedef struct DMA_CHx_DEBUG_STATUS_s DMA_CHx_DEBUG_STATUS_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_DEBUG_STATUS register. */
#define DMA_CHx_DEBUG_STATUS_RESET 0x00000000
/* The byte offset of the DMA_CHx_DEBUG_STATUS register from the beginning of the component. */
#define DMA_CHx_DEBUG_STATUS_OFST  0x64

/*
 * Register : DMA_CH0_Desc_Mem_Cache_Fill_Level
 *
 * The DMA Channelx Descriptor Cache Fill Level Status register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------------------
 *  [4:0]   | R      | 0x0   | DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL
 *  [7:5]   | R      | 0x0   | DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5
 *  [12:8]  | R      | 0x0   | DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL
 *  [31:13] | R      | 0x0   | DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13
 *
 */
/*
 * Field : TX_FILL_LVL
 *
 * TxDMA Descriptor Cache Fill Level
 *
 * This field gives the fill level of the Descriptor Cache for TxDMA channel 0. A
 * value of 0 implies empty and a value of 0x10 implies it is full, with 16
 * descriptors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_LSB	 0
/* The Most Significant Bit (MSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_MSB	 4
/* The width in bits of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_WIDTH	 5
/* The mask used to set the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL register field value. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_SET_MSK	 0x0000001f
/* The mask used to clear the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL register field value. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_CLR_MSK	 0xffffffe0
/* The reset value of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_RESET	 0x0
/* Extracts the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL field value from a register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_GET(value) (((value)&0x0000001f) >> 0)
/* Produces a DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL register field value suitable for
 * setting the register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL_SET(value) (((value) << 0) & 0x0000001f)

/*
 * Field : Reserved_7_5
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_LSB	  5
/* The Most Significant Bit (MSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_MSB	  7
/* The width in bits of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_WIDTH	  3
/* The mask used to set the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 register field value. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_SET_MSK	  0x000000e0
/* The mask used to clear the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 register field value.
 */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_CLR_MSK	  0xffffff1f
/* The reset value of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_RESET	  0x0
/* Extracts the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 field value from a register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_GET(value) (((value)&0x000000e0) >> 5)
/* Produces a DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 register field value suitable for
 * setting the register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5_SET(value) (((value) << 5) & 0x000000e0)

/*
 * Field : RX_FILL_LVL
 *
 * RxDMA Descriptor Cache Fill Level
 *
 * This field gives the fill level of the Descriptor Cache for RxDMA Channel 0. A
 * value of 0 implies empty and a value of 0x10 implies it is full, with 16
 * descriptors.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_LSB	 8
/* The Most Significant Bit (MSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_MSB	 12
/* The width in bits of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_WIDTH	 5
/* The mask used to set the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL register field value. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_SET_MSK	 0x00001f00
/* The mask used to clear the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL register field value. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_CLR_MSK	 0xffffe0ff
/* The reset value of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_RESET	 0x0
/* Extracts the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL field value from a register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_GET(value) (((value)&0x00001f00) >> 8)
/* Produces a DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL register field value suitable for
 * setting the register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL_SET(value) (((value) << 8) & 0x00001f00)

/*
 * Field : Reserved_31_13
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_LSB	    13
/* The Most Significant Bit (MSB) position of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13
 * register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_MSB	    31
/* The width in bits of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_WIDTH	    19
/* The mask used to set the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 register field value.
 */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_SET_MSK    0xffffe000
/* The mask used to clear the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 register field value.
 */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_CLR_MSK    0x00001fff
/* The reset value of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 register field. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_RESET	    0x0
/* Extracts the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 field value from a register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_GET(value) (((value)&0xffffe000) >> 13)
/* Produces a DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 register field value suitable for
 * setting the register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13_SET(value) (((value) << 13) & 0xffffe000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL.
 */
struct DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_s {
	const volatile uint32_t TX_FILL_LVL : 5; /* DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_TX_FILL_LVL */
	const volatile uint32_t
		Reserved_7_5 : 3; /* DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_7_5 */
	const volatile uint32_t RX_FILL_LVL : 5; /* DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RX_FILL_LVL */
	const volatile uint32_t
		Reserved_31_13 : 19; /* DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESERVED_31_13 */
};

/* The typedef declaration for register DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL. */
typedef struct DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_s DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL register. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_RESET 0x00000000
/* The byte offset of the DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL register from the beginning of the
 * component. */
#define DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_OFST	0x68

/*
 * Register : DMA_CH0_Miss_Packet_Cnt
 *
 * This register has the number of the packets that were dropped by the DMA either
 * due to Bus Error or due to programming the RPF field in the DMA_CH0_Rx_Control
 * register.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:-----------------------------------------------------------------
 *  [10:0]  | R      | 0x0   | DMA_CHx_MISS_PACKET_CNT_MFC
 *  [14:11] | R      | 0x0   | DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11
 *  [15]    | R      | 0x0   | DMA_CHx_MISS_PACKET_CNT_MFCO
 *  [31:16] | R      | 0x0   | DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16
 *
 */
/*
 * Field : MFC
 *
 * Missed Packet Counter
 *
 * This counter indicates the number of packet counter that were dropped by the DMA
 * either due to Bus Error or due to programming RPF field in DMA_CH0_Rx_Control
 * register. (Refer RPF field of DMA_CH0_Rx_Control register for more details.) The
 * counter gets cleared when this register is read.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_MISS_PACKET_CNT_MFC register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_LSB	       0
/* The Most Significant Bit (MSB) position of the DMA_CHx_MISS_PACKET_CNT_MFC register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_MSB	       10
/* The width in bits of the DMA_CHx_MISS_PACKET_CNT_MFC register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_WIDTH      11
/* The mask used to set the DMA_CHx_MISS_PACKET_CNT_MFC register field value. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_SET_MSK    0x000007ff
/* The mask used to clear the DMA_CHx_MISS_PACKET_CNT_MFC register field value. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_CLR_MSK    0xfffff800
/* The reset value of the DMA_CHx_MISS_PACKET_CNT_MFC register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_RESET      0x0
/* Extracts the DMA_CHx_MISS_PACKET_CNT_MFC field value from a register. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_GET(value) (((value)&0x000007ff) >> 0)
/* Produces a DMA_CHx_MISS_PACKET_CNT_MFC register field value suitable for setting the register. */
#define DMA_CHx_MISS_PACKET_CNT_MFC_SET(value) (((value) << 0) & 0x000007ff)

/*
 * Field : Reserved_14_11
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register
 * field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_LSB	  11
/* The Most Significant Bit (MSB) position of the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register
 * field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_MSB	  14
/* The width in bits of the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_WIDTH	  4
/* The mask used to set the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register field value. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_SET_MSK	  0x00007800
/* The mask used to clear the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register field value. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_CLR_MSK	  0xffff87ff
/* The reset value of the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_RESET	  0x0
/* Extracts the DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 field value from a register. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_GET(value) (((value)&0x00007800) >> 11)
/* Produces a DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 register field value suitable for setting the
 * register. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11_SET(value) (((value) << 11) & 0x00007800)

/*
 * Field : MFCO
 *
 * Overflow status of MFC Counter
 *
 * When this bit is set, the MFC counter does not get incremented further.
 *
 * This bit gets cleared when this register is read.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_MISS_PACKET_CNT_MFCO register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_LSB	15
/* The Most Significant Bit (MSB) position of the DMA_CHx_MISS_PACKET_CNT_MFCO register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_MSB	15
/* The width in bits of the DMA_CHx_MISS_PACKET_CNT_MFCO register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_WIDTH	1
/* The mask used to set the DMA_CHx_MISS_PACKET_CNT_MFCO register field value. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_SET_MSK	0x00008000
/* The mask used to clear the DMA_CHx_MISS_PACKET_CNT_MFCO register field value. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_CLR_MSK	0xffff7fff
/* The reset value of the DMA_CHx_MISS_PACKET_CNT_MFCO register field. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_RESET	0x0
/* Extracts the DMA_CHx_MISS_PACKET_CNT_MFCO field value from a register. */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_GET(value) (((value)&0x00008000) >> 15)
/* Produces a DMA_CHx_MISS_PACKET_CNT_MFCO register field value suitable for setting the register.
 */
#define DMA_CHx_MISS_PACKET_CNT_MFCO_SET(value) (((value) << 15) & 0x00008000)

/*
 * Field : Reserved_31_16
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register
 * field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_LSB	  16
/* The Most Significant Bit (MSB) position of the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register
 * field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_MSB	  31
/* The width in bits of the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_WIDTH	  16
/* The mask used to set the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register field value. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_SET_MSK	  0xffff0000
/* The mask used to clear the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register field value. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_CLR_MSK	  0x0000ffff
/* The reset value of the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register field. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_RESET	  0x0
/* Extracts the DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 field value from a register. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 register field value suitable for setting the
 * register. */
#define DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_MISS_PACKET_CNT.
 */
struct DMA_CHx_MISS_PACKET_CNT_s {
	const volatile uint32_t MFC : 11;	     /* DMA_CHx_MISS_PACKET_CNT_MFC */
	const volatile uint32_t Reserved_14_11 : 4;  /* DMA_CHx_MISS_PACKET_CNT_RESERVED_14_11 */
	const volatile uint32_t MFCO : 1;	     /* DMA_CHx_MISS_PACKET_CNT_MFCO */
	const volatile uint32_t Reserved_31_16 : 16; /* DMA_CHx_MISS_PACKET_CNT_RESERVED_31_16 */
};

/* The typedef declaration for register DMA_CHx_MISS_PACKET_CNT. */
typedef struct DMA_CHx_MISS_PACKET_CNT_s DMA_CHx_MISS_PACKET_CNT_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_MISS_PACKET_CNT register. */
#define DMA_CHx_MISS_PACKET_CNT_RESET 0x00000000
/* The byte offset of the DMA_CHx_MISS_PACKET_CNT register from the beginning of the component. */
#define DMA_CHx_MISS_PACKET_CNT_OFST  0x6c

/*
 * Register : DMA_CH0_Tx_Data_Xfer_Ring_Offset
 *
 * This register indicates the Offset of the Tx Descriptor List, for which the DMA
 * engine is fetching the data.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------------------------
 *  [15:0]  | R      | 0x0   | DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET
 *  [31:16] | R      | 0x0   | DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12
 *
 */
/*
 * Field : DESC_OFFSET
 *
 * TxDMA Channelx Data Transfer ring Offset
 *
 * In DMA, this field indicates the ring offset of the Descriptor DMA currently
 * working on data transmission.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_LSB	0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_MSB	15
/* The width in bits of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_WIDTH	16
/* The mask used to set the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_SET_MSK	0x0000ffff
/* The mask used to clear the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_CLR_MSK	0xffff0000
/* The reset value of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_RESET	0x0
/* Extracts the DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET field value from a register. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field value suitable for setting
 * the register. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_LSB	   16
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_MSB	   31
/* The width in bits of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_WIDTH	   16
/* The mask used to set the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field value. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_SET_MSK	   0xffff0000
/* The mask used to clear the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field value.
 */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_CLR_MSK	   0x0000ffff
/* The reset value of the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_RESET	   0x0
/* Extracts the DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 field value from a register. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field value suitable for
 * setting the register. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TX_DATA_XFER_RING_OFFSET.
 */
struct DMA_CHx_TX_DATA_XFER_RING_OFFSET_s {
	const volatile uint32_t DESC_OFFSET : 16; /* DMA_CHx_TX_DATA_XFER_RING_OFFSET_DESC_OFFSET */
	const volatile uint32_t
		Reserved_31_12 : 16; /* DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESERVED_31_12 */
};

/* The typedef declaration for register DMA_CHx_TX_DATA_XFER_RING_OFFSET. */
typedef struct DMA_CHx_TX_DATA_XFER_RING_OFFSET_s DMA_CHx_TX_DATA_XFER_RING_OFFSET_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TX_DATA_XFER_RING_OFFSET register. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_RESET 0x00000000
/* The byte offset of the DMA_CHx_TX_DATA_XFER_RING_OFFSET register from the beginning of the
 * component. */
#define DMA_CHx_TX_DATA_XFER_RING_OFFSET_OFST  0x70

/*
 * Register : DMA_CH0_Rx_Data_Xfer_Ring_Offset
 *
 * The DMA Channelx Receive Data Transfer Ring Offset register indicates the Ring
 * Offset of the Rx Descriptor List, for which the DMA engine is transferring the
 * data.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:--------------------------------------------------------------------------
 *  [15:0]  | R      | 0x0   | DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET
 *  [31:16] | R      | 0x0   | DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12
 *
 */
/*
 * Field : DESC_OFFSET
 *
 * RxDMA Channelx Data Transfer Ring Offset
 *
 * In DMA, this field indicates the ring offset of the Descriptor DMA currently
 * working on data reception.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_LSB	0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_MSB	15
/* The width in bits of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_WIDTH	16
/* The mask used to set the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_SET_MSK	0x0000ffff
/* The mask used to clear the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_CLR_MSK	0xffff0000
/* The reset value of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_RESET	0x0
/* Extracts the DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET field value from a register. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET register field value suitable for setting
 * the register. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_LSB	   16
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_MSB	   31
/* The width in bits of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_WIDTH	   16
/* The mask used to set the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field value. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_SET_MSK	   0xffff0000
/* The mask used to clear the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field value.
 */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_CLR_MSK	   0x0000ffff
/* The reset value of the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_RESET	   0x0
/* Extracts the DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 field value from a register. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 register field value suitable for
 * setting the register. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RX_DATA_XFER_RING_OFFSET.
 */
struct DMA_CHx_RX_DATA_XFER_RING_OFFSET_s {
	const volatile uint32_t DESC_OFFSET : 16; /* DMA_CHx_RX_DATA_XFER_RING_OFFSET_DESC_OFFSET */
	const volatile uint32_t
		Reserved_31_12 : 16; /* DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESERVED_31_12 */
};

/* The typedef declaration for register DMA_CHx_RX_DATA_XFER_RING_OFFSET. */
typedef struct DMA_CHx_RX_DATA_XFER_RING_OFFSET_s DMA_CHx_RX_DATA_XFER_RING_OFFSET_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RX_DATA_XFER_RING_OFFSET register. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_RESET 0x00000000
/* The byte offset of the DMA_CHx_RX_DATA_XFER_RING_OFFSET register from the beginning of the
 * component. */
#define DMA_CHx_RX_DATA_XFER_RING_OFFSET_OFST  0x74

/*
 * Register : DMA_CH0_Tx_Desc_Write_Ring_Offset
 *
 * This register indicates the Offset of the Tx Descriptor List, for which the DMA
 * engine is closing the descriptor.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------------------
 *  [15:0]  | R      | 0x0   | DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET
 *  [31:16] | R      | 0x0   | DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12
 *
 */
/*
 * Field : DESC_OFFSET
 *
 * TxDMA Channelx Descriptor Write Ring Offset
 *
 * This field indicates the ring offset of the descriptor DMA posted write-back
 * request.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_LSB	 0
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_MSB	 15
/* The width in bits of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_WIDTH	 16
/* The mask used to set the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_SET_MSK	 0x0000ffff
/* The mask used to clear the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_CLR_MSK	 0xffff0000
/* The reset value of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_RESET	 0x0
/* Extracts the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET field value from a register. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field value suitable for
 * setting the register. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_LSB	    16
/* The Most Significant Bit (MSB) position of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_MSB	    31
/* The width in bits of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_WIDTH	    16
/* The mask used to set the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field value.
 */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_SET_MSK    0xffff0000
/* The mask used to clear the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field value.
 */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_CLR_MSK    0x0000ffff
/* The reset value of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_RESET	    0x0
/* Extracts the DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 field value from a register. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field value suitable for
 * setting the register. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_TX_DESC_WRITE_RING_OFFSET.
 */
struct DMA_CHx_TX_DESC_WRITE_RING_OFFSET_s {
	const volatile uint32_t
		DESC_OFFSET : 16; /* DMA_CHx_TX_DESC_WRITE_RING_OFFSET_DESC_OFFSET */
	const volatile uint32_t
		Reserved_31_12 : 16; /* DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 */
};

/* The typedef declaration for register DMA_CHx_TX_DESC_WRITE_RING_OFFSET. */
typedef struct DMA_CHx_TX_DESC_WRITE_RING_OFFSET_s DMA_CHx_TX_DESC_WRITE_RING_OFFSET_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET register. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_RESET 0x00000000
/* The byte offset of the DMA_CHx_TX_DESC_WRITE_RING_OFFSET register from the beginning of the
 * component. */
#define DMA_CHx_TX_DESC_WRITE_RING_OFFSET_OFST	0x78

/*
 * Register : DMA_CH0_Rx_Desc_Write_Ring_Offset
 *
 * This register indicates the Offset of the Rx Descriptor List, for which the DMA
 * engine is closing the descriptor.
 *
 * Register Layout
 *
 *  Bits    | Access | Reset | Description
 * :--------|:-------|:------|:---------------------------------------------------------------------------
 *  [15:0]  | R      | 0x0   | DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET
 *  [31:16] | R      | 0x0   | DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12
 *
 */
/*
 * Field : DESC_OFFSET
 *
 * RxDMA Channelx Descriptor Write Ring Offset
 *
 * This field indicates the ring offset of the descriptor DMA posted write-back
 * request.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_LSB	 0
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET
 * register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_MSB	 15
/* The width in bits of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_WIDTH	 16
/* The mask used to set the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_SET_MSK	 0x0000ffff
/* The mask used to clear the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field value. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_CLR_MSK	 0xffff0000
/* The reset value of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_RESET	 0x0
/* Extracts the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET field value from a register. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_GET(value) (((value)&0x0000ffff) >> 0)
/* Produces a DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET register field value suitable for
 * setting the register. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET_SET(value) (((value) << 0) & 0x0000ffff)

/*
 * Field : Reserved_31_12
 *
 * Reserved.
 *
 * Field Access Macros:
 *
 */
/* The Least Significant Bit (LSB) position of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_LSB	    16
/* The Most Significant Bit (MSB) position of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12
 * register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_MSB	    31
/* The width in bits of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_WIDTH	    16
/* The mask used to set the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field value.
 */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_SET_MSK    0xffff0000
/* The mask used to clear the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field value.
 */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_CLR_MSK    0x0000ffff
/* The reset value of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_RESET	    0x0
/* Extracts the DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 field value from a register. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_GET(value) (((value)&0xffff0000) >> 16)
/* Produces a DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 register field value suitable for
 * setting the register. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12_SET(value) (((value) << 16) & 0xffff0000)

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register DMA_CHx_RX_DESC_WRITE_RING_OFFSET.
 */
struct DMA_CHx_RX_DESC_WRITE_RING_OFFSET_s {
	const volatile uint32_t
		DESC_OFFSET : 16; /* DMA_CHx_RX_DESC_WRITE_RING_OFFSET_DESC_OFFSET */
	const volatile uint32_t
		Reserved_31_12 : 16; /* DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESERVED_31_12 */
};

/* The typedef declaration for register DMA_CHx_RX_DESC_WRITE_RING_OFFSET. */
typedef struct DMA_CHx_RX_DESC_WRITE_RING_OFFSET_s DMA_CHx_RX_DESC_WRITE_RING_OFFSET_t;
#endif /* __ASSEMBLY__ */

/* The reset value of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET register. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_RESET 0x00000000
/* The byte offset of the DMA_CHx_RX_DESC_WRITE_RING_OFFSET register from the beginning of the
 * component. */
#define DMA_CHx_RX_DESC_WRITE_RING_OFFSET_OFST	0x7c

#ifndef __ASSEMBLY__
/*
 * The struct declaration for register group DMA_CHx.
 */
struct s {
	volatile DMA_CHx_CONTROL_t DMA_CH0_Control;	  /* DMA_CHx_CONTROL */
	volatile DMA_CHx_TX_CONTROL_t DMA_CH0_Tx_Control; /* DMA_CHx_TX_CONTROL */
	volatile DMA_CHx_RX_CONTROL_t DMA_CH0_Rx_Control; /* DMA_CHx_RX_CONTROL */
	volatile DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS_t
		DMA_CH0_Slot_Function_Control_Status; /* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS */
	volatile DMA_CHx_TXDESC_LIST_HADDRESS_t
		DMA_CH0_TxDesc_List_HAddress; /* DMA_CHx_TXDESC_LIST_HADDRESS */
	volatile DMA_CHx_TXDESC_LIST_LADDRESS_t
		DMA_CH0_TxDesc_List_LAddress; /* DMA_CHx_TXDESC_LIST_LADDRESS */
	volatile DMA_CHx_RXDESC_LIST_HADDRESS_t
		DMA_CH0_RxDesc_List_HAddress; /* DMA_CHx_RXDESC_LIST_HADDRESS */
	volatile DMA_CHx_RXDESC_LIST_LADDRESS_t
		DMA_CH0_RxDesc_List_LAddress; /* DMA_CHx_RXDESC_LIST_LADDRESS */
	volatile uint32_t _pad_0x20_0x23;     /* *UNDEFINED* */
	volatile DMA_CHx_TXDESC_TAIL_LPOINTER_t
		DMA_CH0_TxDesc_Tail_LPointer; /* DMA_CHx_TXDESC_TAIL_LPOINTER */
	volatile uint32_t _pad_0x28_0x2b;     /* *UNDEFINED* */
	volatile DMA_CHx_RXDESC_TAIL_LPOINTER_t
		DMA_CH0_RxDesc_Tail_LPointer;		    /* DMA_CHx_RXDESC_TAIL_LPOINTER */
	volatile DMA_CHx_TX_CONTROL2_t DMA_CH0_Tx_Control2; /* DMA_CHx_TX_CONTROL2 */
	volatile DMA_CHx_RX_CONTROL2_t DMA_CH0_Rx_Control2; /* DMA_CHx_RX_CONTROL2 */
	volatile DMA_CHx_INTERRUPT_ENABLE_t DMA_CH0_Interrupt_Enable; /* DMA_CHx_INTERRUPT_ENABLE */
	volatile DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER_t
		DMA_CH0_Rx_Interrupt_Watchdog_Timer; /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER */
	volatile uint32_t _pad_0x40_0x43;	     /* *UNDEFINED* */
	volatile DMA_CHx_CURRENT_APP_TXDESC_L_t
		DMA_CH0_Current_App_TxDesc_L; /* DMA_CHx_CURRENT_APP_TXDESC_L */
	volatile uint32_t _pad_0x48_0x4b;     /* *UNDEFINED* */
	volatile DMA_CHx_CURRENT_APP_RXDESC_L_t
		DMA_CH0_Current_App_RxDesc_L; /* DMA_CHx_CURRENT_APP_RXDESC_L */
	volatile DMA_CHx_CURRENT_APP_TXBUFFER_H_t
		DMA_CH0_Current_App_TxBuffer_H; /* DMA_CHx_CURRENT_APP_TXBUFFER_H */
	volatile DMA_CHx_CURRENT_APP_TXBUFFER_L_t
		DMA_CH0_Current_App_TxBuffer_L; /* DMA_CHx_CURRENT_APP_TXBUFFER_L */
	volatile DMA_CHx_CURRENT_APP_RXBUFFER_H_t
		DMA_CH0_Current_App_RxBuffer_H; /* DMA_CHx_CURRENT_APP_RXBUFFER_H */
	volatile DMA_CHx_CURRENT_APP_RXBUFFER_L_t
		DMA_CH0_Current_App_RxBuffer_L;		      /* DMA_CHx_CURRENT_APP_RXBUFFER_L */
	volatile DMA_CHx_STATUS_t DMA_CH0_Status;	      /* DMA_CHx_STATUS */
	volatile DMA_CHx_DEBUG_STATUS_t DMA_CH0_Debug_Status; /* DMA_CHx_DEBUG_STATUS */
	volatile DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL_t
		DMA_CH0_Desc_Mem_Cache_Fill_Level; /* DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL */
	volatile DMA_CHx_MISS_PACKET_CNT_t DMA_CH0_Miss_Packet_Cnt; /* DMA_CHx_MISS_PACKET_CNT */
	volatile DMA_CHx_TX_DATA_XFER_RING_OFFSET_t
		DMA_CH0_Tx_Data_Xfer_Ring_Offset; /* DMA_CHx_TX_DATA_XFER_RING_OFFSET */
	volatile DMA_CHx_RX_DATA_XFER_RING_OFFSET_t
		DMA_CH0_Rx_Data_Xfer_Ring_Offset; /* DMA_CHx_RX_DATA_XFER_RING_OFFSET */
	volatile DMA_CHx_TX_DESC_WRITE_RING_OFFSET_t
		DMA_CH0_Tx_Desc_Write_Ring_Offset; /* DMA_CHx_TX_DESC_WRITE_RING_OFFSET */
	volatile DMA_CHx_RX_DESC_WRITE_RING_OFFSET_t
		DMA_CH0_Rx_Desc_Write_Ring_Offset; /* DMA_CHx_RX_DESC_WRITE_RING_OFFSET */
};

/* The typedef declaration for register group DMA_CHx. */
typedef struct s t;
/* The struct declaration for the raw register contents of register group DMA_CHx. */
struct raw_s {
	volatile uint32_t DMA_CHx_Control;    /* DMA_CHx_CONTROL */
	volatile uint32_t DMA_CHx_Tx_Control; /* DMA_CHx_TX_CONTROL */
	volatile uint32_t DMA_CHx_Rx_Control; /* DMA_CHx_RX_CONTROL */
	volatile uint32_t
		DMA_CHx_Slot_Function_Control_Status;	/* DMA_CHx_SLOT_FUNCTION_CONTROL_STATUS */
	volatile uint32_t DMA_CHx_TxDesc_List_HAddress; /* DMA_CHx_TXDESC_LIST_HADDRESS */
	volatile uint32_t DMA_CHx_TxDesc_List_LAddress; /* DMA_CHx_TXDESC_LIST_LADDRESS */
	volatile uint32_t DMA_CHx_RxDesc_List_HAddress; /* DMA_CHx_RXDESC_LIST_HADDRESS */
	volatile uint32_t DMA_CHx_RxDesc_List_LAddress; /* DMA_CHx_RXDESC_LIST_LADDRESS */
	volatile uint32_t _pad_0x20_0x23;		/* *UNDEFINED* */
	volatile uint32_t DMA_CHx_TxDesc_Tail_LPointer; /* DMA_CHx_TXDESC_TAIL_LPOINTER */
	volatile uint32_t _pad_0x28_0x2b;		/* *UNDEFINED* */
	volatile uint32_t DMA_CHx_RxDesc_Tail_LPointer; /* DMA_CHx_RXDESC_TAIL_LPOINTER */
	volatile uint32_t DMA_CHx_Tx_Control2;		/* DMA_CHx_TX_CONTROL2 */
	volatile uint32_t DMA_CHx_Rx_Control2;		/* DMA_CHx_RX_CONTROL2 */
	volatile uint32_t DMA_CHx_Interrupt_Enable;	/* DMA_CHx_INTERRUPT_ENABLE */
	volatile uint32_t
		DMA_CHx_Rx_Interrupt_Watchdog_Timer;	  /* DMA_CHx_RX_INTERRUPT_WATCHDOG_TIMER */
	volatile uint32_t _pad_0x40_0x43;		  /* *UNDEFINED* */
	volatile uint32_t DMA_CH0_Current_App_TxDesc_L;	  /* DMA_CHx_CURRENT_APP_TXDESC_L */
	volatile uint32_t _pad_0x48_0x4b;		  /* *UNDEFINED* */
	volatile uint32_t DMA_CHx_Current_App_RxDesc_L;	  /* DMA_CHx_CURRENT_APP_RXDESC_L */
	volatile uint32_t DMA_CHx_Current_App_TxBuffer_H; /* DMA_CHx_CURRENT_APP_TXBUFFER_H */
	volatile uint32_t DMA_CHx_Current_App_TxBuffer_L; /* DMA_CHx_CURRENT_APP_TXBUFFER_L */
	volatile uint32_t DMA_CHx_Current_App_RxBuffer_H; /* DMA_CHx_CURRENT_APP_RXBUFFER_H */
	volatile uint32_t DMA_CHx_Current_App_RxBuffer_L; /* DMA_CHx_CURRENT_APP_RXBUFFER_L */
	volatile uint32_t DMA_CHx_Status;		  /* DMA_CHx_STATUS */
	volatile uint32_t DMA_CHx_Debug_Status;		  /* DMA_CHx_DEBUG_STATUS */
	volatile uint32_t DMA_CHx_Desc_Mem_Cache_Fill_Level; /* DMA_CHx_DESC_MEM_CACHE_FILL_LEVEL */
	volatile uint32_t DMA_CHx_Miss_Packet_Cnt;	     /* DMA_CHx_MISS_PACKET_CNT */
	volatile uint32_t DMA_CHx_Tx_Data_Xfer_Ring_Offset;  /* DMA_CHx_TX_DATA_XFER_RING_OFFSET */
	volatile uint32_t DMA_CHx_Rx_Data_Xfer_Ring_Offset;  /* DMA_CHx_RX_DATA_XFER_RING_OFFSET */
	volatile uint32_t DMA_CHx_Tx_Desc_Write_Ring_Offset; /* DMA_CHx_TX_DESC_WRITE_RING_OFFSET */
	volatile uint32_t DMA_CHx_Rx_Desc_Write_Ring_Offset; /* DMA_CHx_RX_DESC_WRITE_RING_OFFSET */
};

/* The typedef declaration for the raw register contents of register group DMA_CHx. */
typedef struct DMA_CHx_raw_s DMA_CHx_raw_t;
#endif /* __ASSEMBLY__ */

#endif /* _ZEPHYR_DRIVERS_ETHERNET_ETH_DWC_XGMAC_REG_H_ */
